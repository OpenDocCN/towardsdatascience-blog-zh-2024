<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>3 Popular Methods for Spatial Interpolation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>3 Popular Methods for Spatial Interpolation</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/3-best-methods-for-spatial-interpolation-912cab7aee47?source=collection_archive---------4-----------------------#2024-04-09">https://towardsdatascience.com/3-best-methods-for-spatial-interpolation-912cab7aee47?source=collection_archive---------4-----------------------#2024-04-09</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="cd01" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">From scratch, in Python</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@alexroz?source=post_page---byline--912cab7aee47--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Aleksei Rozanov" class="l ep by dd de cx" src="../Images/748b69bfaccf39c9aa568a9e6f41eec3.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*JISS93SvFnwE3NMNTl8HAQ.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--912cab7aee47--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@alexroz?source=post_page---byline--912cab7aee47--------------------------------" rel="noopener follow">Aleksei Rozanov</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--912cab7aee47--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">10 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Apr 9, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">8</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/001778775344af81b306237ca482d2f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1XJoI6B78rwwbv5hjiOVzg.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="1d24" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk nz"><span class="l oa ob oc bo od oe of og oh ed">I</span>nterpolation is a quite common mathematical concept, which is used not only by data scientists, but also people from a vast range of fields. However, when dealing with geospatial data, interpolation gets more complicated, since you need to create a representative grid based on several often sparse observations.</p><p id="2535" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Before diving into geospatial part, let’s have a brief recap on linear interpolation.</p><blockquote class="oi oj ok"><p id="fdc3" class="nd ne ol nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">As always, to follow up the tutorial, you can download and run the notebook <a class="af nc" href="https://github.com/alexxxroz/Medium/blob/main/SpatialInterpolation.ipynb" rel="noopener ugc nofollow" target="_blank">here</a>.</p></blockquote><p id="3b0a" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">For the purpose of demonstration I’ll use a regular polynomial function:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="264e" class="oq or fq on b bg os ot l ou ov">def F(x):<br/>  return -2*x**3+x**2+2.1<br/><br/>x = np.arange(-5,5, 0.1)<br/>y = F(x)</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk ow"><img src="../Images/cf8d98b5a651c1aa5f0a1d3acbbc0385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*ptI9Ytgje65-Wm3kFywAgw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="f805" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now we can randomly sample several points [-4.2, 0, 2.5] and connect them together:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk ow"><img src="../Images/e8719b75ecd4d6a0fc7f3f0127f7eac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*7Any91O00ESwXBD76IzDtQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="0403" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">This is called linear interpolation, since the function is approximated by a straight line at each interval, and now, knowing function’s values only at 3 points, we can find the values inside the interval [-4.2;2.5].</p><p id="4183" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">There are many other methods, which have higher accuracy, but the idea behind them is the same: find the functions values between at least two known points.</p><p id="489f" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now it’s time to get to geospatial part. In this tutorial, our goal will be to perform spatial interpolation of daily average air temperature measured at meteorological sites across Switzerland provided by <a class="af nc" href="https://www.ncdc.noaa.gov/cdo-web/datatools/selectlocation" rel="noopener ugc nofollow" target="_blank">NOAA</a>. The expected result is a grid of temperatures with cells of 0.1° resolution.</p><p id="2d3d" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Firstly, we need to acquire an administrative boundary of Switzerland and visualize it using geopandas:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="c6fd" class="oq or fq on b bg os ot l ou ov">import geopandas as gdp<br/><br/>shape = gpd.read_file('gadm41_CHE_0.shp')<br/>shape.plot()</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk ox"><img src="../Images/5e55dea85838eb0bcc54cd63a1bb2fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*HUX36c5wMchvN-8tm99UhA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="5d06" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Indeed, looks like it’s Switzerland, wow =)</p><p id="714d" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now let’s plot our temperature observations and overlay them with the country shape. To do that, let’s load meteorological data to regular pandas dataframe and then convert it to a geopandas one with coordinates transformed to the <em class="ol">shapely</em> points:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="9610" class="oq or fq on b bg os ot l ou ov">import pandas as pd<br/>from shapely.geometry import Point<br/><br/>df = pd.read_csv('3639866.csv')<br/><br/>points = list()<br/>for i in range(len(df)):<br/>  point = Point(df.loc[i, 'LONGITUDE'], df.loc[i, 'LATITUDE'])<br/>  points.append(point)<br/><br/>gdf = gpd.GeoDataFrame(geometry=points).set_crs(shape.crs)</span></pre><p id="c3e5" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">After doing that we can easily overlay the two dataframes using <em class="ol">matplotlib</em>.</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="8904" class="oq or fq on b bg os ot l ou ov">fig, ax = plt.subplots(figsize=(16,9))<br/>shape.plot(ax=ax, color='black')<br/>gdf.plot(ax=ax, color='r', markersize=85)<br/>plt.show()</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk oy"><img src="../Images/f4faf1e5e8b63083eefa2d94851ca8a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p7D5xobYc3ZNBXSvaZEK8g.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="bf5c" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To visualize our task let’s create the grid for interpolation and overlay it with the map above:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="0782" class="oq or fq on b bg os ot l ou ov">import matplotlib.ticker as mticker<br/>import cartopy.crs as ccrs<br/>from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER<br/><br/>LAT, LON = np.arange(45.75, 48, 0.1), np.arange(6, 10.81, 0.1)<br/><br/>fig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(16, 9))<br/>shape.plot(ax=ax, color='grey')<br/>gdf.plot(ax=ax, color='r', markersize=85)<br/><br/>gl = ax.gridlines(draw_labels=True,linewidth=2, color='black', alpha=0.5, linestyle='--')<br/>gl.xlocator = mticker.FixedLocator(LON)<br/>gl.ylocator = mticker.FixedLocator(LAT)<br/>gl.xformatter = LONGITUDE_FORMATTER<br/>gl.yformatter = LATITUDE_FORMATTER<br/>plt.show()</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk oz"><img src="../Images/e4607c90b750b50ae111a917e734562d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAHGo3QLJdg3FhxPcz37Nw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="bc8d" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">So the goal is to produce interpolation on the regular grid illustrated above having 8 temperature observations.</p><h1 id="1b06" class="pa or fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">I. Nearest Neighbor (NN)</h1><p id="4bd2" class="pw-post-body-paragraph nd ne fq nf b go pv nh ni gr pw nk nl nm px no np nq py ns nt nu pz nw nx ny fj bk">The first super intuitive and simple method is called Nearest Neighbor (NN). As you can guess from its name, the algorithm assigns the value of the nearest observation to each grid node.</p><p id="9879" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To implement it we will need only two functions. The first function is called Euclidean, and it calculates the distance between two points using the following formula:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qa"><img src="../Images/0d1d55d8a5f799b2ed5b785c283e1d97.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/0*s4SArAj7txg8GDrQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="b9ad" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The second one is the NN method itself. After creating an empty array to store the values we iterate over all latitudes and longitudes, calculate distances from each point to the current grid node and assign the value of the closest observation to that grid node:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="2a80" class="oq or fq on b bg os ot l ou ov">def Euclidean(x1,x2,y1,y2):<br/>  return ((x1-x2)**2+(y1-y2)**2)**0.5<br/><br/>def NN(data, LAT, LON):<br/>  array = np.empty((LAT.shape[0], LON.shape[0]))<br/><br/>  for i, lat in enumerate(LAT):<br/>    for j, lon in enumerate(LON):<br/>      idx = data.apply(lambda row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat), axis = 1).argmin() <br/>      array[i,j] = data.loc[idx, 'TAVG']<br/>  return array</span></pre><p id="639c" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The whole idea is here, in this line:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="4f05" class="oq or fq on b bg os ot l ou ov">idx = data.apply(lambda row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat), axis = 1).argmin()</span></pre><p id="4d0c" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Variable data is our pandas dataframe with meteo sites (each row represents one site). So in the <em class="ol">for</em> loop we calculate the distance and find the index of the site with the minimum distance.</p><p id="3999" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now let’s run the algorithm and wrap the results into xarray dataset:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="a018" class="oq or fq on b bg os ot l ou ov">t2m = NN(df, LAT, LON)<br/>ds = xr.Dataset(<br/>    {'TAVG': (['lat', 'lon'], t2m)},<br/>    coords={'lat': LAT, 'lon': LON})</span></pre><p id="534d" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now we can plot the results:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qb"><img src="../Images/467e205cd93ce8b723cd2532c76ca361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzPzzshlr1SbseoEToJSrw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="cd5b" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Looks nice, but let’s enhance our plot by creating a Switzerland mask using regionmask library:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="79ac" class="oq or fq on b bg os ot l ou ov">shape['new_column'] = 0<br/>sw = shape.dissolve(by='new_column')['geometry']<br/>rg = regionmask.mask_3D_geopandas(sw, lon_or_obj=ds.lon, lat=ds.lat)<br/><br/>fig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(16, 9))<br/>#shape.plot(ax=ax, color='black')<br/>ds.where(rg).TAVG.plot(ax=ax, alpha=0.6)<br/>gdf.plot(ax=ax, color='r', markersize=85)<br/>ax.gridlines(draw_labels=True,linewidth=2, color='black', alpha=0.5, linestyle='--')<br/>plt.show()</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qb"><img src="../Images/e7f7730e717c2319598913a194acc95f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6GmMABbvrUSRLFAsfZLlvQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="a64f" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">As you can see this method might be applied only to categorical data. Since we are dealing with temperature, which is continuous variable, meaning it can take any value in a certain range, this interpolation is misleading. In real life there always gradients and randomness.</p><p id="b331" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">So let’s have a look at more advanced algorithm.</p><h1 id="8630" class="pa or fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">II. Inverse Distance Weighting (IDW)</h1><p id="17ea" class="pw-post-body-paragraph nd ne fq nf b go pv nh ni gr pw nk nl nm px no np nq py ns nt nu pz nw nx ny fj bk">Basically, Inverse Distance Weighting (IDW) is an enhanced version of NN:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="3670" class="oq or fq on b bg os ot l ou ov">def IDW(data, LAT, LON, betta=2):<br/>  array = np.empty((LAT.shape[0], LON.shape[0]))<br/><br/>  for i, lat in enumerate(LAT):<br/>    for j, lon in enumerate(LON):<br/>      weights = data.apply(lambda row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat)**(-betta), axis = 1)<br/>      z = sum(weights*data.TAVG)/weights.sum()<br/>      array[i,j] = z<br/>  return array</span></pre><p id="174b" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">As you can see, instead of assigning the value of the closest known point, here we calculate weights. To do that the aforementioned Euclidean distanced is used as well, but this time we raise each distance to the <strong class="nf fr">-</strong>β-th power (β is an arbitrary value). These weights are basically the contribution of each ground point to a certain grid node. The greater the distance, the less this point influence the node value.</p><p id="fbce" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">After getting the weights we calculate the weighted average.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qc"><img src="../Images/e1e8c71eaf2d24be507f660bc5ad8a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/format:webp/1*zbBkg-rbkLLeGfurq3FVRQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qd"><img src="../Images/a8c951cc303dfcb26d32ae11e115651a.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*70t3grh57pB6wZHLdfzcSw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="4300" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Let’s plot it:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qe"><img src="../Images/92f3b15ccad15743feffd844cd4c00ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRiUXa8dnANzWdtnAu3cLg.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="1e64" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">As you can see, now results are much more realistic and smooth!</p><h1 id="e75a" class="pa or fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">III. Kriging</h1><p id="2dd3" class="pw-post-body-paragraph nd ne fq nf b go pv nh ni gr pw nk nl nm px no np nq py ns nt nu pz nw nx ny fj bk">The last method for today is Kriging. Among these three, this one is most complex, and we will only touch upon it. In case you want to use it consciously and effectively, consider having look at the literature!</p><p id="e732" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">So the main idea of the method is the usage of variogram (or semivariogram). In essence, a variogram quantifies how the variability of some parameter changes with distance and direction. This exactly what we need when dealing with air temperature.</p><p id="63ca" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To implement the Kriging algorithms we will need two types of variograms: <strong class="nf fr">experimental</strong> and <strong class="nf fr">theoretical</strong>.</p><p id="35f8" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The first one is really easy to calculate. It’s defined as<strong class="nf fr"> gamma γ</strong>:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qf"><img src="../Images/4abd2abbed6ff877bef3b09fb87691a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*GI0vU0fQhcGMoAR5cnTU3Q.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="4e16" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">where h — geographical distance between two points, z — temperature function. So in a nutshell it’s an average of temperature differences at known points.</p><p id="1291" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The theoretical variogram is a little bit more complicated. Firstly, there are many of them:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qg"><img src="../Images/2ee04146f677148333add1dd78b6b9ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1270/format:webp/1*3kunXfxarTBe0BK4m5yHmQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="ce36" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">where p — is partial sill, d — distance (we used <em class="ol">h</em> before), n — nugget, r — range.</p><p id="85c0" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">I found a really good visual explanation of these parameters at <a class="af nc" href="https://iri.columbia.edu/~rijaf/CDTUserGuide/html/interpolation_methods.html" rel="noopener ugc nofollow" target="_blank">CDT Columbia</a>. I adopted an image, which illustrates the dependence between <strong class="nf fr">γ </strong>and distance, from their material. As you can see now it’s clear what sill, partial sill, nugget and range are.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qh"><img src="../Images/8565dd27b5eed2585089effddec4cff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*Xm5c7M070Y3_ceYELrV5mQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="9e0f" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">So the whole idea of the algorithm is to adjust the parameters of the parameters of theoretical variogram so it would fit to the experimental one and then predict the values of nodes using it.</p><p id="329d" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To implement the method we’ll need several extra libraries and to create a class called OrdinaryKriging.</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="3c50" class="oq or fq on b bg os ot l ou ov">from scipy.linalg import solve<br/>from itertools import product<br/>from sklearn.metrics import mean_squared_error as MSE<br/><br/>class OrdinaryKriging:<br/>    def __init__(self, lats, lons, values):<br/>        self.lats = lats<br/>        self.lons= lons<br/>        self.values = values<br/><br/>        self.nugget_values = [0, 1, 2, 3, 4]<br/>        self.sill_values = [1, 2, 3, 4, 5]<br/>        self.range_values = [1, 2, 3, 4, 5]<br/><br/>        # Generate all combinations of parameter values to fit<br/>        self.parameter_combinations = list(product(self.nugget_values, self.sill_values, self.range_values))<br/>        self.optimal_pars = None<br/><br/>    def theoretical_variogram(self, h, nugget, sill, r):<br/>        return nugget + (sill-nugget) * (1-np.exp(-3*h/r))<br/><br/>    def Euclidean(self, X, Y):<br/>        all_dists, point_dists = [], []<br/>        for x,y in zip(X, Y):<br/>          k = 0<br/>          for k in range(len(X)):<br/>            h = np.linalg.norm(np.array([x, y]) - np.array([X[k], Y[k]]))<br/>            point_dists.append(h)<br/>          all_dists.append(point_dists)<br/>          point_dists = []<br/>        return all_dists<br/><br/>    def gamma(self):<br/>        distances = self.Euclidean(self.lats, self.lons)<br/>        differences = np.abs(self.values.reshape(-1,1) - self.values)<br/>        variogram_values = []<br/>        for h in np.unique(distances):<br/>            values_at_h = differences[(distances == h)]<br/>            variogram_values.append(np.mean(values_at_h**2))<br/>        return variogram_values, np.unique(distances)<br/><br/>    def fit(self):<br/>        experimental_variogram, distances = self.gamma()<br/>        fit_metrics = []<br/>        for nugget, sill, range_ in self.parameter_combinations:<br/>            theoretical_variogram_values = self.theoretical_variogram(distances, nugget, sill, range_)<br/>            fit_metric = MSE(experimental_variogram, theoretical_variogram_values)<br/>            fit_metrics.append((nugget, sill, range_, fit_metric))<br/><br/>        self.optimal_pars = min(fit_metrics, key=lambda x: x[3])[:3]<br/><br/>    def predict(self, point):<br/>        points = np.array([(x,y) for x,y in zip(self.lats, self.lons)])<br/>        distances = np.linalg.norm(points - point, axis=1)<br/>        pars = list(self.optimal_pars)<br/>        pars.insert(0, distances)<br/>        weights = self.theoretical_variogram(*pars)<br/>        weights /= np.sum(weights)<br/>        return np.dot(weights, self.values)<br/><br/>kriging = OrdinaryKriging(df.LATITUDE.values, df.LONGITUDE.values, df.TAVG.values)<br/><br/>kriging.fit()</span></pre><p id="a19d" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now let’s consider each function separately. <br/>The <strong class="nf fr">__init__</strong> function besides initializing coordinates and values consists of three lists comprising possible values of nugget, sill and range. All three are mixed together in all possible combinations and stored in the parameter_combinations variable. We will need it later for searching the optimal ones.</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="8a88" class="oq or fq on b bg os ot l ou ov">def __init__(self, lats, lons, values):<br/>        self.lats = lats<br/>        self.lons= lons<br/>        self.values = values<br/><br/>        self.nugget_values = [0, 1, 2, 3, 4]<br/>        self.sill_values = [1, 2, 3, 4, 5]<br/>        self.range_values = [1, 2, 3, 4, 5]<br/><br/>        # Generate all combinations of parameter values to fit<br/>        self.parameter_combinations = list(product(self.nugget_values, self.sill_values, self.range_values))<br/>        self.optimal_pars = None</span></pre><p id="ab68" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The second function, <strong class="nf fr">theoretical_variogram</strong>, is simply a python implementation of one of the aforementioned formulas. In our case, it’s the <em class="ol">exponential</em> one (but you can write code for another one and compare the results):</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="729e" class="oq or fq on b bg os ot l ou ov">def theoretical_variogram(self, h, nugget, sill, r):<br/> return nugget + (sill-nugget) * (1-np.exp(-3*h/r))</span></pre><p id="e1b4" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The third class method <strong class="nf fr">Euclidean</strong>. It’s an altered version of the function we created for NN and IDW. This time we return a matrix (n,n) where each row represents distances between a point and all other points (one of the values in each row is 0, since the distance between a point and itself is 0).</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="f982" class="oq or fq on b bg os ot l ou ov">def Euclidean(self, X, Y):<br/>        all_dists, point_dists = [], []<br/>        for x,y in zip(X, Y):<br/>          k = 0<br/>          for k in range(len(X)):<br/>            h = np.linalg.norm(np.array([x, y]) - np.array([X[k], Y[k]]))<br/>            point_dists.append(h)<br/>          all_dists.append(point_dists)<br/>          point_dists = []<br/>        return all_dists</span></pre><p id="0bf6" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The fourth function performs the <strong class="nf fr">fitting</strong>. Here it obtains experimental variogram values and Euclidean distances. Then, iterating over our combinations of sill, range and nugget it calculates the theoretical variogram values with the following estimation of Mean Squared Error, or MSE, between theoretical and experimental values (but you can use other metrics). Then we save the optimal parameters to the class variable optimal_pars.</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="ee6b" class="oq or fq on b bg os ot l ou ov">def fit(self):<br/>        experimental_variogram, distances = self.gamma()<br/>        fit_metrics = []<br/>        for nugget, sill, range_ in self.parameter_combinations:<br/>            theoretical_variogram_values = self.theoretical_variogram(distances, nugget, sill, range_)<br/>            fit_metric = MSE(experimental_variogram, theoretical_variogram_values)<br/>            fit_metrics.append((nugget, sill, range_, fit_metric))<br/><br/>        self.optimal_pars = min(fit_metrics, key=lambda x: x[3])[:3]</span></pre><p id="debf" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">And the last, but not least function is <strong class="nf fr">predict</strong>. Getting a point (lat;lon) as input, it estimates the distance between the point and other known values. Then it calls the theoretical_variogram function passing the optimal parameters we obtained earlier and getting weights as output. Then a weighted mean is calculated and returned.</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="7b42" class="oq or fq on b bg os ot l ou ov">def predict(self, point):<br/>        points = np.array([(x,y) for x,y in zip(self.lats, self.lons)])<br/>        distances = np.linalg.norm(points - point, axis=1)<br/>        pars = list(self.optimal_pars)<br/>        pars.insert(0, distances)<br/>        weights = self.theoretical_variogram(*pars)<br/>        weights /= np.sum(weights)<br/>        return np.dot(weights, self.values)</span></pre><p id="42bf" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now we can collect all the predictions and visualize the map:</p><pre class="mm mn mo mp mq om on oo bp op bb bk"><span id="fe78" class="oq or fq on b bg os ot l ou ov">row, grid = [], []<br/>for lat in LAT:<br/>  for lon in LON:<br/>    row.append(kriging.predict(np.array([lat, lon])))<br/>  grid.append(row)<br/>  row=[]<br/><br/>ds = xr.Dataset(<br/>    {'TAVG': (['lat', 'lon'], grid)},<br/>    coords={'lat': LAT, 'lon': LON})<br/><br/>fig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(16, 9))<br/>ds.where(rg).TAVG.plot(ax=ax, alpha=0.6)<br/>gdf.plot(ax=ax, color='r', markersize=85)<br/>ax.gridlines(draw_labels=True,linewidth=2, color='black', alpha=0.5, linestyle='--')<br/>plt.show()</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qi"><img src="../Images/1349a0969a19bd1bac7ea47919a97413.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mtnksVDLzuN-jZWR8pcmwA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by <a class="af nc" href="https://medium.com/@alexroz" rel="noopener">author</a>.</figcaption></figure><p id="3342" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">As you can see, the result is quite different from what we get from IDW. For Kriging the most important parameter is the kind of theoretical variogram you pick, since it basically defines the relationship between the predicted values and distance. In case you don’t want to play around with the code I provide here or your own, you can explore <a class="af nc" href="https://geostat-framework.readthedocs.io/projects/pykrige/en/stable/#license" rel="noopener ugc nofollow" target="_blank">PyKrige</a> library which has implementations of many variogram models.</p><p id="12af" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Hopefully this article was informative and insightful for you!</p><p id="1b31" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">===========================================</p><p id="8d15" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk"><strong class="nf fr"><em class="ol">All my publications on Medium are free and open-access, that’s why I’d really appreciate if you followed me here!</em></strong></p><p id="aebe" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">P.s. I’m extremely passionate about (Geo)Data Science, ML/AI and Climate Change. So if you want to work together on some project pls contact me in <a class="af nc" href="https://www.linkedin.com/in/alexxxroz/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>.</p><p id="4ba9" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">🛰️Follow for more🛰️</p></div></div></div></div>    
</body>
</html>
- en: How to Store and Query 100 Million Items Using Just 77MB with Python Bloom Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/how-to-store-and-query-100-million-items-using-just-77mb-with-python-bloom-filters-6b3e8549f032?source=collection_archive---------2-----------------------#2024-02-08](https://towardsdatascience.com/how-to-store-and-query-100-million-items-using-just-77mb-with-python-bloom-filters-6b3e8549f032?source=collection_archive---------2-----------------------#2024-02-08)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Perform lightning-fast, memory efficient membership checks in Python with this
    need-to-know data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://mikehuls.medium.com/?source=post_page---byline--6b3e8549f032--------------------------------)[![Mike
    Huls](../Images/8f9f55a0d25db00799c5d37383b7f5b6.png)](https://mikehuls.medium.com/?source=post_page---byline--6b3e8549f032--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--6b3e8549f032--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--6b3e8549f032--------------------------------)
    [Mike Huls](https://mikehuls.medium.com/?source=post_page---byline--6b3e8549f032--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--6b3e8549f032--------------------------------)
    ·11 min read·Feb 8, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/97200918356e1b6e481565d52747e46a.png)'
  prefs: []
  type: TYPE_IMG
- en: Programming with a view (image by ChatGPT)
  prefs: []
  type: TYPE_NORMAL
- en: 'A Bloom filter is a super-fast, memory-efficient data structure with many use-cases.
    The Bloom filter answers a simple question: does a set contain a given value?
    A good Bloom filter can contain 100 million items, use only 77MB of memory and
    still be lightning fast. It achieves this incredible efficiency by being probabilistic:
    when you ask if it contains an item, it can respond in two ways: **definitely
    not** or **maybe yes**.'
  prefs: []
  type: TYPE_NORMAL
- en: A Bloom filter can either tell you **with certainty** that an item is **not**
    a member of a set, or that it **probably is**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this article we’ll find out how a Bloom filter works, how to implement one,
    and we’ll go through some practical use cases. In the end you’ll have a new tool
    in your belt to optimize your scripts significantly! Let’s code!
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin..
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This article explores the mechanics of a Bloom Filter and provides a basic
    Python implementation to illustrate its inner workings in 6 steps:'
  prefs: []
  type: TYPE_NORMAL
- en: When to use a Bloom filter? Characteristics and use cases
  prefs:
  - PREF_OL
  type: TYPE_NORMAL

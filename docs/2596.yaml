- en: 'AI Agent Workflows: A Complete Guide on Whether to Build With LangGraph or
    LangChain'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/ai-agent-workflows-a-complete-guide-on-whether-to-build-with-langgraph-or-langchain-117025509fa0?source=collection_archive---------0-----------------------#2024-10-25](https://towardsdatascience.com/ai-agent-workflows-a-complete-guide-on-whether-to-build-with-langgraph-or-langchain-117025509fa0?source=collection_archive---------0-----------------------#2024-10-25)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**A deep dive into two libraries by the same creator — LangChain and LangGraph:
    their key building blocks, how they handle core pieces of their functionality,
    and deciding between them for your use case**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@sandibesen?source=post_page---byline--117025509fa0--------------------------------)[![Sandi
    Besen](../Images/97361d97f50269f70b6621da2256bc29.png)](https://medium.com/@sandibesen?source=post_page---byline--117025509fa0--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--117025509fa0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--117025509fa0--------------------------------)
    [Sandi Besen](https://medium.com/@sandibesen?source=post_page---byline--117025509fa0--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--117025509fa0--------------------------------)
    ·11 min read·Oct 25, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Language models have unlocked possibilities for how users can interact with
    AI systems and how these systems can communicate with each other — through natural
    language.
  prefs: []
  type: TYPE_NORMAL
- en: When enterprises want to build solutions using Agentic AI capabilities one of
    the first technical questions is often “what tools do I use?” For those that are
    eager to get started, this is the first roadblock.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/bbabc9b4020e5715a76bb4a605734055.png)'
  prefs: []
  type: TYPE_IMG
- en: Source:Dalle-3
  prefs: []
  type: TYPE_NORMAL
- en: '**In this article, we will explore two of the most popular frameworks for building
    Agentic AI Applications — LangChain and LangGraph.** **By the end of this article
    you should have a thorough understanding of the key building blocks, how each
    framework differs in handling core pieces of their functionality, and be able
    to form an educated point of view on which framework best fits your problem.**'
  prefs: []
  type: TYPE_NORMAL
- en: Since the practice of widely incorporating Generative AI into solutions is relatively
    new, open-source players are actively competing to develop the “best” agent framework
    and orchestration tools. This means that although each player brings a unique
    approach to the table, they are rolling out new functionality near constantly.
    When reading this piece keep in mind that what’s true today, might not be true
    tomorrow!
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: I originally intended to draw the comparison between AutoGen, LangChain,
    and LangGraph. However, AutoGen has* [*announced*](https://microsoft.github.io/autogen/0.2/blog/2024/10/02/new-autogen-architecture-preview/)
    *that it launching AutoGen 0.4, a complete redesign of the framework from the
    foundation up. Look out for another article when AutoGen 0.4 launches!*'
  prefs: []
  type: TYPE_NORMAL
- en: Base Components Of LangChain and LangGraph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By understanding the different base elements of each framework, you will have
    a richer understanding of the key differences on how they handle certain core
    functionality in the next section. The below description is not an exhaustive
    list of all of the components of each framework, but serves as a strong basis
    to understand the difference in their general approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**LangChain**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods for working with LangChain: as a sequential chain of
    predefined commands or using LangChain agents. Each approach is different in the
    way it handles tools and orchestration. A chain follows a predefined linear workflow
    while an agent acts as a coordinator that can make more dynamic (non linear) decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chains: A sequence of steps that can include calls to an llm, agent, tool,
    external data source, procedural code, and more. Chains can branch, meaning a
    single chain to split into multiple paths based on logical conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Agents or Language Models: A Language Model has the ability to generate responses
    in natural language. But the Agent uses a language model plus added capabilities
    to reason, call tools, and repeat the process of calling tools in case there are
    any failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tools: Code based functions that can be called in the chain or invoked by an
    agent to interact with external systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prompts: This can include a system prompt that instructs the model how to complete
    a task and what tools are available, information injected from external data sources
    that provided the model more context, and the user prompt or task for the model
    to complete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LangGraph**'
  prefs: []
  type: TYPE_NORMAL
- en: LangGraph approaches AI workflows from a different standpoint. Much like the
    name suggests, it orchestrates workflows like a graph. Because of its flexibility
    in handling different flows between AI agents, procedural code, and other tools,
    it is better suited for use cases where a linear chain method, branched chain,
    or simple agent system wouldn’t meet the needs of the use case. LangGraph was
    designed to handle more complex conditional logic and feedback loops compared
    to LangChain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphs: A flexible way of organizing a workflow that can include calls to an
    llm, tool, external data source, procedural code, and more. LangGraph supports
    cyclical graphs as well; which means you can create loops and feedback mechanisms
    so nodes can be revisited multiple times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nodes: Represent steps in the workflow, such as an LLM query, an API call,
    or tool execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edges and Conditional Edges: Edges define the flow of information by connecting
    the output of one node as the input to the next. A conditional edge defines the
    flow of information from one node to another if a certain condition is met. Developers
    can custom define these conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'State: State is the current status of the application as information flows
    through the graph. It is a developer defined mutable TypedDict object that contains
    all the relevant information for the current execution of the graph. LangGraph
    automatically handles the updating of state at each node as information flows
    through the graph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Agents or Language Models: Language models within a graph are solely responsible
    for generating a text response to an input. The agent capability leverages a language
    model but enables the graph to have multiple nodes representing different components
    of the agent (such as reasoning, tool selection, and execution of a tool). The
    agent can make decisions about which path to take in the graph, update the state
    of the graph, and perform more tasks than just text generation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Difference Between How Each Framework Handles Core Functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LangGraph and LangChain overlap in some of their capabilities but they approach
    the problem from a different perspective. LangChain focuses on either linear workflows
    through the use of chains or different AI agent patterns. While LangGraph focuses
    on creating a more flexible, granular, process based workflow that can include
    AI agents, tool calls, procedural code, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In general, LangChain require less of a learning curve than LangGraph. There
    are more abstractions and pre-defined configurations that make LangChain easier
    to implement for simple use cases. LangGraph allows more custom control over the
    design of the workflow, which means that it is less abstracted and the developer
    needs to learn more to use the framework effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tool Calling**:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LangChain**'
  prefs: []
  type: TYPE_NORMAL
- en: In LangChain there are two ways tools can be called depending on if you are
    using a chain to sequence a series of steps or are just using its agent capabilities
    without it being explicitly defined in a chain. In a chain, tools are included
    as a pre-defined step in the chain — meaning that they aren’t necessarily called
    by the agent because it was already predetermined they were going to be called
    in the chain. However, when you have an agent not defined in a chain, the agent
    has autonomy to decided what tool to invoke and when based on the list of tools
    it is privy to.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example of Flow for a Chain:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a937a13e7dc33df0a6714362f650f726.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Sandi Besen
  prefs: []
  type: TYPE_NORMAL
- en: Create the function that represents the tool and make it compatible with the
    chain
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incorporate the tool into the chain
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the chain
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Example of Flow for an Agent :*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/80980bbb40706002a4595f55bc4957e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Sandi Besen
  prefs: []
  type: TYPE_NORMAL
- en: The tool is defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tool is added to the agent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent receives a query and decides whether and when to use the search tool.
    The agent may use the tool multiple times if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**LangGraph**'
  prefs: []
  type: TYPE_NORMAL
- en: In **LangGraph**, tools are usually represented as a node on the graph. If the
    graph contains an agent, then then it is the agent that determines which tool
    to invoke based on its reasoning abilities. Based on the agent’s tool decision,
    the graph navigates to the “tool node” to handle the execution of the tool. Conditional
    logic can be included in the edge from the agent to the tool node to add additional
    logic that determines if a tool gets executed. This gives the developer another
    layer of control if desired. If there is no agent in the graph, then much like
    in LanchChain’s chain, the tool can be included in the workflow based on conditional
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: '*Example of Flow for a Graph with anAgent:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c7156da1e5dbb0a3dc3af2b9532cb2fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Sandi Besen
  prefs: []
  type: TYPE_NORMAL
- en: The tool is defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the tool is bound to the agent
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent decides if a tool is needed, and if so which tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The LangGraph framework detects a tool call is required and navigates to the
    tool node in the graph to execute the tool call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tool output is captured and added to the state of the graph
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent is called again with the updated state to allow it to make a decision
    on what to do next
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Example of Flow for a graph without an Agent:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bd4b0a727fce78bbe0e2c0babed8a5ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by Sandi Besen
  prefs: []
  type: TYPE_NORMAL
- en: The tool is defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tool is added to the graph as a node
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Conditional edges can be used to determine when to use a certain tool node and
    control the flow of the graph
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tool can be configured to update the state of the graph
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*If you want to learn more about tool calling, my friend* [*Tula Masterman*](https://medium.com/u/ce8c2ab0804a?source=post_page---user_mention--117025509fa0--------------------------------)
    *has an excellent* [*article*](https://medium.com/towards-data-science/ai-agents-the-intersection-of-tool-calling-and-reasoning-in-generative-ai-ff268eece443)
    *about how tool calling works in Generative AI.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Neither LangChain nor LangGraph support [semantic functions](https://www.developerscantina.com/p/semantic-kernel-functions/)
    out of the box like MSFT’s Semantic Kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: Conversation History and Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LangChain**'
  prefs: []
  type: TYPE_NORMAL
- en: Langchain offers built-in abstractions for handling conversation history and
    memory. There are options for the level of granularity (and therefore the amount
    of tokens) you’d like to pass to the llm which include the full session conversation
    history, a summarized version, or a custom defined memory. Developers can also
    create custom long term memory systems where they can store memories in external
    databases to be retrieved when relevant.
  prefs: []
  type: TYPE_NORMAL
- en: '**LangGraph**'
  prefs: []
  type: TYPE_NORMAL
- en: In LangGraph, the state handles memory by keeping track of defined variables
    at every point in time. State can include things like conversation history, steps
    of a plan, the output of a language model’s previous response, and more. It can
    be passed from one node to the next so that each node has access to what the current
    state of the system is. However, long term persistent memory across sessions is
    not available as a direct feature of the framework. To implement this, developers
    could include nodes responsible to store memories and other variables in an external
    database to be retrieved later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Out of the box RAG capabilities:**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LangChain**'
  prefs: []
  type: TYPE_NORMAL
- en: LangChain can handle complex retrieval and generation workflows and has a more
    established set of tools to help developers integrate RAG into their application.
    For instance LangChain offers document loading, text parsing, embedding creation,
    vector storage, and retrieval capabilities out of the box by using langchain.document_loaders,
    langchain.embeddings, and langchain.vectorstores directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**LangGraph**'
  prefs: []
  type: TYPE_NORMAL
- en: In LangGraph, RAG needs to be developed from scratch as part of the graph structure.
    For example there could be separate nodes for document parsing, embedding, and
    retrieval that would be connected by normal or conditional edges. The state of
    each node would be used to pass information between steps in the RAG pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallelism:**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LangChain**'
  prefs: []
  type: TYPE_NORMAL
- en: LangChain offers the opportunity to run multiple chains or agents in parallel
    by using the RunnableParallel class. For more advanced parallel processing and
    asynchronous tool calling, the developer would have to custom implement these
    capabilities by using python libraries such as ayncio.
  prefs: []
  type: TYPE_NORMAL
- en: '**LangGraph**'
  prefs: []
  type: TYPE_NORMAL
- en: LangGraph supports the parallel execution of nodes, as long as there aren’t
    any dependencies (like the output of one language model’s response as an input
    for the next node). This means that it can support multiple agents running at
    the same time in a graph as long as they are not dependent nodes. Like LangChain,
    LangGraph can use a RunnableParallel class to run multiple graphs in parallel.
    LangGraph also supports parallel tool calling by using python libraries like ayncio.
  prefs: []
  type: TYPE_NORMAL
- en: '**Retry Logic and Error Handling:**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LangChain**'
  prefs: []
  type: TYPE_NORMAL
- en: In LangChain, the error handling is explicitly defined by the developer and
    can either be done by introducing retry logic into the chain its self or in the
    agent if a tool call fails.
  prefs: []
  type: TYPE_NORMAL
- en: '**LangGraph**'
  prefs: []
  type: TYPE_NORMAL
- en: In LangGraph you can actually embed error handling into your workflow by having
    it be its own node. When certain tasks fail you can point to another node or have
    the same node retry. The best part is that only the particular node that fails
    is re-tried, not the entire workflow. This means the graph can resume from the
    point of failure rather than having to start from the beginning. If your use case
    requires many steps and tool calls, this could be imortant.
  prefs: []
  type: TYPE_NORMAL
- en: In Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use LangChain without LangGraph, LangGraph without LangChain, or both
    together! It’s also completely possible to explore using LangGraph’s graph based
    orchestration with other Agentic AI frameworks like MSFT’s AutoGen by making the
    AutoGen Agents their own nodes in the graph. Safe to say there are a lot of option
    — and it can feel overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: 'So after all this research, when should I use each? Although there are no hard
    and fast rules, below is my personal option:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use LangChain Only When:**'
  prefs: []
  type: TYPE_NORMAL
- en: You need to quickly prototype or develop AI workflows that either involve sequential
    tasks (such as such as document retrieval, text generation, or summarization)
    that follow a predefined linear pattern. Or you want to leverage AI agent patterns
    that can dynamically make decisions, but you don’t need granular control over
    a complex workflow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use LangGraph Only When:**'
  prefs: []
  type: TYPE_NORMAL
- en: Your use case requires non-linear workflows where multiple components interact
    dynamically such as workflows that depend on conditions, need complex branching
    logic, error handling, or parallelism. You are willing to build custom implementations
    for the components that are not abstracted for you like in LangChain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using LangChain and LanGraph Together When:**'
  prefs: []
  type: TYPE_NORMAL
- en: You enjoy the pre-built extracted components of LangChain such as the out of
    the box RAG capabilities, memory functionality, etc. but also want to manage complex
    task flows using LangGraph’s non-linear orchestration. Using both frameworks together
    can be a powerful tool for extracting the best abilities from each.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, whether you choose LangChain, LangGraph, or a combination of both
    depends on the specific needs of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: The opinions expressed both in this article and paper are solely those
    of the authors and do not necessarily reflect the views or policies of their respective
    employers.'
  prefs: []
  type: TYPE_NORMAL
- en: Still have questions or think that something needs to be further clarified?
    Drop me a DM on [LinkedIn](https://www.linkedin.com/in/sandibesen/)! I‘m always
    eager to engage in food for thought and iterate on my work.
  prefs: []
  type: TYPE_NORMAL
- en: '***References***:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/navigating-the-new-types-of-llm-agents-and-architectures-309382ce9f88?source=post_page-----117025509fa0--------------------------------)
    [## Navigating the New Types of LLM Agents and Architectures'
  prefs: []
  type: TYPE_NORMAL
- en: The failure of ReAct agents gives way to a new generation of agents — and possibilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/navigating-the-new-types-of-llm-agents-and-architectures-309382ce9f88?source=post_page-----117025509fa0--------------------------------)
    [](https://langchain-ai.github.io/langgraph/?source=post_page-----117025509fa0--------------------------------)
    [## Home
  prefs: []
  type: TYPE_NORMAL
- en: Build language agents as graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: langchain-ai.github.io](https://langchain-ai.github.io/langgraph/?source=post_page-----117025509fa0--------------------------------)
    [](https://www.pinecone.io/learn/langgraph-research-agent/?source=post_page-----117025509fa0--------------------------------)
    [## LangGraph and Research Agents | Pinecone
  prefs: []
  type: TYPE_NORMAL
- en: LangGraph is a graph-based agentic framework that allows us to build more flexible
    and controllable AI agents. Here…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'www.pinecone.io](https://www.pinecone.io/learn/langgraph-research-agent/?source=post_page-----117025509fa0--------------------------------)
    [](https://www.comet.com/site/blog/chaining-the-future-an-in-depth-dive-into-langchain/?source=post_page-----117025509fa0--------------------------------)
    [## Chaining the Future: An In-depth Dive into LangChain'
  prefs: []
  type: TYPE_NORMAL
- en: LLM chains are a sequence of interconnected components designed to execute tasks
    in a specific in order to maximize the…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'www.comet.com](https://www.comet.com/site/blog/chaining-the-future-an-in-depth-dive-into-langchain/?source=post_page-----117025509fa0--------------------------------)
    [](/from-basics-to-advanced-exploring-langgraph-e8c1cf4db787?source=post_page-----117025509fa0--------------------------------)
    [## From Basics to Advanced: Exploring LangGraph'
  prefs: []
  type: TYPE_NORMAL
- en: Building single- and multi-agent workflows with human-in-the-loop interactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/from-basics-to-advanced-exploring-langgraph-e8c1cf4db787?source=post_page-----117025509fa0--------------------------------)
  prefs: []
  type: TYPE_NORMAL

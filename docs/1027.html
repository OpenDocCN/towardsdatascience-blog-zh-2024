<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Building an AI-Powered Business Manager</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Building an AI-Powered Business Manager</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-an-ai-powered-business-manager-e2a31a2fe984?source=collection_archive---------3-----------------------#2024-04-23">https://towardsdatascience.com/building-an-ai-powered-business-manager-e2a31a2fe984?source=collection_archive---------3-----------------------#2024-04-23</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><figure class="fr fs ft fu fv fw fo fp paragraph-image"><div role="button" tabindex="0" class="fx fy ed fz bh ga"><div class="fo fp fq"><img src="../Images/dc602a5cdef860b9a6b382b91264e95b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zEqb2J3_vtY9mf5SjTtasA.jpeg"/></div></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">Created with <a class="af gi" href="https://labs.openai.com/s/1rNDsRujptitO6sPd57aWyZp" rel="noopener ugc nofollow" target="_blank">DALL·E</a></figcaption></figure><div/><div><h2 id="93a2" class="pw-subtitle-paragraph hi gk gl bf b hj hk hl hm hn ho hp hq hr hs ht hu hv hw hx cq dx">A step-by-step guide to linking your AI agent with a SQL database — Part 2 of the series</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hy hz ia ib ic ab"><div><div class="ab id"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@lukas.kowejsza?source=post_page---byline--e2a31a2fe984--------------------------------" rel="noopener follow"><div class="l ie if by ig ih"><div class="l ed"><img alt="Lukasz Kowejsza" class="l ep by dd de cx" src="../Images/8d920478bee9ad674a6c79462128b0db.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*gH4EgquV4LSB3aBWcBvU1Q.jpeg"/><div class="ii by l dd de em n ij eo"/></div></div></a></div></div><div class="ik ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--e2a31a2fe984--------------------------------" rel="noopener follow"><div class="l il im by ig in"><div class="l ed"><img alt="Towards Data Science" class="l ep by br io cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="ii by l br io em n ij eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="ip ab q"><div class="ab q iq"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b ir is bk"><a class="af ag ah ai aj ak al am an ao ap aq ar it" data-testid="authorName" href="https://medium.com/@lukas.kowejsza?source=post_page---byline--e2a31a2fe984--------------------------------" rel="noopener follow">Lukasz Kowejsza</a></p></div></div></div><span class="iu iv" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b ir is dx"><button class="iw ix ah ai aj ak al am an ao ap aq ar iy iz ja" disabled="">Follow</button></p></div></div></span></div></div><div class="l jb"><span class="bf b bg z dx"><div class="ab cn jc jd je"><div class="jf jg ab"><div class="bf b bg z dx ab jh"><span class="ji l jb">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar it ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--e2a31a2fe984--------------------------------" rel="noopener follow"><p class="bf b bg z jj jk jl jm jn jo jp jq bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="iu iv" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">29 min read</span><div class="jr js l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Apr 23, 2024</span></div></span></div></span></div></div></div><div class="ab cp jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki"><div class="h k w ea eb q"><div class="ky l"><div class="ab q kz la"><div class="pw-multi-vote-icon ed ji lb lc ld"><div class=""><div class="le lf lg lh li lj lk am ll lm ln ld"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l lo lp lq lr ls lt lu"><p class="bf b dy z dx"><span class="lf">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao le lx ly ab q ee lz ma" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lw"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count lv lw">5</span></p></button></div></div></div><div class="ab q kj kk kl km kn ko kp kq kr ks kt ku kv kw kx"><div class="mb k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al mc an ao ap iy md me mf" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep mg cn"><div class="l ae"><div class="ab cb"><div class="mh mi mj mk ml gb ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al mc an ao ap iy mm mn ma mo mp mq mr ms s mt mu mv mw mx my mz u na nb nc"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al mc an ao ap iy mm mn ma mo mp mq mr ms s mt mu mv mw mx my mz u na nb nc"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al mc an ao ap iy mm mn ma mo mp mq mr ms s mt mu mv mw mx my mz u na nb nc"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><p id="81cf" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Imagine streamlining your entire business management through a single, user-friendly interface on your phone. While juggling multiple apps is common practice, the future lies in consolidating all your interactions into one chat-based platform, powered by the capabilities of Large Language Models (LLMs).</p><p id="0769" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">For small businesses, this approach offers significant advantages. By centralizing data management tasks within a unified chat interface, owners can save time, reduce complexity, and minimize reliance on disparate software tools. The result is a more efficient allocation of resources, allowing a greater focus on core business growth activities.</p><p id="3fe9" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">However, the potential extends beyond just small businesses. The concepts and techniques detailed in this tutorial are adaptable to personal use cases as well. From managing to-do lists and tracking expenses to organizing collections, a chat-based interface provides an intuitive and efficient way to interact with your data.</p><p id="1471" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">This article is the second installment in a series that guides you through the process of developing such a software project, from initial concept to practical implementation. Building upon the components introduced in the previous article, we will establish the foundational elements of our application, including:</p><ul class=""><li id="90ec" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bk">Setting up the database schema</li><li id="739e" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">Defining core application functionality</li><li id="77c9" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">Structuring the project repository</li><li id="d89a" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">Creating Tools capable of interacting with multiple SQL database tables using natural language commands</li></ul><p id="6d0b" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">By the end of this tutorial, you will have a clear understanding of how to architect a chat-based interface that leverages LLMs to simplify data management tasks. Whether you’re a small business owner looking to streamline operations or an individual seeking to optimize personal organization, the principles covered here will provide a solid starting point for your own projects.</p><p id="2218" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Let’s begin by briefly recapping the key takeaways from the previous article to set the context for our current objectives.</p><h1 id="6150" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">Recap</h1><p id="b88e" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk"><a class="af gi" rel="noopener" target="_blank" href="/leverage-openai-tool-calling-building-a-reliable-ai-agent-from-scratch-4e21fcd15b62">In the first part of this series</a>, we built a prototype agent workflow capable of interacting with tool objects. Our goal was to reduce hallucination in tool arguments generated by the underlying language model, in our case <code class="cx pi pj pk pl b">gpt-3.5-turbo</code>.</p><p id="64ff" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To achieve this, we implemented two key changes:</p><ol class=""><li id="be99" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny pm oa ob bk">Removed required parameters in the tool schema</li><li id="f41c" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny pm oa ob bk">Added a parameter validation step before executing the desired function</li></ol><p id="f092" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">By setting all tool parameters to optional and manually checking for missing parameters, we eliminated the urge for the Agent/LLM to hallucinate missing values.</p><p id="035f" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The key objects introduced in the previous article were:</p><ul class=""><li id="67cb" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bk"><code class="cx pi pj pk pl b">OpenAiAgent</code>: The main agent workflow class</li><li id="355d" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk"><code class="cx pi pj pk pl b">Tool</code>: A class representing a tool the agent can use</li><li id="4906" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk"><code class="cx pi pj pk pl b">ToolResult</code> and <code class="cx pi pj pk pl b">StepResult</code>: Classes for encapsulating tool execution results</li></ul><p id="0bb6" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">These components formed the foundation of our agent system, allowing it to process user requests, select appropriate tools, and generate responses.</p><p id="bb63" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">If you’d like a more detailed explanation or want to know the reasoning behind specific design choices, feel free to check out the previous article: <a class="af gi" href="https://medium.com/towards-data-science/leverage-openai-tool-calling-building-a-reliable-ai-agent-from-scratch-4e21fcd15b62" rel="noopener">Leverage OpenAI Tool Calling: Building a Reliable AI Agent from Scratch</a></p><p id="bbef" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">With this recap in mind, let’s dive into the next phase of our project — integrating database functionality to store and manage business data.</p><h1 id="a943" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">Why Chat Interface for Small Business Data Management</h1><p id="7db1" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">Small businesses often face unique challenges when it comes to data maintenance. Like larger corporations, they need to regularly update and maintain various types of data, such as accounting records, time tracking, invoices, and more. However, the complexity and costs associated with modern ERP (Enterprise Resource Planning) systems can be prohibitive for small businesses. As a result, many resort to using a series of Excel spreadsheets to capture and maintain essential data.</p><p id="f18b" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The problem with this approach is that small business owners, who are rarely dedicated solely to administrative tasks, cannot afford to invest significant time and effort into complex administration and control processes. The key is to define lean processes and update data as it arises, minimizing the overhead of data management.</p><p id="4782" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">By leveraging the power of Large Language Models and creating a chat interface, we aim to simplify and streamline data management for small businesses. The chatbot will act as a unified interface, allowing users to input data, retrieve information, and perform various tasks using natural language commands. This eliminates the need for navigating multiple spreadsheets or developing complex web applications with multiple forms and dashboards.</p><p id="47ca" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Throughout this series, we will gradually enhance the chatbot’s capabilities, adding features such as role-based access control, advanced querying and evaluation, multimodal support, and integration with popular communication platforms like WhatsApp. By the end of the series, you will have a powerful and flexible tool that can adapt to your specific needs, whether you’re running a small business or simply looking to organize your personal life more efficiently.</p><p id="32ca" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Let’s get started!</p><h1 id="eafd" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">1. Project Structure</h1><p id="d0c0" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">To ensure a well-organized and maintainable project, we’ve structured our repository to encapsulate different functionalities and components systematically. Here’s an overview of the repository structure:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="103c" class="pv oi gl pl b bg pw px l py pz">project-root/<br/>│<br/>├── database/<br/>│ ├── db.py # Database connection and setup<br/>│ ├── models.py # Database models/schemas<br/>| └── utils.py # Database utilities<br/>│<br/>├── tools/<br/>│ ├── base.py # Base class for tools<br/>│ ├── add.py # Tool for adding data to the database<br/>│ ├── query.py # Tool for querying data from the database<br/>| └── utils.py # Tool utilities<br/>│<br/>├── agents/<br/>│ ├── base.py # Main AI agent logic<br/>│ ├── routing.py # Specialized agent for routing tasks<br/>│ ├── task.py # Tool wrapper for OpenAI subagents<br/>| └── utils.py # agent utilities<br/>│<br/>└── utils.py # Utility functions and classes</span></pre><p id="b864" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">This structure allows for a clear separation of concerns, making it easier to develop, maintain, and scale our application.</p><h1 id="37a6" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">2. Set up Database</h1><p id="2a1e" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">Choosing the right database and ORM (Object-Relational Mapping) library is crucial for our application. For this project, we’ve selected the following frameworks:</p><ul class=""><li id="847d" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bk">SQLAlchemy: A powerful SQL toolkit and Object-Relational Mapping (ORM) library for Python. It provides a set of tools for interacting with databases using Python objects and classes.</li><li id="d3ae" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">SQLModel: A library that builds on top of SQLAlchemy and Pydantic, offering a simple and intuitive way to define database models and perform database operations.</li></ul><p id="0e41" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">By leveraging SQLModel, we can seamlessly integrate with Pydantic and SQLAlchemy, enabling efficient data validation and database operations while eliminating the risk of SQL injection attacks. Moreover, SQLModel allows us to easily build upon our previously designed <code class="cx pi pj pk pl b">Tool</code> class, which uses Pydantic models for creating a tool schema.</p><p id="bcbd" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To ensure the security and robustness of our application, we implement the following measures:</p><ol class=""><li id="0c5e" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny pm oa ob bk">Role-based access control: Executable operations are bound to user roles, ensuring that users can only perform actions they are authorized to do. This adds an extra layer of security and prevents unauthorized access to sensitive data.</li><li id="76ea" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny pm oa ob bk">Prevention of SQL injection attacks: By utilizing ChatGPT’s natural language understanding capabilities, we can validate and sanitize user inputs, mitigating the risk of SQL injection vulnerabilities. SQLModel’s integration with Pydantic helps us enforce strict data validation rules.</li></ol><p id="7e07" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">With our tech stack decided, let’s dive into setting up the database and defining our models.</p><h1 id="2152" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">2.1 Database Models</h1><p id="1524" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">To begin building our prototype application, we’ll define the essential database tables and their corresponding SQLModel definitions. For this tutorial, we’ll focus on three core tables:</p><ul class=""><li id="1dea" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bk">Expense</li><li id="d1a7" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">Revenue</li><li id="b907" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">Customer</li></ul><p id="867f" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">These tables will serve as the foundation for our application, allowing us to demonstrate the key functionalities and interactions.</p><p id="1634" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Create a new file named <code class="cx pi pj pk pl b">models.py</code> in the <code class="cx pi pj pk pl b">database</code> directory and define the tables using SQLModel:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="2d0c" class="pv oi gl pl b bg pw px l py pz"># database\models.py<br/>from typing import Optional  <br/>  <br/>from pydantic import BeforeValidator, model_validator  <br/>from sqlmodel import SQLModel, Field  <br/>from datetime import time, datetime  <br/>from typing_extensions import Annotated <br/><br/>def validate_date(v):  <br/>    if isinstance(v, datetime):  <br/>        return v  <br/>  <br/>    for f in ["%Y-%m-%d", "%Y-%m-%d %H:%M:%S"]:  <br/>        try:  <br/>            return datetime.strptime(v, f)  <br/>        except ValueError:  <br/>            pass  <br/>  <br/>    raise ValueError("Invalid date format")  <br/>  <br/>  <br/>def numeric_validator(v):  <br/>    if isinstance(v, int):  <br/>        return float(v)  <br/>    elif isinstance(v, float):  <br/>        return v  <br/>    raise ValueError("Value must be a number")  <br/>  <br/>  <br/>DateFormat = Annotated[datetime, BeforeValidator(validate_date)]  <br/>Numeric = Annotated[float, BeforeValidator(numeric_validator)]<br/>  <br/>class Customer(SQLModel, table=True):  <br/>    id: Optional[int] = Field(primary_key=True, default=None)<br/>    company: str<br/>    first_name: str  <br/>    last_name: str  <br/>    phone: str  <br/>    address: str  <br/>    city: str  <br/>    zip: str  <br/>    country: str  <br/>  <br/>  <br/>class Revenue(SQLModel, table=True):  <br/>    id: Optional[int] = Field(primary_key=True, default=None)  <br/>    description: str  <br/>    net_amount: Numeric  <br/>    gross_amount: Numeric  <br/>    tax_rate: Numeric  <br/>    date: DateFormat  <br/>  <br/>  <br/>class Expense(SQLModel, table=True):  <br/>    id: Optional[int] = Field(primary_key=True, default=None)  <br/>    description: str  <br/>    net_amount: Numeric = Field(description="The net amount of the expense")  <br/>    gross_amount: Numeric  <br/>    tax_rate: Numeric  <br/>    date: DateFormat</span></pre><p id="5418" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">In addition to the standard SQLModel fields, we’ve defined three custom type annotations: <code class="cx pi pj pk pl b">DateFormat</code>, <code class="cx pi pj pk pl b">TimeFormat</code>, and <code class="cx pi pj pk pl b">Numeric</code>. These annotations leverage Pydantic’s <code class="cx pi pj pk pl b">BeforeValidator</code> to ensure that the input data is correctly formatted before being stored in the database. The <code class="cx pi pj pk pl b">validate_date</code> function handles the conversion of string input to the appropriate <code class="cx pi pj pk pl b">datetime</code>. This approach allows us to accept a variety of date formats from the Large Language Model, reducing the need for strict format enforcement in the prompts.</p><h1 id="af01" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">2.2 Database Engine</h1><p id="d09f" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">With our models defined, we need a script to set up the database engine and create the corresponding tables. Let’s create a <code class="cx pi pj pk pl b">db.py</code> file in the <code class="cx pi pj pk pl b">database</code> directory to handle this:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="44a3" class="pv oi gl pl b bg pw px l py pz"># database/db.py<br/>from database.models import *  <br/>from sqlmodel import SQLModel, create_engine  <br/>import os  <br/>  <br/>  <br/># local stored database  <br/>DATABASE_URL = "sqlite:///app.db"  <br/>  <br/>engine = create_engine(DATABASE_URL, echo=True) <br/>  <br/>  <br/>def create_db_and_tables():  <br/>    SQLModel.metadata.create_all(engine)  <br/>  <br/>  <br/>create_db_and_tables()</span></pre><p id="afff" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">In this script, we import our models and the necessary SQLModel components. We define the <code class="cx pi pj pk pl b">DATABASE_URL</code> to point to a local SQLite database file named <code class="cx pi pj pk pl b">app.db</code>. We create an <code class="cx pi pj pk pl b">engine</code> using <code class="cx pi pj pk pl b">create_engine</code> from SQLModel, passing in the <code class="cx pi pj pk pl b">DATABASE_URL</code>. The <code class="cx pi pj pk pl b">echo=True</code> parameter enables verbose output for debugging purposes.</p><p id="0868" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The <code class="cx pi pj pk pl b">create_db_and_tables</code> function uses <code class="cx pi pj pk pl b">SQLModel.metadata.create_all</code> to generate the corresponding tables in the database based on our defined models. Finally, we call this function to ensure the database and tables are created when the script is run.</p><p id="a5f3" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">With our database setup complete, we can now focus on updating our <code class="cx pi pj pk pl b">Tool</code> class to work seamlessly with SQLModel and enhance our tool schema conversion process.</p><h1 id="237b" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">3. Tool Class</h1><p id="998e" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">In this section, we’ll discuss the updates made to the <code class="cx pi pj pk pl b">Tool</code> class to handle SQLModel instances and improve the validation process. For a more detailed explanation of the <code class="cx pi pj pk pl b">Tool</code> class, visit my previous article.</p><p id="560f" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">First, we’ve added <code class="cx pi pj pk pl b">Type[SQLModel]</code> as a possible type for the <code class="cx pi pj pk pl b">model</code> field using the <code class="cx pi pj pk pl b">Union</code> type hint. This allows the <code class="cx pi pj pk pl b">Tool</code> class to accept both Pydantic's <code class="cx pi pj pk pl b">BaseModel</code> and SQLModel's <code class="cx pi pj pk pl b">SQLModel</code> as valid model types.</p><p id="9316" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Next, we’ve introduced a new attribute called <code class="cx pi pj pk pl b">exclude_keys</code> of type <code class="cx pi pj pk pl b">list[str]</code> with a default value of <code class="cx pi pj pk pl b">["id"]</code>. The purpose of this attribute is to specify which keys should be excluded from the validation process and the OpenAI tool schema generation. In this case the default excluded key is <code class="cx pi pj pk pl b">id</code> since for data entry creation with <code class="cx pi pj pk pl b">SqlModel</code> the id is automatically generated during ingestion.</p><p id="86a2" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">On top of that we introduced <code class="cx pi pj pk pl b">parse_model</code> boolean attribute to our Tool class. Where we can basically decided if the tool function is called with our pydantic/SQLModel or with keyword arguments.</p><p id="12e0" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">In the <code class="cx pi pj pk pl b">validate_input()</code> method, we've added a check to ensure that the keys specified in <code class="cx pi pj pk pl b">exclude_keys</code> are not considered as missing keys during the validation process. This is particularly useful for fields like <code class="cx pi pj pk pl b">id</code>, which are automatically generated by SQLModel and should not be required in the input.</p><p id="46ca" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Similarly, in the <code class="cx pi pj pk pl b">openai_tool_schema</code> property, we've added a loop to remove the excluded keys from the generated schema. This ensures that the excluded keys are not included in the schema sent to the OpenAI API. For recap we use the <code class="cx pi pj pk pl b">openai_tool_schema</code> property to remove <code class="cx pi pj pk pl b">required</code> arguments from our tool schema. This is done to elimenate hallucination by our language model.</p><p id="edfe" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Moreover, we changed the import from <code class="cx pi pj pk pl b">from pydantic.v1 import BaseModel</code> to <code class="cx pi pj pk pl b">from pydantic import BaseModel</code>. Since <code class="cx pi pj pk pl b">SQLModel</code> is based on Pydantic v2, we want to be consistent and use Pydantic v2 at this point.</p><p id="7af5" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Here’s the updated code for the <code class="cx pi pj pk pl b">Tool</code> class:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="b3a0" class="pv oi gl pl b bg pw px l py pz"># tools/base.py<br/>from typing import Type, Callable, Union<br/><br/>from tools.convert import convert_to_openai_tool<br/>from pydantic import BaseModel, ConfigDict<br/>from sqlmodel import SQLModel<br/><br/><br/>class ToolResult(BaseModel):<br/>    content: str<br/>    success: bool<br/><br/><br/>class Tool(BaseModel):<br/>    name: str<br/>    model: Union[Type[BaseModel], Type[SQLModel], None]<br/>    function: Callable<br/>    validate_missing: bool = True<br/>    parse_model: bool = False<br/>    exclude_keys: list[str] = ["id"]<br/><br/>    model_config = ConfigDict(arbitrary_types_allowed=True)<br/><br/>    def run(self, **kwargs) -&gt; ToolResult:<br/>        if self.validate_missing and model is not None:<br/>            missing_values = self.validate_input(**kwargs)<br/>            if missing_values:<br/>                content = f"Missing values: {', '.join(missing_values)}"<br/>                return ToolResult(content=content, success=False)<br/><br/>        if self.parse_model:<br/>            if hasattr(self.model, "model_validate"):<br/>                input_ = self.model.model_validate(kwargs)<br/>            else:<br/>                input_ = self.model(**kwargs)<br/>            result = self.function(input_)<br/><br/>        else:<br/>            result = self.function(**kwargs)<br/>        return ToolResult(content=str(result), success=True)<br/><br/>    def validate_input(self, **kwargs):<br/>        if not self.validate_missing or not self.model:<br/>            return []<br/>        model_keys = set(self.model.__annotations__.keys()) - set(self.exclude_keys)<br/>        input_keys = set(kwargs.keys())<br/>        missing_values = model_keys - input_keys<br/>        return list(missing_values)<br/><br/>    @property<br/>    def openai_tool_schema(self):<br/>        schema = convert_to_openai_tool(self.model)<br/>        # set function name<br/>        schema["function"]["name"] = self.name<br/><br/>        # remove required field<br/>        if schema["function"]["parameters"].get("required"):<br/>            del schema["function"]["parameters"]["required"]<br/>        # remove exclude keys<br/>        if self.exclude_keys:<br/>            for key in self.exclude_keys:<br/>                if key in schema["function"]["parameters"]["properties"]:<br/>                    del schema["function"]["parameters"]["properties"][key]<br/>        return schema</span></pre><p id="c025" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">These updates to the <code class="cx pi pj pk pl b">Tool</code> class provide more flexibility and control over the validation process and schema generation when working with SQLModel instances.</p><h1 id="7ff7" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">3.1 Custom Tool Schema Conversion</h1><p id="2e70" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">In our <code class="cx pi pj pk pl b">Tool</code> class, we create a schema from a Pydantic model using the <code class="cx pi pj pk pl b">convert_to_openai_tool</code> function from Langchain. However, this function is based on Pydantic v1, while SQLModel uses Pydantic v2. To make the conversion function compatible, we need to adapt it. Let's create a new script called <code class="cx pi pj pk pl b">convert.py</code>:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="9b83" class="pv oi gl pl b bg pw px l py pz"># tools/convert.py<br/>from langchain_core.utils.function_calling import _rm_titles<br/>from typing import Type, Optional<br/>from langchain_core.utils.json_schema import dereference_refs<br/>from pydantic import BaseModel<br/><br/>def convert_to_openai_tool(<br/>        model: Type[BaseModel],<br/>        *,<br/>        name: Optional[str] = None,<br/>        description: Optional[str] = None,<br/>) -&gt; dict:<br/>    """Converts a Pydantic model to a function description for the OpenAI API."""<br/>    function = convert_pydantic_to_openai_function(<br/>        model, name=name, description=description<br/>    )<br/>    return {"type": "function", "function": function}<br/><br/>def convert_pydantic_to_openai_function(<br/>        model: Type[BaseModel],<br/>        *,<br/>        name: Optional[str] = None,<br/>        description: Optional[str] = None,<br/>        rm_titles: bool = True,<br/>) -&gt; dict:<br/>    """Converts a Pydantic model to a function description for the OpenAI API."""<br/><br/>    model_schema = model.model_json_schema() if hasattr(model, "model_json_schema") else model.schema()<br/>    <br/>    schema = dereference_refs(model_schema)<br/>    schema.pop("definitions", None)<br/>    title = schema.pop("title", "")<br/>    default_description = schema.pop("description", "")<br/>    return {<br/>        "name": name or title,<br/>        "description": description or default_description,<br/>        "parameters": _rm_titles(schema) if rm_titles else schema,<br/>    }</span></pre><p id="7114" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">This adapted conversion function handles the differences between Pydantic v1 and v2, ensuring that our <code class="cx pi pj pk pl b">Tool</code> class can generate compatible schemas for the OpenAI API.</p><p id="fd45" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Next, update the import statement in <code class="cx pi pj pk pl b">tools/base.py</code> to use the new <code class="cx pi pj pk pl b">convert_to_openai_tool</code> function:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="a703" class="pv oi gl pl b bg pw px l py pz"># tools/base.py<br/>from typing import Type, Callable, Union<br/><br/>from tools.convert import convert_to_openai_tool<br/>from pydantic import BaseModel<br/>from sqlmodel import SQLModel<br/>#...rest of the code ...</span></pre><p id="97d2" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">With these changes in place, our <code class="cx pi pj pk pl b">Tool</code> class can now handle SQLModel instances and generate schemas that are compatible with the OpenAI API.</p><blockquote class="qa qb qc"><p id="7eef" class="nd ne qd nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk"><em class="gl">Note: If you encounter dependency issues, you may consider removing the Langchain dependency entirely and including the </em><code class="cx pi pj pk pl b"><em class="gl">_rm_titles</em></code><em class="gl"> and </em><code class="cx pi pj pk pl b"><em class="gl">dereference_refs</em></code><em class="gl"> functions directly in the </em><code class="cx pi pj pk pl b"><em class="gl">convert.py</em></code><em class="gl"> file.</em></p></blockquote><p id="5d97" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">By adapting the tool schema conversion process, we’ve ensured that our application can seamlessly work with SQLModel and Pydantic v2, enabling us to leverage the benefits of these libraries while maintaining compatibility with the OpenAI API.</p><h1 id="b366" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">4. Defining SQL Tools</h1><p id="f910" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">In this section, we will create functions and tools to interact with our database tables using SQL.</p><h2 id="11a1" class="qe oi gl bf oj qf qg qh om qi qj qk op nm ql qm qn nq qo qp qq nu qr qs qt qu bk">4.1 Add Data Tool</h2><p id="2fbe" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">First, let’s define a generic function <code class="cx pi pj pk pl b">add_row_to_table</code> that takes a SQLModel instance and adds it to the corresponding table:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="f27e" class="pv oi gl pl b bg pw px l py pz"># tools/add.py<br/>from sqlmodel import SQLModel, Session, select<br/><br/>def add_row_to_table(model_instance: SQLModel):  <br/>    with Session(engine) as session:  <br/>        session.add(model_instance)  <br/>        session.commit()  <br/>        session.refresh(model_instance)  <br/>    return f"Successfully added {model_instance} to the table"</span></pre><p id="d821" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Next, we’ll create a model-specific function <code class="cx pi pj pk pl b">add_expense_to_table</code> that takes input arguments for an Expense entry and adds it to the table:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="0c8f" class="pv oi gl pl b bg pw px l py pz"># tools/add.py<br/># ...<br/>def add_expense_to_table(**kwargs):<br/>    model_instance = Expense.model_validate(kwargs)<br/>    return add_row_to_table(model_instance)</span></pre><p id="80fa" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">In <code class="cx pi pj pk pl b">add_expense_to_table</code>, we use the <code class="cx pi pj pk pl b">model_validate()</code> method to trigger the execution of the previously defined BeforeValidator and ensure data validation.</p><p id="7dd7" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To avoid writing separate functions for each table or SQLModel, we can dynamically generate the functions:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="7452" class="pv oi gl pl b bg pw px l py pz"># example usage<br/><br/>def add_entry_to_table(sql_model: Type[SQLModel]):  <br/>    # return a Callable that takes a SQLModel instance and adds it to the table  <br/>    return lambda **data: add_row_to_table(model_instance=sql_model.model_validate(data))<br/>    <br/>add_expense_to_table = add_entry_to_table(Expense)</span></pre><p id="9810" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">This approach produces the same result and can be used to dynamically generate functions for all other models.</p><p id="f061" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">With these functions in place, we can create tools using our <code class="cx pi pj pk pl b">Tool</code> class to add entries to our database tables via the OpenAIAgent:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="d7b1" class="pv oi gl pl b bg pw px l py pz">add_expense_tool = Tool(<br/> name="add_expense_tool",<br/> description="useful for adding expenses to database",<br/> function=add_entry_to_table(Expense),<br/> model=Expense,<br/> validate_missing=True<br/>)<br/><br/>add_revenue_tool = Tool(<br/> name="add_revenue_tool",<br/> description="useful for adding revenue to database",<br/> function=add_entry_to_table(Revenue),<br/> model=Revenue,<br/> validate_missing=True<br/>)</span></pre><h1 id="a851" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">4.2 Query Tool</h1><p id="4508" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">While we need to create an add_xxx_tool for each table due to varying input schemas, we only need one query tool for querying all tables. To eliminate the risk of SQL injection, we will use the SQL sanitization provided by SQLAlchemy and SQLModel. This means we will query the database through standard Python classes and objects instead of parsing SQL statements directly.</p><p id="4b4e" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">For the queries we want to perform on our tables, we will need the following logic:</p><ol class=""><li id="9597" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny pm oa ob bk"><strong class="nf gm">select statement</strong> -&gt; <code class="cx pi pj pk pl b">SELECT * FROM table_name</code> Arguments: <code class="cx pi pj pk pl b">columns</code>, <code class="cx pi pj pk pl b">table_name</code></li><li id="646b" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny pm oa ob bk"><strong class="nf gm">where statement</strong> -&gt; <code class="cx pi pj pk pl b">WHERE column_name = value</code><br/>Arguments: <code class="cx pi pj pk pl b">column</code>, <code class="cx pi pj pk pl b">operator</code>, <code class="cx pi pj pk pl b">value</code></li></ol><p id="6bcc" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">In SQLModel, this corresponds to the following sanitized code when we want to find all expenses for coffee in the <code class="cx pi pj pk pl b">Expense</code> table:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="040a" class="pv oi gl pl b bg pw px l py pz">result = database.execute(<br/>  select(Expense).where(Expense.description == "Coffee")<br/>)</span></pre><p id="ab35" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To abstract this into a pydantic model:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="672c" class="pv oi gl pl b bg pw px l py pz"># tools/query.py<br/>from typing import Union, Literal<br/>from pydantic import BaseModel<br/><br/>class WhereStatement(BaseModel):  <br/>    column: str  <br/>    operator: Literal["eq", "gt", "lt", "gte", "lte", "ne", "ct"]  <br/>    value: str  <br/>  <br/>class QueryConfig(BaseModel):  <br/>    table_name: str  <br/>    columns: list[str]  <br/>    where: list[Union[WhereStatement, None]]</span></pre><p id="63ec" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The <code class="cx pi pj pk pl b">QueryConfig</code> model allows us to set a <code class="cx pi pj pk pl b">table_name</code>, <code class="cx pi pj pk pl b">columns</code>, and <code class="cx pi pj pk pl b">where</code> statements. The <code class="cx pi pj pk pl b">where</code> property accepts a list of <code class="cx pi pj pk pl b">WhereStatement</code> models or an empty list (when we want to return all values with no further filtering). A <code class="cx pi pj pk pl b">WhereStatement</code> is a submodel defining a column, operator, and value. The <code class="cx pi pj pk pl b">Literal</code> type is used to restrict the allowed operators to a predefined set.</p><p id="9dd0" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Next, we define a function that executes a query based on the <code class="cx pi pj pk pl b">QueryConfig</code>:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="75c5" class="pv oi gl pl b bg pw px l py pz"># tools/query.py<br/># ...<br/>from database.models import Expense, Revenue, Customer<br/><br/>TABLES = {<br/>    "expense": Expense,<br/>    "revenue": Revenue,<br/>    "customer": Customer<br/>}<br/><br/><br/><br/>def query_data_function(**kwargs) -&gt; ToolResult:  <br/>    """Query the database via natural language."""<br/>    query_config = QueryConfig.model_validate(kwargs)<br/>    <br/>    if query_config.table_name not in TABLES:  <br/>        return ToolResult(content=f"Table name {query_config.table_name} not found in database models", success=False)  <br/>  <br/>    sql_model = TABLES[query_config.table_name]  <br/>  <br/>    # query_config = validate_query_config(query_config, sql_model)  <br/>    data = sql_query_from_config(query_config, sql_model)  <br/>  <br/>    return ToolResult(content=f"Query results: {data}", success=True)  <br/>    <br/>  <br/>def sql_query_from_config(  <br/>        query_config: QueryConfig,  <br/>        sql_model: Type[SQLModel]):  <br/>  <br/>    with Session(engine) as session:  <br/>        selection = []  <br/>        for column in query_config.select_columns:  <br/>            if column not in sql_model.__annotations__:  <br/>                return f"Column {column} not found in model {sql_model.__name__}"  <br/>            selection.append(getattr(sql_model, column))  <br/>        <br/>        statement = select(*selection)  <br/>        wheres = query_config.where  <br/>        if wheres:  <br/>            for where in wheres:  <br/>  <br/>                if where.column not in sql_model.__annotations__:  # noqa  <br/>                    return (f"Column {where['column']} not found "<br/>                       "in model {sql_model.__name__}")<br/>  <br/>                elif where.operator == "eq":  <br/>                    statement = statement.where(<br/>                     getattr(sql_model, where.column) == where.value)  <br/>                elif where.operator == "gt":  <br/>                    statement = statement.where(<br/>                     getattr(sql_model, where.column) &gt; where.value)  <br/>                elif where.operator == "lt":  <br/>                    statement = statement.where(<br/>                     getattr(sql_model, where.column) &lt; where.value)  <br/>                elif where.operator == "gte":  <br/>                    statement = statement.where(<br/>                     getattr(sql_model, where.column) &gt;= where.value)  <br/>                elif where.operator == "lte":  <br/>                    statement = statement.where(<br/>                     getattr(sql_model, where.column) &lt;= where.value)  <br/>                elif where.operator == "ne":  <br/>                    statement = statement.where(<br/>                     getattr(sql_model, where.column) != where.value)  <br/>                elif where.operator == "ct":  <br/>                    statement = statement.where(<br/>                     getattr(sql_model, where.column).contains(where.value))  <br/>  <br/>        result = session.exec(statement)  <br/>        data = result.all()  <br/>        try:  <br/>            data = [repr(d) for d in data]  <br/>        except:  <br/>            pass  <br/>    return data</span></pre><p id="146f" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The <code class="cx pi pj pk pl b">query_data_function</code> serves as a high-level abstraction for selecting our table model from the <code class="cx pi pj pk pl b">TABLES</code> dictionary, while <code class="cx pi pj pk pl b">sql_query_from_config</code> is the underlying function for executing the <code class="cx pi pj pk pl b">QueryConfig</code> on a table (SQLModel).</p><blockquote class="qa qb qc"><p id="db25" class="nd ne qd nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">In `QueryConfig` you can choose to also define table_names as Literal type, where you hard code the available table names into it. You can even dynamically define the Literal using our TABLES dictionary. By doing so you can reduce false arguments for table_name. For now I have choosen to not use an enum object, because I will provide the agent prompt with context about the currently available tables and there underling ORM schema. I plan to add a tool for our future agent to create new tables on it’s own.While I can dynamically change the agent’s prompt, it won’t be straightforward to change the enum object within `QueryConfig` on our running server.</p></blockquote><p id="fcd7" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Finally, we can define our query tool:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="07fc" class="pv oi gl pl b bg pw px l py pz">query_data_tool = Tool(  <br/>    name="query_data_tool",  <br/>    description = "useful to perform queries on a database table",<br/>    model=QueryConfig,  <br/>    function=query_data_function, <br/>)</span></pre><p id="571b" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">With these tools in place, our OpenAIAgent is now capable of adding and querying data in our database tables using natural language commands.</p><h1 id="e7e0" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">5. Configure Agent</h1><p id="7fb2" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">To enable successful tool usage for our previously defined tools, the Agent from the previous article will need more context information, especially for using the query tool. The Agent prompt will need to include information about available tables and their schemas. Since we only use two tables at this point, we can include the ORM schema and table names in the system prompt or user prompt. Both options might work well, but I prefer to include variable information like this in the user prompt. By doing so, we can create few-shot examples that demonstrate context-aware tool usage.</p><p id="fcaf" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To make our Agent capable of handling variable context in the system prompt and user prompt, we can update our Agent class as follows:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="0602" class="pv oi gl pl b bg pw px l py pz">import colorama  <br/>from colorama import Fore  <br/>from openai import OpenAI  <br/>from pydantic import BaseModel  <br/>from tools.base import Tool, ToolResult  <br/>from agents.utils import parse_function_args, run_tool_from_response  <br/>  <br/>  <br/>class StepResult(BaseModel):  <br/>    event: str  <br/>    content: str  <br/>    success: bool  <br/>  <br/>  <br/>SYSTEM_MESSAGE = """You are tasked with completing specific objectives and must report the outcomes. At your disposal, you have a variety of tools, each specialized in performing a distinct type of task.  <br/>  <br/>For successful task completion:  <br/>Thought: Consider the task at hand and determine which tool is best suited based on its capabilities and the nature of the work. If you can complete the task or answer a question, soley by the information provided you can use the report_tool directly.  <br/>  <br/>Use the report_tool with an instruction detailing the results of your work or to answer a user question.  <br/>If you encounter an issue and cannot complete the task:  <br/>  <br/>Use the report_tool to communicate the challenge or reason for the task's incompletion.  <br/>You will receive feedback based on the outcomes of each tool's task execution or explanations for any tasks that couldn't be completed. This feedback loop is crucial for addressing and resolving any issues by strategically deploying the available tools.  <br/>  <br/>Return only one tool call at a time.  <br/>  <br/>{context}  <br/>"""<br/><br/><br/>class OpenAIAgent:  <br/>  <br/>    def __init__(  <br/>            self,  <br/>            tools: list[Tool],  <br/>            client: OpenAI = OpenAI(),  <br/>            system_message: str = SYSTEM_MESSAGE,  <br/>            model_name: str = "gpt-3.5-turbo-0125",  <br/>            max_steps: int = 5,  <br/>            verbose: bool = True,  <br/>            examples: list[dict] = None,  <br/>            context: str = None,  <br/>            user_context: str = None  <br/>    ):  <br/>        self.tools = tools  <br/>        self.client = client  <br/>        self.model_name = model_name  <br/>        self.system_message = system_message  <br/>        self.step_history = []  <br/>        self.max_steps = max_steps  <br/>        self.verbose = verbose  <br/>        self.examples = examples or []  <br/>        self.context = context or ""  <br/>        self.user_context = user_context  <br/>  <br/>    def to_console(self, tag: str, message: str, color: str = "green"):  <br/>        if self.verbose:  <br/>            color_prefix = Fore.__dict__[color.upper()]  <br/>            print(color_prefix + f"{tag}: {message}{colorama.Style.RESET_ALL}")  <br/>  <br/>    def run(self, user_input: str, context: str = None):  <br/>  <br/>        openai_tools = [tool.openai_tool_schema for tool in self.tools]  <br/>        system_message = self.system_message.format(context=context)  <br/>  <br/>        if self.user_context:  <br/>            context = f"{self.user_context}\n{context}" if context else self.user_context  <br/>  <br/>        if context:  <br/>            user_input = f"{context}\n---\n\nUser Message: {user_input}"  <br/>  <br/>        self.to_console("START", f"Starting Agent with Input:\n'''{user_input}'''")  <br/>  <br/>  <br/>        self.step_history = [  <br/>            {"role": "system", "content": system_message},  <br/>            *self.examples,  <br/>            {"role": "user", "content": user_input}  <br/>        ]  <br/>  <br/>        step_result = None  <br/>        i = 0  <br/>  <br/>        while i &lt; self.max_steps:  <br/>            step_result = self.run_step(self.step_history, openai_tools)  <br/>            if step_result.event == "finish":  <br/>                break  <br/>            elif step_result.event == "error":  <br/>                self.to_console(step_result.event, step_result.content, "red")  <br/>            else:  <br/>                self.to_console(step_result.event, step_result.content, "yellow")  <br/>  <br/>            i += 1  <br/>  <br/>        self.to_console("Final Result", step_result.content, "green")  <br/>  <br/>        return step_result.content  <br/>  <br/>    def run_step(self, messages: list[dict], tools):  <br/>  <br/>        # plan the next step  <br/>        response = self.client.chat.completions.create(  <br/>            model=self.model_name,  <br/>            messages=messages,  <br/>            tools=tools  <br/>        )  <br/>        # check for multiple tool calls  <br/>        if response.choices[0].message.tool_calls and len(response.choices[0].message.tool_calls) &gt; 1:  <br/>            messages = [  <br/>                *self.step_history,  <br/>                {"role": "user", "content": "Error: Please return only one tool call at a time."}  <br/>            ]  <br/>            return self.run_step(messages, tools)  <br/>  <br/>        # add message to history  <br/>        self.step_history.append(response.choices[0].message)  <br/>        # check if tool call is present  <br/>        if not response.choices[0].message.tool_calls:  <br/>            msg = response.choices[0].message.content  <br/>            step_result = StepResult(event="Error", content=f"No tool calls were returned.\nMessage: {msg}", success=False)  <br/>            return step_result  <br/>  <br/>        tool_name = response.choices[0].message.tool_calls[0].function.name  <br/>        tool_kwargs = parse_function_args(response)  <br/>  <br/>        # execute the tool call  <br/>        self.to_console("Tool Call", f"Name: {tool_name}\nArgs: {tool_kwargs}", "magenta")  <br/>        tool_result = run_tool_from_response(response, tools=self.tools)  <br/>        tool_result_msg = self.tool_call_message(response, tool_result)  <br/>        self.step_history.append(tool_result_msg)  <br/>  <br/>        if tool_name == "report_tool":  <br/>            try:  <br/>                step_result = StepResult(  <br/>                    event="finish",  <br/>                    content=tool_result.content,  <br/>                    success=True  <br/>                )  <br/>            except:  <br/>                print(tool_result)  <br/>                raise ValueError("Report Tool failed to run.")  <br/>  <br/>            return step_result  <br/>  <br/>        elif tool_result.success:  <br/>            step_result = StepResult(  <br/>                event="tool_result",  <br/>                content=tool_result.content,  <br/>                success=True)  <br/>        else:  <br/>            step_result = StepResult(  <br/>                event="error",  <br/>                content=tool_result.content,  <br/>                success=False  <br/>            )  <br/>  <br/>        return step_result  <br/>  <br/>    def tool_call_message(self, response, tool_result: ToolResult):  <br/>        tool_call = response.choices[0].message.tool_calls[0]  <br/>        return {  <br/>            "tool_call_id": tool_call.id,  <br/>            "role": "tool",  <br/>            "name": tool_call.function.name,  <br/>            "content": tool_result.content,  <br/>        }</span></pre><p id="f0c6" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The main changes compared to our previous version:</p><ul class=""><li id="8b6b" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bk">We placed a “{context}” placeholder in the default system prompt.</li><li id="1557" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">We added <code class="cx pi pj pk pl b">context</code> and <code class="cx pi pj pk pl b">user_context</code> as input arguments to <code class="cx pi pj pk pl b">__init__()</code>.</li><li id="0d7c" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">We added <code class="cx pi pj pk pl b">context</code> to the <code class="cx pi pj pk pl b">run()</code> method.</li><li id="0ae8" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">In <code class="cx pi pj pk pl b">run()</code>, we add <code class="cx pi pj pk pl b">context</code> to the user message if defined.</li><li id="8a19" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">We also added an <code class="cx pi pj pk pl b">examples</code> attribute to <code class="cx pi pj pk pl b">__init__()</code> that, if set, will be passed between the system and user messages in <code class="cx pi pj pk pl b">run()</code>.</li></ul><p id="7f8b" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now we can define a system context and a user context while initializing our agent. Additionally, we can pass a user context when calling the run method. If <code class="cx pi pj pk pl b">context</code> is passed to the run method, it will overwrite the <code class="cx pi pj pk pl b">user_context</code> from initialization for that run.</p><h1 id="55f7" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">5.1 Providing Context to the Agent</h1><p id="0ef4" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">Before we can run our Agent, let’s define a function that generates context information. We want to automatically generate <code class="cx pi pj pk pl b">user_context</code>, which we can then pass to the Agent's run function as implemented above. To keep it simple, we want a single line for each table as context information that should include:</p><ul class=""><li id="c823" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bk">Table name</li><li id="fcfa" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk">Column_name: <code class="cx pi pj pk pl b">&lt;type&gt;</code></li></ul><p id="9c16" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">After a few attempts with trial and error, the following function will do the job:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="b6de" class="pv oi gl pl b bg pw px l py pz"># utils.py<br/>from typing import Type  <br/>import types  <br/>import typing  <br/>  <br/>import sqlalchemy  <br/>from pydantic import BaseModel<br/><br/>def orm_model_to_string(input_model_cls: Type[BaseModel]):  <br/>    """Get the ORM model string from the input model"""  <br/>  <br/>    def process_field(key, value):  <br/>        if key.startswith("__"):  <br/>            return None  <br/>        if isinstance(value, typing._GenericAlias):  <br/>            if value.__origin__ == sqlalchemy.orm.base.Mapped:  <br/>                return None  <br/>            if isinstance(value, typing._AnnotatedAlias):  # noqa  <br/>                return key, value.__origin__  <br/>            elif isinstance(value, typing._UnionGenericAlias) or isinstance(value, types.UnionType):  <br/>                return key, value.__args__[0]  <br/>        return key, value  <br/>  <br/>    fields = dict(filter(None, (process_field(k, v) for k, v in input_model_cls.__annotations__.items())))  <br/>    return ", ".join([f"{k} = &lt;{v.__name__}&gt;" for k, v in fields.items()])<br/><br/>def generate_context(*table_models) -&gt; str:<br/>   context_str = "You can access the following tables in database:\n"<br/>   for table in table_models:<br/>    context_str += f" - {table.__name__}: {orm_model_to_string(table)}\n" <br/>   return context_str</span></pre><p id="2b1d" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">If we pass <code class="cx pi pj pk pl b">Expense</code> and <code class="cx pi pj pk pl b">Revenue</code> to <code class="cx pi pj pk pl b">generate_context()</code>, we should get the following context string:</p><p id="eba0" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">We want the Agent to know the current date and day of the week, so we can reference the correct date. So let’s add some date parsing functions to our utils class:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="6691" class="pv oi gl pl b bg pw px l py pz"># utils.py<br/>from datetime import datetime<br/><br/>#... rest of utils.py ...<br/><br/>def weekday_by_date(date: datetime):<br/>    days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]<br/>    return days[date.weekday()]<br/><br/><br/>def date_to_string(date: datetime):<br/>    return f"{weekday_by_date(date)} {parse_date(date)}"<br/><br/><br/>def parse_date(date: datetime):<br/>    return date.strftime("%Y-%m-%d")</span></pre><p id="df45" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now let’s create the context for a query agent</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="eae0" class="pv oi gl pl b bg pw px l py pz"># utils.py<br/><br/># ...<br/><br/>def generate_query_context(*table_models) -&gt; str:<br/>    today = f"Today is {date_to_string(datetime.now())}"<br/>    context_str = "You can access the following tables in database:\n"<br/>    for table in table_models:<br/>        context_str += f" - {table.__name__}: {orm_model_to_string(table)}\n" <br/>    return f"{today}\n{context_str}"</span></pre><pre class="qv ps pl pt bp pu bb bk"><span id="3c42" class="pv oi gl pl b bg pw px l py pz">from database.models import Expense, Revenue<br/>print(generate_query_context(Expense, Revenue))</span></pre><pre class="qv ps pl pt bp pu bb bk"><span id="a512" class="pv oi gl pl b bg pw px l py pz">Today is Sunday 2024-04-21<br/>You can access the following tables in database:<br/> - Expense: id = &lt;int&gt;, description = &lt;str&gt;, net_amount = &lt;float&gt;, gross_amount = &lt;float&gt;, tax_rate = &lt;float&gt;, date = &lt;datetime&gt;<br/> - Revenue: id = &lt;int&gt;, description = &lt;str&gt;, net_amount = &lt;float&gt;, gross_amount = &lt;float&gt;, tax_rate = &lt;float&gt;, date = &lt;datetime&gt;</span></pre><h1 id="78c2" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">5.2 Routing Agent</h1><p id="acd4" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">As we add more tools, the complexity of our setup may start to limit the usability of cheaper models like “gpt-3.5-turbo”. In the next article, we might consider switching to Anthropic Claude, since their newly released tool-use API feature seems promising, even for the more affordable HAIKU model, in handling multiple tools simultaneously. However, for now, we will continue using OpenAI’s GPT models.</p><p id="4a9e" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">When developing for personal use and before creating production-ready applications, I find it useful to optimize the workflow for smaller models, such as <code class="cx pi pj pk pl b">gpt-3.5-turbo</code> in this case. This approach forces us to create a streamlined processing logic and prompting system. While we may not achieve 100% reliability without using the most powerful model, we will be able to catch flaws and identify unclear instructions. If your application works in 9 out of 10 cases with a smaller model, you will have a production-ready logic that will perform even better with a stronger model.</p><p id="9c6a" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To make multi-tool handling reliable with <code class="cx pi pj pk pl b">gpt-3.5-turbo</code> we will implement a routing agent whose sole purpose is to route the user query to the appropriate task agent. This allows us to separate execution logic and reduce complexity. Each agent will have a limited scope, enabling us to separate access roles and operations in the future. I have observed that even with gpt-4, there are instances where the agent does not know when its task is finished.</p><p id="3322" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">By introducing a routing agent, we can break down the problem into smaller, more manageable parts. The routing agent will be responsible for understanding the user’s intent and directing the query to the relevant task agent. This approach not only simplifies the individual agents’ responsibilities but also makes the system more modular and easier to maintain.</p><p id="80e4" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Furthermore, separating the execution logic and complexity will pave the way for implementing role-based access control in the future. Each task agent can be assigned specific permissions and access levels, ensuring that sensitive operations are only performed by authorized agents.</p><p id="faae" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">While the routing agent adds an extra step in the process, it ultimately leads to a more robust and scalable system. By optimizing for smaller models and focusing on clear, concise prompts, we can create a solid foundation that will perform even better when we switch to more powerful models like Claude Opus or GPT-4.</p><p id="96ce" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Let’s have a look on the implementation of the routing agent</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="d92b" class="pv oi gl pl b bg pw px l py pz"># agents/routing.py<br/>from openai import OpenAI<br/>import colorama<br/>from agents.task_agent import TaskAgent<br/>from agents.utils import parse_function_args<br/><br/><br/>SYSTEM_MESSAGE = """You are a helpful assistant.<br/>Role: You are an AI Assistant designed to serve as the primary point of contact for users interacting through a chat interface. <br/>Your primary role is to understand users' requests related to database operations and route these requests to the appropriate tool.<br/><br/>Capabilities: <br/>You have access to a variety of tools designed for Create, Read operations on a set of predefined tables in a database. <br/><br/>Tables:<br/>{table_names}<br/>"""<br/><br/>NOTES = """Important Notes:<br/>Always confirm the completion of the requested operation with the user.<br/>Maintain user privacy and data security throughout the interaction.<br/>If a request is ambiguous or lacks specific details, ask follow-up questions to clarify the user's needs."""<br/><br/><br/><br/><br/>class RoutingAgent:<br/><br/>    def __init__(<br/>            self,<br/>            tools: list[TaskAgent] = None,<br/>            client: OpenAI = OpenAI(),<br/>            system_message: str = SYSTEM_MESSAGE,<br/>            model_name: str = "gpt-3.5-turbo-0125",<br/>            max_steps: int = 5,<br/>            verbose: bool = True,<br/>            prompt_extra: dict = None,<br/>            examples: list[dict] = None,<br/>            context: str = None<br/>    ):<br/>        self.tools = tools or ROUTING_AGENTS<br/>        self.client = client<br/>        self.model_name = model_name<br/>        self.system_message = system_message<br/>        self.memory = []<br/>        self.step_history = []<br/>        self.max_steps = max_steps<br/>        self.verbose = verbose<br/>        self.prompt_extra = prompt_extra or PROMPT_EXTRA<br/>        self.examples = self.load_examples(examples)<br/>        self.context = context or ""<br/><br/>    def load_examples(self, examples: list[dict] = None):<br/>        examples = examples or []<br/>        for agent in self.tools:<br/>            examples.extend(agent.routing_example)<br/>        return examples<br/><br/>    def run(self, user_input: str, employee_id: int = None, **kwargs):<br/>        context = create_routing_agent_context(employee_id)<br/>        if context:<br/>            user_input_with_context = f"{context}\n---\n\nUser Message: {user_input}"<br/>        else:<br/>            user_input_with_context = user_input<br/><br/>        self.to_console("START", f"Starting Task Agent with Input:\n'''{user_input_with_context}'''")<br/>        partial_variables = {**self.prompt_extra, "context": context}<br/>        system_message = self.system_message.format(**partial_variables)<br/><br/>        messages = [<br/>            {"role": "system", "content": system_message},<br/>            *self.examples,<br/>            {"role": "user", "content": user_input}<br/>        ]<br/><br/>        tools = [tool.openai_tool_schema for tool in self.tools]<br/><br/>        response = self.client.chat.completions.create(<br/>            model=self.model_name,<br/>            messages=messages,<br/>            tools=tools<br/>        )<br/>        self.step_history.append(response.choices[0].message)<br/>        self.to_console("RESPONSE", response.choices[0].message.content, color="blue")<br/>        tool_kwargs = parse_function_args(response)<br/>        tool_name = response.choices[0].message.tool_calls[0].function.name<br/>        self.to_console("Tool Name", tool_name)<br/>        self.to_console("Tool Args", tool_kwargs)<br/><br/>        agent = self.prepare_agent(tool_name, tool_kwargs)<br/>        return agent.run(user_input)<br/><br/>    def prepare_agent(self, tool_name, tool_kwargs):<br/>        for agent in self.tools:<br/>            if agent.name == tool_name:<br/>                input_kwargs = agent.arg_model.model_validate(tool_kwargs)<br/>                return agent.load_agent(**input_kwargs.dict())<br/>        raise ValueError(f"Agent {tool_name} not found")<br/><br/>    def to_console(self, tag: str, message: str, color: str = "green"):<br/>        if self.verbose:<br/>            color_prefix = colorama.Fore.__dict__[color.upper()]<br/>            print(color_prefix + f"{tag}: {message}{colorama.Style.RESET_ALL}")</span></pre><p id="a635" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The biggest differences to our <code class="cx pi pj pk pl b">OpenAIAgent</code> are:</p><ul class=""><li id="35e1" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bk"><strong class="nf gm">No open loop: </strong>we want the routing agent to route user’s queries to the appropriate agent. So instead of creating an open loop we select the desired agent via tool calling and pass the user query to it. The routing Agent should not do any other task or follow-up question.</li><li id="3551" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk"><strong class="nf gm">Agents as Tools</strong>: Instead of calling a tool the routing agent setup a subagent. So our previously defined <code class="cx pi pj pk pl b">OpenAIAgent</code>is now a tool within our routing agent.</li></ul><h1 id="72c2" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">5.3 Agent as a Tool — Task Agent</h1><p id="12b3" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">To use our <code class="cx pi pj pk pl b">OpenAIAgent</code>as a tool, we need to introduce some sort of tool class dedicated for Agents. We want to define a name and description for each agent and automate the initialization process. Therefore, we define our last class for this tutorial the<code class="cx pi pj pk pl b">TaskAgent</code>.</p><p id="281c" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">The <code class="cx pi pj pk pl b">TaskAgent</code> class serves similar functionality as the <code class="cx pi pj pk pl b">Tool</code> class. We define a name a description and an input model which we call <code class="cx pi pj pk pl b">arg_model</code>.</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="43d8" class="pv oi gl pl b bg pw px l py pz">from typing import Type, Callable, Optional<br/><br/>from agents.base import OpenAIAgent<br/>from tools.base import Tool<br/>from tools.report_tool import report_tool<br/>from pydantic import BaseModel, ConfigDict, Field<br/><br/>from tools.utils import convert_to_openai_tool<br/><br/><br/>SYSTEM_MESSAGE = """You are tasked with completing specific objectives and must report the outcomes. At your disposal, you have a variety of tools, each specialized in performing a distinct type of task.<br/><br/>For successful task completion:<br/>Thought: Consider the task at hand and determine which tool is best suited based on its capabilities and the nature of the work. <br/>If you can complete the task or answer a question, soley by the information provided you can use the report_tool directly.<br/><br/>Use the report_tool with an instruction detailing the results of your work or to answer a user question.<br/>If you encounter an issue and cannot complete the task:<br/><br/>Use the report_tool to communicate the challenge or reason for the task's incompletion.<br/>You will receive feedback based on the outcomes of each tool's task execution or explanations for any tasks that couldn't be completed. This feedback loop is crucial for addressing and resolving any issues by strategically deploying the available tools.<br/><br/>On error: If information are missing consider if you can deduce or calculate the missing information and repeat the tool call with more arguments.<br/><br/>Use the information provided by the user to deduct the correct tool arguments.<br/>Before using a tool think about the arguments and explain each input argument used in the tool. <br/>Return only one tool call at a time! Explain your thoughts!<br/>{context}<br/>"""<br/><br/><br/>class EmptyArgModel(BaseModel):<br/>    pass<br/><br/><br/>class TaskAgent(BaseModel):<br/>    name: str<br/>    description: str<br/>    arg_model: Type[BaseModel] = EmptyArgModel<br/><br/>    create_context: Callable = None<br/>    create_user_context: Callable = None<br/>    tool_loader: Callable = None<br/><br/>    system_message: str = SYSTEM_MESSAGE<br/>    tools: list[Tool]<br/>    examples: list[dict] = None<br/>    routing_example: list[dict] = Field(default_factory=list)<br/><br/>    model_config = ConfigDict(arbitrary_types_allowed=True)<br/><br/>    def load_agent(self, **kwargs) -&gt; OpenAIAgent:<br/><br/>        input_kwargs = self.arg_model(**kwargs)<br/>        kwargs = input_kwargs.dict()<br/><br/>        context = self.create_context(**kwargs) if self.create_context else None<br/>        user_context = self.create_user_context(**kwargs) if self.create_user_context else None<br/><br/>        if self.tool_loader:<br/>            self.tools.extend(self.tool_loader(**kwargs))<br/><br/>        if report_tool not in self.tools:<br/>            self.tools.append(report_tool)<br/><br/>        return OpenAIAgent(<br/>            tools=self.tools,<br/>            context=context,<br/>            user_context=user_context,<br/>            system_message=self.system_message,<br/>            examples=self.examples,<br/>        )<br/><br/>    @property<br/>    def openai_tool_schema(self):<br/>        return convert_to_openai_tool(self.arg_model, name=self.name, description=self.description)</span></pre><p id="e261" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Additionally, we added all relevant attributes to our <code class="cx pi pj pk pl b">TaskAgent</code> class, which we need for an underlying specialized <code class="cx pi pj pk pl b">OpenAIAgent</code> :</p><ul class=""><li id="bcd0" class="nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa ob bk"><code class="cx pi pj pk pl b">create_context</code> / <code class="cx pi pj pk pl b">create_user_context</code>: Here we can pass a function to create the context or user context like in section 5.1</li><li id="73f4" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk"><code class="cx pi pj pk pl b">tool_loader</code> is another callable function which we may need for setting up the underlying agent. As in our dynamic tool building previously explained, we may need tools that are dynamically built based on the user input/routing agent input.</li><li id="285e" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk"><code class="cx pi pj pk pl b">system_message</code> is the agent’s system prompt. In our example, it will be the default system prompt for every agent, but it can be an optimized version for each specialized agent.</li><li id="9f85" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk"><code class="cx pi pj pk pl b">tools</code>: Predefined tools the agent should use.</li><li id="ec3f" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk"><code class="cx pi pj pk pl b">examples</code>: Examples to include in subagent’s message history</li><li id="6178" class="nd ne gl nf b hj oc nh ni hm od nk nl nm oe no np nq of ns nt nu og nw nx ny nz oa ob bk"><code class="cx pi pj pk pl b">routing_example</code>: Examples to include in routing agent’s message history</li></ul><p id="4d4d" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Moreover, we have an emty BaseModel called <code class="cx pi pj pk pl b">EmptyArgModel</code> which is default <code class="cx pi pj pk pl b">arg_model</code> in our TaskAgent</p><figure class="pn po pp pq pr fw fo fp paragraph-image"><div role="button" tabindex="0" class="fx fy ed fz bh ga"><div class="fo fp qw"><img src="../Images/296be241ea21139c029a09fa600081de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wvt2wnexoCTIOpGG6xsjxA.png"/></div></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">Created by the author <a class="af gi" href="https://mermaid.live/" rel="noopener ugc nofollow" target="_blank">mermaid</a></figcaption></figure><p id="9242" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Let’s see if it all plays together!</p><h1 id="8a0d" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">Run Agent</h1><p id="3eaa" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">Now, it’s time to test if our routing and subagents work well together. As we introduced examples as a paremeter we can use several test runs to inspect major flaws in the execution and define example usage for each sub agent.</p><p id="e1d9" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Let’s define our subagents first:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="16da" class="pv oi gl pl b bg pw px l py pz">from database.models import Expense, Revenue, Customer<br/>from agents.task import TaskAgent<br/>from utils import generate_query_context<br/><br/>from tools.base import Tool<br/>from tools.query import query_data_tool<br/>from tools.add import add_entry_to_table<br/><br/><br/>query_task_agent = TaskAgent(<br/>    name="query_agent",<br/>    description="An agent that can perform queries on multiple data sources",<br/>    create_user_context=lambda: generate_query_context(Expense, Revenue, Customer),<br/>    tools=[query_data_tool]<br/>)<br/><br/>add_expense_agent = TaskAgent(<br/>    name="add_expense_agent",<br/>    description="An agent that can add an expense to the database",<br/>    create_user_context=lambda: generate_query_context(Expense) + "\nRemarks: The tax rate is 0.19. The user provide the net amount you need to calculate the gross amount.",<br/>    tools=[<br/>        Tool(<br/>            name="add_expense",<br/>            description="Add an expense to the database",<br/>            function=add_entry_to_table(Expense),<br/>            model=Expense<br/>        )<br/>    ]<br/>)<br/><br/>add_revenue_agent = TaskAgent(<br/>    name="add_revenue_agent",<br/>    description="An agent that can add a revenue entry to the database",<br/>    create_user_context=lambda: generate_query_context(Revenue) + "\nRemarks: The tax rate is 0.19. The user provide the gross_amount you should use the tax rate to calculate the net_amount.",<br/>    tools=[<br/>        Tool(<br/>            name="add_revenue",<br/>            description="Add a revenue entry to the database",<br/>            function=add_entry_to_table(Revenue),<br/>            model=Revenue<br/>        )<br/>    ]<br/>)<br/><br/>add_customer_agent = TaskAgent(<br/>    name="add_customer_agent",<br/>    description="An agent that can add a customer to the database",<br/>    create_user_context=lambda: generate_query_context(Customer),<br/>    tools=[<br/>        Tool(<br/>            name="add_customer",<br/>            description="Add a customer to the database",<br/>            function=add_entry_to_table(Customer),<br/>            model=Customer<br/>        )<br/>    ]<br/>)</span></pre><p id="ee50" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">As you can see we added some remarks as string to <code class="cx pi pj pk pl b">create_user_context</code> for revenue and expense agents. We want the sub agent to handle tax rates and calculate the net or gross amount automatically to test the reasoning capabilites of our sub agent.</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="74d4" class="pv oi gl pl b bg pw px l py pz">from agents.routing import RoutingAgent<br/><br/>routing_agent = RoutingAgent(<br/>    tools=[<br/>        query_task_agent,<br/>        add_expense_agent,<br/>        add_revenue_agent,<br/>        add_customer_agent<br/>    ]<br/>)<br/><br/><br/>routing_agent.run("I have spent 5 € on a office stuff. Last Thursday")</span></pre><pre class="qv ps pl pt bp pu bb bk"><span id="e97e" class="pv oi gl pl b bg pw px l py pz">START: Starting Routing Agent with Input:<br/>I have spent 5 € on a office stuff. Last Thursday<br/><br/>Tool Name: add_expense_agent<br/>Tool Args: {}<br/><br/>START: Starting Task Agent with Input:<br/>"""Today is Sunday 2024-04-21<br/>You can access the following tables in database:<br/> - expense: id = &lt;int&gt;, description = &lt;str&gt;, net_amount = &lt;float&gt;, gross_amount = &lt;float&gt;, tax_rate = &lt;float&gt;, date = &lt;datetime&gt;<br/><br/>Remarks: The tax rate is 0.19. The user provide the net amount you need to calculate the gross amount.<br/>---<br/>User Message: I have spent 5 € on a office stuff. Last Thursday"""<br/><br/>Tool Call: Name: add_expense<br/>Args: {'description': 'office stuff', 'net_amount': 5, 'tax_rate': 0.19, 'date': '2024-04-18'}<br/>Message: None<br/>error: Missing values: gross_amount<br/><br/>Tool Call: Name: add_expense<br/>Args: {'description': 'office stuff', 'net_amount': 5, 'tax_rate': 0.19, 'date': '2024-04-18', 'gross_amount': 5.95}<br/>Message: None<br/>tool_result: Successfully added net_amount=5.0 id=2 gross_amount=5.95 description='office stuff' date=datetime.datetime(2024, 4, 18, 0, 0) tax_rate=0.19 to the table<br/><br/>Error: No tool calls were returned.<br/>Message: I have successfully added the expense for office stuff with a net amount of 5€, calculated the gross amount, and recorded it in the database.<br/><br/>Tool Call: Name: report_tool<br/>Args: {'report': 'Expense for office stuff with a net amount of 5€ has been successfully added. Gross amount calculated as 5.95€.'}<br/>Message: None<br/><br/>Final Result: Expense for office stuff with a net amount of 5€ has been successfully added. Gross amount calculated as 5.95€.</span></pre><p id="1eff" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Now let’s add a revenue:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="ef51" class="pv oi gl pl b bg pw px l py pz">routing_agent.run("Two weeks ago on Saturday we had a revenue of 1000 € in the shop")</span></pre><pre class="qv ps pl pt bp pu bb bk"><span id="5e4a" class="pv oi gl pl b bg pw px l py pz">START: Starting Routing Agent with Input:<br/>Two weeks ago on Saturday we had a revenue of 1000 € in the shop<br/><br/>Tool Name: add_revenue_agent<br/>Tool Args: {}<br/><br/>START: Starting Task Agent with Input:<br/>"""Today is Sunday 2024-04-21<br/>You can access the following tables in database:<br/> - revenue: id = &lt;int&gt;, description = &lt;str&gt;, net_amount = &lt;float&gt;, gross_amount = &lt;float&gt;, tax_rate = &lt;float&gt;, date = &lt;datetime&gt;<br/><br/>Remarks: The tax rate is 0.19. The user provide the gross_amount you should use the tax rate to calculate the net_amount.<br/>---<br/>User Message: Two weeks ago on Saturday we had a revenue of 1000 € in the shop"""<br/><br/>Tool Call: Name: add_revenue<br/>Args: {'description': 'Revenue from the shop', 'gross_amount': 1000, 'tax_rate': 0.19, 'date': '2024-04-06'}<br/>Message: None<br/>error: Missing values: net_amount<br/><br/>Tool Call: Name: add_revenue<br/>Args: {'description': 'Revenue from the shop', 'gross_amount': 1000, 'tax_rate': 0.19, 'date': '2024-04-06', 'net_amount': 840.34}<br/>Message: None<br/>tool_result: Successfully added net_amount=840.34 gross_amount=1000.0 tax_rate=0.19 description='Revenue from the shop' id=1 date=datetime.datetime(2024, 4, 6, 0, 0) to the table<br/><br/>Error: No tool calls were returned.<br/>Message: The revenue entry for the shop on April 6, 2024, with a gross amount of 1000€ has been successfully added to the database. The calculated net amount after applying the tax rate is 840.34€.<br/><br/>Tool Call: Name: report_tool<br/>Args: {'report': 'completed'}<br/>Message: None<br/><br/>Final Result: completed</span></pre><p id="0416" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">And for the last test let’s try to query the revenue that created from database:</p><pre class="pn po pp pq pr ps pl pt bp pu bb bk"><span id="9be5" class="pv oi gl pl b bg pw px l py pz">routing_agent.run("How much revenue did we made this month?")</span></pre><pre class="qv ps pl pt bp pu bb bk"><span id="350b" class="pv oi gl pl b bg pw px l py pz">START: Starting Routing Agent with Input:<br/>How much revenue did we made this month?<br/><br/>Tool Name: query_agent<br/>Tool Args: {}<br/><br/>START: Starting Agent with Input:<br/>"""Today is Sunday 2024-04-21<br/>You can access the following tables in database:<br/> - expense: id = &lt;int&gt;, description = &lt;str&gt;, net_amount = &lt;float&gt;, gross_amount = &lt;float&gt;, tax_rate = &lt;float&gt;, date = &lt;datetime&gt;<br/> - revenue: id = &lt;int&gt;, description = &lt;str&gt;, net_amount = &lt;float&gt;, gross_amount = &lt;float&gt;, tax_rate = &lt;float&gt;, date = &lt;datetime&gt;<br/> - customer: id = &lt;int&gt;, company_name = &lt;str&gt;, first_name = &lt;str&gt;, last_name = &lt;str&gt;, phone = &lt;str&gt;, address = &lt;str&gt;, city = &lt;str&gt;, zip = &lt;str&gt;, country = &lt;str&gt;<br/><br/>---<br/><br/>User Message: How much revenue did we made this month?"""<br/><br/>Tool Call: Name: query_data_tool<br/>Args: {'table_name': 'revenue', 'select_columns': ['gross_amount'], 'where': [{'column': 'date', 'operator': 'gte', 'value': '2024-04-01'}, {'column': 'date', 'operator': 'lte', 'value': '2024-04-30'}]}<br/>Message: None<br/>tool_result: content="Query results: ['1000.0']" success=True<br/><br/>Error: No tool calls were returned.<br/>Message: The revenue made this month is $1000.00.<br/><br/>Tool Call: Name: report_tool<br/>Args: {'report': 'The revenue made this month is $1000.00.'}<br/>Message: None<br/><br/>Final Result: The revenue made this month is $1000.00.</span></pre><p id="afab" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">All tools worked as expected. The Routing Agent worked perfectly. For theTask Agent I had to update the prompt several times.</p><p id="77d2" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">I would recommend to add some example tool calls to each task agent when not working with state-of-the-art models like gpt-4. In general I would recommend to tackle flaws with examples and more intuitive designs instead of prompt engineering. Reapting flaws are indicators for not straightforward designs. For example when the agent struggles with calculating the gross or net amount just add a ‘calculate_gross_amount_tool’ or ‘calculate_net_amount_tool’. GPT-4 on the other hand would handle use cases like that without hestitating.</p><h1 id="f7d6" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">Conclusion</h1><p id="572d" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">In this article, we’ve taken a significant step forward in our journey to create a comprehensive chat-based interface for managing small businesses using Large Language Models.</p><p id="f8f3" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">By setting up our database schema, defining core functionalities, and structuring our project repository, we’ve laid a solid foundation for the development of our application.</p><p id="a239" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">We started by designing our database models using SQLModel, which allowed us to seamlessly integrate with Pydantic and SQLAlchemy. This approach ensures efficient data validation and database operations while minimizing the risk of SQL injection attacks.</p><p id="dd39" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">We then proceeded to update our <code class="cx pi pj pk pl b">Tool</code> class to handle SQLModel instances and improve the validation process. Next, we implemented SQL tools for adding data to our database tables and querying data using natural language commands. By leveraging the power of SQLModel and Pydantic, we were able to create a robust and flexible system that can handle a wide range of user inputs and generate accurate SQL queries.</p><p id="3c54" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">We configured our OpenAIAgent to provide context-aware tool usage by updating the agent class to handle variable context in the system prompt and user prompt. This allows our agent to understand the available tables and their schemas, enabling more accurate and efficient tool usage. While we’ve made significant progress, there’s still much more to explore and implement.</p><p id="f76f" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To further enhance our chatbot, we introduced the TaskAgent class, which serves a similar functionality as the Tool class. The TaskAgent allows us to define a name, description, and input model for each agent, automating the initialization process.</p><p id="a75f" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Finally, we tested our routing and subagents by defining subagents for querying data, adding expenses, adding revenue. We demonstrated how the agents handle tax rates and calculate net or gross amounts automatically, showcasing the reasoning capabilities of our subagents.</p><h2 id="c86d" class="qe oi gl bf oj qf qg qh om qi qj qk op nm ql qm qn nq qo qp qq nu qr qs qt qu bk">Next steps</h2><p id="3947" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">In the next part of this series, we’ll focus on enhancing our agent’s capabilities by adding support for more tools and potentially testing Claude as a new default language model. We’ll also explore integrating our application with popular communication platforms (WhatsApp) to make it even more accessible and user-friendly.</p><p id="c775" class="pw-post-body-paragraph nd ne gl nf b hj ng nh ni hm nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">As we continue to refine and expand our application, the possibilities are endless. By leveraging the power of Large Language Models and creating intuitive chat-based interfaces, we can revolutionize the way small businesses manage their data and streamline their operations. Stay tuned for the next installment in this exciting series!</p><h1 id="7bd0" class="oh oi gl bf oj ok ol hl om on oo ho op oq or os ot ou ov ow ox oy oz pa pb pc bk">Source Code</h1><p id="7d1e" class="pw-post-body-paragraph nd ne gl nf b hj pd nh ni hm pe nk nl nm pf no np nq pg ns nt nu ph nw nx ny fj bk">Additionally, the entire source code for the projects covered is available on GitHub. You can access it at <a class="af gi" href="https://github.com/elokus/ArticleDemo2" rel="noopener ugc nofollow" target="_blank">https://github.com/elokus/ArticleDemo2</a></p></div></div></div></div>    
</body>
</html>
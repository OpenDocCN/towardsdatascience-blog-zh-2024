<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Improving Code Quality with Array and DataFrame Type Hints</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Improving Code Quality with Array and DataFrame Type Hints</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/improving-code-quality-with-array-and-dataframe-type-hints-cac0fb75cc11?source=collection_archive---------5-----------------------#2024-09-19">https://towardsdatascience.com/improving-code-quality-with-array-and-dataframe-type-hints-cac0fb75cc11?source=collection_archive---------5-----------------------#2024-09-19</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="20e1" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">How generic type specification permits powerful static analysis and runtime validation</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@flexatone?source=post_page---byline--cac0fb75cc11--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Christopher Ariza" class="l ep by dd de cx" src="../Images/35208ace15080724e4cd6690e43d6502.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/2*4B_4Z_CZMfdTChq_8zQOmQ.png"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--cac0fb75cc11--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@flexatone?source=post_page---byline--cac0fb75cc11--------------------------------" rel="noopener follow">Christopher Ariza</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--cac0fb75cc11--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">10 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Sep 19, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">2</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/a75b36f65c66b95f33aea2faefea4dbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OyfF0Y8gyge9Pf3-6L5TgA.jpeg"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Photo by Author</figcaption></figure><p id="ff0c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As tools for Python type annotations (or hints) have evolved, more complex data structures can be typed, improving maintainability and static analysis. Arrays and DataFrames, as complex containers, have only recently supported complete type annotations in Python. NumPy 1.22 introduced generic specification of arrays and dtypes. Building on NumPy’s foundation, <a class="af ny" href="https://github.com/static-frame/static-frame" rel="noopener ugc nofollow" target="_blank">StaticFrame</a> 2.0 introduced complete type specification of DataFrames, employing NumPy primitives and variadic generics. This article demonstrates practical approaches to fully type-hinting arrays and DataFrames, and shows how the same annotations can improve code quality with both static analysis and runtime validation.</p><p id="f287" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><a class="af ny" href="https://github.com/static-frame/static-frame" rel="noopener ugc nofollow" target="_blank">StaticFrame</a> is an open-source DataFrame library of which I am an author.</p><h1 id="ec77" class="nz oa fq bf ob oc od gq oe of og gt oh oi oj ok ol om on oo op oq or os ot ou bk">Type Hints Improve Code Quality</h1><p id="e503" class="pw-post-body-paragraph nc nd fq ne b go ov ng nh gr ow nj nk nl ox nn no np oy nr ns nt oz nv nw nx fj bk">Type hints (see <a class="af ny" href="https://peps.python.org/pep-0484/" rel="noopener ugc nofollow" target="_blank">PEP 484</a>) improve code quality in a number of ways. Instead of using variable names or comments to communicate types, Python-object-based type annotations provide maintainable and expressive tools for type specification. These type annotations can be tested with type checkers such as <code class="cx pa pb pc pd b">mypy</code> or <code class="cx pa pb pc pd b">pyright</code>, quickly discovering potential bugs without executing code.</p><p id="5776" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The same annotations can be used for runtime validation. While reliance on duck-typing over runtime validation is common in Python, runtime validation is more often needed with complex data structures such as arrays and DataFrames. For example, an interface expecting a DataFrame argument, if given a Series, might not need explicit validation as usage of the wrong type will likely raise. However, an interface expecting a 2D array of floats, if given an array of Booleans, might benefit from validation as usage of the wrong type may not raise.</p><p id="054e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Many important typing utilities are only available with the most-recent versions of Python. Fortunately, the <code class="cx pa pb pc pd b">typing-extensions</code> package back-ports standard library utilities for older versions of Python. A related challenge is that type checkers can take time to implement full support for new features: many of the examples shown here require at least <code class="cx pa pb pc pd b">mypy</code> 1.9.0.</p><h1 id="2db6" class="nz oa fq bf ob oc od gq oe of og gt oh oi oj ok ol om on oo op oq or os ot ou bk">Elemental Type Annotations</h1><p id="6a5a" class="pw-post-body-paragraph nc nd fq ne b go ov ng nh gr ow nj nk nl ox nn no np oy nr ns nt oz nv nw nx fj bk">Without type annotations, a Python function signature gives no indication of the expected types. For example, the function below might take and return any types:</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="0f36" class="ph oa fq pd b bg pi pj l pk pl">def process0(v, q): ... # no type information</span></pre><p id="7bd8" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">By adding type annotations, the signature informs readers of the expected types. With modern Python, user-defined and built-in classes can be used to specify types, with additional resources (such as <code class="cx pa pb pc pd b">Any</code>, <code class="cx pa pb pc pd b">Iterator</code>, <code class="cx pa pb pc pd b">cast()</code>, and <code class="cx pa pb pc pd b">Annotated</code>) found in the standard library <code class="cx pa pb pc pd b">typing</code> module. For example, the interface below improves the one above by making expected types explicit:</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="b5af" class="ph oa fq pd b bg pi pj l pk pl">def process0(v: int, q: bool) -&gt; list[float]: ...</span></pre><p id="7179" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">When used with a type checker like <code class="cx pa pb pc pd b">mypy</code>, code that violates the specifications of the type annotations will raise an error during static analysis (shown as comments, below). For example, providing an integer when a Boolean is required is an error:</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="ab26" class="ph oa fq pd b bg pi pj l pk pl">x = process0(v=5, q=20)<br/># tp.py: error: Argument "q" to "process0"<br/># has incompatible type "int"; expected "bool"  [arg-type]</span></pre><p id="49b3" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Static analysis can only validate statically defined types. The full range of runtime inputs and outputs is often more diverse, suggesting some form of runtime validation. The best of both worlds is possible by reusing type annotations for runtime validation. While there are libraries that do this (e.g., <code class="cx pa pb pc pd b">typeguard</code> and <code class="cx pa pb pc pd b">beartype</code>), StaticFrame offers <code class="cx pa pb pc pd b">CallGuard</code>, a tool specialized for comprehensive array and DataFrame type-annotation validation.</p><p id="6399" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A Python decorator is ideal for leveraging annotations for runtime validation. <code class="cx pa pb pc pd b">CallGuard</code> offers two decorators: <code class="cx pa pb pc pd b"><a class="af ny" href="http://twitter.com/CallGuard" rel="noopener ugc nofollow" target="_blank">@CallGuard</a>.check</code>, which raises an informative <code class="cx pa pb pc pd b">Exception</code> on error, or <code class="cx pa pb pc pd b"><a class="af ny" href="http://twitter.com/CallGuard" rel="noopener ugc nofollow" target="_blank">@CallGuard</a>.warn</code>, which issues a warning.</p><p id="5567" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Further extending the <code class="cx pa pb pc pd b">process0</code> function above with <code class="cx pa pb pc pd b"><a class="af ny" href="http://twitter.com/CallGuard" rel="noopener ugc nofollow" target="_blank">@CallGuard</a>.check</code>, the same type annotations can be used to raise an <code class="cx pa pb pc pd b">Exception</code> (shown again as comments) when runtime objects violate the requirements of the type annotations:</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="1609" class="ph oa fq pd b bg pi pj l pk pl">import static_frame as sf<br/><br/>@sf.CallGuard.check<br/>def process0(v: int, q: bool) -&gt; list[float]:<br/>    return [x * (0.5 if q else 0.25) for x in range(v)]<br/><br/>z = process0(v=5, q=20)<br/># static_frame.core.type_clinic.ClinicError:<br/># In args of (v: int, q: bool) -&gt; list[float]<br/># └── Expected bool, provided int invalid</span></pre><p id="6f7f" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">While type annotations must be valid Python, they are irrelevant at runtime and can be wrong: it is possible to have correctly verified types that do not reflect runtime reality. As shown above, reusing type annotations for runtime checks ensures annotations are valid.</p><h1 id="f8c6" class="nz oa fq bf ob oc od gq oe of og gt oh oi oj ok ol om on oo op oq or os ot ou bk">Array Type Annotations</h1><p id="e3d4" class="pw-post-body-paragraph nc nd fq ne b go ov ng nh gr ow nj nk nl ox nn no np oy nr ns nt oz nv nw nx fj bk">Python classes that permit component type specification are “generic”. Component types are specified with positional “type variables”. A list of integers, for example, is annotated with <code class="cx pa pb pc pd b">list[int]</code>; a dictionary of floats keyed by tuples of integers and strings is annotated <code class="cx pa pb pc pd b">dict[tuple[int, str], float]</code>.</p><p id="ba5f" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With NumPy 1.20, <code class="cx pa pb pc pd b">ndarray</code> and <code class="cx pa pb pc pd b">dtype</code> become generic. The generic <code class="cx pa pb pc pd b">ndarray</code> requires two arguments, a shape and a <code class="cx pa pb pc pd b">dtype</code>. As the usage of the first argument is still under development, <code class="cx pa pb pc pd b">Any</code> is commonly used. The second argument, <code class="cx pa pb pc pd b">dtype</code>, is itself a generic that requires a type variable for a NumPy type such as <code class="cx pa pb pc pd b">np.int64</code>. NumPy also offers more general generic types such as <code class="cx pa pb pc pd b">np.integer[Any]</code>.</p><p id="8569" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">For example, an array of Booleans is annotated <code class="cx pa pb pc pd b">np.ndarray[Any, np.dtype[np.bool_]]</code>; an array of any type of integer is annotated <code class="cx pa pb pc pd b">np.ndarray[Any, np.dtype[np.integer[Any]]]</code>.</p><p id="3ae1" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As generic annotations with component type specifications can become verbose, it is practical to store them as type aliases (here prefixed with “T”). The following function specifies such aliases and then uses them in a function.</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="a216" class="ph oa fq pd b bg pi pj l pk pl">from typing import Any<br/>import numpy as np<br/><br/>TNDArrayInt8 = np.ndarray[Any, np.dtype[np.int8]]<br/>TNDArrayBool = np.ndarray[Any, np.dtype[np.bool_]]<br/>TNDArrayFloat64 = np.ndarray[Any, np.dtype[np.float64]]<br/><br/>def process1(<br/>        v: TNDArrayInt8,<br/>        q: TNDArrayBool,<br/>        ) -&gt; TNDArrayFloat64:<br/>    s: TNDArrayFloat64 = np.where(q, 0.5, 0.25)<br/>    return v * s</span></pre><p id="60b5" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As before, when used with <code class="cx pa pb pc pd b">mypy</code>, code that violates the type annotations will raise an error during static analysis. For example, providing an integer when a Boolean is required is an error:</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="6ea8" class="ph oa fq pd b bg pi pj l pk pl">v1: TNDArrayInt8 = np.arange(20, dtype=np.int8)<br/>x = process1(v1, v1)<br/># tp.py: error: Argument 2 to "process1" has incompatible type<br/># "ndarray[Any, dtype[floating[_64Bit]]]"; expected "ndarray[Any, dtype[bool_]]"  [arg-type]</span></pre><p id="7076" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The interface requires 8-bit signed integers (<code class="cx pa pb pc pd b">np.int8</code>); attempting to use a different sized integer is also an error:</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="dc8d" class="ph oa fq pd b bg pi pj l pk pl">TNDArrayInt64 = np.ndarray[Any, np.dtype[np.int64]]<br/>v2: TNDArrayInt64 = np.arange(20, dtype=np.int64)<br/>q: TNDArrayBool = np.arange(20) % 3 == 0<br/>x = process1(v2, q)<br/># tp.py: error: Argument 1 to "process1" has incompatible type<br/># "ndarray[Any, dtype[signedinteger[_64Bit]]]"; expected "ndarray[Any, dtype[signedinteger[_8Bit]]]"  [arg-type]</span></pre><p id="8fb9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">While some interfaces might benefit from such narrow numeric type specifications, broader specification is possible with NumPy’s generic types such as <code class="cx pa pb pc pd b">np.integer[Any]</code>, <code class="cx pa pb pc pd b">np.signedinteger[Any]</code>, <code class="cx pa pb pc pd b">np.float[Any]</code>, etc. For example, we can define a new function that accepts any size signed integer. Static analysis now passes with both <code class="cx pa pb pc pd b">TNDArrayInt8</code> and <code class="cx pa pb pc pd b">TNDArrayInt64</code> arrays.</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="debb" class="ph oa fq pd b bg pi pj l pk pl">TNDArrayIntAny = np.ndarray[Any, np.dtype[np.signedinteger[Any]]]<br/>def process2(<br/>        v: TNDArrayIntAny, # a more flexible interface<br/>        q: TNDArrayBool,<br/>        ) -&gt; TNDArrayFloat64:<br/>    s: TNDArrayFloat64 = np.where(q, 0.5, 0.25)<br/>    return v * s<br/><br/>x = process2(v1, q) # no mypy error<br/>x = process2(v2, q) # no mypy error</span></pre><p id="c971" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Just as shown above with elements, generically specified NumPy arrays can be validated at runtime if decorated with <code class="cx pa pb pc pd b">CallGuard.check</code>:</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="48a0" class="ph oa fq pd b bg pi pj l pk pl">@sf.CallGuard.check<br/>def process3(v: TNDArrayIntAny, q: TNDArrayBool) -&gt; TNDArrayFloat64:<br/>    s: TNDArrayFloat64 = np.where(q, 0.5, 0.25)<br/>    return v * s<br/><br/>x = process3(v1, q) # no error, same as mypy<br/>x = process3(v2, q) # no error, same as mypy<br/>v3: TNDArrayFloat64 = np.arange(20, dtype=np.float64) * 0.5<br/>x = process3(v3, q) # error<br/># static_frame.core.type_clinic.ClinicError:<br/># In args of (v: ndarray[Any, dtype[signedinteger[Any]]],<br/># q: ndarray[Any, dtype[bool_]]) -&gt; ndarray[Any, dtype[float64]]<br/># └── ndarray[Any, dtype[signedinteger[Any]]]<br/>#     └── dtype[signedinteger[Any]]<br/>#         └── Expected signedinteger, provided float64 invalid</span></pre><p id="7210" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">StaticFrame provides utilities to extend runtime validation beyond type checking. Using the <code class="cx pa pb pc pd b">typing</code> module’s <code class="cx pa pb pc pd b">Annotated</code> class (see <a class="af ny" href="https://peps.python.org/pep-0593/" rel="noopener ugc nofollow" target="_blank">PEP 593</a>), we can extend the type specification with one or more StaticFrame <code class="cx pa pb pc pd b">Require</code> objects. For example, to validate that an array has a 1D shape of <code class="cx pa pb pc pd b">(24,)</code>, we can replace <code class="cx pa pb pc pd b">TNDArrayIntAny</code> with <code class="cx pa pb pc pd b">Annotated[TNDArrayIntAny, sf.Require.Shape(24)]</code>. To validate that a float array has no NaNs, we can replace <code class="cx pa pb pc pd b">TNDArrayFloat64</code> with <code class="cx pa pb pc pd b">Annotated[TNDArrayFloat64, sf.Require.Apply(lambda a: ~a.insna().any())]</code>.</p><p id="1adb" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Implementing a new function, we can require that all input and output arrays have the shape <code class="cx pa pb pc pd b">(24,)</code>. Calling this function with the previously created arrays raises an error:</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="3ded" class="ph oa fq pd b bg pi pj l pk pl">from typing import Annotated<br/><br/>@sf.CallGuard.check<br/>def process4(<br/>        v: Annotated[TNDArrayIntAny, sf.Require.Shape(24)],<br/>        q: Annotated[TNDArrayBool, sf.Require.Shape(24)],<br/>        ) -&gt; Annotated[TNDArrayFloat64, sf.Require.Shape(24)]:<br/>    s: TNDArrayFloat64 = np.where(q, 0.5, 0.25)<br/>    return v * s<br/><br/>x = process4(v1, q) # types pass, but Require.Shape fails<br/># static_frame.core.type_clinic.ClinicError:<br/># In args of (v: Annotated[ndarray[Any, dtype[int8]], Shape((24,))], q: Annotated[ndarray[Any, dtype[bool_]], Shape((24,))]) -&gt; Annotated[ndarray[Any, dtype[float64]], Shape((24,))]<br/># └── Annotated[ndarray[Any, dtype[int8]], Shape((24,))]<br/>#     └── Shape((24,))<br/>#         └── Expected shape ((24,)), provided shape (20,)</span></pre><h1 id="9612" class="nz oa fq bf ob oc od gq oe of og gt oh oi oj ok ol om on oo op oq or os ot ou bk">DataFrame Type Annotations</h1><p id="5dea" class="pw-post-body-paragraph nc nd fq ne b go ov ng nh gr ow nj nk nl ox nn no np oy nr ns nt oz nv nw nx fj bk">Just like a dictionary, a DataFrame is a complex data structure composed of many component types: the index labels, column labels, and the column values are all distinct types.</p><p id="51d6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A challenge of generically specifying a DataFrame is that a DataFrame has a variable number of columns, where each column might be a different type. The Python <code class="cx pa pb pc pd b">TypeVarTuple</code> variadic generic specifier (see <a class="af ny" href="https://peps.python.org/pep-0646/" rel="noopener ugc nofollow" target="_blank">PEP 646</a>), first released in Python 3.11, permits defining a variable number of column type variables.</p><p id="84e2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With StaticFrame 2.0, <code class="cx pa pb pc pd b">Frame</code>, <code class="cx pa pb pc pd b">Series</code>, <code class="cx pa pb pc pd b">Index</code> and related containers become generic. Support for variable column type definitions is provided by <code class="cx pa pb pc pd b">TypeVarTuple</code>, back-ported with the implementation in <code class="cx pa pb pc pd b">typing-extensions</code> for compatibility down to Python 3.9.</p><p id="bd2d" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A generic <code class="cx pa pb pc pd b">Frame</code> requires two or more type variables: the type of the index, the type of the columns, and zero or more specifications of columnar value types specified with NumPy types. A generic <code class="cx pa pb pc pd b">Series</code> requires two type variables: the type of the index and a NumPy type for the values. The <code class="cx pa pb pc pd b">Index</code> is itself generic, also requiring a NumPy type as a type variable.</p><p id="23a7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With generic specification, a <code class="cx pa pb pc pd b">Series</code> of floats, indexed by dates, can be annotated with <code class="cx pa pb pc pd b">sf.Series[sf.IndexDate, np.float64]</code>. A <code class="cx pa pb pc pd b">Frame</code> with dates as index labels, strings as column labels, and column values of integers and floats can be annotated with <code class="cx pa pb pc pd b">sf.Frame[sf.IndexDate, sf.Index[np.str_], np.int64, np.float64]</code>.</p><p id="d8d0" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Given a complex <code class="cx pa pb pc pd b">Frame</code>, deriving the annotation might be difficult. StaticFrame offers the <code class="cx pa pb pc pd b">via_type_clinic</code> interface to provide a complete generic specification for any component at runtime:</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="8809" class="ph oa fq pd b bg pi pj l pk pl">&gt;&gt;&gt; v4 = sf.Frame.from_fields([range(5), np.arange(3, 8) * 0.5],<br/>columns=('a', 'b'), index=sf.IndexDate.from_date_range('2021-12-30', '2022-01-03'))<br/>&gt;&gt;&gt; v4<br/>&lt;Frame&gt;<br/>&lt;Index&gt;         a       b         &lt;&lt;U1&gt;<br/>&lt;IndexDate&gt;<br/>2021-12-30      0       1.5<br/>2021-12-31      1       2.0<br/>2022-01-01      2       2.5<br/>2022-01-02      3       3.0<br/>2022-01-03      4       3.5<br/>&lt;datetime64[D]&gt; &lt;int64&gt; &lt;float64&gt;<br/><br/># get a string representation of the annotation<br/>&gt;&gt;&gt; v4.via_type_clinic<br/>Frame[IndexDate, Index[str_], int64, float64]</span></pre><p id="f7b5" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As shown with arrays, storing annotations as type aliases permits reuse and more concise function signatures. Below, a new function is defined with generic <code class="cx pa pb pc pd b">Frame</code> and <code class="cx pa pb pc pd b">Series</code> arguments fully annotated. A <code class="cx pa pb pc pd b">cast</code> is required as not all operations can statically resolve their return type.</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="c095" class="ph oa fq pd b bg pi pj l pk pl">TFrameDateInts = sf.Frame[sf.IndexDate, sf.Index[np.str_], np.int64, np.int64]<br/>TSeriesYMBool = sf.Series[sf.IndexYearMonth, np.bool_]<br/>TSeriesDFloat = sf.Series[sf.IndexDate, np.float64]<br/><br/>def process5(v: TFrameDateInts, q: TSeriesYMBool) -&gt; TSeriesDFloat:<br/>    t = v.index.iter_label().apply(lambda l: q[l.astype('datetime64[M]')]) # type: ignore<br/>    s = np.where(t, 0.5, 0.25)<br/>    return cast(TSeriesDFloat, (v.via_T * s).mean(axis=1))</span></pre><p id="82cc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">These more complex annotated interfaces can also be validated with <code class="cx pa pb pc pd b">mypy</code>. Below, a <code class="cx pa pb pc pd b">Frame</code> without the expected column value types is passed, causing <code class="cx pa pb pc pd b">mypy</code> to error (shown as comments, below).</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="06ca" class="ph oa fq pd b bg pi pj l pk pl">TFrameDateIntFloat = sf.Frame[sf.IndexDate, sf.Index[np.str_], np.int64, np.float64]<br/>v5: TFrameDateIntFloat = sf.Frame.from_fields([range(5), np.arange(3, 8) * 0.5],<br/>columns=('a', 'b'), index=sf.IndexDate.from_date_range('2021-12-30', '2022-01-03'))<br/><br/>q: TSeriesYMBool = sf.Series([True, False],<br/>index=sf.IndexYearMonth.from_date_range('2021-12', '2022-01'))<br/><br/>x = process5(v5, q)<br/># tp.py: error: Argument 1 to "process5" has incompatible type<br/># "Frame[IndexDate, Index[str_], signedinteger[_64Bit], floating[_64Bit]]"; expected<br/># "Frame[IndexDate, Index[str_], signedinteger[_64Bit], signedinteger[_64Bit]]"  [arg-type]</span></pre><p id="072a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To use the same type hints for runtime validation, the <code class="cx pa pb pc pd b">sf.CallGuard.check</code> decorator can be applied. Below, a <code class="cx pa pb pc pd b">Frame</code> of three integer columns is provided where a <code class="cx pa pb pc pd b">Frame</code> of two columns is expected.</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="18e9" class="ph oa fq pd b bg pi pj l pk pl"># a Frame of three columns of integers<br/>TFrameDateIntIntInt = sf.Frame[sf.IndexDate, sf.Index[np.str_], np.int64, np.int64, np.int64]<br/>v6: TFrameDateIntIntInt = sf.Frame.from_fields([range(5), range(3, 8), range(1, 6)],<br/>columns=('a', 'b', 'c'), index=sf.IndexDate.from_date_range('2021-12-30', '2022-01-03'))<br/><br/>x = process5(v6, q)<br/># static_frame.core.type_clinic.ClinicError:<br/># In args of (v: Frame[IndexDate, Index[str_], signedinteger[_64Bit], signedinteger[_64Bit]],<br/># q: Series[IndexYearMonth, bool_]) -&gt; Series[IndexDate, float64]<br/># └── Frame[IndexDate, Index[str_], signedinteger[_64Bit], signedinteger[_64Bit]]<br/>#     └── Expected Frame has 2 dtype, provided Frame has 3 dtype</span></pre><p id="0caa" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">It might not be practical to annotate every column of every <code class="cx pa pb pc pd b">Frame</code>: it is common for interfaces to work with <code class="cx pa pb pc pd b">Frame</code> of variable column sizes. <code class="cx pa pb pc pd b">TypeVarTuple</code> supports this through the usage of <code class="cx pa pb pc pd b">*tuple[]</code> expressions (introduced in Python 3.11, back-ported with the <code class="cx pa pb pc pd b">Unpack</code> annotation). For example, the function above could be defined to take any number of integer columns with that annotation <code class="cx pa pb pc pd b">Frame[IndexDate, Index[np.str_], *tuple[np.int64, ...]]</code>, where <code class="cx pa pb pc pd b">*tuple[np.int64, ...]]</code> means zero or more integer columns.</p><p id="8104" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The same implementation can be annotated with a far more general specification of columnar types. Below, the column values are annotated with <code class="cx pa pb pc pd b">np.number[Any]</code> (permitting any type of numeric NumPy type) and a <code class="cx pa pb pc pd b">*tuple[]</code> expression (permitting any number of columns): <code class="cx pa pb pc pd b">*tuple[np.number[Any], …]</code>. Now neither <code class="cx pa pb pc pd b">mypy</code> nor <code class="cx pa pb pc pd b">CallGuard</code> errors with either previously created <code class="cx pa pb pc pd b">Frame</code>.</p><pre class="mm mn mo mp mq pe pd pf bp pg bb bk"><span id="78f3" class="ph oa fq pd b bg pi pj l pk pl">TFrameDateNums = sf.Frame[sf.IndexDate, sf.Index[np.str_], *tuple[np.number[Any], ...]]<br/><br/>@sf.CallGuard.check<br/>def process6(v: TFrameDateNums, q: TSeriesYMBool) -&gt; TSeriesDFloat:<br/>    t = v.index.iter_label().apply(lambda l: q[l.astype('datetime64[M]')]) # type: ignore<br/>    s = np.where(t, 0.5, 0.25)<br/>    return tp.cast(TSeriesDFloat, (v.via_T * s).mean(axis=1))<br/><br/>x = process6(v5, q) # a Frame with integer, float columns passes<br/>x = process6(v6, q) # a Frame with three integer columns passes</span></pre><p id="37f1" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As with NumPy arrays, <code class="cx pa pb pc pd b">Frame</code> annotations can wrap <code class="cx pa pb pc pd b">Require</code> specifications in <code class="cx pa pb pc pd b">Annotated</code> generics, permitting the definition of additional run-time validations.</p><h1 id="d28f" class="nz oa fq bf ob oc od gq oe of og gt oh oi oj ok ol om on oo op oq or os ot ou bk">Type Annotations with Other Libraries</h1><p id="37f3" class="pw-post-body-paragraph nc nd fq ne b go ov ng nh gr ow nj nk nl ox nn no np oy nr ns nt oz nv nw nx fj bk">While StaticFrame might be the first DataFrame library to offer complete generic specification and a unified solution for both static type analysis and run-time type validation, other array and DataFrame libraries offer related utilities.</p><p id="43ba" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Neither the <code class="cx pa pb pc pd b">Tensor</code> class in PyTorch (2.4.0), nor the <code class="cx pa pb pc pd b">Tensor</code> class in TensorFlow (2.17.0) support generic type or shape specification. While both libraries offer a <code class="cx pa pb pc pd b">TensorSpec</code> object that can be used to perform run-time type and shape validation, static type checking with tools like <code class="cx pa pb pc pd b">mypy</code> is not supported.</p><p id="f81f" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As of Pandas 2.2.2, neither the Pandas <code class="cx pa pb pc pd b">Series</code> nor <code class="cx pa pb pc pd b">DataFrame</code> support generic type specifications. A number of third-party packages have offered partial solutions. The <code class="cx pa pb pc pd b">pandas-stubs</code> library, for example, provides type annotations for the Pandas API, but does not make the <code class="cx pa pb pc pd b">Series</code> or <code class="cx pa pb pc pd b">DataFrame</code> classes generic. The Pandera library permits defining <code class="cx pa pb pc pd b">DataFrameSchema</code> classes that can be used for run-time validation of Pandas DataFrames. For static-analysis with <code class="cx pa pb pc pd b">mypy</code>, Pandera offers alternative <code class="cx pa pb pc pd b">DataFrame</code> and <code class="cx pa pb pc pd b">Series</code> subclasses that permit generic specification with the same <code class="cx pa pb pc pd b">DataFrameSchema</code> classes. This approach does not permit the expressive opportunities of using generic NumPy types or the unpack operator for supplying variadic generic expressions.</p><h1 id="f388" class="nz oa fq bf ob oc od gq oe of og gt oh oi oj ok ol om on oo op oq or os ot ou bk">Conclusion</h1><p id="b394" class="pw-post-body-paragraph nc nd fq ne b go ov ng nh gr ow nj nk nl ox nn no np oy nr ns nt oz nv nw nx fj bk">Python type annotations can make static analysis of types a valuable check of code quality, discovering errors before code is even executed. Up until recently, an interface might take an array or a DataFrame, but no specification of the types contained in those containers was possible. Now, complete specification of component types is possible in NumPy and StaticFrame, permitting more powerful static analysis of types.</p><p id="dc06" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Providing correct type annotations is an investment. Reusing those annotations for runtime checks provides the best of both worlds. StaticFrame’s <code class="cx pa pb pc pd b">CallGuard</code> runtime type checker is specialized to correctly evaluate fully specified generic NumPy types, as well as all generic StaticFrame containers.</p></div></div></div></div>    
</body>
</html>
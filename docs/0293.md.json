["```py\n# Create node lookup for channels\nnode_lookup = {0: 'Demand',\n               1: 'Call waiting time',\n               2: 'Call abandoned', \n               3: 'Reported problems',                   \n               4: 'Discount sent',\n               5: 'Churn'                                                                             \n }\n\ntotal_nodes = len(node_lookup)\n\n# Create adjacency matrix - this is the base for our graph\ngraph_actual = np.zeros((total_nodes, total_nodes))\n\n# Create graph using expert domain knowledge\ngraph_actual[0, 1] = 1.0 # Demand -> Call waiting time\ngraph_actual[0, 2] = 1.0 # Demand -> Call abandoned\ngraph_actual[0, 3] = 1.0 # Demand -> Reported problems\ngraph_actual[1, 2] = 1.0 # Call waiting time -> Call abandoned\ngraph_actual[1, 5] = 1.0 # Call waiting time -> Churn\ngraph_actual[2, 3] = 1.0 # Call abandoned -> Reported problems\ngraph_actual[2, 5] = 1.0 # Call abandoned -> Churn\ngraph_actual[3, 4] = 1.0 # Reported problems -> Discount sent\ngraph_actual[3, 5] = 1.0 # Reported problems -> Churn\ngraph_actual[4, 5] = 1.0 # Discount sent -> Churn\n```", "```py\ndef data_generator(max_call_waiting, inbound_calls, call_reduction):\n    '''\n     A data generating function that has the flexibility to reduce the value of node 0 (Call waiting time) - this enables us to calculate ground truth counterfactuals\n\n    Args:\n        max_call_waiting (int): Maximum call waiting time in seconds\n        inbound_calls (int): Total number of inbound calls (observations in data)\n        call_reduction (float): Reduction to apply to call waiting time\n\n    Returns:\n        DataFrame: Generated data\n    '''\n\n    df = pd.DataFrame(columns=node_lookup.values())\n\n    df[node_lookup[0]] = np.random.randint(low=10, high=max_call_waiting, size=(inbound_calls)) # Demand\n    df[node_lookup[1]] = (df[node_lookup[0]] * 0.5) * (call_reduction) + np.random.normal(loc=0, scale=40, size=inbound_calls) # Call waiting time\n    df[node_lookup[2]] = (df[node_lookup[1]] * 0.5) + (df[node_lookup[0]] * 0.2) + np.random.normal(loc=0, scale=30, size=inbound_calls) # Call abandoned\n    df[node_lookup[3]] = (df[node_lookup[2]] * 0.6) + (df[node_lookup[0]] * 0.3) + np.random.normal(loc=0, scale=20, size=inbound_calls) # Reported problems\n    df[node_lookup[4]] = (df[node_lookup[3]] * 0.7) + np.random.normal(loc=0, scale=10, size=inbound_calls) # Discount sent\n    df[node_lookup[5]] = (0.10 * df[node_lookup[1]] ) + (0.30 * df[node_lookup[2]]) + (0.15 * df[node_lookup[3]]) + (-0.20 * df[node_lookup[4]]) # Churn\n\n    return df\n```", "```py\n# Generate data\nnp.random.seed(999)\ndf = data_generator(max_call_waiting=600, inbound_calls=10000, call_reduction=1.00)\n\nsns.pairplot(df)\n```", "```py\n# Setup graph\ngraph = nx.from_numpy_array(graph_actual, create_using=nx.DiGraph)\ngraph = nx.relabel_nodes(graph, node_lookup)\n\n# Create SCM\ncausal_model = gcm.InvertibleStructuralCausalModel(graph)\ncausal_model.set_causal_mechanism('Demand', gcm.EmpiricalDistribution()) # Root node\ncausal_model.set_causal_mechanism('Call waiting time', gcm.AdditiveNoiseModel(gcm.ml.create_ridge_regressor())) # Non-root node\ncausal_model.set_causal_mechanism('Call abandoned', gcm.AdditiveNoiseModel(gcm.ml.create_ridge_regressor())) # Non-root node\ncausal_model.set_causal_mechanism('Reported problems', gcm.AdditiveNoiseModel(gcm.ml.create_ridge_regressor())) # Non-root node\ncausal_model.set_causal_mechanism('Discount sent', gcm.AdditiveNoiseModel(gcm.ml.create_ridge_regressor())) # Non-root \ncausal_model.set_causal_mechanism('Churn', gcm.AdditiveNoiseModel(gcm.ml.create_ridge_regressor())) # Non-root \ngcm.fit(causal_model, df)\n```", "```py\n# Ridge regression\ny = df['Churn'].copy()\nX = df.iloc[:, 1:-1].copy()\nmodel = RidgeCV()\nmodel = model.fit(X, y)\ny_pred = model.predict(X)\n\nprint(f'Intercept: {model.intercept_}')\nprint(f'Coefficient: {model.coef_}')\n# Ground truth[0.10 0.30 0.15 -0.20]\n```", "```py\n# Set call reduction to 20%\nreduce = 0.20\ncall_reduction = 1 - reduce\n\n# Generate counterfactual data\nnp.random.seed(999)\ndf_cf = data_generator(max_call_waiting=600, inbound_calls=10000, call_reduction=call_reduction)\n```", "```py\n# Ground truth counterfactual\nground_truth = round((df['Churn'].sum() - df_cf['Churn'].sum()) / df['Churn'].sum(), 2)\n\n# Causal graph counterfactual\ndf_counterfactual = gcm.counterfactual_samples(causal_model, {'Call waiting time': lambda x: x*call_reduction}, observed_data=df)\ncausal_graph = round((df['Churn'].sum() - df_counterfactual['Churn'].sum()) / (df['Churn'].sum()), 3)\n\n# Ridge regression counterfactual\nridge_regression = round((df['Call waiting time'].sum() * 1.0 * model.coef_[0] - (df['Call waiting time'].sum() * call_reduction * model.coef_[0])) / (df['Churn'].sum()), 3)\n```"]
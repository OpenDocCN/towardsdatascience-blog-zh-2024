- en: Market Basket Analysis Using High Utility Itemset Mining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/market-basket-analysis-using-high-utility-itemset-mining-df233b297c0d?source=collection_archive---------5-----------------------#2024-09-11](https://towardsdatascience.com/market-basket-analysis-using-high-utility-itemset-mining-df233b297c0d?source=collection_archive---------5-----------------------#2024-09-11)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Finding high-value patterns in transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@brechterlaurin?source=post_page---byline--df233b297c0d--------------------------------)[![Laurin
    Brechter](../Images/5a68b96bddf86846a2bef9d482ef9dd3.png)](https://medium.com/@brechterlaurin?source=post_page---byline--df233b297c0d--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--df233b297c0d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--df233b297c0d--------------------------------)
    [Laurin Brechter](https://medium.com/@brechterlaurin?source=post_page---byline--df233b297c0d--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--df233b297c0d--------------------------------)
    ¬∑9 min read¬∑Sep 11, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '*In this post, I will give an alternative to popular techniques in market basket
    analysis that can help practitioners find high-value patterns rather than just
    the most frequent ones. We will gain some intuition into different pattern mining
    problems and look at a real-world example. The full code can be found* [*here*](https://github.com/LaurinBrechter/PatternMining/blob/main/market_basket_analysis.ipynb)*.
    All images are created by the author.*'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have written a more [introductory article](https://medium.com/@brechterlaurin/customer-analytics-pattern-mining-on-clickstream-data-in-python-1bcd2de15a5d)
    about pattern mining already; if you‚Äôre not familiar with some of the concepts
    that come up here, feel free to check that one out first.
  prefs: []
  type: TYPE_NORMAL
- en: In short, pattern mining tries to find patterns in data (duuh). Most of the
    time, this data comes in the form of (multi-)sets or sequences. In my last article,
    for example, I looked at the sequence of actions that a user performs on a website.
    In this case, we **would** care about the ordering of the items.
  prefs: []
  type: TYPE_NORMAL
- en: In other cases, such as the one we will discuss below, we do not care about
    the ordering of the items. We only list all the items that were in the transaction
    and how often they appeared.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/41cb825f15fa90e48e2542357f2cca25.png)'
  prefs: []
  type: TYPE_IMG
- en: Example Transacton Database
  prefs: []
  type: TYPE_NORMAL
- en: So for example, transaction 1 contained ü•™ 3 times and üçé once. As we see, we
    lose information about the ordering of the items, but in many scenarios (as the
    one we will discuss below), there is no logical ordering of the items. This is
    similar to a bag of words in NLP.
  prefs: []
  type: TYPE_NORMAL
- en: Market Basket Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Market Basket Analysis* (MBA) is a data analysis technique commonly used in
    retail and marketing to uncover relationships between products that customers
    tend to purchase together. It aims to identify patterns in customers‚Äô shopping
    baskets or transactions by analyzing their purchasing behavior. The central idea
    is to understand the co-occurrence of items in shopping transactions, which helps
    businesses optimize their strategies for product placement, cross-selling, and
    targeted marketing campaigns.'
  prefs: []
  type: TYPE_NORMAL
- en: Frequent Itemset Mining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Frequent Itemset Mining* (FIM) is the process of finding frequent patterns
    in transaction databases. We can look at the frequency of a pattern (i.e. a set
    of items) by calculating its support. In other words, the support of a pattern
    X is the number of transactions T that contain X (and are in the database D).
    That is, we are simply looking at how often the pattern X appears in the database.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8e4e64bb847ac52b766b74fa02f9f7b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Definition of the support.
  prefs: []
  type: TYPE_NORMAL
- en: In FIM, we then want to find all the sequences that have a support bigger than
    some threshold (often called *minsup*). If the support of a sequence is higher
    than minsup, it is considered frequent.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In FIM, we only look at the existence of an item in a sequence. That is, whether
    an item appears two times or 200 times does not matter, we simply represent it
    as a one. But we often have cases (such as MBA), where not only the existence
    of an item in a transaction is relevant but also how many times it appeared in
    the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is that frequency does not always imply relevance. In that sense,
    FIM assumes that all items in the transaction are equally important. However,
    it is reasonable to assume that someone buying caviar might be more important
    for a business than someone buying bread, as caviar is potentially a high ROI/profit
    item.
  prefs: []
  type: TYPE_NORMAL
- en: High Utility Itemset Mining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These limitations directly bring us to *High Utility Itemset Mining* (HUIM)
    and [*High Utility Quantitative Itemset Mining*](https://data-mining.philippe-fournier-viger.com/an-introduction-to-high-utility-quantitative-itemset-mining/)
    (HUQIM) which are generalizations of FIM that try to address some of the problems
    of normal FIM.
  prefs: []
  type: TYPE_NORMAL
- en: Our first generalization is that items can appear more than once in a transaction
    (i.e. we have a multiset instead of a simple set). As said before, in normal itemset
    mining, we transform the transaction into a set and only look at whether the item
    exists in the transaction or not. So for example the two transactions below would
    have the same representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Above, both these two transactions would be represented as [a,b] in regular
    FIM. We quickly see that, in some cases, we could miss important details. For
    example, if a and b were some items in a customer‚Äôs shopping cart, it would matter
    a lot whether we have *a* (e.g. a loaf of bread) five times or only once. Therefore,
    we represent the transaction as a multiset in which we write down, how many times
    each item appeared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is also efficient if the items can appear in a large number of items (e.g.
    100 or 1000 times). In that case, we need not write down all the a‚Äôs or b‚Äôs but
    simply how often they appear.
  prefs: []
  type: TYPE_NORMAL
- en: The generalization that both the quantitative and non-quantitative methods make,
    is to assign every item in the transaction a utility (e.g. profit or time). Below,
    we have a table that assigns every possible item a unit profit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ab15ac9523c16807736ef0d97bc7f37b.png)'
  prefs: []
  type: TYPE_IMG
- en: Utility of Items
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then calculate the utility of a specific pattern such as {ü•™, üçé} by summing
    up the utility of those items in the transactions that contain them. In our example
    we would have:'
  prefs: []
  type: TYPE_NORMAL
- en: (3ü•™ * $1 + 1üçé * $2) +
  prefs: []
  type: TYPE_NORMAL
- en: (1 ü•™ * $1 + 2üçé * $2) = $10
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/41cb825f15fa90e48e2542357f2cca25.png)'
  prefs: []
  type: TYPE_IMG
- en: Transacton Database from Above
  prefs: []
  type: TYPE_NORMAL
- en: So, we get that this pattern has a utility of $10\. With FIM, we had the task
    of finding frequent patterns. Now, we have to find patterns with high utility.
    This is mainly because we assume that frequency does not imply importance. In
    regular FIM, we might have missed rare (infrequent) patterns that provide a high
    utility (e.g. the diamond), which is not true with HUIM.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to define the notion of a *transaction utility*. This is simply
    the sum of the utility of all the items in the transaction. For our transaction
    3 in the database, this would be
  prefs: []
  type: TYPE_NORMAL
- en: 1ü•™ * $1 + 2ü¶û*$10 + 2üçé*$2 = $25
  prefs: []
  type: TYPE_NORMAL
- en: Note that solving this problem and finding all high-utility items is more difficult
    than regular FPM. This is because the utility does not follow the Apriori property.
  prefs: []
  type: TYPE_NORMAL
- en: The Apriori Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let X and Y be two patterns occurring in a transaction database D. The apriori
    property says that if X is a subset of Y, then the support of X must be at least
    as big as Y's.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1c3c25ff7dd2c5206f3c08921935d9b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Apriori property.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if a subset of Y is infrequent, Y itself must be infrequent
    since it must have a smaller support. Let‚Äôs say we have X = {a} and Y = {a,b}.
    If Y appears 4 times in our database, then X must appear at least 4 times, since
    X is a subset of Y. This makes sense since we are making the pattern less general
    / more specific by adding an item which means that it will fit less transactions.
    This property is used in most algorithms as it implies that if {a} is infrequent
    all supersets are also infrequent and we can eliminate them from the search space
    [3].
  prefs: []
  type: TYPE_NORMAL
- en: This property does not hold when we are talking about utility. A superset Y
    of transaction X could have more or less utility. If we take the example from
    above, {ü•™} has a utility of $4\. But this does not mean we cannot look at supersets
    of this pattern. For example, the superset we looked at {ü•™, üçé} has a higher utility
    of $10\. At the same time, a superset of a pattern won‚Äôt always have more utility
    since it might be that this superset just doesn‚Äôt appear very often in the DB.
  prefs: []
  type: TYPE_NORMAL
- en: Idea Behind HUIM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we can‚Äôt use the apriori property for HUIM directly, we have to come up
    with some other upper bound for narrowing down the search space. One such bound
    is called *Transaction-Weighted Utilization* (TWU). To calculate it, we sum up
    the transaction utility of the transactions that contain the pattern X of interest.
    Any superset Y of X can‚Äôt have a higher utility than the TWU. Let‚Äôs make this
    clearer with an example. The TWU of {ü•™,üçé} is $30 ($5 from transaction 1 and $5
    from transaction 3). When we look at a superset pattern Y such as {ü•™ ü¶û üçé} we can
    see that there is no way it would have more utility since all transactions that
    have Y in them also have X in them.
  prefs: []
  type: TYPE_NORMAL
- en: There are now various algorithms for solving HUIM. All of them receive a minimum
    utility and produce the patterns that have at least that utility as their output.
    In this case, I have used the [EFIM](https://www.philippe-fournier-viger.com/EFIM_JOURNAL_VERSION%20KAIS%202016.pdf)
    algorithm since it is fast and memory efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this article, I will work with the [Market Basket Analysis](https://www.kaggle.com/datasets/aslanahmedov/market-basket-analysis/data)
    dataset from Kaggle (used with permission from the original dataset author).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/52a9c188eeffd3d5623867a20fcea425.png)'
  prefs: []
  type: TYPE_IMG
- en: Above, we can see the distribution of transaction values found in the data.
    There is a total of around 19,500 transactions with an average transaction value
    of $526 and 26 distinct items per transaction. In total, there are around 4000
    unique items. We can also make an [ABC analysis](https://en.wikipedia.org/wiki/ABC_analysis)
    where we put items into different buckets depending on their share of total revenue.
    We can see that around 500 of the 4000 items make up around 70% of the revenue
    (A-items). We then have a long right-tail of items (around 2250) that make up
    around 5% of the revenue (C-items).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/00215688bf024d53c61c4bc6ec612e03.png)'
  prefs: []
  type: TYPE_IMG
- en: Preprocessing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The initial data is in a long format where each row is a line item within a
    bill. From the BillNo we can see to which transaction the item belongs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2dc515f0b73bc158e7e17eddb1a6b66e.png)'
  prefs: []
  type: TYPE_IMG
- en: Initial Data Format
  prefs: []
  type: TYPE_NORMAL
- en: After some preprocessing, we get the data into the format required by [PAMI](https://github.com/UdayLab/PAMI)
    which is the Python library we are going to use for applying the EFIM algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f1b0a477c01d571854d796c79562909a.png)'
  prefs: []
  type: TYPE_IMG
- en: Transaction Database
  prefs: []
  type: TYPE_NORMAL
- en: We can then apply the [EFIM](https://udaylab.github.io/PAMI/highUtilityPatternMining.html)
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm then returns a list of patterns that meet this minimum utility
    criterion.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c97eeb8c4bf93dc415d2d0efaf12a071.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the point at which a subject matter expert would have to look at these
    patterns to see if there is something worth taking a closer look at. We can for
    example see that the combination of VINTAGE BEAD PINK PURSE‚Äô and ‚ÄòANT COPPER RED
    BOUDICCA BRACELET‚Äô seems to perform quite well. In that case, we might think about
    offering these items as a bundle or recommending them together.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this blog post, we looked at classical FIM and its limitations. Especially
    when we care about the transaction value of a pattern and the potential revenue
    it can provide, it can be beneficial to use HUIM and mine patterns with high utility.
  prefs: []
  type: TYPE_NORMAL
- en: Resources & Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[1] [High Utility Itemset Mining](https://www.youtube.com/watch?v=dty9ircNDqI&list=PLQWbHaW8RsA1wND30_Re9V5-c8pr1H56H&index=9&ab_channel=PhilippeFournier-Viger)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2] [The Pattern Mining Course](https://www.youtube.com/playlist?list=PLQWbHaW8RsA1wND30_Re9V5-c8pr1H56H)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3] [EFIM: A Fast and Memory Efficient Algorithm for High-Utility Itemset Mining](https://www.philippe-fournier-viger.com/EFIM_JOURNAL_VERSION%20KAIS%202016.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[4] [Coursera Course on Pattern Mining](https://www.coursera.org/learn/data-patterns?specialization=data-mining)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

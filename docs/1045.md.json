["```py\n@action(reads=[\"counter\"], writes=[\"counter\"])\ndef count(state: State) -> Tuple[dict, State]:\n    current = state[\"counter\"] + 1\n    result = {\"counter\": current}\n    return result, state.update(counter=counter)\n```", "```py\nfrom burr.core import ApplicationBuilder, default, expr\napp = (\n    ApplicationBuilder()\n    .with_state(counter=0) # initialize the count to zero\n    .with_actions(\n        count=count, \n        done=done # implementation left out above\n    ).with_transitions(\n        (\"count\", \"count\", expr(\"counter < 10\")), # Keep counting if the counter is less than 10\n        (\"count\", \"done\", default) # Otherwise, we're done\n    ).with_entrypoint(\"count\") # we have to start somewhere\n    .build()\n)\n```", "```py\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: Union[str, None] = None):\n    \"\"\"A very simpler example of an endpoint that takes in arguments.\"\"\"\n    return {\"item_id\": item_id, \"q\": q}\n```", "```py\n@action(\n    reads=[\"response_instructions\", \"incoming_email\"], \n    writes=[\"clarification_questions\"]\n)\ndef determine_clarifications(state: State) -> Tuple[dict, State]:\n    \"\"\"Determines if the response instructions require clarification.\"\"\"\n\n    incoming_email = state[\"incoming_email\"]\n    response_instructions = state[\"response_instructions\"]\n    client = _get_openai_client()\n\n    result = client.chat.completions.create(\n        model=\"gpt-4\",\n        messages=[\n            {\n                \"role\": \"system\",\n                \"content\": (\"You are a chatbot that has the task of \"\n                            \"generating responses to an email on behalf \"\n                            \"of a user. \"),\n            },\n            {\n                \"role\": \"user\",\n                \"content\": (\n                    f\"The email you are to respond to is: {incoming_email}.\"\n                     # ... left out, see link above\n                    \"The questions, joined by newlines, must be the only \"\n                    \"text you return. If you do not need clarification, \"\n                    \"return an empty string.\"\n                ),\n            },\n        ],\n    )\n    content = result.choices[0].message.content\n    all_questions = content.split(\"\\n\") if content else []\n    return {\"clarification_questions\": all_questions}, state.update(\n        clarification_questions=all_questions)\n```", "```py\napplication = (\n    ApplicationBuilder()\n    # define our actions\n    .with_actions(\n        process_input,\n        determine_clarifications,\n        clarify_instructions,\n        formulate_draft,\n        process_feedback,\n        final_result,\n    )\n    # define how our actions connect\n    .with_transitions(\n        (\"process_input\", \"determine_clarifications\"),\n        (\n            \"determine_clarifications\",\n            \"clarify_instructions\",\n            expr(\"len(clarification_questions) > 0\"),\n        ),\n        (\"determine_clarifications\", \"formulate_draft\"),\n        (\"clarify_instructions\", \"formulate_draft\"),\n        (\"formulate_draft\", \"process_feedback\"),\n        (\"process_feedback\", \"formulate_draft\", expr(\"len(feedback) > 0\")),\n        (\"process_feedback\", \"final_result\"),\n    )\n    .with_state(draft_history=[])\n    .with_entrypoint(\"process_input\")\n    .build()\n)\n```", "```py\ndef request_answers(questions):\n    \"\"\"Requests answers from the user for the questions the LLM has\"\"\"\n    answers = []\n    print(\"The email assistant wants more information:\\n\")\n    for question in questions:\n        answers.append(input(question))\n    return answers\n\ndef request_feedback(draft):\n    \"\"\"Requests feedback from the user for a draft\"\"\"\n    print( \n        f\"here's a draft!: \\n {draft} \\n \\n What feedback do you have?\",\n    )\n    return input(\"Write feedback or leave blank to continue (if you're happy)\")\ninputs = {\n    \"email_to_respond\" : EMAIL,\n    \"response_instructions\" : INSTRUCTIONS\n}\n\n# in our notebook cell:\nwhile True:\n    action, result, state = app.run(\n        halt_before=[\"clarify_instructions\", \"process_feedback\"], \n        halt_after=[\"final_result\"],\n        inputs=inputs\n    )\n    if action.name == \"clarify_instructions\":\n        questions = state[\"clarification_questions\"]\n        answers = request_answers(questions)\n        inputs = {\n            \"clarification_inputs\" : answers\n        }\n    if action.name == \"process_feedback\":\n        feedback = request_feedback(state[\"current_draft\"])\n        inputs = {\"feedback\" : feedback}\n    if action.name == \"final_result\":\n        print(\"final result is:\", state[\"current_draft\"])\n        break\n```", "```py\nstate_persister = SQLLitePersister(\n    db_path=\"sqllite.db\", \n    table_name=\"email_assistant_table\"\n)\n\napp = (\n    ApplicationBuilder().\n    ... # the code we had above\n    .initialize(  \n        initializer=state_persister,\n        resume_at_next_action=True,\n        default_state={\"chat_history\" : []},\n        default_entrypoint=\"process_input\"\n    )\n    .with_identifiers(app_id=app_id)\n    .build()\n)\n```", "```py\n@functools.lru_cache(maxsize=128)\ndef get_application(app_id: str) -> Application:\n    app = email_assistant_application.application(app_id=app_id)\n    return app\n```", "```py\nclass EmailAssistantState(pydantic.BaseModel):\n    app_id: str\n    email_to_respond: Optional[str]\n    response_instructions: Optional[str]\n    questions: Optional[List[str]]\n    answers: Optional[List[str]]\n    drafts: List[str]\n    feedback_history: List[str]\n    final_draft: Optional[str]\n    # This stores the next step, which tells the frontend which ones to call\n    next_step: Literal[\n        \"process_input\", \"clarify_instructions\", \n        \"process_feedback\", None]\n\n    @staticmethod\n    def from_app(app: Application):\n        # implementation left out, call app.state and translate to \n        # pydantic model we can use `app.get_next_action()` to get \n        #the next step and return it to the user\n        ...\n```", "```py\ndef run_through(\n    project_id: str, \n    app_id: Optional[str], \n    inputs: Dict[str, Any]\n) -> EmailAssistantState:\n    email_assistant_app = get_application(project_id, app_id)\n    email_assistant_app.run(\n        halt_before=[\"clarify_instructions\", \"process_feedback\"],\n        halt_after=[\"final_result\"],\n        inputs=inputs,\n    )\n    return EmailAssistantState.from_app(email_assistant_app)\n```"]
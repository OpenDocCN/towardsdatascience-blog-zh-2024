["```py\ndef data_generator(tau_weight, interaction_num):\n\n    # Set number of observations\n    n=10000\n\n    # Set number of features\n    p=10\n\n    # Create features\n    X = np.random.uniform(size=n * p).reshape((n, -1))\n\n    # Nuisance parameters\n    b = (\n        np.sin(np.pi * X[:, 0] * X[:, 1])\n        + 2 * (X[:, 2] - 0.5) ** 2\n        + X[:, 3]\n        + 0.5 * X[:, 4]\n        + X[:, 5] * X[:, 6]\n        + X[:, 7] ** 3\n        + np.sin(np.pi * X[:, 8] * X[:, 9])\n    )\n\n    # Create binary treatment\n    T = np.random.binomial(1, expit(b))\n\n    # treatment interactions\n    interaction_1 = X[:, 0] * X[:, 1] + X[:, 2]\n    interaction_2 = X[:, 3] * X[:, 4] + X[:, 5]\n    interaction_3 = X[:, 6] * X[:, 7] + X[:, 9]\n\n    # Set treatment effect\n    if interaction_num==1:\n        tau = tau_weight * interaction_1\n    elif interaction_num==2:\n        tau = tau_weight * interaction_2\n    elif interaction_num==3:\n        tau = tau_weight * interaction_3\n\n    # Calculate outcome\n    y = b + T * tau + np.random.normal(size=n)\n\n    return X, T, tau, y\n```", "```py\nnp.random.seed(123)\n\n# Generate samples for 3 different treatments\nX1, T1, tau1, y1 = data_generator(0.75, 1)\nX2, T2, tau2, y2 = data_generator(0.50, 2)\nX3, T3, tau3, y3 = data_generator(0.90, 3)\n```", "```py\nnp.random.seed(123)\n\n# Train DML model using flexible stage 1 models\ndml1 = LinearDML(model_y=LGBMRegressor(), model_t=LGBMClassifier(), discrete_treatment=True)\ndml1.fit(y1, T=T1, X=X1, W=None)\n\n# Train DML model using flexible stage 1 models\ndml2 = LinearDML(model_y=LGBMRegressor(), model_t=LGBMClassifier(), discrete_treatment=True)\ndml2.fit(y2, T=T2, X=X2, W=None)\n\n# Train DML model using flexible stage 1 models\ndml3 = LinearDML(model_y=LGBMRegressor(), model_t=LGBMClassifier(), discrete_treatment=True)\ndml3.fit(y3, T=T3, X=X3, W=None)\n```", "```py\n# Create a figure and subplots\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\n\n# Plot scatter plots on each subplot\nsns.scatterplot(x=dml1.effect(X1), y=tau1, ax=axes[0])\naxes[0].set_title('Treatment 1')\naxes[0].set_xlabel('Estimated CATE')\naxes[0].set_ylabel('Actual CATE')\n\nsns.scatterplot(x=dml2.effect(X2), y=tau2, ax=axes[1])\naxes[1].set_title('Treatment 2')\naxes[1].set_xlabel('Estimated CATE')\naxes[1].set_ylabel('Actual CATE')\n\nsns.scatterplot(x=dml3.effect(X3), y=tau3, ax=axes[2])\naxes[2].set_title('Treatment 3')\naxes[2].set_xlabel('Estimated CATE')\naxes[2].set_ylabel('Actual CATE')\n\n# Add labels to the entire figure\nfig.suptitle('Actual vs Estimated')\n\n# Show plots\nplt.show()\n```", "```py\n# Create mapping for cost of each treatment\ncost_dict = {'T1': 0.1, 'T2': 0.2, 'T3': 0.3}\n\n# Set constraints\nmax_cost = 3000\n```", "```py\n# Concatenate features\nX = np.concatenate((X1, X2, X3), axis=0)\n\n# Estimate CATE for each treatment using DML models\nTreatment_1 = dml1.effect(X)\nTreatment_2 = dml2.effect(X)\nTreatment_3 = dml3.effect(X)\ncate = pd.DataFrame({\"T1\": Treatment_1, \"T2\": Treatment_2, \"T3\": Treatment_3})\n\n# Select the best treatment for each customer\nbest_treatment = cate.idxmax(axis=1)\nbest_value = cate.max(axis=1)\n\n# Map cost for each treatment\nbest_cost = pd.Series([cost_dict[value] for value in best_treatment])\n\n# Create dataframe with each customers best treatment and associated cost\nbest_df = pd.concat([best_value, best_cost], axis=1)\nbest_df.columns = [\"value\", \"cost\"]\nbest_df = best_df.sort_values(by=['value'], ascending=False).reset_index(drop=True)\n\n# Naive optimisation\nbest_df_cum = best_df.cumsum()\nopt_index = best_df_cum['cost'].searchsorted(max_cost)\nnaive_order_value = round(best_df_cum.iloc[opt_index]['value'], 0)\nnaive_cost_check = round(best_df_cum.iloc[opt_index]['cost'], 0)\n\nprint(f'The total order value from the naive treatment strategy is {naive_order_value} with a cost of {naive_cost_check}')\n```", "```py\n# Cost mapping for all treatments\ncost_mapping = {'T1': [cost_dict[\"T1\"]] * 30000,\n                'T2': [cost_dict[\"T2\"]] * 30000,\n                'T3': [cost_dict[\"T3\"]] * 30000}\n\n# Create DataFrame\ndf_costs = pd.DataFrame(cost_mapping)\n```", "```py\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# Set constraints\nmax_cost = 3000\nmin_cost = 3000\n\n# Create input arrays\ncosts = df_costs.to_numpy()\norder_value = cate.to_numpy()\n\nnum_custs = len(costs)\nnum_treatments = len(costs[0])\n\n# x[i, j] is an array of 0-1 variables, which will be 1 if customer i is assigned to treatment j.\nx = {}\nfor i in range(num_custs):\n    for j in range(num_treatments):\n        x[i, j] = solver.IntVar(0, 1, '')\n\n# Each customer is assigned to at most 1 treatment.\nfor i in range(num_custs):\n    solver.Add(solver.Sum([x[i, j] for j in range(num_treatments)]) <= 1)\n\n# Cost constraints\nsolver.Add(sum([costs[i][j] * x[i, j] for j in range(num_treatments) for i in range(num_custs)]) <= max_cost)\nsolver.Add(sum([costs[i][j] * x[i, j] for j in range(num_treatments) for i in range(num_custs)]) >= min_cost)\n\n# Objective\nobjective_terms = []\nfor i in range(num_custs):\n    for j in range(num_treatments):\n        objective_terms.append((order_value[i][j] * x[i, j] - costs[i][j] * x[i, j] ))\nsolver.Maximize(solver.Sum(objective_terms))\n\n# Solve\nstatus = solver.Solve()\n\nassignments = []\nvalues = []\n\nif status == pywraplp.Solver.OPTIMAL or status == pywraplp.Solver.FEASIBLE:\n    for i in range(num_custs):\n        for j in range(num_treatments):\n            # Test if x[i,j] is 1 (with tolerance for floating point arithmetic).\n            if x[i, j].solution_value() > -0.5:\n                assignments.append([i, j])\n                values.append([x[i, j].solution_value(), costs[i][j] * x[i, j].solution_value(), order_value[i][j]])\n\n# Create a DataFrame from the collected data\ndf = pd.DataFrame(assignments, columns=['customer', 'treatment'])\ndf['assigned'] = [x[0] for x in values]\ndf['cost'] = [x[1] for x in values]\ndf['order_value'] = [x[2] for x in values]\n\ndf\n```", "```py\nopt_order_value = round(df['order_value'][df['assigned'] == 1].sum(), 0)\nopt_cost_check = round(df['cost'][df['assigned'] == 1].sum(), 0)\n\nprint(f'The total order value from the optimised treatment strategy is {opt_order_value} with a cost of {opt_cost_check}')\n```"]
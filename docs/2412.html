<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Time Complexity Analysis of Perfect Binary Tree Traversal</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Time Complexity Analysis of Perfect Binary Tree Traversal</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/time-complexity-analysis-of-perfect-binary-tree-traversal-c2e4cccf6c97?source=collection_archive---------9-----------------------#2024-10-03">https://towardsdatascience.com/time-complexity-analysis-of-perfect-binary-tree-traversal-c2e4cccf6c97?source=collection_archive---------9-----------------------#2024-10-03</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="2e7c" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Deriving the tightest asymptotic bound of a particular tree traversal algorithm</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://cardstdani.medium.com/?source=post_page---byline--c2e4cccf6c97--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Daniel García Solla" class="l ep by dd de cx" src="../Images/b6e7bc9fdfdfcda7875215b1e0264d9e.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/da:true/resize:fill:88:88/0*ySYZ9y6FyJnXPoaQ"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--c2e4cccf6c97--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://cardstdani.medium.com/?source=post_page---byline--c2e4cccf6c97--------------------------------" rel="noopener follow">Daniel García Solla</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--c2e4cccf6c97--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">29 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Oct 3, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">2</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/fcd17c04446c6273e6410ec13e4ce97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5WdWRpxP6r41WmMV0IsL1g@2x.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><h1 id="2f93" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Introduction</h1><p id="76bf" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Data structures and algorithms are key elements in any software development, especially due to their impact on the final product quality. On the one hand, characterizing a process by means of a widely known and studied algorithm leads to a potential increase in the maintainability of codebases, since there is a large volume of open source resources and documentation available on the web. But, the main feature that is the reason why much effort is spent when deciding which data structure to use for the representation of information or the ideal algorithm for the performance of a given task is efficiency, both in terms of memory and time. In short, the choice of a good procedure or structure usually produces an advantage over other products on the market, whose response time, computational resources needed to fulfill its purpose or scalability are inadequate for its requirements.</p><p id="d550" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Therefore, in order to make proper decisions in this regard, it is necessary to <a class="af oz" rel="noopener" target="_blank" href="/big-o-d13a8b1068c8"><strong class="oa fr"><em class="pa">measure</em></strong></a> the cost of the algorithms accurately to subsequently perform studies in which a sufficiently valid comparison can be established to discard implementations or data structures that do not fit the product requirements, which often involve time and space constraints. As such, these two quantities are quantified by their asymptotic growth as the size of the input data provided grows to infinity. That is, the measure of how efficient an algorithm is depends on the growth of the time or space resources required for its execution given a certain increase in the input size, whereby the more they increase with the same variation of the input size, the worse its performance is considered, since they will need more resources than necessary. On the other hand, the selection of a suitable data structure on which efficient algorithms can be applied depends mainly on the complexity of the information to be modeled, although the final objective is that the algorithms determined by their <a class="af oz" href="https://dev.to/m__mdy__m/data-structures-a-comprehensive-introduction-2o13#:~:text=Common%20operations%20include%20insertion%20(adding,structure%20for%20a%20given%20task." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">operations</em></strong></a> <em class="pa">(add(), remove(), search(element)…)</em> have the minimum asymptotic growth achievable.</p><h2 id="5f98" class="pb nd fq bf ne pc pd pe nh pf pg ph nk oh pi pj pk ol pl pm pn op po pp pq pr bk">Objective</h2><p id="abb9" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">In this work, with the aim of showing the method to describe the time complexity of an algorithm and to allow its comparison with other alternatives, we will first start with a data structure, namely a perfectly balanced binary tree, and an algorithm executed on it. Subsequently, the format of its input will be formalized, visualizations will be built to understand its composition, as well as the procedure trace, and finally the ultimate bound will be reached through a formal development, which will be simplified and detailed as much as possible.</p><h1 id="a3c6" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Algorithm Definition</h1><p id="3c7b" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">The algorithm we are about to work with involves a binary tree with the restriction of being perfectly balanced. By definition, a binary tree is a pair formed by a set of nodes and another set of edges that represent connections between nodes, so that each of the nodes of the set has a connection with exactly two nodes known as child nodes. And, of all the existing <a class="af oz" rel="noopener" target="_blank" href="/5-types-of-binary-tree-with-cool-illustrations-9b335c430254"><strong class="oa fr"><em class="pa">trees</em></strong></a> that can be formed from this definition, here we are only interested in those designated as <a class="af oz" href="https://www.geeksforgeeks.org/perfect-binary-tree/" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">perfect</em></strong></a>.</p><p id="1d6d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">A <a class="af oz" href="https://cs.stackexchange.com/q/153285" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">perfect</em></strong></a> binary tree is distinguished by the equality in the depth of its leaf nodes, i.e. those of its last level, and by the constant number of children equal to two in the remaining nodes. The depth of a node within the tree, in turn, is the length of the path between its root and the node in question. Hence, the appearance of the data structure will be akin to:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ps"><img src="../Images/cc13a8472549053c3e0866b672947a52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQfOQy_Y1H-POgIs1EhOYQ@2x.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="7d39" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In this particular case, we are dealing with a perfect binary tree of depth two, since the nodes of the last level fulfill the condition of having the same depth, equivalent to that value. Additionally, in the picture the nodes have been numbered in a certain way that will be useful in this context. Specifically, the integer corresponding to each node stems from the execution of a <a class="af oz" href="https://www.youtube.com/watch?v=oDqjPvD54Ss" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">breadth-first traversal</em></strong></a> starting from the root, which is equivalent to a <a class="af oz" href="https://www.baeldung.com/cs/level-order-traversal-binary-tree" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">level-order traversal</em></strong></a> given the tree hierarchy. Therein, if the visited nodes are numbered starting from 0, a labeling like the one shown above will be settled, in which each level contains all the nodes assigned to integers between <strong class="oa fr">2^l-1</strong> and <strong class="oa fr">2^(l+1)-2</strong>, where <strong class="oa fr">l</strong> is the level. To see the source of this expression, it suffices to find a function that, with a level <strong class="oa fr">l</strong> as input, returns the minimum integer in the interval of that level, as well as another function that calculates the opposite, i.e. the maximum.</p><p id="3168" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">First, let <strong class="oa fr">m(l)</strong> be the function that returns the minimum. Thus, by observing the sequence it should follow as the input increases, we notice the pattern <strong class="oa fr">{0,1,3,7,15,31,63…}</strong>. And, when searching for its initial values in OEIS, it yields a match with the sequence <a class="af oz" href="https://oeis.org/A000225" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">A000225</em></strong></a>. According to the definition of this sequence, its values are given by the expression <strong class="oa fr">2^l — 1</strong>, but, to see why this is the one that models the progression of <strong class="oa fr">m(l)</strong>, it is necessary to establish a relation between two contiguous evaluations <strong class="oa fr">m(l)</strong> and <strong class="oa fr">m(l+1)</strong>, which will lead to such formulation. Then, if we consider the minimum value for one level <strong class="oa fr">l</strong> and that of the next, we can start from the assumption that the difference between the two is always equal to the number of nodes existing in the level with the least number of nodes. For instance, in level 1 there are only two nodes, whose labels are <strong class="oa fr">{1,2}</strong>. The minimum value in this level is 1, and the next one is 3, so it is easy to verify that <strong class="oa fr">3=1+2</strong>, that is, the minimum value of level <strong class="oa fr">{1,2}</strong> plus the number of nodes in it. With this, and knowing that the number of nodes in a level, being a binary tree, is exactly <a class="af oz" href="https://courses.cs.vt.edu/~cs3114/Fall09/wmcquain/Notes/T03a.BinaryTreeTheorems.pdf" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">2^l</strong></a> nodes, we arrive at the following formulation of <strong class="oa fr">m(l)</strong>:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pt"><img src="../Images/25084d906558e9dc5fb5820be6193455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hmdV6odRTmW4TAX3sBTukw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="7ab7" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In summary, <strong class="oa fr">m(l)</strong> is expressed as the minimum integer in the previous level <strong class="oa fr">m(l-1)</strong> plus the nodes contained in it <strong class="oa fr">2^(l-1)</strong>, in addition to the base case <strong class="oa fr">m(0)=0</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pu"><img src="../Images/2c0b2549198f22ae42f32429fc8c8fec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x7sFU9QD6M-Blo3_7q-P5g.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="7a95" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">So, when expanding <strong class="oa fr">m(l)</strong> by evaluating its recursive term, a pattern appears with which this function can be characterized. Briefly, every power of 2 from 0 arising from <strong class="oa fr">m(l-l)</strong> up to <strong class="oa fr">l-1</strong> is aggregated. Finally, after solving the summation, we arrive at the same expression present in the definition of <a class="af oz" href="https://oeis.org/A000225" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">A000225</em></strong></a>. Consequently, we now proceed to obtain the maximum integer at level <strong class="oa fr">l</strong>, which is denoted by a new function <strong class="oa fr">M(l)</strong>. In this case, the sequence formed by its evaluations is of the form <strong class="oa fr">{0,2,6,14,30,62…}</strong>, also recorded in OEIS as <a class="af oz" href="https://oeis.org/A000918" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">A000918</em></strong></a>. For its derivation, we can leverage the outcome of <strong class="oa fr">m(l)</strong>, so that by knowing the number of nodes present at each level, <strong class="oa fr">M(l)</strong> can be defined as the minimum integer at each level <strong class="oa fr">m(l)</strong> plus the number of nodes in it.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pv"><img src="../Images/f18c4b0b7f8c055cfbc71828aa76d00e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l6YMpFB7dVq17G7Bt84IQA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="d602" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In order to arrive at the ultimate expression <strong class="oa fr">2^(l+1)-2</strong>, we add <strong class="oa fr">m(l)</strong> and the number of nodes at that level except for one, the minimum. And, as this value coincides with <strong class="oa fr">m(l)</strong>, we can conclude <strong class="oa fr">M(l)=2m(l)</strong>.</p><p id="22f3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">After defining the data structure the algorithm will work with and discovering some potentially useful properties for a complexity analysis, the algorithm in question, expressed in pseudocode, is introduced:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pw"><img src="../Images/afd683c191414b6cca210ecf354b7c89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AswJka-HknSNEkBa0v_LZA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="9a01" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">At first, although we will later expand on this in detail, the input consists of a vector <em class="pa">(array)</em> denoted as <strong class="oa fr">L</strong> where the binary tree is represented. With it, every entry of the array corresponding to nodes in the tree is linearly traversed by means of a for loop. And, within each iteration of this loop, a temporary variable <strong class="oa fr">pos </strong>is initialized to store array elements, so it will have the same type <em class="pa">(integer)</em>. In addition, in the iteration, all the nodes that form the path from the root of the tree to the node represented by the array entry on which the for is running are traversed via the while loop nested within it. For this purpose, the exit condition <strong class="oa fr">pos&gt;0</strong> is set, which corresponds to the situation where pos has reached the root. As long as this condition is not met, <strong class="oa fr">pos</strong> will update its value to that of its parent node, so assuming that the input structure is correct, there is a guarantee that for every node in the tree the while loop will always reach the root, and therefore terminate.</p><h2 id="6cce" class="pb nd fq bf ne pc pd pe nh pf pg ph nk oh pi pj pk ol pl pm pn op po pp pq pr bk">Input Characterization</h2><p id="f3aa" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">To grasp this process, it is essential to be familiar with the input format. In particular, the way in which the binary tree can be represented in the form of an <a class="af oz" href="https://youtu.be/zuWvrqcZwuU?si=_JNNft-71S-TRZeR" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">array</em></strong></a>, being the structure used by the algorithm. To this end, and to simplify this representation, a transformation is performed in the labeling of the tree nodes, so that the breadth traversal they were labeled with at the beginning is executed from the root node starting at the integer 1. Or, seen in another way, 1 is added to the original label of all nodes.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk px"><img src="../Images/9ad99efb02da3bdcd5db7e344e60eac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZWb9qM_3lsLrbV3IxoqoVg@2x.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="b346" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The result of the aforementioned transformation is shown above. As evidenced, the minimum and maximum values of the labels at each level have also been modified. Although, due to the properties of the transformation, it is sufficient to apply its inverse to the functions <strong class="oa fr">m(l)</strong> and <strong class="oa fr">M(l)</strong> to re-characterize the label sequences correctly.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk py"><img src="../Images/35881a10ceb78e35ae97cfec5bfe24ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5AIqwf_BU6Jr9XQr5gGjPw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="de7e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Consequently, if the transformation on the nodes consists of adding 1 to its label, its inverse subtracts such quantity. This way, after applying the inverse transformation to both functions, we arrive at the upper expressions, modeling the sequence of minimum and maximum value labels for each tree level. On the other hand, by means of the new labeling, the data structure can be represented as an array, like the one our algorithm takes as input. Similarly, since it is a perfect tree, we know that it will have a regular structure in terms of number of nodes, as well as their location in the hierarchy. Because of this, considering the input array <strong class="oa fr">L[n+1]</strong>, we can relate its indexes to the values stored in those positions.</p><p id="dc20" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">For example, as depicted in the above image next to the “linked” representation of the tree, we can map the labels of each node to the array indexes, so that <strong class="oa fr">L[1]</strong> stands for the instance of the root node, <strong class="oa fr">L[2]</strong> and <strong class="oa fr">L[3]</strong> for their respective child nodes, and so on up to the terminal nodes. However, it is also necessary to denote their edges explicitly, so it is decided to store in the array values the label corresponding to the parent node of a given one by a certain index. In short, for each node <strong class="oa fr">i</strong> <em class="pa">(index)</em> of the array, the value stored in <strong class="oa fr">L[i]</strong> corresponds to the label of <strong class="oa fr">i</strong>’s parent node. Yet, as a matter of correctness, the first index of the list <strong class="oa fr">L[0]</strong> is not considered to correspond to any node. Moreover, its value is set to -1 to denote that it has no node above it in the hierarchy.</p><p id="0d43" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In view of this idea, it is worthwhile to study the properties of the sequence <strong class="oa fr">{-1,0,1,1,1,2,2…}</strong> <strong class="oa fr"><em class="pa">(</em></strong><a class="af oz" href="https://oeis.org/A123108" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">A123108</em></strong></a><strong class="oa fr"><em class="pa">)</em></strong>, or even to find a function to span its values, which will be valuable in the analysis. Hence, it is first important to consider how the child nodes and the parent <strong class="oa fr">L[i]</strong> of a given node <strong class="oa fr">i</strong> are determined.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pz"><img src="../Images/46554b6a43a053ba6e9b26131db34491.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdBQA36QYWJOHMHaeBSJvA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="25aa" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Regarding the child nodes of a given node <strong class="oa fr">i</strong>, if we account that any subtree of the original structure is also a perfect tree, it can be inferred that <strong class="oa fr">m(l)</strong> will serve its purpose within the scope of the subtree, resulting in the difference between the labels of any node and its left child being <strong class="oa fr">i</strong> <em class="pa">(below instead of i is denoted as 2^l, both equivalent)</em>, which coincides with the amount of nodes at the lower level.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qa"><img src="../Images/36da8e732d33e53b7b35abc2c6596fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGtaMnqr1s9JxhI4Loj0gw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="8ca3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Furthermore, to view that it is fulfilled in all subtrees, offsets <strong class="oa fr">α</strong> and <strong class="oa fr">β</strong> are attached to the left child and parent node labels repectively, resulting in the equivalence <strong class="oa fr">2α=β</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qb"><img src="../Images/876a29c3daa79e6df8250474cb846842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajF00uiffGzG0Yx-BmdKAg.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="9c05" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Assuming that the offsets do not exceed the node limit at their level, the amount of nodes present at the level of the child node located between its minimum <strong class="oa fr">m(l+1)</strong> and itself is twice that of the same magnitude considered at the upper level with its parent node. Hence, by doubling the number of nodes at each level by definition of a perfect binary tree, it is concluded that the label of the left child node of one <strong class="oa fr">i </strong>is given by the expression <strong class="oa fr">2i</strong>, being that of its right child <strong class="oa fr">2i+1</strong> accordingly. Likewise, a node <strong class="oa fr">i</strong> will always have a parent node, except in the case where it is the root, whose parent will be <strong class="oa fr">L[0]</strong>, which is not treated as a tree node.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qc"><img src="../Images/37ab4baf65c40a3d5289a41fadee1277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wrFW6lnG5SCf4_HEassdw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="98f5" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">To determine the function that outputs the label of the parent node, we first define the functions <strong class="oa fr">Cleft(i)</strong> and <strong class="oa fr">Cright(i)</strong> that get the respective child nodes. In this manner, if these functions transform the label in such a way that the result is equivalent to a descent in the hierarchy, their inverses will lead to the opposite effect, which is expected in case we want to retrieve the parent. After defining <strong class="oa fr">P(i)</strong> as the function that returns the parent node of <strong class="oa fr">i</strong>, equivalently denoted as the value in the vector <strong class="oa fr">L[i]</strong>, it is necessary to make a distinction in the expression applied for its computation according to the properties of the input. That is, if the node is labeled even, that means it is the left child of some node, so the inverse of <strong class="oa fr">Cleft(i)</strong> will be invoked. On the other hand, in case it is odd, the function <strong class="oa fr">P(i)</strong> has as expression the inverse transformation to <strong class="oa fr">Cright(i)</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qd"><img src="../Images/ace2a7d60c9c75a0a21c4fb9148d683d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zlgUIUJvqQQNhWLXY-3qZw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="29d7" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Graphically, both formulations for even and odd labeled nodes exhibit asymptotically similar growth as <strong class="oa fr">i</strong> increases. Even, due to the properties of the floor function it is possible to constrain the values of <strong class="oa fr">P(i)</strong> with odd <strong class="oa fr">i</strong> via <strong class="oa fr">i/2</strong>-dependent bounds and a constant. As a result, this leads to the following property:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qe"><img src="../Images/7f7efa75e194640014edf1d4ed677639.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*D1D9N9UmD3JRJmGBS1Y9XQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="9e59" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">By observing the above graph it is not possible to guarantee that the asymptotic growth of both subexpressions of <strong class="oa fr">P(i)</strong> is exactly equal. But, after deriving the bounds for the odd case and determining that the dependence has order <strong class="oa fr">O(i)</strong>, we can compute the limit when the node label tends to infinity of the ratio between the two functions, being their growths equivalent as expected.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qf"><img src="../Images/8216159f5513bc4c8236273b0221ba0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*p0Z3SQAN2p5slbDPn_sJRg.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="882b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Consequently, for simplicity it would be convenient to provide a single formulation for <strong class="oa fr">P(i)</strong> regardless of the input received, so the simplest option is to consider the growth order of the even case <strong class="oa fr">i/2</strong>, since the remaining case has the same asymptotic growth.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qg"><img src="../Images/74836524eed23cd5ef1fad632dc9e016.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cds-gHsi_KgF_VoZmxr0OA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="c011" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Nevertheless, the <strong class="oa fr">i/2</strong> operation does not return integers for nodes with odd label, so to address this concern it is decided to apply the floor function again to<strong class="oa fr"> i/2</strong>. Visually, the value of <strong class="oa fr">Floor[i/2]</strong> can be bounded in a similar way by the original function and its same value minus 1 due to the properties of the <a class="af oz" href="https://proofwiki.org/wiki/Floor_is_between_Number_and_One_Less" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">floor</em></strong></a> function. But, as the objective is to reach a correct expression for <strong class="oa fr">P(i)</strong>, not an approximate one that serves for an asymptotic analysis, still, it is deemed necessary to define it from the floor of <strong class="oa fr">i/2</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qh"><img src="../Images/2bf6995e7ca79c6fe3a4816217032f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*bxqeNdsRazNM-RSSswquxQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="a33b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The main reason for selecting such definition arises from the formal definition of the input array:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qi"><img src="../Images/3f60f6c84ffd954310cb1c7329f7319c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XD0sLOQAGRnTahfXAkGRlw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="a888" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Since <strong class="oa fr">L</strong> contains the labels of the parent nodes determined by each array index, it is possible to characterize them from the function <strong class="oa fr">P(i)</strong>, where <strong class="oa fr">i</strong> in this case is a valid index. In other words, the first value <strong class="oa fr">L[0]</strong> must equal -1, which is denoted in a special way without the use of <strong class="oa fr">P(i)</strong> as it cannot generate that value. Then, the base array<strong class="oa fr"> {-1}</strong> is <a class="af oz" href="https://math.stackexchange.com/a/3459732" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">concatenated</em></strong></a><strong class="oa fr"><em class="pa"> </em></strong>with the sequence <strong class="oa fr">{P(1),P(2),P(3)…}</strong> whose length is the total number of nodes and whose values correspond to the parent nodes of the label sequence <strong class="oa fr">{1,2,3…}</strong>.</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="4cd6" class="qn nd fq qk b bg qo qp l qq qr">GenerateTree[n_] := Flatten[{-1, Table[i/2, {i, 1, n}]}]<br/>GenerateTree[15]</span></pre><p id="243d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Once the sequence contained in the input array has been modeled, above is the <a class="af oz" href="https://www.wolfram.com/" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">Wolfram</em></strong></a> code needed to generate a tree with 15 nodes, resulting in <strong class="oa fr">L={-1, 1/2, 1, 3/2, 2, 5/2, 3, 7/2, 4, 9/2, 5, 11/2, 6, 13/2, 7, 15/2}</strong>. As expected, by not using the Floor function in <strong class="oa fr">P(i)</strong>, nodes with odd index return rational numbers, so after redefining the <strong class="oa fr">GenerateTree[]</strong> function with the appropriate <strong class="oa fr">P(i)</strong>, the correct sequence <strong class="oa fr">L={-1, 0, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7}</strong> is achieved:</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="08ad" class="qn nd fq qk b bg qo qp l qq qr">GenerateTree[n_] := Flatten[{-1, Table[i/2 // Floor, {i, 1, n}]}]<br/>GenerateTree[15]</span></pre><h2 id="46f7" class="pb nd fq bf ne pc pd pe nh pf pg ph nk oh pi pj pk ol pl pm pn op po pp pq pr bk">Input Visualization</h2><p id="4563" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Besides building the array, it is appropriate to visualize it to ensure that the indexes and values contained in it match its definition. For this purpose, <a class="af oz" href="https://reference.wolfram.com/language/guide/DataVisualization.html" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">Wolfram’s</em></strong></a> graphical features are used to automate the tree visualization process from the sequence created by <strong class="oa fr">GenerateTree[]</strong>:</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="3a82" class="qn nd fq qk b bg qo qp l qq qr">PlotBinaryTreeFromList[treeList_List] := <br/> Module[{n = Length[treeList], edges},<br/>  edges = Flatten[Table[{i -&gt; 2 i, i -&gt; 2 i + 1}, {i, 1, Floor[n/2]}]];<br/>  edges = Select[edges, #[[2]] &lt;= n &amp;];<br/>  TreePlot[edges, VertexLabeling -&gt; True, <br/>   VertexRenderingFunction -&gt; ({Inset[treeList[[#2]], #1]} &amp;), <br/>   DirectedEdges -&gt; False, ImageSize -&gt; Full]]<br/>n = 31;<br/>treeList = GenerateTree[n]<br/>PlotBinaryTreeFromList[Drop[treeList, 1]]</span></pre><p id="0905" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">When building a tree with exactly 31 nodes,<strong class="oa fr"> L={-1, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3 … 14, 14, 15, 15}</strong>, which graphically resembles the following:</p></div></div><div class="mr"><div class="ab cb"><div class="lm qs ln qt lo qu cf qv cg qw ci bh"><figure class="mm mn mo mp mq mr qy qz paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qx"><img src="../Images/3e111466c29f7cb4151cd53115534a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*8U7zFKuPGxmAkK3mNdARKQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="f419" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Concretely, the blue text denotes the index of the parent node, while the other text in black illustrates the label of the node in question.</p><h2 id="9755" class="pb nd fq bf ne pc pd pe nh pf pg ph nk oh pi pj pk ol pl pm pn op po pp pq pr bk">Implementation</h2><p id="bb5c" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Now with a well-defined input, it is possible to comprehend at a more abstract level what the operations of the tree traversal actually do. On one side, the outer <a class="af oz" href="https://reference.wolfram.com/language/ref/For.html" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">For[]</em></strong></a> loop traverses through all the nodes in level order from the lowest level to the one where the root is located. And, for each node the <a class="af oz" href="https://reference.wolfram.com/language/ref/While.html" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">While[]</em></strong></a> loop traverses the path from the root to the visited node in reverse order, although the important aspect for the time complexity bound is its length.</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="0993" class="qn nd fq qk b bg qo qp l qq qr">TreeIteration[v_List] := Module[{n, pos}, n = Length[v];<br/>  For[i = n, i &gt;= 0, i--,<br/>   pos = v[[i]];<br/>   Print["FOR: ", i];<br/>   While[pos &gt; 0,<br/>    Print["While: ", pos];<br/>    pos = v[[pos + 1]];<br/>    ]]]</span></pre><p id="fc32" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">So, after implementing it in Wolfram, some <a class="af oz" href="https://reference.wolfram.com/language/ref/Print.html" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">Print[]</em></strong></a> are included to display the index of the parent node of the nodes it traverses during its execution, enabling an easier reconstruction of its trace.</p><h2 id="30db" class="pb nd fq bf ne pc pd pe nh pf pg ph nk oh pi pj pk ol pl pm pn op po pp pq pr bk">Output</h2><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="9a13" class="qn nd fq qk b bg qo qp l qq qr">n = 7;<br/>treeList = GenerateTree[n]<br/>TreeIteration[treeList]<br/>PlotBinaryTreeFromList[Drop[treeList, 1]]</span></pre><p id="2602" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Running the algorithm with a 7-node tree, represented as <strong class="oa fr">L={-1, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3}</strong>, yields the following outcome:</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="dd99" class="qn nd fq qk b bg qo qp l qq qr">FOR: 8<br/>While: 3<br/>While: 1<br/>FOR: 7<br/>While: 3<br/>While: 1<br/>FOR: 6<br/>While: 2<br/>While: 1<br/>FOR: 5<br/>While: 2<br/>While: 1<br/>FOR: 4<br/>While: 1<br/>FOR: 3<br/>While: 1<br/>FOR: 2<br/>FOR: 1<br/>FOR: 0</span></pre><p id="084a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">At first glance, the trace is not too revealing, so it should be combined with the tree depiction:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qx"><img src="../Images/f2f3bb5b7ca324310b2f1143268ccf54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqnlPGzTacnLY_Wo3b3gsw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author</figcaption></figure><p id="1159" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In the first iteration of the for loop, the traversal starts at the last node of the lowest level, whose parent has index 3. Subsequently, this node is also visited by the while loop, until in the next iteration it reaches the root and ends. In the succeeding for iteration, the same process is performed with the difference that it begins with the node with index 6, whose parent node is the same as before. Thus, it can be noted that the for is actually traversing all the existing paths in the tree that connect each of the nodes to the root.</p><h1 id="0e98" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Analysis</h1><p id="bf17" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">With the algorithm in place, and after having fully characterized its input and understood its operation, it is suitable to proceed with its analysis, both in terms of memory and time. On the one hand, the analysis of the memory occupied is straightforward in this case, since the algorithm does not need additional memory to perform its task, beyond the integer value pos in which the node traversed in each iteration is stored. Accordingly, the asymptotic bound representing the additional <a class="af oz" href="https://www.theodinproject.com/lessons/javascript-space-complexity" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">memory consumption</em></strong></a> is constant <strong class="oa fr">O(1)</strong>. And, if we consider the space occupied by the input, an amount of memory of order <strong class="oa fr">O(n)</strong> would be required, where <strong class="oa fr">n</strong> is the number of nodes in the tree, or more precisely <strong class="oa fr">O(2^d)</strong>, where <strong class="oa fr">d</strong> is the tree <a class="af oz" href="https://cs.stackexchange.com/q/6161" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">depth</em></strong></a>.</p><p id="5d1e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">On the other hand, to determine the time complexity bound, we must define an <a class="af oz" href="https://www.cs.utexas.edu/~mitra/csSpring2017/cs313/lectures/algo.html" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">elementary operation</em></strong></a> to be accounted for. For this algorithm, it is established as the asingnation executed inside the while loop, which at an abstract level can be considered as the traversal of an edge between a node and its parent. Therefore, to ascertain how many times this operation is invoked, the cost of the algorithm is first decomposed into two functions. There is, on one side, the cost <strong class="oa fr">Tf(n)</strong> of the for loop, which represents the total of one algorithm’s execution. This, in turn, is defined as the sum of the costs incurred by the while loop, designated as <strong class="oa fr">Tw(i)</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk ra"><img src="../Images/19078da9140ae40df70f20436e6de1b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*_DJg9MS3BFf31EC8WkO-Mw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="385c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">For all nodes <strong class="oa fr">i</strong> contained in the array, we need to determine how many elementary operations are involved in the traversal of the path from the root to <strong class="oa fr">i</strong>, so we append the corresponding <strong class="oa fr">Tw(i)</strong> evaluation. Specifically, that function will return the exact number of assignments caused by a certain input node. Thus, since we know that the first <strong class="oa fr">L[0]</strong> cannot walk any path to the root, it is not counted, keeping the sum limits between 1 and the number of nodes <strong class="oa fr">n</strong> in the tree.</p><p id="664f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Before continuing, we proceed to demonstrate that the application of the function <strong class="oa fr">P(i)</strong> to a node <strong class="oa fr">i</strong> located at level <strong class="oa fr">l</strong> of the tree results in the label of a node located at the immediately upper level, since the elementary operation considered in this analysis is equivalent to <strong class="oa fr">pos=P(pos)</strong>, mainly due to the input features:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rb"><img src="../Images/ca9f58c1cf3c1fca77412363cfff91d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yGmS0hTTLG6l-PKXk3FUyw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="3d2e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">As shown, we begin with the inequality that any node must fulfill with respect to the level at which it is found, being its label bounded by the functions <strong class="oa fr">m(l)</strong> and <strong class="oa fr">M(l)</strong>, and assuming that <strong class="oa fr">l</strong> is its level. Afterwards, when applying <strong class="oa fr">P</strong>, several simplifications can be effected, leading to the conclusion that <strong class="oa fr">P(i)</strong> lies between <strong class="oa fr">2^(l-1)</strong> and <strong class="oa fr">2^l-1</strong>, both coinciding with the evaluations <strong class="oa fr">m(l-1)</strong> and <strong class="oa fr">M(l-1)</strong>, suggesting that after the transformation the resulting node is located at level <strong class="oa fr">l-1</strong>. With this, we are demonstrating that after several iterations of the while loop, the node stored in pos will have a level closer to the tree root. Consequently, if enough of them are completed, the path is guaranteed to reach the root and terminate. Although, in case of considering an infinite tree this might not hold.</p><h2 id="a3ff" class="pb nd fq bf ne pc pd pe nh pf pg ph nk oh pi pj pk ol pl pm pn op po pp pq pr bk">Approach 1</h2><p id="f7ca" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">At the moment, we know that the complexity is driven by <strong class="oa fr">Tf(n)</strong>, despite the lack of an exact expression for <strong class="oa fr">Tw(i)</strong>, so we proceed to discuss three different ways to characterize this function, and thereby the overall asymptotic growth of the execution time.</p><p id="8d33" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Regardless of how the remaining function is found, a constraint on the tree nodes will be met in all analyses. Namely, since they all have a single parent, except the root, we can ensure that the path length between an arbitrary node located at a level <strong class="oa fr">l</strong> and the root is equal to <strong class="oa fr">l</strong>. Primarily this is due to the property demonstrated above, although it can also be evidenced by the realization that each node present on such a path is at a different level, which can vary from 0 to <strong class="oa fr">l</strong>. Then, as the while loop traverses every node in the path, it is concluded that the operations counted in <strong class="oa fr">Tw(i)</strong> are exactly <strong class="oa fr">l</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rc"><img src="../Images/8b9cf656b598bc8afd4915196459a405.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*Pte43lWnyWZWKSfASbeQ6w.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="f0c0" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now, the analysis is focused on computing the level of a given node, so we start from the upper inequality. That is, the label of a node <strong class="oa fr">i </strong>is at a level <strong class="oa fr">l</strong> bounded by <strong class="oa fr">m(l)</strong> and <strong class="oa fr">M(l)</strong>, yielding two conditions with which the level can be accurately quantified:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rd"><img src="../Images/b57480f336aa49bdf130d145597ab539.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jemNUOOcF6Tj7Q1lglvRPw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="f795" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">On the one hand, solving from the left side of the inequality leads to a condition reducible to a floor operation on <strong class="oa fr">log_2(i)</strong>, by its own definition. From this, it can be inferred that the level is equal to that quantity, although the other condition of the original inequality still needs to be verified.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk re"><img src="../Images/748b5612af530c4f808dac61fcdf6905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*-EyKSwRi4bKD7d6vCD4eeA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="f0f9" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Starting from the right-hand side, we arrive at a lower bound for <strong class="oa fr">l</strong>, which a priori appears to be complementary to the preceding. However, after operating and applying the definition of the ceiling function, we arrive at the following formulation for the level, since its value is the minimum integer that satisfies the last inequality shown above.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rf"><img src="../Images/025f2be6ece4a8dadebc9b58862813a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vSTbOZqm-RxzjS5uV7ku3g.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="e020" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Recapitulating, so far we have derived several expressions for the level of a node <strong class="oa fr">i</strong>, which at first could be thought of as bounds of that value due to their nature. Nonetheless, the level must be an integer, so it is conceivable to check the distance between them, just in case it were small enough to uniquely identify a single value.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rg"><img src="../Images/9a230abd713b2181cd165e191d4463ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hbLRYeBhgCU2VWgpdvpXUQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="aa8a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In summary, it is <a class="af oz" href="https://math.stackexchange.com/a/4977835/988049" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">proven</em></strong></a><strong class="oa fr"><em class="pa"> </em></strong>that both expressions are identical for all the values that the node labels may have. Therefore, the level of a node can be inferred by either of the above formulae, the left one being the simplest, and so the one that will be used in the analysis.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rh"><img src="../Images/eab719432eb37b6ad80a2c4c6d1b1dc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*FnJ16xy1YR2sylfw3P6sww.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="d053" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">As the level of <strong class="oa fr">i</strong> coincides with the elementary operations of the while loop, the cost <strong class="oa fr">Tw(i)</strong> is defined analogously to the node’s level from which the path to the top must commence.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ri"><img src="../Images/33b7c46d3f398d660fded47e55c960e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xK04RqaKeDb6LS5LZsPXsQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="f34b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Next, with an expression for the cost of each iteration of the for loop as a function of the initial node, we can try to find the sum of all the costs generated by the nodes of the tree. But, as there is a floor function in each summand, we will first study the impact of not applying this function on the ultimate bound, in order to simplify the summation, as well as the resulting bound in case the floor becomes dispensable.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rj"><img src="../Images/fa16e308f35a73c9c6ab9da1e23d1dec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0y914UJVbCTMF96YOaCPLA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author</figcaption></figure><p id="d58c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">If we plot <strong class="oa fr">Tf(n)</strong> for a decent range of <strong class="oa fr">n</strong>, a slight difference is discernible between the function with the floor of each summand removed and the original one. Particularly, the one that directly sums the logarithm values without any additional transformation appears to be a upper bound of the actual complexity, so if we proceed to solve the sum where each term is directly <strong class="oa fr">log_2(i)</strong>, we can arrive at a bound that asymptotically may be somewhat larger than the actual one, establishing itself as the upper one:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rk"><img src="../Images/394d275fcd0c052862dbbdb8a95bcf50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1NZo4ovvKTTqi3Jf7p5mQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="8961" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">By expressing the sum in a closed form, we could assume that the algorithm requires an execution time no greater than the order <a class="af oz" href="https://stackoverflow.com/q/8118221" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">O(log(n!))</strong></a> with respect to the number of nodes in the input tree. Still, this bound can be further simplified. For instance, if we consider that in each iteration of the for loop, which is executed as many times as n nodes, a work is performed proportional and not higher than the maximum level of the tree, we would get an upper bound of order <a class="af oz" href="https://cs.stackexchange.com/a/70211" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">O(n log(n))</strong></a>. As a consequence, if we <a class="af oz" href="https://en.wikipedia.org/wiki/Asymptotic_analysis#:~:text=)-,if%20and%20only%20if,-(de%C2%A0Bruijn" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">compare</em></strong></a> it with the previous order <a class="af oz" href="https://math.stackexchange.com/a/4416026" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">O(log(n!))</strong></a> through the limit of its ratio when the input tends to infinity, we conclude that both are equivalent, allowing the simplification of the upper bound of the algorithm’s runtime to <strong class="oa fr">O(n log(n))</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rl"><img src="../Images/fc7e1a707bd3e3767ec5b620451a725d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_4J6s-IR_6527AZ2MHx8A.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="e09e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">At this juncture, the upper bound ensures that the runtime overhead of the algorithm does not exceed the order <strong class="oa fr">O(n log(n))</strong> in terms of growth with respect to the input. However, the interest of the analysis resides in bounding the cost as much as possible, i.e., finding the <a class="af oz" href="https://cs.stackexchange.com/q/74013" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">tight</em></strong></a> bound, not an upper one, which in some cases may differ significantly. For this, it is necessary to find a closed form for the sum <strong class="oa fr">Tf(n)</strong> above, especially when the floor function is applied to the summands. Intuitively, the application of the floor will reduce the value of each term to some extent, and the ultimate value may vary due to the dependence between the upper limit and the size of the tree.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rm"><img src="../Images/8e6697aef1b2fb5fed3f1e221ce911bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vA4uc03f6Mh9pk8YogoeLQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="b86c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Firstly, for <strong class="oa fr">log_2(i)</strong> to be an integer and to avoid applying the floor transformation, the node label must be of the form <strong class="oa fr">2^l</strong>, where <strong class="oa fr">l</strong> must necessarily refer to the level at which it is encountered.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rn"><img src="../Images/682fc7ab1ad33f5c26d9d56ea614c519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MXSDJtX-bt7UV8JlPU9Kg@2x.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="93da" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Coincident with <strong class="oa fr">m(l)</strong>, above it is shown that all nodes <strong class="oa fr">i=m(l)</strong> whose label is the minimum of their level will result in <strong class="oa fr">log_2(i)</strong> being an integer, namely <strong class="oa fr">l</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ro"><img src="../Images/80a29ed7f387c3babfa3e950ba122fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DDuVRW_02ACxUzGW1XBiRg.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="6789" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Therefore, by feeding all labels between <strong class="oa fr">m(l)</strong> and <strong class="oa fr">M(l)</strong> as input to the <strong class="oa fr">floor(log_2(i))</strong> function, it should yield its level, which has been found to coincide with that of the “representative” <strong class="oa fr">m(l)</strong> node of that level. Briefly, this allows to assume that every node of a particular level will incur in the same cost <strong class="oa fr">Tw(i)</strong>, as the path’s length from any one of them to the root is exactly equal to l.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rp"><img src="../Images/90f5e366636951adb12795c02eefc167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w79XqYsXvqYmtO_388dggA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="2808" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Subsequently, the number of nodes at each level is deduced, which as one might guess without this step is <strong class="oa fr">2^l</strong>, that is, if at each level the number of nodes of the previous one is doubled, for a certain level this quantity will be given by the product of the <a class="af oz" href="https://www.sciencedirect.com/topics/computer-science/branching-factor#:~:text=Branching%20Factor%20is%20defined%20as,tree%20or%20graph%20data%20structure." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">branching factor</em></strong></a> by itself <strong class="oa fr">l</strong> times.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rq"><img src="../Images/fa7f01ede5c0b7a63beaf0e8bddae0a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*PTK1hJ5QOOaQ_7E9Ms9oRw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="5499" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In conclusion, the runtime cost of the algorithm at all nodes of the same level <strong class="oa fr">l</strong> is the product between the length of the path to the root, coincident with the level, and the number of nodes in it. And, from this result a closed form for <strong class="oa fr">Tf(n)</strong> dependent on the depth <strong class="oa fr">d</strong> of the tree can be drawn:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rr"><img src="../Images/e3e2a8d0b798abc85ea021cad2d7208e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1wYHL9KPxV9Z-8-if_UX5w.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="82fb" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">By rewriting the sum as a function of the levels from 0 to the <a class="af oz" href="https://cs.stackexchange.com/a/6162" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">depth</em></strong></a>, we arrive at the above expression, which can be concretized by defining the relationship between <strong class="oa fr">d</strong> and the total number of nodes <strong class="oa fr">n</strong>:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rs"><img src="../Images/93bf746a8bc021ce11b721fbb91ed6ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9op4x05jeQT2710_zjGVHw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="54f5" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Since n is the label of the last node, <strong class="oa fr">floor(log_2(n))</strong> guarantees to return the value of the last level, which in turn coincides with the depth <strong class="oa fr">d</strong>. Thus, by the above formulation of the complete cost <strong class="oa fr">Tf(n)</strong> we conclude with the following tight bound:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rt"><img src="../Images/bec73bb33d09427e1067b6053f565596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yzNx25mHovsuVqmBsm7Hng.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="7795" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">At this point, it is worth trying to simplify it, so that it is featured by a simpler expression. For this reason, we proceed to calculate its ratio with the previous upper bounds, which will mainly show the difference between both in case they are <a class="af oz" href="https://artofproblemsolving.com/wiki/index.php/Asymptotic_equivalence" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">asymptotically equivalent</em></strong></a>, or diverge in the opposite case <em class="pa">(although it could also converge to 0)</em>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ru"><img src="../Images/6f61ea3ae674b3eb38e06c38459e0479.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pj2WoHslO8KdeWFEdbCsKQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="9521" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Nevertheless, the limits of the ratio produce the same result for both upper bounds, being asymptotically equivalent. And, as they lie on a real interval, it can be inferred that the tight bound is equivalent to the upper one, at least asymptotically, since the ratio indicates a negligible difference at infinity.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rv"><img src="../Images/ed3ba3f5fb35ed62ad591db497430a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*ZJXGuX6Dg12MA0u5F74kRA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="6e8e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Finally, the time complexity of the algorithm is determined by the top order, which can be achieved in several ways as we will see below. Before continuing, though, it is worth noting the relationship between the two expressions found for the tight bound. While the latter depends directly on the number of nodes, the original one can be formed by rewriting the one shown above replacing <strong class="oa fr">n</strong> by the number of nodes at the last level, which contributes to a better understanding of the dependence between the runtime and the properties of the data structure involved.</p><h2 id="21da" class="pb nd fq bf ne pc pd pe nh pf pg ph nk oh pi pj pk ol pl pm pn op po pp pq pr bk">Approach 2</h2><p id="4e41" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Another way to proceed with the analysis is by defining each value contained in the input array:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rw"><img src="../Images/3ad17c7dc32722e37ce4e3dd3e0cd4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ml-qSgR4Vy9RmaajGSJVNw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="5262" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Each one is identified by a concrete evaluation <strong class="oa fr">P(i)</strong>, from which the following constraint can be inferred:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rx"><img src="../Images/df8740005edd52fcf50443d2ffa1f6af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEUlAw6sGmBOgZH9DlgyGA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="0d59" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">By representing <strong class="oa fr">P(i)</strong> an ascent in the tree, any input bounded by <strong class="oa fr">[0,n]</strong> that can be provided to the function will always return a result present in the same interval, which leads to the formalization of the traversal performed by the while loop and whereby we will achieve <strong class="oa fr">Tw(i)</strong>:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ry"><img src="../Images/56b21bf79dcfde3f8af3f0df09a946a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JnNqCXJ9zmoe6ze7_qPGDw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="909b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">At the beginning of the traversal, any node <strong class="oa fr">i</strong> is chosen, ascending to its parent <strong class="oa fr">P(i)</strong>, then to its ancestor <strong class="oa fr">P(P(i))</strong> and so on until reaching the root with label 1. Actually, the loop stops when reaching the “node” <strong class="oa fr">L[0]</strong>, however, here it is considered that it stops at the root, since the difference in cost will be constant. So, above we formalize this process by <a class="af oz" href="https://math.stackexchange.com/a/248229/988049" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">composing</em></strong></a> <strong class="oa fr">P(i)</strong> a variable number of times, which as we know coincides with the length of the path to the root, can be set equal to the node’s level l.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rz"><img src="../Images/f4e31948aa81627b9047a1273e588505.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJxQaBK4S5pXMZ3GDODthA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="ea7c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">With this approach, the cost <strong class="oa fr">Tw(i)</strong> is defined as the level of the input node, which can also be acquired by finding the integer that satisfies the upper equality.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk sa"><img src="../Images/280dab5964a86670cdea4782c2f2e214.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*pime-a8mjE-aMVZ2-0SWog.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="0a13" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">At this point, when obtaining the integer l that causes the repeated composition to result in 1, we first apply the <a class="af oz" href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions#cite_ref-18:~:text=be%20proved%20similarly.-,Nested%20divisions,-%5Bedit%5D" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">properties</em></strong></a> of the floor function to describe the composition in a closed form. Also, it is <a class="af oz" href="https://math.stackexchange.com/q/233670/988049" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">demonstrable </em></strong></a>that the composition of the function P results in the above <a class="af oz" href="https://math.stackexchange.com/q/4977869/988049" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">expression</em></strong></a>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sb"><img src="../Images/95216cfd8ccc4286713abfa93727c010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zdCWjeFSzGx1CLfNas65xA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="1916" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Thereafter, by definition of the floor function, an inequality is established between the closed form of the <a class="af oz" href="https://reference.wolfram.com/language/ref/Nest.html" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">composition</em></strong></a> and the outcome it should reach. That is, the equality dictates that after <strong class="oa fr">l</strong> compositions exactly the value of the root is reached, although, since the argument of the floor may be greater than 1, we proceed from the inferred inequality. Finally, we conclude with an expression for the level of a certain node <strong class="oa fr">i</strong>, which we will use to find <strong class="oa fr">Tf(n)</strong>, and hence the complexity.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sc"><img src="../Images/df8b9d9273ce80cc06d06d6bc5a96dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_7FCWpwumqxLxpJ-nYDYng.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="2d51" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">When replacing <strong class="oa fr">Tw(i)</strong> by the level of node <strong class="oa fr">i</strong>, the summation produced is equivalent to the one solved in the previous analysis, so the final expression is also equivalent.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk sd"><img src="../Images/c7b72b0a7ee17a4bec3f57054dff44bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*1NHyb6xH7RSmWcDIh4KFkw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="23af" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Ultimately, the tight bound derived from this procedure is of order <strong class="oa fr">nlog(n)</strong>, coinciding with the previously inferred one. In turn, it may also be rewritten as a function of tree’s depth, which in certain situations becomes helpful.</p><h2 id="4f84" class="pb nd fq bf ne pc pd pe nh pf pg ph nk oh pi pj pk ol pl pm pn op po pp pq pr bk">Approach 3</h2><p id="74b5" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Lastly, we will explore an alternate way to perform this analysis and acquire the prior asymptotic bound. In this case, we shall start from the label <strong class="oa fr">i</strong> of a parent node stored in the array. This label at low level is represented as a positive integer, specifically in <a class="af oz" href="https://www.sciencedirect.com/topics/computer-science/binary-number-system" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">base 2</em></strong></a>. Therefore, its binary form can be denoted as follows:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk se"><img src="../Images/a09213565412f3c00b02e8c083b61712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xacz51EfQ-FnKTSPyZCM_w.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="6a96" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">On one hand, it is defined as the sum of the products of the bits by their value in the corresponding base, which in a compact format is formalized as a group of bits whose subscript denotes such value.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sf"><img src="../Images/02443051deee30807a09c041babbbae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tgD2l-R82QbcIbghCqV-TQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="ad50" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Each of the bits is an integer 0 or 1, whose subscript belongs to the interval of the integers comprised between 0 and <strong class="oa fr">B(i)-1</strong>, where <strong class="oa fr">B(i)</strong> is the function that returns the length of the binary representation of the integer <strong class="oa fr">i</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk sg"><img src="../Images/85f2cf552697bf2065113e63190b52f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*aCP36Ysjjum5W8ySTY1V2g.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="fb30" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">As for its formulation, it remains <a class="af oz" href="https://math.stackexchange.com/a/1508909/988049" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">proven</em></strong></a><strong class="oa fr"><em class="pa"> </em></strong>that the number of bits needed to describe an integer in base 2 is given by the above equality. A priori, the logarithmic term is identical to the expression describing the level at which node <strong class="oa fr">i</strong> is located, so we can begin to elucidate the rest of the procedure.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sh"><img src="../Images/d09cafc7c97469a9b442f08b540847ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrTEhiOjJI5pN5cjZ9bNSw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="c8ff" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">To calculate <strong class="oa fr">Tw(i)</strong>, it is necessary to account for the effect of <strong class="oa fr">P(i)</strong> on the binary representation of the node label. Simply put, the label resulting from the repeated application of <strong class="oa fr">P(i)</strong> must be 1, or in this case for simplicity 0. Therefore, by dividing the label by 2 and applying the floor function, it can be guaranteed that in binary the equivalent of this function is a shift operation to the right. So, after <strong class="oa fr">B(i)</strong> shifts, the resulting label will be 0, concluding the path of the while loop and incurring a cost proportional to<strong class="oa fr"> floor(log_2(i))+1</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk si"><img src="../Images/6a8ad8e685b01d846ca836fab61f3757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WrMZMsy6tyAmFaT7bfOXVQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="b47e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Likewise, when substituting <strong class="oa fr">B(i)</strong> in the sum of the overall cost, in this analysis we end up with an additional term <strong class="oa fr">n</strong>, which, being smaller than the final value, is asymptotically negligible.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sj"><img src="../Images/d315226a23a8b559ff330b8fbe3fc100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jakw38I45su1nTw-Qg080Q.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="99a3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In conclusion, with this procedure the same tight bound is deduced, keeping the runtime cost of the algorithm classified by the order <strong class="oa fr">nlog(n)</strong>.</p><h2 id="16ec" class="pb nd fq bf ne pc pd pe nh pf pg ph nk oh pi pj pk ol pl pm pn op po pp pq pr bk">Time Measurements</h2><p id="fdfe" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Finally, after the theoretical analysis, experimental measurements will be collected of the time it takes to finish the algorithm for inputs of different sizes, in order to show how well or poorly the runtime growth matches the tight bound.</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="6eff" class="qn nd fq qk b bg qo qp l qq qr">data = Flatten[<br/>   ParallelTable[<br/>    Table[{n, <br/>      AbsoluteTiming[TreeIteration[GenerateTree[n]]][[1]]}, {index, 0,<br/>       n}], {n, 1, 300}], 1];</span></pre><p id="3c9c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">To this end, several Wolfram functions are used in the measurement process. The most significant of these is <a class="af oz" href="https://reference.wolfram.com/language/ref/AbsoluteTiming.html" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">AbsoluteTiming[]</em></strong></a>, which records the time in seconds it took to run the algorithm with a tree consisting of n nodes. Here, we do not select values of <strong class="oa fr">n</strong> that are powers of 2, we simply consider that the input is a complete tree instead of a perfect one in order to observe how the execution time grows in relation to the number of nodes. Then, measurements are taken for n from 1 to 300, performing <strong class="oa fr">n</strong> runs for each corresponding number of nodes.</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="9bb6" class="qn nd fq qk b bg qo qp l qq qr">nonlinearModel = NonlinearModelFit[points, a*x*Log[x], {a}, x]<br/>ListPlot[{points, Table[{x, nonlinearModel[x]}, {x, 0, 300}]}, <br/> PlotStyle -&gt; {Red, Green}, ImageSize -&gt; Large, <br/> AxesLabel -&gt; {"n", "Time (s)"}]</span></pre><p id="d768" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Afterwards, a fitting model of the form <strong class="oa fr"><em class="pa">c*nlog(n)</em></strong> is defined in which <strong class="oa fr"><em class="pa">c</em></strong> represents a constant used as a parameter, adjusting its value to the measurement dataset as dictated by the <a class="af oz" href="https://reference.wolfram.com/language/ref/NonlinearModelFit.html" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">NonLinearModelFit[]</em></strong></a> function.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sk"><img src="../Images/c036f7e4b106acc6a129bc72e6a56edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g6C5KIwzBgIjgVEWVwjMfA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="5673" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Once the model has been fitted, the top outcome is generated, the interpretation of which is significantly more meaningful when plotted against the data points:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk sl"><img src="../Images/c45129341efb7df0a50d5559ed570aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*94KaMIZCiniunHlXGnu9eA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="e806" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">As seen, the dataset shows some variability due to practical interferences in the measurement process. However, the growth as n is increased is clearly similar to an order <strong class="oa fr">nlog(n)</strong>, which is also remarkable in comparison with the location of the model, being situated in a zone somewhat lower than the average between the two regions that visibly show a higher density of measurements.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sm"><img src="../Images/4018972fde6479c87a4a0d722a4b4905.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QrAww2HdbuD36r2OFHbCLw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="cdee" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Finally, with the previous fitting results and an <a class="af oz" rel="noopener" target="_blank" href="/r-squared-vs-adjusted-r-squared-simplified-543993e69558"><strong class="oa fr"><em class="pa">adjusted R²</em></strong></a> of 0.934551, it can be concluded that the model correctly captures the growth trend of the dataset. Though, its variability translates into a slight uncertainty in the value of the c constant.</p><h1 id="b896" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Conclusion</h1><p id="d814" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">The formal analysis of the algorithm characterizes the asymptotic growth of its execution time by the order <strong class="oa fr">Θ(nlog(n))</strong>. Such bound has been calculated from three different approaches, although all of them are based on the same idea of determining the depth of each tree node. In the first one, the level was used as the depth measure, which is equivalent to the number of times <strong class="oa fr">P(i)</strong> must compose with itself to reach the label of the root node, and, in turn, to the number of bits needed to represent the label of the initial node <strong class="oa fr">i</strong> in binary.</p><p id="c8ba" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Also, as a final note, it is worth mentioning that most of the Wolfram code involved in this analysis was generated by the <a class="af oz" href="https://openai.com/index/hello-gpt-4o/" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">GPT-4o</em></strong></a> model from <a class="af oz" href="https://openai.com/chatgpt/" rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pa">ChatGPT</em></strong></a>.</p></div></div></div></div>    
</body>
</html>
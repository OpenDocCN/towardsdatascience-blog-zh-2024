["```py\npip install --upgrade openai \npip install python-dotenv\npip install unstructured\npip install python-docx\n```", "```py\nimport openai\n\n# Unstructured\nfrom unstructured.partition.docx import partition_docx\nfrom unstructured.cleaners.core import group_broken_paragraphs\n\n# Data and other libraries\nimport pandas as pd\nimport re\nfrom typing import List, Dict\nimport os\nfrom dotenv import load_dotenv\n```", "```py\nimport openai\n\n# Specify the path to the .env file\ndotenv_path = '/content/.env'\n\n_ = load_dotenv(dotenv_path) # read local .env file\nopenai.api_key  = os.environ['OPENAI_API_KEY']\n```", "```py\nelements = partition_docx(\n    filename=\"/content/libro.docx\", \n    paragraph_grouper=group_broken_paragraphs\n)\n```", "```py\nprint(elements[10])\n\n# Returns: Destino sorprendente, es el título que la autora le puso ...\n```", "```py\n[\n  {\"title\": title 1, \"content\": [paragraph 1, paragraph 2, ..., paragraph n]},\n  {\"title\": title 2, \"content\": [paragraph 1, paragraph 2, ..., paragraph n]},\n  ...\n  {\"title\": title n, \"content\": [paragraph 1, paragraph 2, ..., paragraph n]},\n]\n```", "```py\ndef group_by_chapter(elements: List) -> List[Dict]:\n    chapters = []\n    current_title = None\n\n    for element in elements:\n\n      text_style = element.metadata.emphasized_text_tags # checks if it is 'b' or 'i' and returns list\n      unique_text_style = list(set(text_style)) if text_style is not None else None\n\n      # we consider an element a title if it is a title category and the style is bold\n      is_title = (element.category == \"Title\") & (unique_text_style == ['b'])\n\n      # we consider an element a narrative content if it is a narrative text category or\n      # if it is a title category, but it is italic or italic and bold\n      is_narrative = (element.category == \"NarrativeText\") | (\n          ((element.category == \"Title\") & (unique_text_style is None)) |\n          ((element.category == \"Title\") & (unique_text_style == ['i'])) |\n          ((element.category == \"Title\") & (unique_text_style == ['b', 'i']))\n      )\n\n      # for new titles\n      if is_title:\n        print(f\"Adding title {element.text}\")\n\n        # Add previous chapter when a new one comes in, unless current title is None\n        if current_title is not None:\n          chapters.append(current_chapter)\n\n        current_title = element.text\n        current_chapter = {\"title\": current_title, \"content\": []}\n\n      elif is_narrative:\n        print(f\"Adding Narrative {element.text}\")\n        current_chapter[\"content\"].append(element.text)\n\n      else:\n        print(f'### No need to convert. Element type: {element.category}')\n\n    return chapters\n```", "```py\nbook_chapters[2] \n\n# Returns \n{'title': 'Proemio',\n 'content': [\n    'La autobiografía es considerada ...',\n    'Dentro de las artes literarias, ...',\n    'Se encuentra más próxima a los, ...',\n  ]\n}\n```", "```py\ndef translate_book(book_chapters: List[Dict]) -> Dict:\n  translated_book = []\n  for chapter in book_chapters:\n    print(f\"Translating following chapter: {chapter['title']}.\")\n    translated_title = translate_title(chapter['title'])\n    translated_chapter_content = translate_chapter(chapter['content'])\n    translated_book.append({\n        \"title\": translated_title,\n        \"content\": translated_chapter_content\n        })\n  return translated_book\n```", "```py\ndef translate_title(title: str) -> str:\n  response = client.chat.completions.create(\n    model=\"gpt-3.5-turbo\",\n    messages= [{\n        \"role\": \"system\",\n        \"content\": f\"Translate the following book title into English:\\n{title}\"\n        }]\n  )\n  return response.choices[0].message.content\n```", "```py\n# Function to translate a chapter using OpenAI API\ndef translate_chapter(chapter_paragraphs: List[str]) -> str:\n    translated_content = \"\"\n\n    for i, paragraph in enumerate(chapter_paragraphs):\n\n        print(f\"Translating paragraph {i + 1} out of {len(chapter_paragraphs)}\")\n\n        # Builds the message dynamically based on whether there is previous translated content\n        messages = [{\n          \"role\": \"system\", \n          \"content\": \"You are a helpful translator for a book.\"\n        }]\n\n        if translated_content:\n            latest_content = get_last_three_sentences(translated_content)\n            messages.append(\n                {\n                  \"role\": \"system\",\n                  \"content\": f\"This is the latest text from the book that you've translated from Spanish into English:\\n{latest_content}\"\n                }\n            )\n\n        # Adds the user message for the current paragraph\n        messages.append(\n            {\n              \"role\": \"user\", \n              \"content\": f\"Translate the following text from the book into English:\\n{paragraph}\"\n            }\n        )\n\n        # Calls the API\n        response = client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=messages\n        )\n\n        # Extracts the translated content and appends it\n        paragraph_translation = response.choices[0].message.content\n        translated_content += paragraph_translation + '\\n\\n'\n\n    return translated_content\n```", "```py\ndef get_last_three_sentences(paragraph: str) -> str:\n    # Use regex to split the text into sentences\n    sentences = re.split(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s', paragraph)\n\n    # Get the last three sentences (or fewer if the paragraph has less than 3 sentences)\n    last_three = sentences[-3:]\n\n    # Join the sentences into a single string\n    return ' '.join(last_three)\n```", "```py\nfrom docx import Document\n\ndef create_docx_from_chapters(chapters: Dict, output_filename: str) -> None:\n    doc = Document()\n\n    for chapter in chapters:\n        # Add chapter title as Heading 1\n        doc.add_heading(chapter['title'], level=1)\n\n        # Add chapter content as normal text\n        doc.add_paragraph(chapter['content'])\n\n        # Add a page break after each chapter\n        doc.add_page_break()\n\n    # Save the document\n    doc.save(output_filename)\n```"]
["```py\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nimg = mpimg.imread('MOD_01.jpg')\nimg2 = mpimg.imread('MOD_24.jpg')\n```", "```py\nimg = img[140:600,110:500,:]\nimg2 = img2[140:600,110:500,:]\n\nfig, ax = plt.subplots(ncols=2, figsize=(16,9))\nax[0].imshow(img)\nax[1].imshow(img2)\nfor i in range(2):\n  ax[i].set_facecolor('black')\n  ax[i].set_xticks([])\n  ax[i].set_yticks([])\nax[0].set_title('2000-08-01', fontsize=26)\nax[1].set_title('2023-08-01', fontsize=26)\nplt.show()\n```", "```py\ndf = pd.DataFrame({'R': img[:,:, 0].flatten(), 'G': img[:,:, 1].flatten(), 'B':img[:,:, 2].flatten()})\ndf2 = pd.DataFrame({'R': img2[:,:, 0].flatten(), 'G': img2[:,:, 1].flatten(), 'B':img2[:,:, 2].flatten()})\n```", "```py\ndef kmeans(data, K, kind):\n  L = list()\n  new_centroids = data.sample(K).values\n\n  data = distance(data.copy(), new_centroids, kind)\n  old_centroids = new_centroids.copy()\n  new_centroids = np.array([data[data.Class == Class][['R', 'G', 'B']].mean().values for Class in data.loc[:,'C1':f'C{K}'].columns])\n  i = 1\n  print(f'Iteration: {i}\\tDistance: {abs(new_centroids.mean()-old_centroids.mean())}')\n  while abs(new_centroids.mean()-old_centroids.mean())>0.001:\n    L.append(abs(new_centroids.mean()-old_centroids.mean()))\n    data = distance(data, new_centroids, kind)\n    old_centroids = new_centroids.copy()\n    new_centroids = np.array([data[data.Class == Class][['R', 'G', 'B']].mean().values for Class in data.loc[:,'C1':f'C{K}'].columns])\n    i+=1\n    print(f'Iteration: {i}\\tDistance: {abs(new_centroids.mean()-old_centroids.mean())}')\n  print(f\"k-Means has ended with {i} iteratinons\")\n  return data, L\n```", "```py\nL = list()\nnew_centroids = data.sample(K).values\n```", "```py\ndef distance(data, centroids, kind):\n  #kind = euclidean, manhattan, chebyshev\n  #Here we add to the dataframe as many clusters C-ith as needed\n  cols=list()\n  for i in range(1,k+1):\n    if kind=='euclidean':\n      data[f'C{i}'] = ((centroids[i-1][0]-data.R)**2+(centroids[i-1][1]-data.G)**2+(centroids[i-1][2]-data.B)**2)**0.5\n    elif kind=='manhattan':\n      data[f'C{i}'] = abs(centroids[i-1][0]-data.R)+abs(centroids[i-1][1]-data.G)+abs(centroids[i-1][2]-data.B)\n    elif kind=='chebyshev':\n      merged=pd.concat([centroids[i-1][0]-data.R, centroids[i-1][1]-data.G, centroids[i-1][2]-data.B], axis=1)\n      data[f'C{i}'] = merged.max(axis=1)\n    cols.append(f'C{i}')\n  data['Class'] = data[cols].abs().idxmin(axis=1) #assigning clusters to points\n  return data #returning the dataframe with k cluster columns and one Class column with the final cluster\n```", "```py\ndata = distance(data.copy(), new_centroids, kind)\nold_centroids = new_centroids.copy()\nnew_centroids = np.array([data[data.Class == Class][['R', 'G', 'B']].mean().values for Class in data.loc[:,'C1':f'C{K}'].columns])\n```", "```py\nwhile abs(new_centroids.mean()-old_centroids.mean())>0.001:\n    L.append(abs(new_centroids.mean()-old_centroids.mean()))\n    data = distance(data, new_centroids, kind)\n    old_centroids = new_centroids.copy()\n    new_centroids = np.array([data[data.Class == Class][['R', 'G', 'B']].mean().values for Class in data.loc[:,'C1':f'C{K}'].columns])\n```", "```py\nk = 3\nsegmented_1, segmented_2, distances_1, distances_2 = {}, {}, {}, {}\nsegmented_1['euclidean'], distances_1['euclidean'] = kmeans(df, k, 'euclidean')\nsegmented_2['euclidean'], distances_2['euclidean'] = kmeans(df2, k, 'euclidean')\nsegmented_1['manhattan'], distances_1['manhattan'] = kmeans(df, k, 'manhattan')\nsegmented_2['manhattan'], distances_2['manhattan'] = kmeans(df2, k, 'manhattan')\nsegmented_1['chebyshev'], distances_1['chebyshev'] = kmeans(df, k, 'chebyshev')\nsegmented_2['chebyshev'], distances_2['chebyshev'] = kmeans(df2, k, 'chebyshev')\n```", "```py\nd = {'C1':0, 'C2': 1, 'C3':2}\nfor key in segmented_1.keys():\n  segmented_1[key].Class = segmented_1[key].Class.apply(lambda x: d[x])\n  segmented_2[key].Class = segmented_2[key].Class.apply(lambda x: d[x])\n```", "```py\nfor key in segmented_1.keys():\n  fig, ax = plt.subplots(ncols=2, nrows=2, figsize=(10,10))\n  ax[0, 0].imshow(img)\n  ax[0, 1].imshow(segmented_1[key].Class.values.reshape(460,390))\n  ax[0, 0].set_title('MOD09GA RGB', fontsize=18)\n  ax[0, 1].set_title(f'kMeans\\n{key[0].upper()+key[1:]} Distance', fontsize=18)\n\n  ax[1, 0].imshow(img2)\n  ax[1, 1].imshow(segmented_2[key].Class.values.reshape(460,390))\n  ax[1, 0].set_title('MOD09GA RGB', fontsize=18)\n  ax[1, 1].set_title(f'kMeans\\n{key[0].upper()+key[1:]} Distance', fontsize=18)\n\n  for i in range(2):\n    for j in range(2):\n      ax[i, j].set_facecolor('black')\n      ax[i, j].set_xticks([])\n      ax[i, j].set_yticks([])\n\n  plt.savefig(f'{key}.png')\n  plt.tight_layout()\n  plt.show()\n```", "```py\nscores_1, scores_2 = {}, {}\nfor key in segmented_1.keys(): #key is a metric for the distance estimation\n  scores_1[key]=round(silhouette_score(segmented_1[key].loc[:, :'C3'], segmented_1[key].Class, metric=key),2)\n  scores_2[key]=round(silhouette_score(segmented_2[key].loc[:, :'C3'], segmented_2[key].Class, metric=key),2)\n  print(f'Distance: {key}\\t Img 1: {scores_1[key]}\\t Img 2: {scores_2[key]}')\n```", "```py\nfor metric, Class in zip(['euclidean', 'manhattan'], [2,1]):\n  img1_water = np.count_nonzero(segmented_1[metric].Class.values == Class)*500*500*1e-6 #pixel size is 500, so the area is 500*500 and to convert to km2 * 1e-6\n  img2_water = np.count_nonzero(segmented_2[metric].Class.values == Class)*500*500*1e-6\n\n  print(f'Distance: {metric}\\tWater Area Before: {round(img1_water)}km\\u00b2\\tWater Area After: {round(img2_water)}km\\u00b2\\tChange: -{100-round(img2_water/img1_water*100)}%')\n```"]
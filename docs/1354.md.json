["```py\nfunction constructive(E){\n    S = {}\n    F = {i for i in E if S union {i} is feasible}\n    while F is not empty{\n        i = choose(F)\n        S = S union {i}\n        F = {i for i in E if S union {i} is feasible}\n    }\n    return S\n}\n```", "```py\nclass Item:\n\n    index: int\n    weight: float\n    value: float\n    density: float\n    selected: bool\n\n    def __init__(self, index, weight, value) -> None:\n        self.index = index\n        self.weight = weight\n        self.value = value\n        self.density = value / weight\n        self.selected = False\n\n    @classmethod\n    def from_dict(cls, x: dict):\n        index = x[\"index\"]\n        weight = x[\"weight\"]\n        value = x[\"value\"]\n        return cls(index, weight, value)\n```", "```py\nfrom typing import Dict, List, Union\n\nclass BaseConstructive:\n\n    items: List[Item]\n    capacity: float\n    solution: List[Item]\n\n    def __init__(self, capacity: float, items: List[Dict[str, Union[int, float]]]) -> None:\n        self.items = []\n        self.capacity = capacity\n        for new_element in items:\n            item = Item.from_dict(new_element)\n            self.items.append(item)\n        self.solution = []\n\n    @property\n    def cost(self):\n        return sum(i.value for i in self.solution)\n```", "```py\nclass BaseConstructive:\n    # Check previous definition\n\n    def solve(self):\n        remaining = self.capacity\n        for item in self.items:\n            if remaining >= item.weight:\n                item.selected = True\n                self.solution.append(item)\n                remaining = remaining - item.weight\n```", "```py\nclass GreedyConstructive(BaseConstructive):\n\n    def solve(self):\n        self.items.sort(key=lambda x: x.density, reverse=True)\n        super().solve()\n```", "```py\nimport copy\nfrom typing import Dict, List, Optional, Tuple\n\nclass Node:\n\n    neighbors: List['Node']\n    index: int\n    selected: bool\n\n    def __init__(self, index):\n        self.index = index\n        self.neighbors = []\n        self.selected = False\n\n    def __repr__(self) -> str:\n        return f\"N{self.index}\"\n\n    def add_neighbor(self, node: 'Node'):\n        if node not in self.neighbors:\n            self.neighbors.append(node)\n\n    def delete(self):\n        for n in self.neighbors:\n            n.neighbors.remove(self)\n\n    @property\n    def degree(self):\n        return len(self.neighbors)\n```", "```py\nclass Graph:\n\n    N: Dict[int, Node]\n\n    def __init__(\n        self,\n        edges: List[Tuple[int, int]],\n        nodes: Optional[List[int]] = None\n    ):\n        # Start the set\n        if nodes is None:\n            self.N = {}\n        else:\n            self.N = {i: Node(i) for i in nodes}\n\n        # Include all neighbors\n        for i, j in edges:\n            self._new_edge(i, j)\n\n    @property\n    def active_nodes(self):\n        return [node for node in self.N.values() if node.selected]\n\n    @property\n    def inactive_nodes(self):\n        return [node for node in self.N.values() if not node.selected]\n\n    @property\n    def nodelist(self):\n        return list(self.N.values())\n\n    @property\n    def queue(self):\n        return [n for n in self.nodelist if not n.selected]\n\n    def _new_node(self, i: int):\n        if i not in self.N:\n            self.N[i] = Node(i)\n\n    def _new_edge(self, i: int, j: int):\n        self._new_node(i)\n        self._new_node(j)\n        self.N[i].add_neighbor(self.N[j])\n        self.N[j].add_neighbor(self.N[i])\n\n    def select(self, node: Node):\n        node.selected = True\n        selected_neighbors = node.neighbors.copy()\n        for n in selected_neighbors:\n            other = self.N.pop(n.index)\n            other.delete()\n\n    def deactivate(self):\n        for n in self.N.values():\n            n.selected = False\n\n    def copy(self):\n        return copy.deepcopy(self)\n```", "```py\nfrom abc import ABC, abstractmethod\nfrom mis.graph import Graph, Node\nfrom typing import List, Optional, Tuple\n\nclass BaseConstructive(ABC):\n\n    graph: Graph\n\n    def __init__(\n        self,\n        edges: List[Tuple[int, int]],\n        nodes: Optional[List[int]] = None,\n    ):\n        self.graph = Graph(edges, nodes)\n```", "```py\nclass BaseConstructive(ABC):\n    # Check previous definitions\n\n    def __call__(self, *args, **kwargs):\n        S = self.solve(*args, **kwargs)\n        for i, n in S.N.items():\n            self.graph.N[i].selected = n.selected\n\n    @property\n    def cost(self):\n        return len(self.graph.active_nodes)\n\n    def solve(self, *args, **kwargs) -> Graph:\n        self.graph.deactivate()\n        G = self.graph.copy()\n        for i in range(len(G.N)):\n            n = self.choice(G)\n            G.select(n)\n            if len(G.queue) == 0:\n                assert len(G.N) == i + 1, \"Unexpected behavior in remaining nodes and iterations\"\n                break\n\n        return G\n\n    @abstractmethod\n    def choice(self, graph: Graph) -> Node:\n        pass\n```", "```py\nimport random\n\nclass RandomChoice(BaseConstructive):\n\n    rng: random.Random\n\n    def __init__(\n        self,\n        edges: List[Tuple[int, int]],\n        nodes: Optional[List[int]] = None,\n        seed=None\n    ):\n        super().__init__(edges, nodes)\n        self.rng = random.Random(seed)\n\n    def choice(self, graph: Graph) -> Node:\n        return self.rng.choice(graph.queue)\n```", "```py\nclass GreedyChoice(BaseConstructive):\n\n    def choice(self, graph: Graph) -> Node:\n        return min([n for n in graph.queue], key=lambda x: x.degree)\n```", "```py\nclass MultiRandom(RandomChoice):\n\n    def solve(self, n_iter: int = 10) -> Graph:\n        best_sol = None\n        best_cost = 0\n        for _ in range(n_iter):\n            G = super().solve()\n            if len(G.N) > best_cost:\n                best_cost = len(G.N)\n                best_sol = G\n        return best_sol\n```"]
["```py\n# Data dictionary: nominal parameters of the sensor response model\ndef load_dd():\n  return Box({\n    'S'  : {\n      'TC'   :   [1, -5.26e-3, 15.34e-6],\n      'noise':   0.12/100,  },\n    'VT': {\n      'TC':      [0, 1.16e-3, 2.78e-6],\n      'noise':   0.1/100,}  \n  })\n\n# Probability density functions for the parameter variations\npdfs = {\n    'S.TC': (norm(0,1.132e-2), norm(0,1.23e-4), norm(0,5.40e-7)),\n    'VT.TC'   : (norm(0,7.66e-6), norm(0,4.38e-7))\n}\n\n# Sensor response model\ndef sensor_response_model(T, sensor_id=0, dd={}, delta={}):\n    S=np.poly1d(np.flip((dd.S.TC+delta.loc[sensor_id]['S.TC'])))(T-25)\n    S+=np.random.normal(0, dd.S.noise, size=len(T))\n\n    VT = 10*np.poly1d(np.flip(dd.VT.TC+np.r_[0,delta.loc[sensor_id]['VT.TC'].values]))(T-25)\n    VT+= np.random.normal(0, dd.VT.noise, size=len(T))\n\n    return {'S': S, 'VT': VT} \n```", "```py\ndf1,_=build_sensors_(ids=np.arange(30))\n```", "```py\ndef full_calibration(df):\n    W = df.groupby(\"id\").apply(\n        lambda g: ols(\"S ~ 1 + VT + I(VT**2)+ I(VT**3)\", data=g).fit().params\n    )\n    W.columns = [f\"w_{k}\" for k, col in enumerate(W.columns)]\n    df[\"w\"] = df.apply(lambda X: W.loc[X.name[0]].values, axis=1)\n\ndf1, W=full_calibration(df1)\n```", "```py\nw0 = W.mean().values\n\ndf2,_=build_sensors_(ids=[0])\ndef blind_calibration(df):\n    return df.assign(w=[w0]*len(df))\ndf2 = blind_calibration(df2)\n```", "```py\nCov0 = W.cov(ddof=len(W) - len(w0))\nsns.jointplot(data=W.apply(pd.Series),x='w_1', y='w_2', kind='kde', fill=True, height=4)\n```"]
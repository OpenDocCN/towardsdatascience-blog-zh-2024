["```py\n# import required packages\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import make_blobs\n```", "```py\n# helper function for calculating Euclidean distance\ndef euclidean_distance(a,b):\n    d = np.sqrt(np.sum((a - b)**2))\n    return d\n\nclass Kmeans:\n\n    # construct method for hyperparameter initialization\n    def __init__(self, k=3, max_iter=100, tol=1e-06):\n        self.k = k\n        self.max_iter = max_iter\n        self.tol = tol\n\n    # randomly picks the initial centroids from the input data\n    def pick_centers(self, X):\n        centers_idxs = np.random.choice(self.n_samples, self.k)\n        return X[centers_idxs]\n\n    # finds the closest centroid for each data point\n    def get_closest_centroid(self, x, centroids):\n        distances = [euclidean_distance(x, centroid) for centroid in centroids]\n        return np.argmin(distances)\n\n    # creates a list with lists containing the idxs of each cluster\n    def create_clusters(self, centroids, X):\n        clusters = [[] for _ in range(self.k)]\n        labels = np.empty(self.n_samples)\n        for i, x in enumerate(X):\n            centroid_idx = self.get_closest_centroid(x, centroids)\n            clusters[centroid_idx].append(i)\n            labels[i] = centroid_idx\n\n        return clusters, labels\n\n    # calculates the centroids for each cluster using the mean value \n    def compute_centroids(self, clusters, X):\n        centroids = np.empty((self.k, self.n_features))\n        for i, cluster in enumerate(clusters):\n            centroids[i] = np.mean(X[cluster], axis=0)\n\n        return centroids\n\n    # helper function to verify if the centroids changed significantly\n    def is_converged(self, old_centroids, new_centroids):\n        distances = [euclidean_distance(old_centroids[i], new_centroids[i]) for i in range(self.k)]\n        return (sum(distances) < self.tol)\n\n    # method to train the data, find the optimized centroids and label each data point according to its cluster\n    def fit_predict(self, X):\n        self.n_samples, self.n_features = X.shape\n        self.centroids = self.pick_centers(X)\n\n        for i in range(self.max_iter):\n            self.clusters, self.labels = self.create_clusters(self.centroids, X)\n            new_centroids = self.compute_centroids(self.clusters, X)\n            if self.is_converged(self.centroids, new_centroids):\n                break\n            self.centroids = new_centroids\n\n    # method for evaluating the intracluster variance of the optimization\n    def clustering_errors(self, X):\n        cluster_values = [X[cluster] for cluster in self.clusters]\n        squared_distances = []\n        # calculation of total squared Euclidean distance\n        for i, cluster_array in enumerate(cluster_values):\n            squared_distances.append(np.sum((cluster_array - self.centroids[i])**2))\n\n        total_error = np.sum(squared_distances)\n        return total_error\n```", "```py\n# create simulated data for examples\nX, _ = make_blobs(n_samples=500, n_features=2, centers=4, \n                  shuffle=False, random_state=0)\n```", "```py\nmodel = Kmeans(k=4)\nmodel.fit_predict(X)\nlabels = model.labels\ncentroids =model.centroids\nplot_clusters(X, labels, centroids)\n```"]
- en: Modeling DAU with Markov Chain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/modeling-dau-with-markov-chain-640ea4fddeb4?source=collection_archive---------1-----------------------#2024-12-02](https://towardsdatascience.com/modeling-dau-with-markov-chain-640ea4fddeb4?source=collection_archive---------1-----------------------#2024-12-02)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to predict DAU using Duolingo’s growth model and control the prediction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@wowone?source=post_page---byline--640ea4fddeb4--------------------------------)[![Vladimir
    Kukushkin](../Images/e41265ea2c2079723f327ca02db3f67f.png)](https://medium.com/@wowone?source=post_page---byline--640ea4fddeb4--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--640ea4fddeb4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--640ea4fddeb4--------------------------------)
    [Vladimir Kukushkin](https://medium.com/@wowone?source=post_page---byline--640ea4fddeb4--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--640ea4fddeb4--------------------------------)
    ·21 min read·Dec 2, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Doubtlessly, DAU, WAU, and MAU — daily, weekly, and monthly [active users](https://en.wikipedia.org/wiki/Active_users)
    — are critical business metrics. An article [“How Duolingo reignited user growth”](https://www.lennysnewsletter.com/p/how-duolingo-reignited-user-growth)
    by [Jorge Mazal](https://www.linkedin.com/in/jorgemazal/), former CPO of Duolingo,
    is #1 in the Growth section of Lenny’s Newsletter blog. In this article, Jorge
    paid special attention to the methodology Duolingo used to model the DAU metric
    (see another article [“Meaningful metrics: how data sharpened the focus of product
    teams”](https://blog.duolingo.com/growth-model-duolingo/) by [Erin Gustafson](https://blog.duolingo.com/author/erin/)).
    This methodology has multiple strengths, but I’d like to focus on how one can
    use this approach for DAU forecasting.'
  prefs: []
  type: TYPE_NORMAL
- en: The new year is coming soon, so many companies are planning their budgets for
    the next year these days. Cost estimations often require DAU forecasts. In this
    article, I’ll show how you can get this prediction using Duolingo’s growth model.
    I’ll explain why this approach is better compared to standard time-series forecasting
    methods and how you can adjust the prediction according to your teams’ plans (e.g.,
    marketing, activation, product teams).
  prefs: []
  type: TYPE_NORMAL
- en: The article text goes along with the code, and a simulated dataset is attached
    so the research is fully reproducible. The Jupyter notebook version is available
    [here](https://github.com/wowone/wowone.github.io/blob/master/posts/2024-12-02_dau_prediction/dau_prediction.ipynb).
    In the end, I’ll share a DAU “calculator” designed in Google Spreadsheet format.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll be narrating on behalf of the collective “we” as if we’re talking together.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Methodology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A quick recap on how the [Duolingo’s growth model](https://blog.duolingo.com/growth-model-duolingo/)
    works. At day d (d = 1, 2, … ) of a user’s lifetime, the user can be in one of
    the following 7 (mutually-exclusive) states: `new`, `current`, `reactivated`,
    `resurrected`, `at_risk_wau`, `at_risk_mau`, `dormant`. The states are defined
    according to indicators of whether a user was active today, in the last 7 days,
    or in the last 30 days. The definition summary is given in the table below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/310a0c6eba807c18e6ad05ec8ab9aa67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Having these states defined (as a set S), we can consider user behavior as
    a [Markov chain](https://en.wikipedia.org/wiki/Markov_chain). Here’s an example
    of a user’s trajectory: `new`→ `current`→ `current`→ `at_risk_wau`→...→ `at_risk_mau`→...→
    `dormant`. Let M be a transition matrix associated with this Markov process: m_{i,
    j} = P(s_j | s_i) are the probabilities that a user moves to state s_j right after
    being at state s_i, where s_i, s_j ∈ S. Such a matrix is inferred from the historical
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we assume that user behavior is stationary (independent of time), the matrix
    M fully describes the states of all users in the future. Suppose that the vector
    u_0 of length 7 contains the counts of users in certain states on a given day,
    denoted as day 0\. According to the Markov model, on the next day 1, we expect
    to have the following number of users states u_1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cd5c149c2584d7449578ec794b6c820c.png)'
  prefs: []
  type: TYPE_IMG
- en: Applying this formula recursively, we derive the number of users in certain
    states on any arbitrary day t > 0 in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the initial distribution u_0, we need to provide the number of new users
    that will appear in the product each day in the future. We’ll address this problem
    as a general time-series forecasting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, having u_t calculated, we can determine DAU values on day t:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DAU_t = #New_t + #Current_t + #Reactivated_t + #Resurrected_t'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we can easily calculate WAU and MAU metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'WAU_t = DAU_t + #AtRiskWau_t,'
  prefs: []
  type: TYPE_NORMAL
- en: 'MAU_t = DAU_t + #AtRiskWau_t + #AtRiskMau_t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, here’s the algorithm outline:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each prediction day t = 1, …, T, calculate the expected number of new users
    #New_1, …, #New_T.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each lifetime day of each user, assign one of the 7 states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the transition matrix M from the historical data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate initial state counts u_0 corresponding to day t=0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively calculate u_{t+1} = M^T * u_t.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate DAU, WAU, and MAU for each prediction day t = 1, …, T.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is devoted to technical aspects of the implementation. If you’re
    interested in studying the model properties rather than code, you may skip this
    section and go to the [Section 4](#1375).
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 Dataset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use a simulated dataset based on historical data of a SaaS app. The data
    is stored in the [dau_data.csv.gz](https://drive.google.com/file/d/16kd8rJBvcgmw95jY42MedRfIxcO4LpPd/view?usp=sharing)
    file and contains three columns: `user_id`, `date`, and `registration_date`. Each
    record indicates a day when a user was active. The dataset includes activity indicators
    for 51480 users from `2020-11-01` to `2023-10-31`. Additionally, data from October
    2020 is included to calculate user states properly, as the `at_risk_mau` and `dormant`
    states require data from one month prior.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3248afffd2cb0a590beb957b9a2eaed4.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how the DAU time-series looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f3da1f5416d7f6c96d1ffe7d01f34913.png)'
  prefs: []
  type: TYPE_IMG
- en: Suppose that today is 2023–10–31 and we want to predict the DAU metric for the
    next 2024 year. We define a couple of global constants `PREDICTION_START` and
    `PREDICTION_END` which encompass the prediction period.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 3.2 Predicting new users amount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start from the new users prediction. We use the [prophet](http://facebook.github.io/prophet/)
    library as one of the easiest ways to forecast time-series data. The `new_users`
    Series contains such data. We extract it from the original `df` dataset selecting
    the rows where the `registration date` is equal to the `date`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`prophet` requires a time-series as a DataFrame containing two columns `ds`
    and `y`, so we reformat the `new_users` Series to the `new_users_prophet` DataFrame.
    Another thing we need to prepare is to create the `future` variable containing
    certain days for prediction: from `prediction_start` to `prediction_end`. This
    logic is implemented in the `predict_new_users` function. The plot below illustrates
    predictions for both past and future periods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e2d4082a52ad9a60f38efb68bc7141e6.png)'
  prefs: []
  type: TYPE_IMG
- en: The `new_users_pred` Series stores the predicted users amount.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 3.3 Getting the states
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In practice, the most calculations are reasonable to execute as SQL queries
    to a database where the data is stored. Hereafter, we will simulate such querying
    using the [duckdb](https://duckdb.org) library.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to assign one of the 7 states to each day of a user’s lifetime within
    the app. According to the definition, for each day, we need to consider at least
    the past 30 days. This is where SQL window functions come in. However, since the
    `df` data contains only records of *active days*, we need to explicitly extend
    them and include the days when a user was not active. In other words, instead
    of this list of records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'we’d like to get a list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: For readability purposes we split the following SQL query into multiple subqueries.
  prefs: []
  type: TYPE_NORMAL
- en: '`full_range`: Create a full sequence of dates for each user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dau_full`: Get the full list of both active and inactive records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`states`: Assign one of the 7 states for each day of a user''s lifetime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The query results are kept in the `states` DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/53ea15d70dd68eaa0f5c26683a10eaf8.png)'
  prefs: []
  type: TYPE_IMG
- en: 3.4 Calculating the transition matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having obtained these states, we can calculate state transition frequencies.
    In the [Section 4.3](#0637) we’ll study how the prediction depends on a period
    in which transitions are considered, so it’s reasonable to pre-aggregate this
    data on daily basis. The resulting `transitions` DataFrame contains `date`, `state_from`,
    `state_to`, and `cnt` columns.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can calculate the transition matrix M. We implement the `get_transition_matrix`
    function, which accepts the `transitions` DataFrame and a pair of dates that encompass
    the transitions period to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: As a baseline, let’s calculate the transition matrix for the whole year from
    `2022-11-01` to `2023-10-31`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3a953164c81ba1b76230eb9fa6cc70de.png)'
  prefs: []
  type: TYPE_IMG
- en: The sum of each row of any transition matrix equals 1 since it represents the
    probabilities of moving from one state to any other state.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Getting the initial state counts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An initial state is retrieved from the `states` DataFrame by the `get_state0`
    function and the corresponding SQL query. The only argument of the function is
    the date for which we want to get the initial state. We assign the result to the
    `state0` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 3.6 Predicting DAU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `predict_dau` function below accepts all the previous variables required
    for the DAU prediction and makes this prediction for a date range defined by the
    `start_date` and `end_date` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/70dcf535319cb880014b98b0a1834a4d.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how the DAU prediction `dau_pred` looks like for the `PREDICTION_START`
    - `PREDICTION_END` period. Besides the expected `dau`, `wau`, and `mau` columns,
    the output contains the number of users in each state for each prediction date.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we calculate the ground-truth values of DAU, WAU, and MAU (along with
    the user state counts), keep them in the `dau_true` DataFrame, and plot the predicted
    and true values altogether.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/09d316078e58553d6b7050786090ae89.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/cabd39f402f83dcda0f85360a2c50474.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve obtained the prediction but so far it’s not clear whether it’s fair or
    not. In the next section, we’ll evaluate the model.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Model evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.1 Baseline model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let’s check whether we really need to build a complex model to
    predict DAU. Wouldn’t it be better to predict DAU as a general time-series using
    the mentioned `prophet` library? The function `predict_dau_prophet` below implements
    this. We try to use some tweaks available in the library in order to make the
    prediction more accurate. In particular:'
  prefs: []
  type: TYPE_NORMAL
- en: we use logistic model instead of linear to avoid negative values;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: we add explicitly monthly and yearly seasonality;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: we remove the outliers;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: we explicitly define a peak period in January and February as “holidays”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The fact that the code turns out to be quite sophisticated indicates that one
    can’t simply apply `prophet` to the DAU time-series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hereafter we test a prediction for multiple predicting horizons: 3, 6, and
    12 months. As a result, we get 3 test sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '3-months horizon: `2023-08-01` - `2023-10-31`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '6-months horizon: `2023-05-01` - `2023-10-31`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1-year horizon: `2022-11-01` - `2023-10-31`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each test set we calculate the [MAPE](https://en.wikipedia.org/wiki/Mean_absolute_percentage_error)
    loss function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/fde884739a1ba0e70bd009db56aaeda1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The MAPE error turns out to be high: 18% — 35%. The fact that the shortest
    horizon has the highest error means that the model is tuned for the long-term
    predictions. This is another inconvenience of such an approach: we have to tune
    the model for each prediction horizon. Anyway, this is our baseline. In the next
    section we’ll compare it with more advanced models.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 General evaluation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section we evaluate the model implemented in the [Section 3.6](#5dc8).
    So far we set the transition period as 1 year before the prediction start. We’ll
    study how the prediction depends on the transition period in the [Section 4.3](#0637).
    As for the new users, we run the model using two options: the real values and
    the predicted ones. Similarly, we fix the same 3 prediction horizons and test
    the model on them.'
  prefs: []
  type: TYPE_NORMAL
- en: The `make_predicion` helper function below implements the described options.
    It accepts `prediction_start`, `prediction_end` arguments defining the prediction
    period for a given horizon, `new_users_mode` which can be either `true` or `predict`,
    and `transition_period`. The options of the latter argument will be explained
    further.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In total, we have 6 prediction scenarios: 2 options for new users and 3 prediction
    horizons. The diagram below illustrates the results. The charts on the left relate
    to the `new_users_mode = ''predict''` option, while the right ones relate to the
    `new_users_mode = ''true''` option.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/d4b663fdf3b9e441c5f502857f49d6b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here are the MAPE values summarizing the prediction quality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/67d12d573e59424179102793f145476a.png)'
  prefs: []
  type: TYPE_IMG
- en: We notice multiple things.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the model demonstrates much better results than the baseline. Indeed,
    the baseline is based on the historical DAU data only, while the model uses the
    user states information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, for the 1-year horizon and `new_users_mode=''predict''` the MAPE error
    is huge: 65%. This is 3 times higher than the corresponding baseline error (21%).
    On the other hand, `new_users_mode=''true''` option gives a much better result:
    8%. It means that the new users prediction has a huge impact on the model, especially
    for long-term predictions. For the shorter periods the difference is less dramatic.
    The major reason for such a difference is that 1-year period includes Christmas
    with its extreme values. As a result, i) it''s hard to predict such high new user
    values, ii) the period heavily impacts user behavior, the transition matrix and,
    consequently, DAU values. Hence, we strongly recommend to implement the new user
    prediction carefully. The baseline model was specially tuned for this Christmas
    period, so it''s not surprising that it outperforms the Markov model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the new users prediction is accurate, the model captures trends well. It
    means that using last 365 days for the transition matrix calculation is a reasonable
    choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interestingly, the true new users data provides worse results for the 3-months
    prediction. This is nothing but a coincidence. The wrong new users prediction
    in October 2023 reversed the predicted DAU trend and made MAPE a bit lower.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s decompose the prediction error and see which states contribure the
    most. By error we mean here `dau_pred` - `dau_true` values, by relative error
    - ( `dau_pred` - `dau_true`) / `dau_true` - see left and right diagrams below
    correspondingly. In order to focus on this aspect, we'll narrow the configuration
    to the 3-months prediction horizon and the `new_users_mode='true'` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/bf9cbc3945f5e93adb2b3bd873e2df2a.png)'
  prefs: []
  type: TYPE_IMG
- en: From the left chart we notice that the error is basically contributed by the
    `current` state. It's not surprising since this state contributes to DAU the most.
    The error for the `reactivated`, and `resurrected` states is quite low. Another
    interesting thing is that this error is mostly negative for the `current` state
    and mostly positive for the `resurrected` state. The former might be explained
    by the fact that the new users who appeared in the prediction period are more
    engaged that the users from the past. The latter indicates that the `resurrected`
    users in reality contribute to DAU less than the transition matrix expects, so
    the `dormant`→ `resurrected` conversion rate is overestimated.
  prefs: []
  type: TYPE_NORMAL
- en: As for the relative error, it makes sense to analyze it for the `current` state
    only. This is because the daily amount of the reactivated and resurrected states
    are low so the relative error is high and noisy. The relative error for the `current`
    state varies between -25% and 4% which is quite high. And since we've fixed the
    new users prediction, this error is explained by the transition matrix inaccuracy
    only. In particular, the `current`→ `current` conversion rate is roughly 0.8 which
    is high and, as a result, it contributes to the error a lot. So if we want to
    improve the prediction we need to consider tuning this conversion rate foremost.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Transitions period impact
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section we kept the transitions period fixed: 1 year before
    a prediction start. Now we’re going to study how long this period should be to
    get more accurate prediction. We consider the same prediction horizons of 3, 6,
    and 12 months. In order to mitigate the noise from the new users prediction, we
    use the real values of the new users amount: `new_users_mode=''true''`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here comes varying of the `transition_period` argument. Its values are masked
    with the `last_<N>d` pattern where `N` stands for the number of days in a transitions
    period. For each prediction horizon we calculate 12 different transition periods
    of 1, 2, ..., 12 months. Then we calculate the MAPE error for each of the options
    and plot the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/011526da7ab75ad565b95a1720864d1e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It turns out that the optimal transitions period depends on the prediction
    horizon. Shorter horizons require shorter transitions periods: the minimal MAPE
    error is achieved at 1, 4, and 8 transition periods for the 3, 6, and 12 months
    correspondingly. Apparently, this is because the longer horizons contain some
    seasonal effects that could be captured only by the longer transitions periods.
    Also, it seems that for the longer prediction horizons the MAPE curve is U-shaped
    meaning that too long and too short transitions periods are both not good for
    the prediction. We’ll develop this idea in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Obsolence and seasonality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nevertheless, fixing a single transition matrix for predicting the whole year
    ahead doesn’t seem to be a good idea: such a model would be too rigid. Usually,
    user behavior varies depending on a season. For example, users who appear after
    Christmas might have some shifts in behavior. Another typical situation is when
    users change their behavior in summer. In this section, we’ll try to take into
    account these seasonal effects.'
  prefs: []
  type: TYPE_NORMAL
- en: So we want to predict DAU for 1 year ahead starting from November 2022\. Instead
    of using a single transition matrix `M_base` which is calculated for the last
    8 months before the prediction start, according to the previous subsection results
    (and labeled as the `last_240d` option below), we'll consider a mixture of this
    matrix and a seasonal one `M_seasonal`. The latter is calculated on monthly basis
    lagging 1 year behind. For example, to predict DAU for November 2022 we define
    `M_seasonal` as the transition matrix for November 2021\. Then we shift the prediction
    horizon to December 2022 and calculate `M_seasonal` for December 2021, etc.
  prefs: []
  type: TYPE_NORMAL
- en: In order to mix `M_base` and `M_seasonal` we define the following two options.
  prefs: []
  type: TYPE_NORMAL
- en: '`seasonal_0.3`: M = 0.3 * `M_seasonal` + 0.7 * `M_base`. 0.3 is a weight that
    was chosen as a local minimum after some experiments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`smoothing`: M = i/(N-1) * `M_seasonal` + (1 - i/(N - 1)) * `M_base` where
    N is the number of months within the predicting period, i = 0, …, N - 1 - the
    month index. The idea of this configuration is to gradually switch from the most
    recent transition matrix `M_base` to seasonal ones as the prediction month moves
    forward from the prediction start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6fda5e3857f98bc9a778ca757cc1d48d.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e4f9865ed7eb29fbb478d7f4fd129e02.png)'
  prefs: []
  type: TYPE_IMG
- en: According to the MAPE errors, `seasonal_0.3` configuration provides the best
    results. Interestingly, `smoothing` approach has appeared to be even worse than
    the `last_240d`. From the diagram above we see that all three models start to
    underestimate the DAU values in July 2023, especially the `smoothing` model. It
    seems that the new users who started appearing in July 2023 are more engaged than
    the users from 2022\. Probably, the app was improved sufficiently or the marketing
    team did a great job. As a result, the `smoothing` model that much relies on the
    outdated transitions data from July 2022 - October 2022 fails more than the other
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Final solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To sum things up, let’s make a final prediction for the 2024 year. We use the
    `seasonal_0.3` configuration and the predicted values for new users.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/3a5bc393283104377c72bb28ccdbc8d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 5\. Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the [Section 4](#1375) we studied the model performance from the prediction
    accuracy perspective. Now let’s discuss the model from the practical point of
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Besides poor accuracy, predicting DAU as a time-series (see the [Section 4.1](#0e38))
    makes this approach very stiff. Essentially, it makes a prediction in such a manner
    so it would fit *historical* data best. In practice, when making plans for a next
    year we usually have some certain expectations about the future. For example,
  prefs: []
  type: TYPE_NORMAL
- en: the marketing team is going to launch some new more effective campaings,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the activation team is planning to improve the onboarding process,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the product team will release some new features that would engage and retain
    users more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our model can take into account such expectations. For the examples above we
    can adjust the new users prediction, the `new`→ `current` and the `current`→ `current`
    conversion rates respectively. As a result, we can get a prediction that doesn't
    match with the historical data but nevertheless would be more realistic. This
    model's property is not just flexible - it's interpretable. You can easily discuss
    all these adjustments with the stakeholders, and they can understand how the prediction
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another advantage of the model is that it doesn’t require predicting whether
    a certain user will be active on a certain day. Sometimes binary classifiers are
    used for this purpose. The downside of this approach is that we need to apply
    such a classifier to each user including all the dormant users and each day from
    a prediction horizon. This is a tremedous computational cost. In contrast, the
    Markov model requires only the initial amount of states ( `state0`). Moreover,
    such classiffiers are often black-box models: they are poorly interpretable and
    hard to adjust.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Markov model also has some limitations. As we already have seen, it’s sensitive
    to the new users prediction. It’s easy to totally ruin the prediction by a wrong
    new users amount. Another problem is that the Markov model is memoryless meaning
    that it doesn’t take into account the user’s history. For example, it doesn’t
    distinguish whether a `current` user is a newbie, experienced, or `reactivated`/
    `resurrected` one. The retention rate of these user types should be certainly
    different. Also, as we discussed earlier, the user behavior might be of different
    nature depending on the season, marketing sources, countries, etc. So far our
    model is not able to capture these differences. However, this might be a subject
    for further research: we could extend the model by fitting more transition matrices
    for different user segments.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as we promised in the introduction, we provide a [DAU spreadsheet calculator](https://docs.google.com/spreadsheets/d/1DxbjrkSy_wvU1lzlNWhrEfWO-Kq1tJrQw0izEHu5ULU/edit?usp=sharing).
    In the `Prediction` sheet you'll need to fill the initial states distribution
    row (marked with blue) and the new users prediction column (marked with purple).
    In the `Conversions` sheet you can adjust the transition matrix values. Remember
    that the sum of each row of the matrix should be equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2cf0749a67ff0865d79889e8e41789ef.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s all for now. I hope that this article was useful for you. In case of
    any questions or suggestions, feel free to ask in the comments below or contact
    me directly on [LinkedIn](https://www.linkedin.com/in/vladimir-kukushkin-95b6487/).
  prefs: []
  type: TYPE_NORMAL
- en: All the images in the post are generated by the author.
  prefs: []
  type: TYPE_NORMAL

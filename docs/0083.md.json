["```py\nimport anyio\nfrom aiconfig import AIConfigRuntime, InferenceOptions\nfrom pathlib import Path\n\nasync def main():\n  # Create an AIConfigRuntime object from a config file\n  config_path = Path(\"config/auto-reply-content-gen.aiconfig.json\")\n  runtime: AIConfigRuntime = AIConfigRuntime.load(config_path)\n\n  # Run inference using the prompt named `generate-text`\n  inference_options = InferenceOptions(stream=False)\n  msg = await runtime.run(\"generate-text\", options=inference_options)\n\n  # Done!\n  print(f\"Generated message: {msg}\")\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n```", "```py\nimport shutil\nimport uuid\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import List, Optional\n\nimport aiofiles\nfrom pydantic import BaseModel, Field\n\nfrom roll.utils import utcnow\n\nclass DataRepository:\n    \"\"\"Represents a file-based data repository.\"\"\"\n\n    def __init__(self, data_dir: Path) -> None:\n        \"\"\"Initializes a new instance of the DataRepository class.\n\n        Args:\n            data_dir (Path): The directory to store data in.\n        \"\"\"\n        self._data_dir = data_dir\n        if not self._data_dir.exists():\n            self._data_dir.mkdir(parents=True, exist_ok=True)\n\n    async def get_keys(self) -> List[str]:\n        \"\"\"Returns the keys of existing records.\"\"\"\n        file_names = [\n            file_path.name\n            for file_path in self._data_dir.iterdir()\n            if file_path.is_dir()\n        ]\n        return file_names\n\n    async def get_all(self) -> List[AutoReplyRecord]:\n        \"\"\"Returns existing records.\n\n        Returns:\n            List[AutoReplyRecord]: A list of all records order by created time.\n        \"\"\"\n        keys = await self.get_keys()\n        records = [await self.get(key=key) for key in keys]\n        sorted_records = sorted(records, key=lambda r: r.created_at, reverse=True)\n        return list(sorted_records)\n\n    async def create(\n        self, ai_config_path: Path, html_template_path: Path\n    ) -> AutoReplyRecord:\n        \"\"\"Create a new record.\n\n        Args:\n            ai_config_path (Path): The path to the AI Config file.\n            html_template_path (Path): The path to the HTML template file.\n\n        Returns:\n            AutoReplyRecord: The newly created record.\n        \"\"\"\n        key = uuid.uuid4().hex\n\n        dir_path = self._data_dir / key\n        dir_path.mkdir(parents=True, exist_ok=True)\n\n        new_ai_config_path = dir_path / ai_config_path.name\n        shutil.copyfile(src=ai_config_path, dst=new_ai_config_path)\n\n        new_html_template_path = dir_path / html_template_path.name\n        shutil.copyfile(src=html_template_path, dst=new_html_template_path)\n\n        record = AutoReplyRecord(\n            key=key,\n            dir=dir_path,\n            ai_config_path=new_ai_config_path,\n            html_template_path=new_html_template_path,\n        )\n\n        await self.save(record=record)\n        return record\n\n    async def save(self, record: AutoReplyRecord) -> None:\n        \"\"\"Save the given record to disk.\n\n        Args:\n            record (AutoReplyRecord): The record to save.\n        \"\"\"\n        file_path = record.dir / RECORD_FILE_NAME\n        async with aiofiles.open(file_path, mode=\"w\") as f:\n            await f.write(record.to_json(indent=2))\n\n    async def get(self, key: str) -> Optional[AutoReplyRecord]:\n        \"\"\"Finds a record by its key.\n\n        Args:\n            key (str): The key to search for.\n\n        Returns:\n            Optional[AutoReplyRecord]: The record if found, None otherwise.\n        \"\"\"\n        file_path = self._data_dir / key / RECORD_FILE_NAME\n        if not file_path.exists():\n            return None\n        async with aiofiles.open(file_path, mode=\"r\") as f:\n            json_data = await f.read()\n        return AutoReplyRecord.from_json(json_data=json_data)\n```", "```py\nimport json\nfrom base64 import b64encode\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import cast\n\nimport aiofiles\nfrom exchangelib import Account, Credentials, OofSettings\nfrom exchangelib.ewsdatetime import EWSDateTime\n\nclass OutlookAutoReplyClient:\n    \"\"\"Represents a client for interacting with Outlook's out-of-office settings.\"\"\"\n\n    def __init__(self, login_name: str, password: str, account_name: str) -> None:\n        \"\"\"Initializes a new instance of the OutlookAutoReplyClient class.\n\n        Args:\n            login_name (str): The login name of the Outlook account.\n            password (str): The password of the Outlook account.\n            account_name (str): The name of the Outlook account.\n\n        \"\"\"\n        credentials = Credentials(username=login_name, password=password)\n        self._account = Account(\n            account_name, credentials=credentials, autodiscover=True\n        )\n\n    async def backup_to_json_file(self, output_path: Path) -> None:\n        \"\"\"Backup Outlook's current out-of-office settings to disk.\n\n        Args:\n            output_path (Path): The location where to store the backup.\n        \"\"\"\n        oof = cast(OofSettings, self._account.oof_settings)\n        start_at = cast(EWSDateTime, oof.start)\n        end_at = cast(EWSDateTime, oof.end)\n        settings = {\n            \"state\": oof.state,\n            \"start\": start_at.ewsformat(),\n            \"end\": end_at.ewsformat(),\n            \"external_audience\": oof.external_audience,\n            \"internal_reply\": oof.internal_reply,\n            \"external_reply\": oof.external_reply,\n        }\n        # Save settings to disk as JSON\n        async with aiofiles.open(output_path, \"w\") as file:\n            json_content = json.dumps(settings, indent=2)\n            await file.write(json_content)\n\n    async def set_internal_reply(self, html_content: str) -> None:\n        \"\"\"Sets the internal auto-reply message for a month.\n\n        Args:\n            html_content (str): The message to set as the internal auto-reply.\n        \"\"\"\n        start_at = datetime.now(tz=timezone.utc) - timedelta(days=1)\n        end_at = datetime.now(tz=timezone.utc) + timedelta(days=5)\n\n        print(f\"Setting internal auto-reply message from {start_at} to {end_at}...\")\n        self._account.oof_settings = OofSettings(\n            state=OofSettings.ENABLED,\n            external_audience=\"None\",\n            internal_reply=html_content,\n            external_reply=\"-\",  # Cannot be empty string or None!\n            start=start_at,\n            end=end_at,\n        )\n```", "```py\n{\n  \"name\": \"auto-reply-content-generator\",\n  \"description\": \"Configuration for generating content for auto-reply messages.\",\n  \"schema_version\": \"latest\",\n  \"metadata\": {\n    \"model_parsers\": {\n      \"gpt-4-1106-preview\": \"gpt-4\"\n    }\n  },\n  \"prompts\": [\n    {\n      \"name\": \"generate-text\",\n      \"input\": \"Write an auto-reply message in Danish following the same structure of earlier messages.\",\n      \"metadata\": {\n        \"model\": {\n          \"name\": \"gpt-4-1106-preview\",\n          \"settings\": {\n            \"model\": \"gpt-4-1106-preview\",\n            \"max_tokens\": 1000,\n            \"temperature\": 0.1,\n            \"system_prompt\": \"You're a renowned expert at crafting witty and engaging out-of-office replies in Danish. [...]\"\n          }\n        }\n      }\n    },\n    {\n      \"name\": \"generate-dall-e-prompt\",\n      \"input\": \"Generate a prompt for DALL-E 3 to create an illustration that complements the following out-of-office message:\\n{{auto_reply_message}}\",\n      \"metadata\": {\n        \"model\": {\n          \"name\": \"gpt-4-1106-preview\",\n          \"settings\": {\n            \"model\": \"gpt-4-1106-preview\",\n            \"max_tokens\": 1000,\n            \"temperature\": 0.1,\n            \"system_prompt\": \"You are an expert prompt engineer for the image generation model: DALL-E 3\\. [...]\"\n          }\n        },\n        \"parameters\": {\n          \"auto_reply_message\": \"Parameter for the auto-reply message.\"\n        }\n      }\n    },\n    {\n      \"name\": \"generate-image\",\n      \"input\": \"{{dall_e_prompt}}\",\n      \"metadata\": {\n        \"model\": {\n          \"name\": \"dall-e-3\",\n          \"settings\": {\n            \"model\": \"dall-e-3\",\n            \"size\": \"1792x1024\",\n            \"quality\": \"standard\"\n          }\n        },\n        \"parameters\": {\n          \"dall_e_prompt\": \"Parameter for the DALL-E prompt.\"\n        }\n      }\n    }\n  ]\n}\n```", "```py\nfrom pathlib import Path\n\nfrom aiconfig import AIConfigRuntime, InferenceOptions\n\nclass AutoReplyContentGenerator:\n    \"\"\"Represents a class that generates content for auto-reply messages.\"\"\"\n\n    def __init__(self, config_file_path: Path, output_dir: Path, verbose: bool) -> None:\n        \"\"\"Initializes a new instance of the AutoReplyContentGenerator class.\n\n        Args:\n            config_file_path (Path): The path to the AI Config file to use.\n            output_dir (Path): The directory to save outputs to.\n            verbose (bool): Whether to print debug messages to stdout.\n        \"\"\"\n        if not config_file_path.exists():\n            raise ValueError(f\"File {config_file_path} not found\")\n\n        self._output_path: Path = output_dir / config_file_path.name\n        self._runtime: AIConfigRuntime = AIConfigRuntime.load(config_file_path)\n        self._verbose = verbose\n\n    async def generate_message(self) -> str:\n        \"\"\"Generates an auto-reply message.\n\n        Returns:\n            str: The generated message.\n        \"\"\"\n        inference_options = InferenceOptions(stream=False)\n\n        if self._verbose:\n            print(\"Running inference for prompt 'generate-text'...\")\n\n        auto_reply_message = await self._runtime.run_and_get_output_text(\n            prompt_name=\"generate-text\",\n            options=inference_options,\n        )\n        self._save_outputs()\n\n        print(f\"Generated auto-reply message:\\n{auto_reply_message}\\n\")\n        return auto_reply_message\n\n    async def generate_image(self, auto_reply_message: str) -> str:\n        \"\"\"Generates an image to accompany the given auto-reply message.\n\n        Args:\n            auto_reply_message (str): The auto-reply message to use as inspiration for the image generation.\n\n        Returns:\n            str: The URL of the generated image.\n        \"\"\"\n        if self._verbose:\n            print(\"Running inference for prompt 'generate-dall-e-prompt'...\")\n\n        inference_options = InferenceOptions(stream=False)\n        dall_e_prompt = await self._runtime.run_and_get_output_text(\n            prompt_name=\"generate-dall-e-prompt\",\n            options=inference_options,\n            params={\n                \"auto_reply_message\": auto_reply_message,\n            },\n        )\n        self._save_outputs()\n\n        if self._verbose:\n            print(f\"Generated prompt for DALL-E:\\n{dall_e_prompt}\\n\")\n            print(\"Running inference for prompt 'generate-image'...\")\n\n        image_url = await self._runtime.run_and_get_output_text(\n            prompt_name=\"generate-image\",\n            options=inference_options,\n            params={\n                \"dall_e_prompt\": dall_e_prompt,\n            },\n        )\n        self._save_outputs()\n\n        if self._verbose:\n            print(f\"Generated image URL:\\n{image_url}\\n\")\n\n        return image_url\n\n    def _save_outputs(self) -> None:\n        \"\"\"Saves the outputs of the models to a JSON file.\"\"\"\n        self._runtime.save(\n            json_config_filepath=str(self._output_path),\n            include_outputs=True,\n        )\n```", "```py\nfrom pathlib import Path\nfrom typing import Optional\nfrom urllib.parse import unquote, urlparse\n\nimport aiofiles\nimport aiohttp\nfrom tqdm.asyncio import tqdm_asyncio\n\nclass FileDownloader:\n    \"\"\"Represents a class that downloads files.\"\"\"\n\n    def __init__(\n        self,\n        output_dir: Path,\n        verify_ssl: bool,\n        verbose: bool,\n        download_chunk_size: int = 1024,\n    ) -> None:\n        \"\"\"Initializes a new instance of the FileDownloader class.\n\n        Args:\n            output_dir (Path): The directory to save downloaded files to.\n            verify_ssl (bool): Whether to verify SSL certificates when downloading files.\n            download_chunk_size (int, optional): The size of each chunk to download. Defaults to 1024.\n        \"\"\"\n        self._http = aiohttp.ClientSession(\n            connector=aiohttp.TCPConnector(ssl=verify_ssl)  # type: ignore\n        )\n        self._chunk_size = download_chunk_size\n\n        self._output_dir = output_dir\n        self._output_dir.mkdir(parents=True, exist_ok=True)\n        self._verbose = verbose\n\n    async def download_one(\n        self, url: str, local_file_name: Optional[str] = None\n    ) -> Path:\n        \"\"\"Downloads an file from a URL and stores it on local disk.\n\n        Args:\n            url (str): The URL to download the file from.\n            local_file_name (Optional[str], optional): The name of the file to save the downloaded file to. Defaults to None.\n\n        Returns:\n            Path: The location of the downloaded file in the local disk.\n        \"\"\"\n        file_path = self._get_local_file_path(url=url, file_name=local_file_name)\n        async with self._http.get(url=url) as response:\n            if response.status != 200:\n                raise Exception(f\"Failed to download file: {response.status}\")\n\n            if self._verbose:\n                print(f\"Downloading file from {url} to {file_path}...\")\n\n            total_size = int(response.headers.get(\"content-length\", 0))\n            with tqdm_asyncio(\n                total=total_size, unit=\"B\", unit_scale=True, desc=\"Downloading\"\n            ) as progress_bar:\n                async with aiofiles.open(file_path, \"wb\") as file:\n                    async for data in response.content.iter_chunked(self._chunk_size):\n                        await file.write(data)\n                        progress_bar.update(len(data))\n        return file_path\n\n    async def close(self) -> None:\n        \"\"\"Closes the HTTP session.\"\"\"\n        await self._http.close()\n\n    def _get_local_file_path(self, url: str, file_name: Optional[str]) -> Path:\n        \"\"\"Gets the path to save the downloaded file to.\n\n        Args:\n            file_name (Optional[str]): The name of the file to save the downloaded file to. Defaults to None.\n\n        Returns:\n            Path: The path to save the downloaded file to.\n        \"\"\"\n        if file_name is None:\n            file_name = unquote(urlparse(url).path.split(\"/\")[-1])\n        file_path = self._output_dir / file_name\n        if file_path.exists():\n            # raise Exception(f\"File {file_path} already downloaded.\")\n            print(f\"WARNING. File {file_path} already exists. Overwritting...\")\n        return file_path\n```", "```py\nfrom pathlib import Path\n\nfrom PIL import Image\n\nclass ImageOptimizer:\n    def __init__(self, max_width: int, quantize: bool, image_quality: int) -> None:\n        \"\"\"Initializes a new instance of the ImageOptimizer class.\n\n        Args:\n            max_width (int): The maximum width of the image in pixels.\n            quantize (bool): Whether to quantize the image to reduce file size.\n            image_quality (int): The quality of the image when saving it to disk from 1 to 100.\n        \"\"\"\n        self._max_width = max_width\n        self._quantize = quantize\n        self._image_quality = image_quality\n\n    def run(self, input_path: Path) -> Path:\n        \"\"\"Optimizes an image and stores the image on disk.\n\n        Args:\n            input_path (Path): The path to the image to optimize.\n\n        Returns:\n            Path: The location of the optimized image on disk.\n        \"\"\"\n        output_path = input_path.parent / f\"{input_path.stem}-optimized.jpg\"\n\n        img = Image.open(input_path)\n        img = img.convert(\"RGB\")\n\n        img.thumbnail(size=(self._max_width, self._max_width), resample=Image.LANCZOS)\n\n        if self._quantize:\n            # Quantize image to reduce file size. Pillow converts the image to a\n            # palette image with at most 256 colors. This is done by storing 1 byte for\n            # each pixel instead of storing 3 bytes for R, G and B for each pixel.\n            # The single byte is used to store the index into the palette.\n            img = img.quantize()\n\n            if output_path.suffix.lower() in [\".jpg\", \".jpeg\"]:\n                # Convert to RGB before saving to JPEG to avoid errors.\n                img = img.convert(\"RGB\")\n\n        img.save(output_path, optimize=True, quality=self._image_quality)\n        return output_path\n```", "```py\nfrom base64 import b64encode\nfrom pathlib import Path\n\nimport aiofiles\n\nclass AutoReplyHtmlCreator:\n    \"\"\"Represents a class that creates the HTML for an auto-reply message.\"\"\"\n\n    def __init__(self, template_file_path: Path) -> None:\n        \"\"\"Initializes a new instance of the AutoReplyHtmlCreator class.\n\n        Args:\n            template_file_path (Path): The path to the HTML template to use.\n        \"\"\"\n        self._template_file_path = template_file_path\n\n        if not template_file_path.exists():\n            raise ValueError(f\"File {template_file_path} not found\")\n\n    async def run(self, message: str, image_file_path: Path, output_path: Path) -> str:\n        \"\"\"Creates the HTML for an auto-reply message.\n\n        Args:\n            message (str): The message to include in the auto-reply.\n            image_file_path (Path): The path to the image to include in the auto-reply.\n            output_path (Path): The path to save the HTML to.\n\n        Returns:\n            str: The HTML for the auto-reply message.\n        \"\"\"\n        async with aiofiles.open(self._template_file_path, \"r\") as file:\n            template = await file.read()\n\n        async with aiofiles.open(image_file_path, \"rb\") as file:\n            image_data = await file.read()\n            image_base64 = b64encode(image_data).decode(\"utf-8\")\n\n        message_in_html = message.replace(\"\\n\\n\", \"</p><p>\")\n        message_in_html = message_in_html.replace(\"\\n\", \"<br/>\")\n        message_in_html = f\"<p>{message_in_html}</p>\"\n\n        html = template.replace(\"{{CONTENT}}\", message_in_html)\n        html = html.replace(\"{{IMAGE_BASE64}}\", image_base64)\n        html = html.replace(\"{{IMAGE_CONTENT_TYPE}}\", \"image/jpeg\")\n\n        async with aiofiles.open(output_path, \"w\") as file:\n            await file.write(html)\n\n        return html\n```", "```py\nfrom pathlib import Path\nfrom typing import cast\n\nimport anyio\nimport streamlit as st\nfrom roll.config import settings\nfrom roll.data import ActiveOutOfOfficeSetting, AutoReplyRecord, DataRepository\nfrom roll.email import AutoReplyHtmlCreator, OutlookAutoReplyClient\nfrom roll.image import ImageOptimizer\nfrom roll.io import FileDownloader\nfrom roll.models import AutoReplyContentGenerator\nfrom roll.utils import utcnow\n\nclass StreamlitApp:\n    def __init__() -> None:\n        ...\n\n    async def run(self) -> None:\n        await self._setup_page_config()\n        await self._build_sidebar()\n        await self._build_main_content()\n\n    async def _setup_page_config(self) -> None:\n        ...\n\n    async def _build_sidebar(self) -> None:\n        ...\n\n    async def _build_main_content(self) -> None:\n        ...\n\n    async def _render_navbar(self, record: AutoReplyRecord) -> None:\n        ...\n\n    async def _create_new_content(self) -> None:\n        ...\n\n    async def _generate_message(self, record: AutoReplyRecord) -> None:\n        ...\n\n    async def _generate_image(self, record: AutoReplyRecord) -> None:\n        ...\n\n    async def _set_out_of_office(self, record: AutoReplyRecord) -> None:\n        ...\n\nasync def main() -> None:\n    \"\"\"Main entry point of the UI.\"\"\"\n    app = StreamlitApp(\n        data_dir=Path(\"data/repository\"),\n        ai_config_path=Path(\"config/auto-reply-content-gen.aiconfig.json\"),\n        html_template_file_path=Path(\"config/auto-reply-template.html\"),\n        oof_data_dir=Path(\"data/oof\"),\n        outlook_login_name=settings.LOGIN,\n        outlook_password=settings.PASSWORD,\n        outlook_account_name=settings.ACCOUNT_NAME,\n    )\n    await app.run()\n\nif __name__ == \"__main__\":\n    anyio.run(main)\n```"]
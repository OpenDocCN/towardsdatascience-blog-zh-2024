["```py\ndef parse_pdfs():\n    \"\"\"\n    Parses all PDF files in the specified directory and loads their content.\n\n    This function iterates through all files in the directory specified by PDF_DIR,\n    checks if they have a .pdf extension, and loads their content using PyPDFLoader.\n    The loaded content from each PDF is appended to a list which is then returned.\n\n    Returns:\n        list: A list containing the content of all loaded PDF documents.\n    \"\"\"\n    docs = []\n    pdfs = os.listdir(PDF_DIR)\n    print(f\"We have {len(pdfs)} pdfs\")\n    for pdf_file in pdfs:\n        if not pdf_file.endswith(\".pdf\"):\n            continue\n        print(f\"Loading PDF: {pdf_file}\")\n        file_path = f\"{PDF_DIR}/{pdf_file}\"\n        loader = PyPDFLoader(file_path)\n        docs = docs + loader.load()\n        print(f\"Loaded {len(docs)} documents\")\n\n    return docs\n\ndocs = parse_pdfs()\n\ntext_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)\nchunks = text_splitter.split_documents(docs)\n```", "```py\ndef summarize_text(text, prompt):\n    \"\"\"\n    Generate a summary of some text based on the user's prompt\n\n    Args:\n\n    text (str) - the text to analyze\n    prompt (str) - prompt instruction on how to summarize the text, eg 'generate a title'\n\n    Returns:\n\n    summary (text) - LLM-generated summary\n\n    \"\"\"\n    messages = [\n        (\n            \"system\",\n            \"You are an assistant that gives very brief single sentence description of text.\",\n        ),\n        (\"human\", f\"{prompt} :: \\n\\n {text}\"),\n    ]\n    ai_msg = llm.invoke(messages)\n    summary = ai_msg.content\n    return summary\n\ndef enrich_metadata(docs):\n    \"\"\"\n    Uses an LLM to populate 'title' and 'description' for text chunks\n\n    Args:\n\n    docs (list) - list of LangChain documents\n\n    Returns:\n\n    docs (list) - list of LangChain documents with metadata fields populated\n\n    \"\"\"\n    new_docs = []\n    for doc in docs:\n\n        # pdf name is last part of doc.metadata['source']\n        pdf_name = doc.metadata[\"source\"].split(\"/\")[-1]\n\n        # Find row in df where pdf_name is in URL\n        row = df[df[\"Document\"].str.contains(pdf_name)]\n        page = doc.metadata[\"page\"] + 1\n        url = f\"{row['Document'].values[0]}?id={str(uuid4())}#page={page}\"\n\n        # We'll use an LLM to generate a summary and title of the text, used by STORM\n        # This is just for the demo, proper application would have better metadata\n        summary = summarize_text(doc.page_content, prompt=\"Please describe this text:\")\n        title = summarize_text(\n            doc.page_content, prompt=\"Please generate a 5 word title for this text:\"\n        )\n\n        doc.metadata[\"description\"] = summary\n        doc.metadata[\"title\"] = title\n        doc.metadata[\"url\"] = url\n        doc.metadata[\"content\"] = doc.page_content\n\n        # print(json.dumps(doc.metadata, indent=2))\n        new_docs.append(doc)\n\n    print(f\"There are {len(docs)} docs\")\n\n    return new_docs\n\ndocs = enrich_metadata(docs)\nchunks = enrich_metadata(chunks)\n```", "```py\ndef build_vector_store(doc_type, docs):\n    \"\"\"\n    Givena  list of LangChain docs, will embed and create a file-system Qdrant vector database.\n    The folder includes doc_type in its name to avoid overwriting.\n\n    Args:\n\n    doc_type (str) - String to indicate level of document split, eg 'pages',\n                     'chunks'. Used to name the database save folder\n    docs (list) - List of langchain documents to embed and store in vector database\n\n    Returns:\n\n    Nothing returned by function, but db saved to f\"{DB_DIR}_{doc_type}\".\n\n    \"\"\"\n\n    print(f\"There are {len(docs)} docs\")\n\n    save_dir = f\"{DB_DIR}_{doc_type}\"\n\n    print(f\"Saving vectors to directory {save_dir}\")\n\n    client = QdrantClient(path=save_dir)\n\n    client.create_collection(\n        collection_name=DB_COLLECTION_NAME,\n        vectors_config=VectorParams(size=num_vectors, distance=Distance.COSINE),\n    )\n\n    vector_store = QdrantVectorStore(\n        client=client,\n        collection_name=DB_COLLECTION_NAME,\n        embedding=embeddings,\n    )\n\n    uuids = [str(uuid4()) for _ in range(len(docs))]\n\n    vector_store.add_documents(documents=docs, ids=uuids)\n\nbuild_vector_store(\"pages\", docs)\nbuild_vector_store(\"chunks\", docs)\n```", "```py\ndef set_instructions(runner):\n    \"\"\"\n    Adjusts templates and personas for the STORM AI Research algorithm.\n\n    Args:\n\n    runner - STORM runner object\n\n    Returns:\n\n    runner - STORM runner object with extra prompting\n\n    \"\"\"\n\n    # Open LMs are generally weaker in following output format.\n    # One way for mitigation is to add one-shot example to the prompt to exemplify the desired output format.\n    # For example, we can add the following examples to the two prompts used in StormPersonaGenerator.\n    # Note that the example should be an object of dspy.Example with fields matching the InputField\n    # and OutputField in the prompt (i.e., dspy.Signature).\n    find_related_topic_example = Example(\n        topic=\"Knowledge Curation\",\n        related_topics=\"https://en.wikipedia.org/wiki/Knowledge_management\\n\"\n        \"https://en.wikipedia.org/wiki/Information_science\\n\"\n        \"https://en.wikipedia.org/wiki/Library_science\\n\",\n    )\n    gen_persona_example = Example(\n        topic=\"Knowledge Curation\",\n        examples=\"Title: Knowledge management\\n\"\n        \"Table of Contents: History\\nResearch\\n  Dimensions\\n  Strategies\\n  Motivations\\nKM technologies\"\n        \"\\nKnowledge barriers\\nKnowledge retention\\nKnowledge audit\\nKnowledge protection\\n\"\n        \"  Knowledge protection methods\\n    Formal methods\\n    Informal methods\\n\"\n        \"  Balancing knowledge protection and knowledge sharing\\n  Knowledge protection risks\",\n        personas=\"1\\. Historian of Knowledge Systems: This editor will focus on the history and evolution of knowledge curation. They will provide context on how knowledge curation has changed over time and its impact on modern practices.\\n\"\n        \"2\\. Information Science Professional: With insights from 'Information science', this editor will explore the foundational theories, definitions, and philosophy that underpin knowledge curation\\n\"\n        \"3\\. Digital Librarian: This editor will delve into the specifics of how digital libraries operate, including software, metadata, digital preservation.\\n\"\n        \"4\\. Technical expert: This editor will focus on the technical aspects of knowledge curation, such as common features of content management systems.\\n\"\n        \"5\\. Museum Curator: The museum curator will contribute expertise on the curation of physical items and the transition of these practices into the digital realm.\",\n    )\n    runner.storm_knowledge_curation_module.persona_generator.create_writer_with_persona.find_related_topic.demos = [\n        find_related_topic_example\n    ]\n    runner.storm_knowledge_curation_module.persona_generator.create_writer_with_persona.gen_persona.demos = [\n        gen_persona_example\n    ]\n\n    # A trade-off of adding one-shot example is that it will increase the input length of the prompt. Also, some\n    # examples may be very long (e.g., an example for writing a section based on the given information), which may\n    # confuse the model. For these cases, you can create a pseudo-example that is short and easy to understand to steer\n    # the model's output format.\n    # For example, we can add the following pseudo-examples to the prompt used in WritePageOutlineFromConv and\n    # ConvToSection.\n    write_page_outline_example = Example(\n        topic=\"Example Topic\",\n        conv=\"Wikipedia Writer: ...\\nExpert: ...\\nWikipedia Writer: ...\\nExpert: ...\",\n        old_outline=\"# Section 1\\n## Subsection 1\\n## Subsection 2\\n\"\n        \"# Section 2\\n## Subsection 1\\n## Subsection 2\\n\"\n        \"# Section 3\",\n        outline=\"# New Section 1\\n## New Subsection 1\\n## New Subsection 2\\n\"\n        \"# New Section 2\\n\"\n        \"# New Section 3\\n## New Subsection 1\\n## New Subsection 2\\n## New Subsection 3\",\n    )\n    runner.storm_outline_generation_module.write_outline.write_page_outline.demos = [\n        write_page_outline_example\n    ]\n    write_section_example = Example(\n        info=\"[1]\\nInformation in document 1\\n[2]\\nInformation in document 2\\n[3]\\nInformation in document 3\",\n        topic=\"Example Topic\",\n        section=\"Example Section\",\n        output=\"# Example Topic\\n## Subsection 1\\n\"\n        \"This is an example sentence [1]. This is another example sentence [2][3].\\n\"\n        \"## Subsection 2\\nThis is one more example sentence [1].\",\n    )\n    runner.storm_article_generation.section_gen.write_section.demos = [\n        write_section_example\n    ]\n\n    return runner\n\ndef latest_dir(parent_folder):\n    \"\"\"\n    Find the most recent folder (by modified date) in the specified parent folder.\n\n    Args:\n        parent_folder (str): The path to the parent folder where the search for the most recent folder will be conducted. Defaults to f\"{DATA_DIR}/storm_output\".\n\n    Returns:\n        str: The path to the most recently modified folder within the parent folder.\n    \"\"\"\n    # Find most recent folder (by modified date) in DATA_DIR/storm_data\n    # TODO, find out how exactly storm passes back its output directory to avoid this hack\n    folders = [f.path for f in os.scandir(parent_folder) if f.is_dir()]\n    folder = max(folders, key=os.path.getmtime)\n\n    return folder\n\ndef generate_footnotes(folder):\n    \"\"\"\n    Generates footnotes from a JSON file containing URL information.\n\n    Args:\n        folder (str): The directory path where the 'url_to_info.json' file is located.\n\n    Returns:\n        str: A formatted string containing footnotes with URLs and their corresponding titles.\n    \"\"\"\n\n    file = f\"{folder}/url_to_info.json\"\n\n    with open(file) as f:\n        data = json.load(f)\n\n    refs = {}\n    for rec in data[\"url_to_unified_index\"]:\n        val = data[\"url_to_unified_index\"][rec]\n        title = data[\"url_to_info\"][rec][\"title\"].replace('\"', \"\")\n        refs[val] = f\"- {val} [{title}]({rec})\"\n\n    keys = list(refs.keys())\n    keys.sort()\n\n    footer = \"\"\n    for key in keys:\n        footer += f\"{refs[key]}\\n\"\n\n    return footer, refs\n\ndef generate_markdown_article(output_dir):\n    \"\"\"\n    Generates a markdown article by reading a text file, appending footnotes, \n    and saving the result as a markdown file.\n\n    The function performs the following steps:\n    1\\. Retrieves the latest directory using the `latest_dir` function.\n    2\\. Generates footnotes for the article using the `generate_footnotes` function.\n    3\\. Reads the content of a text file named 'storm_gen_article_polished.txt' \n       located in the latest directory.\n    4\\. Appends the generated footnotes to the end of the article content.\n    5\\. Writes the modified content to a new markdown file named \n       STORM_OUTPUT_MARKDOWN_ARTICLE in the same directory.\n\n    Args:\n\n    output_dir (str) - The directory where the STORM output is stored.\n\n    \"\"\"\n\n    folder = latest_dir(output_dir)\n    footnotes, refs = generate_footnotes(folder)\n\n    with open(f\"{folder}/storm_gen_article_polished.txt\") as f:\n        text = f.read()\n\n    # Update text references like [10] to link to URLs\n    for ref in refs:\n        print(f\"Ref: {ref}, Ref_num: {refs[ref]}\")\n        url = refs[ref].split(\"(\")[1].split(\")\")[0]\n        text = text.replace(f\"[{ref}]\", f\"\\[[{ref}]({url})\\]\")\n\n    text += f\"\\n\\n## References\\n\\n{footnotes}\"\n\n    with open(f\"{folder}/{STORM_OUTPUT_MARKDOWN_ARTICLE}\", \"w\") as f:\n        f.write(text)\n\ndef run_storm(topic, model_type, db_dir):\n    \"\"\"\n    This function runs the STORM AI Research algorithm using data\n    in a QDrant local database.\n\n    Args:\n\n    topic (str) - The research topic to generate the article for\n    model_type (str) - One of 'openai' and 'ollama' to control LLM used\n    db_dir (str) - Directory where the QDrant vector database is\n\n    \"\"\"\n    if model_type not in [\"openai\", \"ollama\"]:\n        print(\"Unsupported model_type\")\n        sys.exit()\n\n    # Clear lock so can be read\n    if os.path.exists(f\"{db_dir}/.lock\"):\n        print(f\"Removing lock file {db_dir}/.lock\")\n        os.remove(f\"{db_dir}/.lock\")\n\n    print(f\"Loading Qdrant vector store from {db_dir}\")\n\n    engine_lm_configs = STORMWikiLMConfigs()\n\n    if model_type == \"openai\":\n\n        print(\"Using OpenAI models\")\n\n        # Initialize the language model configurations\n        openai_kwargs = {\n            \"api_key\": os.getenv(\"OPENAI_API_KEY\"),\n            \"temperature\": 1.0,\n            \"top_p\": 0.9,\n        }\n\n        ModelClass = (\n            OpenAIModel\n            if os.getenv(\"OPENAI_API_TYPE\") == \"openai\"\n            else AzureOpenAIModel\n        )\n        # If you are using Azure service, make sure the model name matches your own deployed model name.\n        # The default name here is only used for demonstration and may not match your case.\n        gpt_35_model_name = (\n            \"gpt-4o-mini\"\n            if os.getenv(\"OPENAI_API_TYPE\") == \"openai\"\n            else \"gpt-35-turbo\"\n        )\n        gpt_4_model_name = \"gpt-4o\"\n        if os.getenv(\"OPENAI_API_TYPE\") == \"azure\":\n            openai_kwargs[\"api_base\"] = os.getenv(\"AZURE_API_BASE\")\n            openai_kwargs[\"api_version\"] = os.getenv(\"AZURE_API_VERSION\")\n\n        # STORM is a LM system so different components can be powered by different models.\n        # For a good balance between cost and quality, you can choose a cheaper/faster model for conv_simulator_lm\n        # which is used to split queries, synthesize answers in the conversation. We recommend using stronger models\n        # for outline_gen_lm which is responsible for organizing the collected information, and article_gen_lm\n        # which is responsible for generating sections with citations.\n        conv_simulator_lm = ModelClass(\n            model=gpt_35_model_name, max_tokens=10000, **openai_kwargs\n        )\n        question_asker_lm = ModelClass(\n            model=gpt_35_model_name, max_tokens=10000, **openai_kwargs\n        )\n        outline_gen_lm = ModelClass(\n            model=gpt_4_model_name, max_tokens=10000, **openai_kwargs\n        )\n        article_gen_lm = ModelClass(\n            model=gpt_4_model_name, max_tokens=10000, **openai_kwargs\n        )\n        article_polish_lm = ModelClass(\n            model=gpt_4_model_name, max_tokens=10000, **openai_kwargs\n        )\n\n    elif model_type == \"ollama\":\n\n        print(\"Using Ollama models\")\n\n        ollama_kwargs = {\n            # \"model\": \"llama3.2:3b\",\n            \"model\": \"llama3.1:latest\",\n            # \"model\": \"qwen2.5:14b\",\n            \"port\": \"11434\",\n            \"url\": \"http://localhost\",\n            \"stop\": (\n                \"\\n\\n---\",\n            ),  # dspy uses \"\\n\\n---\" to separate examples. Open models sometimes generate this.\n        }\n\n        conv_simulator_lm = OllamaClient(max_tokens=500, **ollama_kwargs)\n        question_asker_lm = OllamaClient(max_tokens=500, **ollama_kwargs)\n        outline_gen_lm = OllamaClient(max_tokens=400, **ollama_kwargs)\n        article_gen_lm = OllamaClient(max_tokens=700, **ollama_kwargs)\n        article_polish_lm = OllamaClient(max_tokens=4000, **ollama_kwargs)\n\n    engine_lm_configs.set_conv_simulator_lm(conv_simulator_lm)\n    engine_lm_configs.set_question_asker_lm(question_asker_lm)\n    engine_lm_configs.set_outline_gen_lm(outline_gen_lm)\n    engine_lm_configs.set_article_gen_lm(article_gen_lm)\n    engine_lm_configs.set_article_polish_lm(article_polish_lm)\n\n    max_conv_turn = 4\n    max_perspective = 3\n    search_top_k = 10\n    max_thread_num = 1\n    device = \"cpu\"\n    vector_db_mode = \"offline\"\n\n    do_research = True\n    do_generate_outline = True\n    do_generate_article = True\n    do_polish_article = True\n\n    # Initialize the engine arguments\n    output_dir=f\"{STORM_OUTPUT_DIR}/{db_dir.split('db_')[1]}\"\n    print(f\"Output directory: {output_dir}\")\n\n    engine_args = STORMWikiRunnerArguments(\n        output_dir=output_dir,\n        max_conv_turn=max_conv_turn,\n        max_perspective=max_perspective,\n        search_top_k=search_top_k,\n        max_thread_num=max_thread_num,\n    )\n\n    # Setup VectorRM to retrieve information from your own data\n    rm = VectorRM(\n        collection_name=DB_COLLECTION_NAME,\n        embedding_model=EMBEDDING_MODEL,\n        device=device,\n        k=search_top_k,\n    )\n\n    # initialize the vector store, either online (store the db on Qdrant server) or offline (store the db locally):\n    if vector_db_mode == \"offline\":\n        rm.init_offline_vector_db(vector_store_path=db_dir)\n\n    # Initialize the STORM Wiki Runner\n    runner = STORMWikiRunner(engine_args, engine_lm_configs, rm)\n\n    # Set instructions for the STORM AI Research algorithm\n    runner = set_instructions(runner)\n\n    # run the pipeline\n    runner.run(\n        topic=topic,\n        do_research=do_research,\n        do_generate_outline=do_generate_outline,\n        do_generate_article=do_generate_article,\n        do_polish_article=do_polish_article,\n    )\n    runner.post_run()\n    runner.summary()\n\n    generate_markdown_article(output_dir)\n```", "```py\nquery = \"Compare the financial impact of different types of disasters and how those impact communities\"\n\nfor doc_type in [\"pages\", \"chunks\"]:\n    db_dir = f\"{DB_DIR}_{doc_type}\"\n    run_storm(query=query, model_type=\"openai\", db_dir=db_dir)\n```"]
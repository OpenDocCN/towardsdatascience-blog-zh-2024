["```py\nimport pandas as pd\nimport numpy as np\n\n# Create the dataset as a dictionary\ndata = {\n    'UVIndex': [2, 10, 1, 7, 3, 9, 5, 11, 1, 8, 3, 9, 11, 5, 7],\n    'Humidity': [15, 95, 10, 98, 18, 90, 25, 80, 95, 40, 20, 30, 85, 92, 12], \n    'WindSpeed': [2, 90, 1, 30, 3, 10, 40, 5, 60, 15, 20, 45, 25, 35, 50],\n    'RainfallAmount': [5,2,7,3,18,3,0,1,25,0,9,0,18,7,0],    \n    'Temperature': [68, 60, 63, 55, 50, 56, 57, 65, 66, 68, 71, 72, 79, 83, 81],  \n    'Crowdedness': [0.15, 0.98, 0.1, 0.85, 0.2, 0.9, 0.92, 0.25, 0.12, 0.99, 0.2, 0.8, 0.05, 0.3, 0.95]\n}\n\n# Create a DataFrame from the dictionary\ndf = pd.DataFrame(data)\n```", "```py\n# 1\\. Equal-Width Binning for UVIndex\ndf['UVIndexBinned'] = pd.cut(df['UVIndex'], bins=4, \n                             labels=['Low', 'Moderate', 'High', 'Very High'])\n```", "```py\n# 2\\. Equal-Frequency Binning for Humidity\ndf['HumidityBinned'] = pd.qcut(df['Humidity'], q=3, \n                               labels=['Low', 'Medium', 'High'])\n```", "```py\n# 3\\. Custom Binning for RainfallAmount\ndf['RainfallAmountBinned'] = pd.cut(df['RainfallAmount'], bins=[-np.inf, 2, 4, 12, np.inf], \n                                    labels=['No Rain', 'Drizzle', 'Rain', 'Heavy Rain'])\n```", "```py\n# 4\\. Logarithmic Binning for WindSpeed\ndf['WindSpeedBinned'] = pd.cut(np.log1p(df['WindSpeed']), bins=3, \n                               labels=['Light', 'Moderate', 'Strong'])\n```", "```py\n# 5\\. Standard Deviation-Based Binning for Temperature\nmean_temp, std_dev = df['Temperature'].mean(), df['Temperature'].std()\nbin_edges = [\n    float('-inf'),  # Ensure all values are captured\n    mean_temp - 2.5 * std_dev,\n    mean_temp - 1.5 * std_dev,\n    mean_temp - 0.5 * std_dev,\n    mean_temp + 0.5 * std_dev,\n    mean_temp + 1.5 * std_dev,\n    mean_temp + 2.5 * std_dev,\n    float('inf')   # Ensure all values are captured\n]\ndf['TemperatureBinned'] = pd.cut(df['Temperature'], bins=bin_edges, \n                                 labels=['Very Low', 'Low', 'Below Avg', 'Average','Above Avg', 'High', 'Very High'])\n```", "```py\n# 6\\. K-Means Binning for Crowdedness\nkmeans = KMeans(n_clusters=3, random_state=42).fit(df[['Crowdedness']])\ndf['CrowdednessBinned'] = pd.Categorical.from_codes(kmeans.labels_, categories=['Low', 'Medium', 'High'])\n```", "```py\n# Print only the binned columns\nbinned_columns = [col for col in df.columns if col.endswith('Binned')]\nprint(df[binned_columns])\n```", "```py\nimport pandas as pd\nimport numpy as np\nfrom sklearn.cluster import KMeans\n\n# Create the dataset\ndata = {\n    'UVIndex': [2, 10, 1, 7, 3, 9, 5, 11, 1, 8, 3, 9, 11, 5, 7],\n    'Humidity': [15, 95, 10, 98, 18, 90, 25, 80, 95, 40, 20, 30, 85, 92, 12], \n    'WindSpeed': [2, 90, 1, 30, 3, 10, 40, 5, 60, 15, 20, 45, 25, 35, 50],\n    'RainfallAmount': [5,2,7,3,18,3,0,1,25,0,9,0,18,7,0],    \n    'Temperature': [68, 60, 63, 55, 50, 56, 57, 65, 66, 68, 71, 72, 79, 83, 81],  \n    'Crowdedness': [0.15, 0.98, 0.1, 0.85, 0.2, 0.9, 0.92, 0.25, 0.12, 0.99, 0.2, 0.8, 0.05, 0.3, 0.95]\n}\n\n# Create a DataFrame from the dictionary\ndf = pd.DataFrame(data)\n\n# 1\\. Equal-Width Binning for UVIndex\ndf['UVIndexBinned'] = pd.cut(df['UVIndex'], bins=4, \n                             labels=['Low', 'Moderate', 'High', 'Very High'])\n\n# 2\\. Equal-Frequency Binning for Humidity\ndf['HumidityBinned'] = pd.qcut(df['Humidity'], q=3, \n                               labels=['Low', 'Medium', 'High'])\n\n# 3\\. Custom Binning for RainfallAmount\ndf['RainfallAmountBinned'] = pd.cut(df['RainfallAmount'], bins=[-np.inf, 2, 4, 12, np.inf], \n                                    labels=['No Rain', 'Drizzle', 'Rain', 'Heavy Rain'])\n\n# 4\\. Logarithmic Binning for WindSpeed\ndf['WindSpeedBinned'] = pd.cut(np.log1p(df['WindSpeed']), bins=3, \n                               labels=['Light', 'Moderate', 'Strong'])\n\n# 5\\. Standard Deviation-Based Binning for Temperature\nmean_temp, std_dev = df['Temperature'].mean(), df['Temperature'].std()\nbin_edges = [\n    float('-inf'),  # Ensure all values are captured\n    mean_temp - 2.5 * std_dev,\n    mean_temp - 1.5 * std_dev,\n    mean_temp - 0.5 * std_dev,\n    mean_temp + 0.5 * std_dev,\n    mean_temp + 1.5 * std_dev,\n    mean_temp + 2.5 * std_dev,\n    float('inf')   # Ensure all values are captured\n]\ndf['TemperatureBinned'] = pd.cut(df['Temperature'], bins=bin_edges, \n                                 labels=['Very Low', 'Low', 'Below Avg', 'Average','Above Avg', 'High', 'Very High'])\n\n# 6\\. KMeans Binning for Crowdedness\nkmeans = KMeans(n_clusters=3, random_state=42).fit(df[['Crowdedness']])\ndf['CrowdednessBinned'] = pd.Categorical.from_codes(kmeans.labels_, categories=['Low', 'Medium', 'High'])\n\n# Print only the binned columns\nbinned_columns = [col for col in df.columns if col.endswith('Binned')]\nprint(df[binned_columns])\n```"]
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Creating a WhatsApp AI Agent with GPT-4o</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Creating a WhatsApp AI Agent with GPT-4o</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/creating-a-whatsapp-ai-agent-with-gpt-4o-f0bc197d2ac0?source=collection_archive---------0-----------------------#2024-12-22">https://towardsdatascience.com/creating-a-whatsapp-ai-agent-with-gpt-4o-f0bc197d2ac0?source=collection_archive---------0-----------------------#2024-12-22</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><figure class="fr fs ft fu fv fw fo fp paragraph-image"><div role="button" tabindex="0" class="fx fy ed fz bh ga"><div class="fo fp fq"><img src="../Images/0d1193bc8f30025fc5f60982397b5141.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtZ0n0nFFWmebZTncI2sqA.jpeg"/></div></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">Created with DALL-E</figcaption></figure><div/><div><h2 id="5177" class="pw-subtitle-paragraph hh gj gk bf b hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw cq dx">How to use the Meta API to build your own LLM-powered Whatsapp chatbot</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hx hy hz ia ib ab"><div><div class="ab ic"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@lukas.kowejsza?source=post_page---byline--f0bc197d2ac0--------------------------------" rel="noopener follow"><div class="l id ie by if ig"><div class="l ed"><img alt="Lukasz Kowejsza" class="l ep by dd de cx" src="../Images/8d920478bee9ad674a6c79462128b0db.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*gH4EgquV4LSB3aBWcBvU1Q.jpeg"/><div class="ih by l dd de em n ii eo"/></div></div></a></div></div><div class="ij ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--f0bc197d2ac0--------------------------------" rel="noopener follow"><div class="l ik il by if im"><div class="l ed"><img alt="Towards Data Science" class="l ep by br in cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="ih by l br in em n ii eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="io ab q"><div class="ab q ip"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b iq ir bk"><a class="af ag ah ai aj ak al am an ao ap aq ar is" data-testid="authorName" href="https://medium.com/@lukas.kowejsza?source=post_page---byline--f0bc197d2ac0--------------------------------" rel="noopener follow">Lukasz Kowejsza</a></p></div></div></div><span class="it iu" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b iq ir dx"><button class="iv iw ah ai aj ak al am an ao ap aq ar ix iy iz" disabled="">Follow</button></p></div></div></span></div></div><div class="l ja"><span class="bf b bg z dx"><div class="ab cn jb jc jd"><div class="je jf ab"><div class="bf b bg z dx ab jg"><span class="jh l ja">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar is ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--f0bc197d2ac0--------------------------------" rel="noopener follow"><p class="bf b bg z ji jj jk jl jm jn jo jp bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="it iu" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">18 min read</span><div class="jq jr l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Dec 22, 2024</span></div></span></div></span></div></div></div><div class="ab cp js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh"><div class="h k w ea eb q"><div class="kx l"><div class="ab q ky kz"><div class="pw-multi-vote-icon ed jh la lb lc"><div class=""><div class="ld le lf lg lh li lj am lk ll lm lc"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l ln lo lp lq lr ls lt"><p class="bf b dy z dx"><span class="le">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao ld lw lx ab q ee ly lz" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lv"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count lu lv">2</span></p></button></div></div></div><div class="ab q ki kj kk kl km kn ko kp kq kr ks kt ku kv kw"><div class="ma k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al mb an ao ap ix mc md me" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep mf cn"><div class="l ae"><div class="ab cb"><div class="mg mh mi mj mk gb ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al mb an ao ap ix ml mm lz mn mo mp mq mr s ms mt mu mv mw mx my u mz na nb"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al mb an ao ap ix ml mm lz mn mo mp mq mr s ms mt mu mv mw mx my u mz na nb"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al mb an ao ap ix ml mm lz mn mo mp mq mr s ms mt mu mv mw mx my u mz na nb"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><p id="12ba" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A game-changer in the field of AI and business management is the integration of AI agents with widely used communication tools. Think of having a familiar chat interface with real-time data requests, updates, and task automation, all made possible by direct WhatsApp interaction with your business’s management or personal assistant AI.</p><p id="fe03" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this third part of our series on creating an AI-powered business manager, I will walk you through the steps of connecting your AI agent to WhatsApp to increase its capabilities and reach. The goal to achieve is an AI Assistant capable of interacting with all your relevant database tables and even creating a table and all necessary tools on its own. As a primary showcase, I focus on a business use case like tracking expenses, invoices, and so on. However you can easily adapt the same logic to create, for example a Personal Assistant that keeps track of your tasks, projects, and ideas.</p><p id="be40" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This is the third part of my series. Before we start, for everyone waiting, I apologize for the long delay. I’ve been busy in the last few months starting a new AI Software Engineering job and adapting to the new work-life balance. I have prepared some future parts of this article so far, and we will explore major changes in the agent workflow, along with more sophisticated workflows featuring several additional features. Some workarounds used in the first two articles were necessary for reliable tool calling at that time but are no longer needed due to better-performing models like GPT-4o and GPT-4o-mini. I would still recommend starting with the first two parts if you are new to tool calling and agent workflow development. I find it useful to understand how to build something from scratch before relying on frameworks like LangChain or, more specifically, LangGraph for deeply customizable Agent Workflows (which I will introduce in the near future).</p><p id="ceee" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">For now, we have to step back and focus on the infrastructure first. I think in most projects, especially in AI Software Projects, it is good practice to initially create a working end-to-end product before getting lost in feature creep. I often find myself overthinking initial design choices and developing a too-complex product in my mind. To overcome this, focusing on building a working end-to-end product within a few days of development time really helps to establish a clear foundation. After that, you will know which features to prioritize and will be able to gather initial feedback. This kickstarts an incremental development process, which is always my goal when I commit to a project.</p><h1 id="a578" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">Recap of Previous Parts</h1><p id="14eb" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">We established the foundation for our AI-powered business manager in earlier installments of this series:</p><ul class=""><li id="3d25" class="nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx oz pa pb bk"><a class="af pc" rel="noopener" target="_blank" href="/leverage-openai-tool-calling-building-a-reliable-ai-agent-from-scratch-4e21fcd15b62"><strong class="ne gl">Part 1</strong></a>: The goal was to develop a prototype agent workflow that could interact with tool objects and reduce hallucinations in tool arguments produced by the underlying language model (LLM).</li><li id="303d" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><a class="af pc" rel="noopener" target="_blank" href="/building-an-ai-powered-business-manager-e2a31a2fe984"><strong class="ne gl">Part 2</strong></a>: We concentrated on defining basic features, organizing the project repository, and building a database schema with SQLModel. We also added SQL tools for data addition and querying and updated the Tool class to accommodate SQLModel objects. Furthermore, we presented a TaskAgent class for automating agent startup and set up an OpenAIAgent for context-aware tool usage.</li></ul><h1 id="f849" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">Scope for This Article</h1><p id="4432" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">As usual, let us begin by defining the scope of this article:</p><ol class=""><li id="1bd7" class="nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx pi pa pb bk"><strong class="ne gl">Integrate the AI Agent with WhatsApp Using MetaAPI<br/></strong>Set up and configure MetaAPI for WhatsApp Business integration.<br/>Ensure the AI agent can send and receive messages through WhatsApp.</li><li id="7894" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk"><strong class="ne gl">Set Up Webhooks and Run Locally Using Ngrok<br/></strong>Create a FastAPI application to handle webhook events from WhatsApp.<br/>Use ngrok to expose the local FastAPI server to the internet.<br/>Configure MetaAPI to send webhook events to the ngrok URL</li></ol><p id="777d" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Since we are moving forward to a deployable server, we also need to adjust our project architecture. We are essentially implementing a FastAPI server, and therefore, my preferred choice of repository structure is Domain-Driven Design (DDD) or rather leaning towards DDD. (You can check the Repo structure <a class="af pc" href="https://github.com/elokus/WhatsappAgent" rel="noopener ugc nofollow" target="_blank">here</a>)</p><h1 id="60b1" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">1. Set up WhatsApp Cloud API</h1><p id="ecca" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">First of all, you need to get familiar with the Cloud API provided by Meta. You can achieve the same results using SaaS products like Twilio, which offer a more user-friendly integration. However, due to the recent data breach and for cost-efficiency reasons, I prefer using the root API provided by Meta.</p><h1 id="b338" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">1.1 Prerequisites</h1><ol class=""><li id="6cb1" class="nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx pi pa pb bk">Before you begin, you will need to register a Meta developer account by following these steps: <a class="af pc" href="https://developers.facebook.com/docs/development/register" rel="noopener ugc nofollow" target="_blank">How to open a Meta developer account</a>. During this registration process, you will need to verify yourself using a phone number. Note that this will not be the phone number of your final WhatsApp client. Instead, you will get a test phone number assigned by the platform, which can later be changed to another phone number.</li><li id="66f8" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">After registration, go to your dashboard and create an app.</li><li id="ce4a" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">Moreover, you will need a Meta Business Account (MBA) that will be associated with your real account, or you can create a new one to link to your MBA. You can also skip this, as you will be automatically prompted to link or create an MBA in the next step.</li></ol><h1 id="d889" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">1.2 Add WhatsApp Product to Your App</h1><p id="508d" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">After you have created an app inside your Meta developer account, you will be asked to add products to it. Here you have to choose WhatsApp and follow the setup process. If you haven’t done so, create a Meta Business Account here. Once you are done, you will have a test WhatsApp Business Account and a test phone number.</p><h1 id="e256" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">1.3 Add a Recipient Number</h1><ol class=""><li id="bce3" class="nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx pi pa pb bk">In the left-hand menu of the App Dashboard, navigate to <br/><strong class="ne gl">WhatsApp</strong> &gt; <strong class="ne gl">API Setup</strong><br/>There under <strong class="ne gl">Send and receive messages</strong>, select the <strong class="ne gl">To</strong> field and choose <strong class="ne gl">Manage phone number list</strong>. Here, you can add a phone number that is allowed to send and receive messages from your test phone number. This should ideally be your own phone number as you want to test your application. Before you link this WhatsApp API Account to a real number, you will only be able to add up to 5 recipient numbers.</li><li id="9177" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">In <code class="cx pj pk pl pm b">WhatsApp &gt; API Setup</code>, you can now send a test message by filling in the <code class="cx pj pk pl pm b">from</code> field with your test phone number and the <code class="cx pj pk pl pm b">to</code> field with your recipient number (your own phone number).</li><li id="eb08" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">Generate an access token. This is your <code class="cx pj pk pl pm b">WHATSAPP_API_TOKEN</code>, which we will need later in step 6.</li></ol><figure class="po pp pq pr ps fw fo fp paragraph-image"><div role="button" tabindex="0" class="fx fy ed fz bh ga"><div class="fo fp pn"><img src="../Images/6790dd7e097200fd38c229e5372fc718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yy6n2NdwO6CrSL2njWj-7g.png"/></div></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">Screenshot ngrok (Image by Author)</figcaption></figure></div></div></div><div class="ab cb pt pu pv pw" role="separator"><span class="px by bm py pz qa"/><span class="px by bm py pz qa"/><span class="px by bm py pz"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="94a1" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We have successfully set up the Cloud API as required. In the next step we will create a Webhook that will enable communication with our AI Assistant application.</p><p id="0107" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To achieve this, we need to create and serve an endpoint in our backend application. This means our Python backend must be accessible through a URL. This URL will act as the Webhook endpoint that the AI Assistant can call to send and receive data.</p><h1 id="9d3b" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">2. Creating a FastAPI Endpoint</h1><p id="a363" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">To be accepted by the Webhook, our root endpoint must verify a specific GET request that will be sent by the webhook when adding our URL. The webhook will send three query parameters:</p><p id="68d0" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><code class="cx pj pk pl pm b">hub.mode</code>, <code class="cx pj pk pl pm b">hub.challenge</code>, <code class="cx pj pk pl pm b">hub.verify.token</code>.</p><p id="391d" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The verification token is defined when creating the webhook in Cloud API. Your backend should verify that this token matches what you have defined and return the <code class="cx pj pk pl pm b">hub.challenge</code> object as a response. Make sure to install FastAPI and Uvicorn using <code class="cx pj pk pl pm b">pip install fastapi uvicorn</code> first.</p><h1 id="bfd3" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">2.1 Create main.py</h1><p id="70b2" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Create a file named <code class="cx pj pk pl pm b">main.py</code> with the following content:</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="f30e" class="qe nz gk pm b bg qf qg l qh qi">from fastapi import FastAPI, Query, HTTPException<br/><br/><br/>VERIFICATION_TOKEN = "abcdefg12345"<br/><br/>app = FastAPI()<br/><br/><br/>@app.get("/")<br/>def verify_whatsapp(<br/>    hub_mode: str = Query("subscribe", description="The mode of the webhook", alias="hub.mode"),<br/>    hub_challenge: int = Query(..., description="The challenge to verify the webhook", alias="hub.challenge"),<br/>    hub_verify_token: str = Query(..., description="The verification token", alias="hub.verify_token"),<br/>):<br/>    if hub_mode == "subscribe" and hub_verify_token == VERIFICATION_TOKEN:<br/>        return hub_challenge<br/>    raise HTTPException(status_code=403, detail="Invalid verification token")<br/><br/><br/>@app.get("/health")<br/>def health():<br/>    return {"status": "healthy"}<br/><br/><br/>@app.get("/readiness")<br/>def readiness():<br/>    return {"status": "ready"}</span></pre><p id="825d" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In the third line, you can define a <code class="cx pj pk pl pm b">VERIFICATION_TOKEN</code> that is used later by the webhook to verify that the backend is under your control. In this case, we have defined it as <code class="cx pj pk pl pm b">"abcdefg12345"</code>, but you can define a custom token of your own.</p><p id="ee94" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">I’ll continue correcting the remaining sections and include the next part shortly!</p><h1 id="fb12" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">2.2 Run the Application</h1><p id="8faf" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Run the application using Uvicorn:</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="cc53" class="qe nz gk pm b bg qf qg l qh qi">uvicorn main:app --reload</span></pre><h1 id="89cb" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">2.3 Serve Your API Locally</h1><p id="713e" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Your backend now runs locally on <code class="cx pj pk pl pm b">http://localhost:8000</code> and/or <code class="cx pj pk pl pm b">http://127.0.0.1:8000</code>.</p><p id="1d3d" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We are now serving the following endpoints:</p><ul class=""><li id="3db7" class="nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx oz pa pb bk">Verify WhatsApp webhook: <code class="cx pj pk pl pm b"><a class="af pc" href="http://127.0.0.1:8000/?hub.mode=subscribe&amp;hub.challenge=1234&amp;hub.verify_token=abcdefg12345" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/?hub.mode=subscribe&amp;hub.challenge=1234&amp;hub.verify_token=abcdefg12345</a></code></li><li id="e67a" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk">Health endpoint: <code class="cx pj pk pl pm b"><a class="af pc" href="http://127.0.0.1:8000/health" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/health</a></code></li><li id="c9f3" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk">Readiness endpoint: <code class="cx pj pk pl pm b"><a class="af pc" href="http://127.0.0.1:8000/readiness" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8000/readiness</a></code></li></ul><p id="0a0d" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">You can use the health endpoint to check if your application is running. Open <code class="cx pj pk pl pm b">http://127.0.0.1:8000/health</code> in your browser, and you should see: <code class="cx pj pk pl pm b">{"status": "healthy"}</code></p></div></div></div><div class="ab cb pt pu pv pw" role="separator"><span class="px by bm py pz qa"/><span class="px by bm py pz qa"/><span class="px by bm py pz"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="f3b3" class="ny nz gk bf oa ob qj hk od oe qk hn og oh ql oj ok ol qm on oo op qn or os ot bk">3. Run a Proxy Server with Ngrok</h1><p id="c5fd" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Since our server is running locally, the WhatsApp Webhook cannot call the endpoint for verification. What we need is a public URL that can be used by the webhook. There are two options: deploy the application to a cloud server or create a proxy server tunnel. Since we are still in the development process, we will use the second option.</p><ol class=""><li id="c565" class="nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx pi pa pb bk">Go to <a class="af pc" href="https://dashboard.ngrok.com/signup" rel="noopener ugc nofollow" target="_blank">ngrok Signup</a> and create a free account.</li><li id="0586" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">Install ngrok locally. Depending on your system, you can use Brew, Chocolatey, or simply download and install it. See: <a class="af pc" href="https://dashboard.ngrok.com/get-started/setup" rel="noopener ugc nofollow" target="_blank">Setup &amp; Installation</a>.</li><li id="65d6" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">After installation, add your authentication code using the following command in your terminal. Replace <code class="cx pj pk pl pm b">$YOUR-AUTHENTICATION_TOKEN</code> with your ngrok authentication token, which can be found under "Your Authtoken" in the ngrok dashboard.</li><li id="8ee2" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">Begin forwarding traffic from your localhost on port 8000 by running the following command in your terminal:</li></ol><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="38d2" class="qe nz gk pm b bg qf qg l qh qi">&gt; ngrok config add-authtoken $YOUR-AUTHENTICATION_TOKEN<br/>&gt; ngrok http http://localhost:8000<br/><br/>Forwarding                    https://&lt;random-string&gt;.ngrok.io -&gt; http://localhost:8000</span></pre><p id="65c6" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Your local server is now accessible via public URLs provided by ngrok. You should see something like this:</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="3718" class="qe nz gk pm b bg qf qg l qh qi">Forwarding                    https://&lt;random-string&gt;.ngrok.io -&gt; http://localhost:8000</span></pre><p id="d41d" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Use the HTTPS URL provided by ngrok for the webhook configuration.</p><h1 id="d567" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">4. Implementing the Webhook</h1><p id="b1ad" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Now let us return to Meta’s Cloud API to implement the desired webhook.</p><ol class=""><li id="1593" class="nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx pi pa pb bk">Navigate to <a class="af pc" href="https://developers.facebook.com/apps/" rel="noopener ugc nofollow" target="_blank">Meta for Developers</a> and select the app created before.</li><li id="b051" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">In the left-hand menu go to <strong class="ne gl">WhatsApp</strong> &gt; <strong class="ne gl">Configuration</strong>.</li><li id="1d13" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">In the <strong class="ne gl">Webhook</strong> section paste your ngrok HTTPS forwarding URL into the <strong class="ne gl">Callback URL</strong> field and enter the <code class="cx pj pk pl pm b">VERIFICATION_TOKEN</code> defined in <code class="cx pj pk pl pm b">main.py</code> into the <strong class="ne gl">Verification Token</strong> field.</li><li id="e777" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">Click the confirm and save button and wait for the webhook to verify your backend.</li><li id="7dd0" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx pi pa pb bk">In the section <strong class="ne gl">Webhook Fields</strong> enable the <code class="cx pj pk pl pm b">messages</code> toggle under <strong class="ne gl">Subscribed Fields</strong>.</li></ol><p id="07c4" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">That’s it! You should now be able to receive WhatsApp messages in your Python backend server.</p><h1 id="3122" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">4.1 Understanding Webhooks and Conversations</h1><p id="f7d4" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Webhooks are HTTP callbacks that enable programs to receive real-time updates when certain events occur such as a new message or a status change. Webhooks make system integrations and automation possible by delivering an HTTP request containing event data to a pre-configured URL (in our case the ngrok proxy server url).</p><p id="bf6c" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To understand the logic and pricing behind webhooks in the Meta cosmos it is helpful to understand some basic principles about conversations.</p><p id="ff6f" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A ‘conversation’ on WhatsApp API starts when:<br/><strong class="ne gl">1. The User sends a message</strong>: This opens a 24-hour window, during which you can reply with messages including text, images, or other media <strong class="ne gl">without additional costs</strong>.</p><p id="d73a" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><strong class="ne gl">2. The Business Initiates Contact</strong>: If no user message has been received recently (no open 24-hour window), your AI assistant must use a <strong class="ne gl">pre-approved template message</strong> to start the conversation. You can add custom templates but they need to be approved by Meta.</p><p id="83dc" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As long as the user keeps replying, the 24-hour window resets with each new message. This makes it possible to have continuous interaction without additional costs. A Conversation costs about 0.00–0.08 USD. The concrete pricing is based on you conversation type Marketing, Utility, Service and your location. FYI: Service Conversations seem to be nowadays for free. You can find the concrete pricing here: <a class="af pc" href="https://developers.facebook.com/docs/whatsapp/pricing" rel="noopener ugc nofollow" target="_blank">Whatsapp Pricing</a></p><h1 id="0e26" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">5. Build a Receive Message Endpoint</h1><p id="70ca" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Now we are able to receive messages in our backend. Since we have subscribed to message objects, each time a message is sent to your test number, the webhook will create a POST request to the callback URL that you defined in the previous step. What we need to do next is to build an endpoint for POST requests in our FastAPI application.</p><p id="bd3f" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let us first define the requirements:</p><ul class=""><li id="7116" class="nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx oz pa pb bk"><strong class="ne gl">Return a 200 HTTP Status Code:</strong> This is essential to inform CloudAPI that the message has been received successfully. Failing to do so will cause CloudAPI to retry sending the message for up to 7 days.</li><li id="2233" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">Extract Phone Number and Message:</strong> The payload of the incoming request contains data that includes the phone number and the message. Which we need to process in the backend.</li><li id="3496" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">Filter Incoming Objects:</strong> Since CloudAPI might send multiple events for the same message (such as sent, received, and read), the backend needs to ensures that only one instance of the message is processed.</li><li id="0be8" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">Handle Multiple Message Types:</strong> The backend can handle different types of messages, such as text, voice messages, and images. In order to not spread the scope of the artice we will only lay the foundation for images but not implement it to the end.</li><li id="db4e" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">Process with LLM-Agent Workflow:</strong> The extracted information is processed using the LLM-Agent workflow, which we have developed with previous parts of this series. You can also use another agentic implementation, e.g. Langchain or Langgraph</li></ul><h1 id="0d26" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">5.1 Define Models and Schemas</h1><p id="2ba4" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">We will receive a payload from a webhook. You can find example payloads in Meta’s documentation: <a class="af pc" href="https://developers.facebook.com/docs/whatsapp/cloud-api/webhooks/payload-examples/" rel="noopener ugc nofollow" target="_blank">Example Payload</a></p><p id="f4fd" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">I prefer to write my code with Pydantic to add type safety to my Python code. Moreover, type annotations and Pydantic are an optimal match for FastAPI applications. So, let’s first define the models used in our endpoint:</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="881e" class="qe nz gk pm b bg qf qg l qh qi"># app/schema.py<br/>from typing import List, Optional  <br/>from pydantic import BaseModel, Field   <br/><br/><br/>class Profile(BaseModel):  <br/>    name: str  <br/><br/>class Contact(BaseModel):  <br/>    profile: Profile  <br/>    wa_id: str  <br/><br/>class Text(BaseModel):  <br/>    body: str<br/><br/>class Image(BaseModel):  <br/>    mime_type: str  <br/>    sha256: str  <br/>    id: str  <br/><br/>class Audio(BaseModel):  <br/>    mime_type: str  <br/>    sha256: str  <br/>    id: str  <br/>    voice: bool  <br/><br/>class Message(BaseModel):  <br/>    from_: str = Field(..., alias="from")  <br/>    id: str  <br/>    timestamp: str  <br/>    text: Text | None = None  <br/>    image: Image | None = None  <br/>    audio: Audio | None = None  <br/>    type: str<br/><br/>class Metadata(BaseModel):  <br/>    display_phone_number: str  <br/>    phone_number_id: str<br/><br/>class Value(BaseModel):  <br/>    messaging_product: str  <br/>    metadata: Metadata  <br/>    contacts: List[Contact] | None = None  <br/>    messages: List[Message] | None = None  <br/><br/>class Change(BaseModel):  <br/>    value: Value  <br/>    field: str  <br/>    statuses: List[dict] | None = None  <br/><br/>class Entry(BaseModel):  <br/>    id: str  <br/>    changes: List[Change]  <br/><br/>class Payload(BaseModel):  <br/>    object: str  <br/>    entry: List[Entry]<br/><br/>class User(BaseModel):  <br/>    id: int  <br/>    first_name: str  <br/>    last_name: str  <br/>    phone: str<br/>    role: str<br/><br/>class UserMessage(BaseModel):  <br/>    user: User  <br/>    message: str | None = None  <br/>    image: Image | None = None  <br/>    audio: Audio | None = None</span></pre><h1 id="4323" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">5.2 Parse Incoming Messages</h1><p id="5ab5" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Next, we are going to create some helper functions for using dependency injection in FastAPI:</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="0563" class="qe nz gk pm b bg qf qg l qh qi"># app/main.py<br/><br/>from app.domain import message_service<br/><br/>def parse_message(payload: Payload) -&gt; Message | None:  <br/>    if not payload.entry[0].changes[0].value.messages:  <br/>        return None  <br/>    return payload.entry[0].changes[0].value.messages[0]  <br/><br/>def get_current_user(message: Annotated[Message, Depends(parse_message)]) -&gt; User | None:  <br/>    if not message:  <br/>        return None  <br/>    return message_service.authenticate_user_by_phone_number(message.from_)  <br/><br/>def parse_audio_file(message: Annotated[Message, Depends(parse_message)]) -&gt; Audio | None:  <br/>    if message and message.type == "audio":  <br/>        return message.audio  <br/>    return None  <br/><br/>def parse_image_file(message: Annotated[Message, Depends(parse_message)]) -&gt; Image | None:  <br/>    if message and message.type == "image":  <br/>        return message.image  <br/>    return None  <br/><br/>def message_extractor(  <br/>        message: Annotated[Message, Depends(parse_message)],  <br/>        audio: Annotated[Audio, Depends(parse_audio_file)],  <br/>):  <br/>    if audio:  <br/>        return message_service.transcribe_audio(audio)  <br/>    if message and message.text:  <br/>        return message.text.body  <br/>    return None</span></pre><ul class=""><li id="b5d8" class="nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx oz pa pb bk"><strong class="ne gl">Parsing the Payload:</strong> The <code class="cx pj pk pl pm b">parse_message</code> function extracts the first message from the incoming payload if it exists. This function returns <code class="cx pj pk pl pm b">None</code> if no messages are found, so that only valid messages are processed.</li><li id="2ae0" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">User Authentication:</strong> The <code class="cx pj pk pl pm b">get_current_user</code> function uses the <code class="cx pj pk pl pm b">parse_message</code> dependency injection to extract the message and then authenticates the user based on the phone number associated with the message. Here we ensure that only authenticated users are allowed to send messages.</li><li id="12da" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">Audio and Image Parsing:</strong> These functions extract audio or image files from the message if the message type is “audio” or “image,” respectively. This allows the application to handle different types of media.</li><li id="1620" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">Message Extraction:</strong> The <code class="cx pj pk pl pm b">message_extractor</code> function attempts to extract text from the message or transcribe audio into text. This ensures that regardless of the message type, the content can be processed.</li></ul><p id="56a5" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Here we have one import from our domain layer. The whole script <code class="cx pj pk pl pm b">message_service</code> is where we place all domain-specific code for this implementation, such as <code class="cx pj pk pl pm b">authenticate_user_by_phone_number</code> and <code class="cx pj pk pl pm b">transcribe_audio</code>.</p><h1 id="e309" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">5.3 Implementing the POST Endpoint</h1><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="ebbb" class="qe nz gk pm b bg qf qg l qh qi"># app/main.py<br/>import threading  <br/>from typing_extensions import Annotated  <br/>from fastapi import APIRouter, Query, HTTPException, Depends  <br/>from app.domain import message_service  <br/>from app.schema import Payload, Message, Audio, Image, User  <br/><br/># ... rest of the code ...<br/><br/>@app.post("/", status_code=200)  <br/>def receive_whatsapp(  <br/>        user: Annotated[User, Depends(get_current_user)],  <br/>        user_message: Annotated[str, Depends(message_extractor)],  <br/>        image: Annotated[Image, Depends(parse_image_file)],  <br/>):  <br/>    if not user and not user_message and not image:  <br/>        return {"status": "ok"}  <br/>    if not user:  <br/>        raise HTTPException(status_code=401, detail="Unauthorized")  <br/>    if image:  <br/>        return print("Image received")  <br/>    if user_message:  <br/>        thread = threading.Thread(<br/>            target=message_service.respond_and_send_message, <br/>            args=(user_message, user)<br/>        )  <br/>        thread.daemon = True  <br/>        thread.start()  <br/>    return {"status": "ok"}</span></pre><ul class=""><li id="c6c0" class="nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx oz pa pb bk"><strong class="ne gl">POST Endpoint Implementation:</strong> This endpoint handles the incoming POST request. It checks if the user, message, or image is valid. If none are valid, it simply returns a status message to CloudAPI. If the user is not authenticated, it raises an <code class="cx pj pk pl pm b">HTTPException</code> with a 401 status code.</li><li id="6eb0" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">Processing Images and Messages:</strong> If an image is received, we make a simple stdout print as a placeholder for future image handling. If a text message is received, it is processed asynchronously using a separate thread to avoid blocking the main application thread. The <code class="cx pj pk pl pm b">message_service.respond_and_send_message</code> function is invoked to handle the message according to the LLM-Agent workflow.</li></ul><p id="5755" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><strong class="ne gl">Explanation for Using Thread Pooling for the Webhook:</strong> WhatsApp will resend the webhook until it gets a 200 response, so thread pooling is used to ensure that message handling doesn’t block the webhook response.</p><h1 id="690d" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">6 Message Services</h1><p id="e306" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">In our presentation layer where we previously defined our endpoint, we use some <code class="cx pj pk pl pm b">message_service</code> functions that need to be defined next. Specifically, we need an implementation for processing and transcribing audio payloads, authenticating users, and finally invoking our agent and sending a response back. We will place all this functionality inside <code class="cx pj pk pl pm b">domain/message_service.py</code>. In production settings, as your application grows, I would recommend splitting them further down into, e.g., <code class="cx pj pk pl pm b">transcription_service.py</code>, <code class="cx pj pk pl pm b">message_service.py</code>, and <code class="cx pj pk pl pm b">authentication_service.py</code>.</p><p id="7428" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In multiple functions in this section, we will make requests to the Meta API <code class="cx pj pk pl pm b">"https://graph.facebook.com/..."</code>. In all of these requests, we need to include authorization headers with <code class="cx pj pk pl pm b">WHATSAPP_API_KEY</code>, which we created in <strong class="ne gl">step 1.3</strong>, as the bearer token. I usually store API keys and tokens in an <code class="cx pj pk pl pm b">.env</code> file and access them with the Python <code class="cx pj pk pl pm b">dotenv</code> library. We also use the OpenAI client with your <code class="cx pj pk pl pm b">OPENAI_API_KEY</code>, which could also be stored in the <code class="cx pj pk pl pm b">.env</code> file.</p><p id="1d1e" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">But for simplicity, let’s just place and initialize them at the top of <code class="cx pj pk pl pm b">message_service.py</code> scripts as follows:</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="e406" class="qe nz gk pm b bg qf qg l qh qi">import os  <br/>import json  <br/>import requests  <br/>from typing import BinaryIO<br/><br/>WHATSAPP_API_KEY = "YOUR_ACCESS_TOKEN"<br/>llm = OpenAI(api_key="YOUR_OPENAI_API_KEY")</span></pre><p id="c4f5" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Replace “YOUR_ACCESS_TOKEN” with your actual access token that you created in step 1.3.</p><h1 id="a579" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">6.1 Processing and Transcribing Audio Files</h1><p id="f7ae" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Handling voice records from a WhatsApp webhook is not as straightforward as it may seem. First of all, it is important to know that the incoming webhook only tells us the data type and an object ID. So it does not contain the binary audio file. We first have to download the audio file using Meta’s Graph API. To download our received audio, we need to make two sequential requests. The first one is a GET request with the <code class="cx pj pk pl pm b">object_id</code> to obtain the download URL. This download URL is the target of our second GET request.</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="864b" class="qe nz gk pm b bg qf qg l qh qi">def download_file_from_facebook(file_id: str, file_type: str, mime_type: str) -&gt; str | None:  <br/>    # First GET request to retrieve the download URL  <br/>    url = f"https://graph.facebook.com/v19.0/{file_id}"  <br/>    headers = {"Authorization": f"Bearer {WHATSAPP_API_KEY}"}  <br/>    response = requests.get(url, headers=headers)<br/>    if response.status_code == 200:  <br/>            download_url = response.json().get('url')  <br/>            # Second GET request to download the file  <br/>            response = requests.get(download_url, headers=headers)  <br/>            if response.status_code == 200:<br/>                # Extract file extension from mime_type    <br/>                file_extension = mime_type.split('/')[-1].split(';')[0]<br/>                # Create file_path with extension<br/>                file_path = f"{file_id}.{file_extension}"  <br/>                with open(file_path, 'wb') as file:  <br/>                    file.write(response.content)  <br/>                if file_type == "image" or file_type == "audio":  <br/>                    return file_path  <br/>            raise ValueError(f"Failed to download file. Status code: {response.status_code}")  <br/>        raise ValueError(f"Failed to retrieve download URL. Status code: {response.status_code}")</span></pre><p id="693a" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Here, we basically get the download URL and download the file to the file system using the object ID and the file extension as its <code class="cx pj pk pl pm b">file_path</code>. If something fails, we raise a <code class="cx pj pk pl pm b">ValueError</code> that indicates where the error occurred.</p><p id="8d6d" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Next, we simply define a function that takes the audio binary and transcribes it using Whisper:</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="9b72" class="qe nz gk pm b bg qf qg l qh qi">def transcribe_audio_file(audio_file: BinaryIO) -&gt; str:  <br/>    if not audio_file:  <br/>        return "No audio file provided"  <br/>    try:  <br/>        transcription = llm.audio.transcriptions.create(  <br/>            file=audio_file,  <br/>            model="whisper-1",  <br/>            response_format="text"  <br/>        )  <br/>        return transcription  <br/>    except Exception as e:  <br/>        raise ValueError("Error transcribing audio") from e</span></pre><p id="00db" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">And finally, let’s bring the download and transcription functions together:</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="42ea" class="qe nz gk pm b bg qf qg l qh qi">def transcribe_audio(audio: Audio) -&gt; str:  <br/>    file_path = download_file_from_facebook(audio.id, "audio", audio.mime_type)  <br/>    with open(file_path, 'rb') as audio_binary:  <br/>        transcription = transcribe_audio_file(audio_binary)  <br/>    try:  <br/>        os.remove(file_path)  <br/>    except Exception as e:  <br/>        print(f"Failed to delete file: {e}")  <br/>    return transcription</span></pre><h1 id="8d04" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">6.2 Authenticate Users</h1><p id="dc4c" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">While using the test number provided by Meta, we have to predefine which numbers our chatbot can send messages to. I am not quite sure and have not tested if any number can send a message to our chatbot. But anyway, as soon as we switch to a custom number, we don’t want anyone to be able to execute our agent chatbot. So we need a method to authenticate the user. We have several options to do this. First of all, we have to think of where to store user information. We could use, for example, a database like PostgreSQL or a non-relational database like Firestore. We can predefine our users in the file system in a JSON file or in an <code class="cx pj pk pl pm b">.env</code> file. For this tutorial, I will go with the simplest way and hardcode the user within a list in our authentication function.</p><p id="2586" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A list entry has the structure of the <code class="cx pj pk pl pm b">User</code> model as defined in <strong class="ne gl">step 5.1</strong>. So a user consists of an ID, first name, last name, and phone number. We have not implemented a role system in our agent workflow yet. But in most use cases with different users, such as in the example case of a small business assistant, different users will have different rights and access scopes. For now, we just pass <code class="cx pj pk pl pm b">"default"</code> as a placeholder role.</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="a48d" class="qe nz gk pm b bg qf qg l qh qi">def authenticate_user_by_phone_number(phone_number: str) -&gt; User | None:  <br/>    allowed_users = [  <br/>        {"id": 1, "phone": "+1234567890", "first_name": "John", "last_name": "Doe", "role": "default"},  <br/>        {"id": 2, "phone": "+0987654321", "first_name": "Jane", "last_name": "Smith", "role": "default"}  <br/>    ]    <br/>    for user in allowed_users:  <br/>        if user["phone"] == phone_number:  <br/>            return User(**user)  <br/>    return None</span></pre><p id="8dd9" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">So just verify if the phone number is in our list of <code class="cx pj pk pl pm b">allowed_users</code> and return the user if it is. Otherwise, we return <code class="cx pj pk pl pm b">None</code>. If you look at our endpoint in <strong class="ne gl">step 5.3</strong>, you will see we raise an error if the user is <code class="cx pj pk pl pm b">None</code> to prevent further processing of unauthorized user messages.</p><h1 id="6e7f" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">6.3 Send Message</h1><p id="0d5f" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Now, our last helper function before we can actually invoke our agent is <code class="cx pj pk pl pm b">send_whatsapp_message</code>. I have included two modes into this function because of some Meta-specific WhatsApp API logic.</p><p id="e07c" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Basically, you are not allowed to send a custom message to a user as a conversation starter. This means you can respond with an individual text message if the user starts the conversation and writes a message to the chatbot first. Otherwise, if you want the chatbot to initiate a conversation, you are limited to approved templates, like the “Hello World” template.</p><p id="129f" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Also important to mention, when we talk about Meta logic, a conversation after being started opens a conversation window of 24 hours in which you can send messages to that user. This conversation window is also what gets charged, not the individual message. It gets a bit more complex based on the type of conversation, such as marketing, support, etc.</p><p id="0566" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">You can also define a template on your own and let it be approved by Meta. I have not done that at this point, so to test if we can send a message from our backend to a user, I use the “Hello World” template. If you add some custom approved templates, you can also use this function to send them to the user.</p><p id="1b38" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">So back to the code. To send a message, we make a POST request and define a payload that either includes the text body or the template:</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="653a" class="qe nz gk pm b bg qf qg l qh qi">def send_whatsapp_message(to, message, template=True):  <br/>    url = f"https://graph.facebook.com/v18.0/289534840903017/messages"  <br/>    headers = {  <br/>        "Authorization": f"Bearer " + WHATSAPP_API_KEY,  <br/>        "Content-Type": "application/json"  <br/>    }  <br/>    if not template:  <br/>        data = {  <br/>            "messaging_product": "whatsapp",  <br/>            "preview_url": False,  <br/>            "recipient_type": "individual",  <br/>            "to": to,  <br/>            "type": "text",  <br/>            "text": {  <br/>                "body": message  <br/>            }  <br/>        }  <br/>    else:  <br/>        data = {  <br/>            "messaging_product": "whatsapp",  <br/>            "to": to,  <br/>            "type": "template",  <br/>            "template": {  <br/>                "name": "hello_world",  <br/>                "language": {  <br/>                    "code": "en_US"  <br/>                }  <br/>            }  <br/>        }  <br/><br/>    response = requests.post(url, headers=headers, data=json.dumps(data))  <br/>    return response.json()</span></pre><h1 id="6b15" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">6.4 Invoke Our Agent</h1><p id="e977" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Finally, we can integrate our agent from our previous examples. At this stage, you can also integrate your custom agent, a Langchain <code class="cx pj pk pl pm b">AgentExecutor</code>, Langgraph <code class="cx pj pk pl pm b">AgentWorkflow</code>, etc.</p><p id="3844" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">So our main function that will be called on each incoming message is <code class="cx pj pk pl pm b">respond_and_send_message</code>, which takes the <code class="cx pj pk pl pm b">user_message</code> string and passes it to our agent workflow as the input object.</p><pre class="po pp pq pr ps qb pm qc bp qd bb bk"><span id="bdc5" class="qe nz gk pm b bg qf qg l qh qi"># app/domain/message_service.py<br/>import json  <br/>import requests<br/>from app.domain.agents.routing_agent import RoutingAgent  <br/>from app.schema import User  <br/><br/>def respond_and_send_message(user_message: str, user: User):  <br/>    agent = RoutingAgent()  <br/>    response = agent.run(user_message, user.id)  <br/>    send_whatsapp_message(user.phone, response, template=False)</span></pre><p id="af7d" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">After invoking our agent, we get a response message that we want to send back to the user using the send_whatsapp_message function.</p></div></div></div><div class="ab cb pt pu pv pw" role="separator"><span class="px by bm py pz qa"/><span class="px by bm py pz qa"/><span class="px by bm py pz"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="8a8c" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now you should be able to send messages to the test number and get answer by the agent executor. <strong class="ne gl">Remark</strong>: While using the Whatsapp test number you have to register phone numbers that are allowed to send messages to your bot in you Meta API app.</p><p id="20ba" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">By following this guide, you’ve taken a big step toward creating a strong LLM-powered chatbot that works seamlessly with WhatsApp. This isn’t just about setting up automated business communication in real-time; it’s about laying the groundwork for more advanced AI-driven workflows down the road.</p><h1 id="8edd" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk"><strong class="al">What have we done:</strong></h1><ul class=""><li id="89cc" class="nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx oz pa pb bk"><strong class="ne gl">WhatsApp Cloud API Integration:</strong><br/>We got Meta’s Cloud API for WhatsApp up and running, including building a webhook for live message handling.</li><li id="ff3b" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">Backend Development with FastAPI:</strong><br/>Set up endpoints to verify webhooks, process incoming messages, and handle responses asynchronously.</li><li id="2eb4" class="nc nd gk ne b hi pd ng nh hl pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx oz pa pb bk"><strong class="ne gl">Multimedia &amp; Authentication Support:</strong><br/>Enabled stuff like audio transcription, and user authentication for more personalized interactions. Image handling is not implemented to the fullest but we have added the possibility for it.</li></ul><h1 id="12aa" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk">Whats Next:</h1><p id="49b1" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">In the next part(s), which I promise to publish sooner 🙏 I will move the implementation to LangGraph. I will add some more capabilities to the agent like creating database tables + tools on its one. Which will make the Agent more flexible. I am also open for Feedback and ideas what to Features to add!</p><h1 id="a54d" class="ny nz gk bf oa ob oc hk od oe of hn og oh oi oj ok ol om on oo op oq or os ot bk"><strong class="al">Wrapping It Up:</strong></h1><p id="f745" class="pw-post-body-paragraph nc nd gk ne b hi ou ng nh hl ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Combining the reach and usability of WhatsApp with LLMs is a big win for businesses and personal use cases. Whether you’re aiming for a personal assistant or a full-blown business tool, this guide gives you the path to get there. Keep tinkering, improving, and pushing boundaries — this is just the start of what you can build.</p><p id="2e49" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Happy coding! 🚀</p></div></div></div><div class="ab cb pt pu pv pw" role="separator"><span class="px by bm py pz qa"/><span class="px by bm py pz qa"/><span class="px by bm py pz"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="b35e" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">You can find the full code here: <a class="af pc" href="https://github.com/elokus/WhatsappAgent" rel="noopener ugc nofollow" target="_blank">Github Repo</a></p><p id="c2ae" class="pw-post-body-paragraph nc nd gk ne b hi nf ng nh hl ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Full Link: <a class="af pc" href="https://github.com/elokus/WhatsappAgent" rel="noopener ugc nofollow" target="_blank">https://github.com/elokus/WhatsappAgent</a></p></div></div></div></div>    
</body>
</html>
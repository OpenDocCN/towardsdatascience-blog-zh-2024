- en: Implementing “Modular RAG” with Haystack and Hypster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/implementing-modular-rag-with-haystack-and-hypster-d2f0ecc88b8f?source=collection_archive---------3-----------------------#2024-10-18](https://towardsdatascience.com/implementing-modular-rag-with-haystack-and-hypster-d2f0ecc88b8f?source=collection_archive---------3-----------------------#2024-10-18)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Transforming RAG systems into LEGO-like reconfigurable frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@giladrubin?source=post_page---byline--d2f0ecc88b8f--------------------------------)[![Gilad
    Rubin](../Images/e98728582365c22c2803d5db0a0f3ca6.png)](https://medium.com/@giladrubin?source=post_page---byline--d2f0ecc88b8f--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--d2f0ecc88b8f--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--d2f0ecc88b8f--------------------------------)
    [Gilad Rubin](https://medium.com/@giladrubin?source=post_page---byline--d2f0ecc88b8f--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--d2f0ecc88b8f--------------------------------)
    ·11 min read·Oct 18, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/665f1ebb6e484102c452f4295f32035a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image Generated using [Midjourney AI](https://www.midjourney.com/), Prompted
    by the author
  prefs: []
  type: TYPE_NORMAL
- en: Intro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping up with the latest in AI can be a challenge, especially when it comes
    to an increasingly evolving field like Retrieval Augmented Generation (RAG). With
    so many different solutions and implementations, one can easily feel lost.
  prefs: []
  type: TYPE_NORMAL
- en: I struggled with this myself for a long time, trying to wrap my head around
    every new article or “trick” to make RAG systems better in one way or another.
    Every new paper, tutorial or blogpost felt like something completely new and it
    became increasingly difficult to keep up with all the acronyms for all the newest
    fancy methods - HyDE, RAPTOR, CRAG, FLARE — they started to sound like Pokémon
    character names to me.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then I came across this paper by Gao et al. (2024) “[**Modular RAG: Transforming
    RAG Systems into LEGO-like Reconfigurable Frameworks”**](https://arxiv.org/abs/2407.21059)**.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c9f2768a8d8fb903c8fa98e34bd40d0c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The main figure from the paper that shows the components from which the authors
    construct RAG solutions. Source: [Modular RAG](https://arxiv.org/abs/2407.21059)'
  prefs: []
  type: TYPE_NORMAL
- en: Modular RAG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This paper provides a structured approach for breaking down RAG systems into
    a unified framework that can encompass diverse solutions and approaches. They
    proposed six main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing:** Organize your data for efficient search.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pre-Retrieval:** Process the user’s query before searching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retrieval:** Find the most relevant information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post-Retrieval:** Refine the retrieved information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generation:** Use an LLM to generate a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestration:** Control the overall flow of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key insight from this paper is that a wide range of existing RAG solutions
    can be described using these components in a LEGO-like manner. This modularity
    provides a framework for understanding, designing, and navigating the process
    of building a RAG system with greater flexibility and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the paper, the authors showcase how this is possible by taking examples
    of existing RAG solutions and expressing them using the same building blocks.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d41279dd94909e693a0427b0faab823b.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Adaptive RAG flow** - where the “judge” decides whether or not to use retrieval.
    Source: [Modular RAG](https://arxiv.org/abs/2407.21059)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/818a2c6d61007b364397301bf777d21f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**FLARE - F**orward-**L**ooking **A**ctive **RE**trieval where each sentence
    can trigger a retrieval step. Source: [Modular RAG](https://arxiv.org/abs/2407.21059)'
  prefs: []
  type: TYPE_NORMAL
- en: 'I highly recommend reading this paper and the set of blog-posts by the author
    of the paper, Yunfan Gao: Modular RAG and RAG Flow: [Part I](https://medium.com/@yufan1602/modular-rag-and-rag-flow-part-%E2%85%B0-e69b32dc13a3),
    [Part II](https://medium.com/@yufan1602/modular-rag-and-rag-flow-part-ii-77b62bf8a5d3).'
  prefs: []
  type: TYPE_NORMAL
- en: Personally, this framework helped me understand how different RAG approaches
    relate to each other, and now I can easily make sense of new papers and implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Modular RAG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how can we actually implement this “Modular RAG” framework?
  prefs: []
  type: TYPE_NORMAL
- en: Since it’s more of a meta-framework — what does that mean in practical terms?
    Does it mean that we need to implement *all* the possible combinations of components?
    Or do we just build the individual components and let developers figure out how
    to put them together?
  prefs: []
  type: TYPE_NORMAL
- en: I believe that in most real-life situations — it’s not necessary to try to cover
    *every* possible RAG configuration, but to narrow down the space of relevant configurations
    based on the requirements and constraints of each project.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, I’ll show you a concrete example of how to build a configurable
    system using a small set of options. Hopefully, this will give you the right perspective
    and tools to create your own version of a Modular RAG that contains the set of
    relevant configurations for your specific use-case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go on to explore the two main tools we’ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: Haystack — The Main Components Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`haystack` is an open-source framework for building production-ready LLM applications,
    retrieval-augmented generative pipelines and state-of-the-art search systems that
    work intelligently over large document collections.'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://haystack.deepset.ai/?source=post_page-----d2f0ecc88b8f--------------------------------)
    [## Haystack | Haystack'
  prefs: []
  type: TYPE_NORMAL
- en: Haystack, the composable open-source AI framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: haystack.deepset.ai](https://haystack.deepset.ai/?source=post_page-----d2f0ecc88b8f--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros:**'
  prefs: []
  type: TYPE_NORMAL
- en: Great component design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pipeline is very flexible and allows for dynamic configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extremely (!) well documented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The framework includes many existing implementations and integrations with Generative
    AI providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons:**'
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline interface can be a bit verbose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using components outside of a pipeline is not very ergonomic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ve played around with a few different Generative AI frameworks, and Haystack
    was by far the easiest for me to understand, use and customize.
  prefs: []
  type: TYPE_NORMAL
- en: Hypster — Managing Configuration Spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`**hypster**` is a lightweight pythonic configuration system for AI & Machine
    Learning projects. It offers minimal, intuitive pythonic syntax, supporting hierarchical
    and swappable configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://medium.com/@giladrubin/introducing-hypster-a-pythonic-framework-for-managing-configurations-to-build-highly-optimized-ai-5ee004dbd6a5?source=post_page-----d2f0ecc88b8f--------------------------------)
    [## Introducing HyPSTER: A Pythonic Framework for Managing Configurations to Build
    Highly Optimized AI…'
  prefs: []
  type: TYPE_NORMAL
- en: Image by the Author
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: medium.com](https://medium.com/@giladrubin/introducing-hypster-a-pythonic-framework-for-managing-configurations-to-build-highly-optimized-ai-5ee004dbd6a5?source=post_page-----d2f0ecc88b8f--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Hypster is a new open-source project that I’ve developed to enable a new kind
    of programming paradigm for AI & ML workflows — one that moves beyond single solutions
    towards a “superposition of workflows” or a “hyper-workflow.”
  prefs: []
  type: TYPE_NORMAL
- en: Hypster allows you to define a range of possible configurations and easily switch
    between them for experimentation and optimization. This makes it simple to add
    and customize your own configuration spaces, instantiate them with different settings,
    and ultimately select the optimal configuration for your production environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Hypster is currently under active development. It is not yet recommended
    for production environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Codebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**This is an advanced tutorial.** It assumes you’re already familiar with the
    main components of RAG.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ll break down the main parts of the codebase and provide my insights as we
    go.
  prefs: []
  type: TYPE_NORMAL
- en: The full and updated code is in the following repository. Don’t forget to add
    your ⭐️
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://github.com/gilad-rubin/modular-rag?source=post_page-----d2f0ecc88b8f--------------------------------)
    [## GitHub - gilad-rubin/modular-rag'
  prefs: []
  type: TYPE_NORMAL
- en: Contribute to gilad-rubin/modular-rag development by creating an account on
    GitHub.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: github.com](https://github.com/gilad-rubin/modular-rag?source=post_page-----d2f0ecc88b8f--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: LLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with our LLM configuration-space definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet demonstrates a basic example of Hypster and Haystack. Using
    the `@config` decorator, we define a function called `llm_config` that encapsulates
    the configuration space for our LLM. This space includes options for selecting
    different LLM providers (Anthropic or OpenAI) and their corresponding models,
    as well as a parameter for controlling the temperature.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `llm_config` function, we use conditional logic to instantiate the
    appropriate Haystack component based on the selected model. This allows us to
    seamlessly switch between different LLMs using a selection without modifying the
    structure of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to create an Anthropic generator with the “haiku” model and a
    temperature of 0.5, we can instantiate the configuration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Indexing pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s move on to create our indexing pipeline, where we’ll define how to process
    our input files. In our case — PDF files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll add an optional functionality — enriching the document with an LLM
    summary based on the first 1000 characters of the document.
  prefs: []
  type: TYPE_NORMAL
- en: This is a nice trick where we use the first `n` characters of a document and
    then, upon splitting the document into chunks, each chunk "inherits" this enriched
    information for its embeddings and response generation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see Haystack’s pipeline in action. If the user selects `enrich_doc_w_llm==True`
    we go on to add components and connections that enable this enrichment. In our
    case: PromptBuilder → LLM → AddLLMMetadata.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see — it’s very flexible and we can construct it on-the-fly using
    conditional logic. This is extremely powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can instantiate the configuration object in a couple of ways. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we get a simple pipeline with a loader and a splitter, with the selected
    splitter configurations
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fd78f82144e6a23775f181cf847f5c26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Otherwise, we can select to enrich the document with an LLM summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that Hypster takes on default values that are defined in each parameter,
    so there’s no need to specify all the parameter selections every time. Here’s
    an illustration of the resulting pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/424c4b7586fb3b12cf3330291cca6f42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how we casually inserted the `llm_config` inside our indexing pipeline
    using `hp.nest(“configs/llm_config.py")`. This nesting ability lets us create
    nested configurations in a hierarchical way. We can define parameters values within
    the nested `llm_config` using dot notation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will result in instantiating an indexing pipeline with the LLM enrichment
    task using the OpenAI `gpt-4o-2024–08` model.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve built a compact configuration space for many potential indexing
    pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of brevity, I will skip over the embedding configuration, where
    I incorporated `fastembed` and `jina` embeddings. If you're curious, please check
    out the [full implementation](https://github.com/gilad-rubin/modular-rag).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the retrieval pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Haystack comes with an in-memory document store for fast experimentation. It
    includes an embedding retriever and a BM25 retriever. In this section — we’ll
    build a configuration space that enables using either a BM25, an embedding retriever
    or both.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re using a couple of “tricks” to make it work. First of all, we use
    `hp.multi_select` which allows us to select multiple options from the options.
    Second, we add “helper” components from the start and end of the pipeline (PassThroughText,
    PassThroughDocuments) to make sure that any selection will start with `query`and
    end with `retrieved_documents` and the rest is relatively straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of example instantiations would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/b0c0e300e43b6f5eb2180093b5aec6f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by the author
  prefs: []
  type: TYPE_NORMAL
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7a2b2312dbc0d40475e14fe896db9c3c.png)'
  prefs: []
  type: TYPE_IMG
- en: In the full implementation, I’ve added a Qdrant vector store, an optional reranking
    step, and a final generation pipeline. These are all meant as examples to show
    the possibilities of adding and customizing the different components in these
    pipelines and you can find them as well in the full repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, we have the main config that binds all of these settings together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'from here we can define pretty much anything we want inside any of the sub-components.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And we’ve instantiated a concrete set of working pipelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e6833095970f9a1928cfc184f1db1d83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now execute them sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Great Response! 👏
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some of you, this might be a lot to take in at once. You might be new to
    Haystack, and this is probably your first encounter with Hypster. That’s perfectly
    understandable!
  prefs: []
  type: TYPE_NORMAL
- en: The code is complex, but I believe that this comes from the inherent complexity
    of building a modular system like this. In addition, defining the exact routings
    of a workflow is a visual task and it’s sometimes harder to read via text.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, this is the first time I’ve seen a fully configurable, modular
    RAG system. It’s exciting for me, and I hope for you as well!
  prefs: []
  type: TYPE_NORMAL
- en: I believe this represents a fundamentally different approach to AI/ML projects.
    Instead of building a codebase for a single solution, we’re building a codebase
    that accommodates multiple potential workflows — a “superposition of workflows”
    or a “hyper-workflow.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get into this kind of programming — you immediately unlock incredible
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hyperparameter Optimization** is easily available (more on that in future
    posts)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Utilizing different configurations for diverse scenarios**. For example,
    queries of type X can use a RAG system with a high weight assigned to the BM25
    retriever and queries of type Y focus mainly on dense embedding techniques.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Agentic Tool Use -** It’s relatively straightforward to wrap this as a tool
    that can be instantiated and used in different scenarios, which means that… Yes!
    We can turn this intoa tool that an AI Agent uses. Think of the possibilities
    there.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A/B testing in Production -** we can deploy this RAG hyperspace to production
    and perform A/B testing just by specifying configurations for each individual
    API request.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outro**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how was it for you?
  prefs: []
  type: TYPE_NORMAL
- en: Making this knowledge accessible is important to me, so your inputs are valuable.
    If you have any questions or comments on this implementation or the overall approach,
    please feel free to add your comments to this article.
  prefs: []
  type: TYPE_NORMAL
- en: I also offer consultation and freelance services to companies looking for a
    structured, common-sense approach to solving business problems using state-of-the-art
    Generative AI and Machine Learning tools.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to contact me via [**E-Mail**](mailto:me@giladrubin.com), [**LinkedIn**](https://www.linkedin.com/in/gilad-rubin-2b72b3218/)
    or my [**Website**](http://www.giladrubin.com) **🌟**
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gao, Y., Xiong, Y., Wang, M., & Wang, H. (2024). [Modular RAG: Transforming
    RAG Systems into LEGO-like Reconfigurable Frameworks](https://arxiv.org/abs/2407.21059).
    arXiv preprint arXiv:2407.21059.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Haystack’s** [Documentation](https://docs.haystack.deepset.ai/docs/intro)
    | [DeepLearning.ai Course](https://www.deeplearning.ai/short-courses/building-ai-applications-with-haystack/)
    | [Github Repo](https://github.com/deepset-ai/haystack)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hypster’s** [Introduction](https://medium.com/@giladrubin/introducing-hypster-a-pythonic-framework-for-managing-configurations-to-build-highly-optimized-ai-5ee004dbd6a5)
    | [Documentation](https://gilad-rubin.gitbook.io/hypster) | [Github Repo](https://github.com/gilad-rubin/hypster)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modular-RAG** [Github Repo](https://github.com/gilad-rubin/modular-rag)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All images without a caption were created by the author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m not affiliated with Deepset/Haystack in any way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

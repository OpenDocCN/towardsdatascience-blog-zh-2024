["```py\nclass CSAgent:\n  # initialising class\n  def __init__(self, name, average_handling_time):\n      # saving parameters mentioned during object creation\n      self.name = name  \n      self.average_handling_time = average_handling_time\n      # specifying constant value\n      self.role = 'CS agent'\n      print('Created %s with name %s' % (self.role, self.name))\n\n  def get_name(self):\n    return self.name\n\n  def get_handling_time(self):\n    return self.average_handling_time\n\n  def update_handling_time(self, average_handling_time):\n    print('Updating time from %.2f to %.2f' % (self.average_handling_time, \n      average_handling_time))\n    self.average_handling_time = average_handling_time\n```", "```py\njohn_agent = CSAgent('John Doe', 12.3)\n# Created CS agent with name John Doe\n```", "```py\nprint(john_agent.__dict__)\n# {'name': 'John Doe', 'average_handling_time': 12.3, 'role': 'CS agent'}\n```", "```py\njohn_agent.update_handling_time(5.4)\n# Updating time from 12.30 to 5.40\n\nprint(john_agent.get_handling_time())\n# 5.4\n```", "```py\nclass Agent:\n  # initialising class\n  def __init__(self, name, average_handling_time, role):\n    # saving parameters mentioned during object creation\n    self.name = name  \n    self.average_handling_time = average_handling_time\n    self.role = role\n    print('Created %s with name %s' % (self.role, self.name))\n\n  def get_name(self):\n    return self.name\n\n  def get_handling_time(self):\n    return self.average_handling_time\n\n  def update_handling_time(self, average_handling_time):\n    print('Updating time from %.2f to %.2f' % (self.average_handling_time, \n      average_handling_time))\n    self.average_handling_time = average_handling_time\n```", "```py\nclass KYCAgent(Agent):\n  def __init__(self, name, average_handling_time):\n    super().__init__(name, average_handling_time, 'KYC agent')\n\n  def get_job_description(self):\n    return 'KYC (Know Your Customer) agents help to verify documents'\n\nclass CSAgent(Agent):\n  def __init__(self, name, average_handling_time):\n    super().__init__(name, average_handling_time, 'CS agent')\n\n  def get_job_description(self):\n    return 'CS (Customer Support) answer customer questions and help resolving their problems'\n```", "```py\nmarie_agent = KYCAgent('Marie', 25)\nmax_agent = CSAgent('Max', 10)\n\nprint(marie_agent.__dict__)\n# {'name': 'Marie', 'average_handling_time': 25, 'role': 'KYC agent'}\nprint(max_agent.__dict__)\n# {'name': 'Max', 'average_handling_time': 10, 'role': 'CS agent'}\n```", "```py\nmarie_agent.update_handling_time(22.5)\n# Updating time from 25.00 to 22.50\n```", "```py\nprint(marie_agent.get_job_description())\n# KYC (Know Your Customer) agents help to verify documents\n\nprint(max_agent.get_job_description())\n# CS (Customer Support) answer customer questions and help resolving their problems\n```", "```py\nclass System:\n  def __init__(self, agents, queue, initial_date,\n  customer_requests_df, logging = True):\n    initial_time = datetime.datetime(initial_date.year, initial_date.month, \n      initial_date.day, 0, 0, 0)\n    self.agents = agents\n    self.queue = RequestQueue(queue)\n    self.logging = logging\n    self.current_time = initial_time\n\n    self._timeline = TimeLine()\n    self.processed_requests = []\n\n    initial_event = PlanScheduleEvent('plan_agents_schedule', initial_time)\n    initial_event.process(self)\n    self.load_customer_request_events(customer_requests_df)\n```", "```py\nclass TimeLine:\n  def __init__(self):\n    self.events = []\n\n  def add_event(self, event:Event):\n    self.events.append(event)\n    self.events.sort(key = lambda x: x.time)\n\n  def get_next_item(self):\n    if len(self.events) == 0:\n      return None\n    return self.events.pop(0)\n\n  def get_remaining_events(self):\n    return len(self.events)\n```", "```py\nclass CustomerRequest:\n  def __init__(self, id, handling_time_secs, creation_time):\n    self.id = id\n    self.handling_time_secs = handling_time_secs\n    self.creation_time = creation_time\n\n  def __str__(self):\n    return f'Customer Request {self.id}: {self.creation_time.strftime(\"%Y-%m-%d %H:%M:%S\")}'\n```", "```py\ntest_object = CustomerRequest(1, 600, datetime.datetime(2024, 5, 1, 9, 42, 1))\n# without defining __str__\nprint(test_object)\n# <__main__.CustomerRequest object at 0x280209130>\n\n# with custom __str__\nprint(test_object)\n# Customer Request 1: 2024-05-01 09:42:01\n```", "```py\nclass RequestQueue:\n  def __init__(self, queue = None):\n    if queue is None:\n      self.requests = []\n    else: \n      self.requests = queue\n\n  def get_requests_in_queue(self):\n    return len(self.requests)\n\n  def add_request(self, request):\n    self.requests.append(request)\n\n  def get_next_item(self):\n    if len(self.requests) == 0:\n      return None\n    return self.requests.pop(0)\n```", "```py\nclass Schedule:\n  def __init__(self, time_periods):\n    self.time_periods = time_periods\n\n  def is_within_working_hours(self, dt):\n    weekday = dt.strftime('%A')\n\n    if weekday not in self.time_periods:\n      return False\n\n    hour = dt.hour\n    time_periods = self.time_periods[weekday]\n    for period in time_periods:\n      if (hour >= period[0]) and (hour < period[1]):\n        return True\n    return False\n```", "```py\nclass Agent:\n  def __init__(self, id, name, schedule, effectiveness = 1):\n    self.id = id\n    self.schedule = schedule\n    self.name = name\n    self.request_in_work = None\n    self.effectiveness = effectiveness\n\n  def is_ready_for_task(self, dt):\n    if (self.request_in_work is None) and (self.schedule.is_within_working_hours(dt)):\n      return True\n    return False\n\n  def start_task(self, customer_request):\n    self.request_in_work = customer_request\n    customer_request.handling_time_secs = int(round(self.effectiveness * customer_request.handling_time_secs))\n\n  def finish_task(self):\n    self.request_in_work = None\n```", "```py\nclass System:\n  def load_customer_request_events(self, df):\n    # filter requests before the start of simulation\n    filt_df = df[df.creation_time >= self.current_time]\n    if filt_df.shape[0] != df.shape[0]:\n      if self.logging:\n        print('Attention: %d requests have been filtered out since they are outdated' % (df.shape[0] - filt_df.shape[0]))\n\n    # create new customer request events for each record\n    for rec in filt_df.sort_values('creation_time').to_dict('records'):\n      customer_request = CustomerRequest(rec['id'], rec['handling_time_secs'], \n        rec['creation_time'])\n\n      self.add_event(NewCustomerRequestEvent(\n        'new_customer_request', rec['creation_time'],\n         customer_request\n      ))\n```", "```py\nclass Event:\n  def __init__(self, event_type, time):\n    self.type = event_type\n    self.time = time\n\n  def __str__(self):\n    if self.type == 'agent_ready_for_task':\n      return '%s (%s) - %s' % (self.type, self.agent.name, self.time)\n    return '%s - %s' % (self.type, self.time)\n```", "```py\n class AgentReadyEvent(Event):\n  def __init__(self, event_type, time, agent):\n    super().__init__(event_type, time)\n    self.agent = agent\n\n  def process(self, system: System):\n    # get next request from the queue\n    next_customer_request = system.queue.get_next_item()\n\n    # start processing request if we had some\n    if next_customer_request is not None:\n      self.agent.start_task(next_customer_request)\n      next_customer_request.start_time = system.current_time\n      next_customer_request.agent_name = self.agent.name\n      next_customer_request.agent_id = self.agent.id\n\n      if system.logging:\n        print('<%s> Agent %s started to work on request %d' % (system.current_time, \n          self.agent.name, next_customer_request.id))\n\n      # schedule finish processing event\n      system.add_event(FinishCustomerRequestEvent('finish_handling_request', \n        system.current_time + datetime.timedelta(seconds = next_customer_request.handling_time_secs), \n        next_customer_request, self.agent)) \n\nclass PlanScheduleEvent(Event):\n  def __init__(self, event_type, time):\n    super().__init__(event_type, time)\n\n  def process(self, system: System):     \n    if system.logging:\n        print('<%s> Scheeduled agents for today' % (system.current_time))\n    current_weekday = system.current_time.strftime('%A')\n\n    # create agent ready events for all agents working on this weekday\n    for agent in system.agents:\n      if current_weekday not in agent.schedule.time_periods:\n        continue\n\n      for time_periods in agent.schedule.time_periods[current_weekday]:\n        system.add_event(AgentReadyEvent('agent_ready_for_task', \n          datetime.datetime(system.current_time.year, system.current_time.month, \n          system.current_time.day, time_periods[0], 0, 0), \n          agent))\n\n    # schedule next planning\n    system.add_event(PlanScheduleEvent('plan_agents_schedule', system.current_time + datetime.timedelta(days = 1)))\n\nclass FinishCustomerRequestEvent(Event):\n  def __init__(self, event_type, time, customer_request, agent):\n    super().__init__(event_type, time)\n    self.customer_request = customer_request\n    self.agent = agent\n\n  def process(self, system):\n    self.agent.finish_task()\n    # log finish time\n    self.customer_request.finish_time = system.current_time\n    # save processed request\n    system.processed_requests.append(self.customer_request)\n\n    if system.logging:\n      print('<%s> Agent %s finished request %d' % (system.current_time, self.agent.name, self.customer_request.id))\n\n    # pick up the next request if agent continue working and we have something in the queue\n    if self.agent.is_ready_for_task(system.current_time):\n      next_customer_request = system.queue.get_next_item()\n      if next_customer_request is not None:\n        self.agent.start_task(next_customer_request)\n        next_customer_request.start_time = system.current_time\n        next_customer_request.agent_name = self.agent.name\n        next_customer_request.agent_id = self.agent.id\n\n        if system.logging:\n            print('<%s> Agent %s started to work on request %d' % (system.current_time, \n              self.agent.name, next_customer_request.id))\n        system.add_event(FinishCustomerRequestEvent('finish_handling_request', \n          system.current_time + datetime.timedelta(seconds = next_customer_request.handling_time_secs), \n          next_customer_request, self.agent)) \n\nclass NewCustomerRequestEvent(Event):\n  def __init__(self, event_type, time, customer_request):\n    super().__init__(event_type, time)\n    self.customer_request = customer_request\n\n  def process(self, system: System):\n    # check whether we have a free agent\n    assigned_agent = system.get_free_agent(self.customer_request)\n\n    # if not put request in a queue\n    if assigned_agent is None:\n      system.queue.add_request(self.customer_request)\n      if system.logging:\n          print('<%s> Request %d put in a queue' % (system.current_time, self.customer_request.id))\n    # if yes, start processing it\n    else:\n      assigned_agent.start_task(self.customer_request)\n      self.customer_request.start_time = system.current_time\n      self.customer_request.agent_name = assigned_agent.name\n      self.customer_request.agent_id = assigned_agent.id\n      if system.logging:\n          print('<%s> Agent %s started to work on request %d' % (system.current_time, assigned_agent.name, self.customer_request.id))\n      system.add_event(FinishCustomerRequestEvent('finish_handling_request', \n        system.current_time + datetime.timedelta(seconds = self.customer_request.handling_time_secs), \n        self.customer_request, assigned_agent))\n```", "```py\nclass System:\n  # defines the stopping criteria\n  def is_simulation_finished(self):\n    if self.queue.get_requests_in_queue() > 0: \n      return False\n    if self._timeline.get_remaining_events() > 0:\n      return False\n    return True\n\n  # wrappers for timeline methods to incapsulate this logic\n  def add_event(self, event):\n    self._timeline.add_event(event)\n\n  def get_next_event(self):\n    return self._timeline.get_next_item()\n\n  # returns free agent if we have one\n  def get_free_agent(self, customer_request):\n    for agent in self.agents:\n      if agent.is_ready_for_task(self.current_time):\n        return agent\n\n  # finds and processes the next event\n  def process_next_event(self):\n    event = self.get_next_event()\n    if self.logging:\n      print('# Processing event: ' + str(event))\n    if (event.type == 'plan_agents_schedule') and self.is_simulation_finished():\n      if self.logging:\n        print(\"FINISH\")\n    else:\n      self.current_time = event.time        \n      event.process(self)\n\n  # main function\n  def run_simulation(self):\n    while not self.is_simulation_finished():\n      self.process_next_event()\n```", "```py\n# initialising agents\nregular_work_week = Schedule(\n  {\n    'Monday': [(9, 12), (13, 18)],\n    'Tuesday': [(9, 12), (13, 18)],\n    'Wednesday': [(9, 12), (13, 18)],\n    'Thursday': [(9, 12), (13, 18)],\n    'Friday': [(9, 12), (13, 18)]\n  }\n)\n\nagents = []\nfor id in range(15):\n  agents.append(Agent(id + 1, 'Agent %s' % id, regular_work_week))\n\n# inital date\nsystem_initial_date = datetime.date(2024, 4, 8)\n\n# initialising the system \nsystem = System(agents, [], system_initial_date, backlog_df, logging = False)\n\n# running the simulation \nsystem.run_simulation()\n```", "```py\n# convert results to data frame and calculate timings\ndef get_processed_results(system):\n  processed_requests_df = pd.DataFrame(list(map(lambda x: x.__dict__, system.processed_requests)))\n  processed_requests_df = processed_requests_df.sort_values('creation_time')\n  processed_requests_df['creation_time_hour'] = processed_requests_df.creation_time.map(\n      lambda x: x.strftime('%Y-%m-%d %H:00:00')\n  )\n\n  processed_requests_df['resolution_time_secs'] = list(map(\n      lambda x, y: int(x.strftime('%s')) - int(y.strftime('%s')),\n      processed_requests_df.finish_time,\n      processed_requests_df.creation_time\n  ))\n\n  processed_requests_df['waiting_time_secs'] = processed_requests_df.resolution_time_secs - processed_requests_df.handling_time_secs\n\n  processed_requests_df['waiting_time_mins'] = processed_requests_df['waiting_time_secs']/60\n  processed_requests_df['handling_time_mins'] = processed_requests_df.handling_time_secs/60\n  processed_requests_df['resolution_time_mins'] = processed_requests_df.resolution_time_secs/60\n  return processed_requests_df\n\n# calculating queue size with 5 mins granularity\ndef get_queue_stats(processed_requests_df):\n  queue_stats = []\n\n  current_time = datetime.datetime(system_initial_date.year, system_initial_date.month, system_initial_date.day, 0, 0, 0)\n  while current_time <= processed_requests_df.creation_time.max() + datetime.timedelta(seconds = 300):\n    queue_size = processed_requests_df[(processed_requests_df.creation_time <= current_time) & (processed_requests_df.start_time > current_time)].shape[0]\n    queue_stats.append(\n      {\n          'time': current_time,\n          'queue_size': queue_size\n      }\n    )\n\n    current_time = current_time + datetime.timedelta(seconds = 300)\n\n  return pd.DataFrame(queue_stats)\n```", "```py\ndef analyse_results(system, show_charts = True):\n  processed_requests_df = get_processed_results(system)\n  queue_stats_df = get_queue_stats(processed_requests_df)\n\n  stats_df = processed_requests_df.groupby('creation_time_hour').aggregate(\n      {'id': 'count', 'handling_time_mins': 'mean', 'resolution_time_mins': 'mean',\n       'waiting_time_mins': 'mean'}\n  )\n\n  if show_charts:\n    fig = px.line(stats_df[['id']], \n      labels = {'value': 'requests', 'creation_time_hour': 'request creation time'},\n      title = '<b>Number of requests created</b>')\n    fig.update_layout(showlegend = False)\n    fig.show()\n\n    fig = px.line(stats_df[['waiting_time_mins', 'handling_time_mins', 'resolution_time_mins']], \n      labels = {'value': 'time in mins', 'creation_time_hour': 'request creation time'},\n      title = '<b>Resolution time</b>')\n    fig.show()\n\n    fig = px.line(queue_stats_df.set_index('time'), \n      labels = {'value': 'number of requests in queue'},\n      title = '<b>Queue size</b>')\n    fig.update_layout(showlegend = False)\n    fig.show()\n\n  processed_requests_df['period'] = processed_requests_df.creation_time.map(\n      lambda x: (x - datetime.timedelta(x.weekday())).strftime('%Y-%m-%d')\n  )\n  queue_stats_df['period'] = queue_stats_df['time'].map(\n      lambda x: (x - datetime.timedelta(x.weekday())).strftime('%Y-%m-%d')\n  )\n\n  period_stats_df = processed_requests_df.groupby('period')\\\n    .aggregate({'id': 'count', 'handling_time_mins': 'mean',\n      'waiting_time_mins': 'mean', \n      'resolution_time_mins': 'mean'})\\\n    .join(queue_stats_df.groupby('period')[['queue_size']].mean())\n\n  return period_stats_df\n\n# execution\nanalyse_results(system)\n```", "```py\ntmp_dfs = []\n\nfor num_agents in tqdm.tqdm(range(15, 105, 5)):\n  agents = []\n  for id in range(num_agents):\n    agents.append(Agent(id + 1, 'Agent %s' % id, regular_work_week))\n  system = System(agents, [], system_initial_date, backlog_df, logging = False)\n  system.run_simulation()\n\n  tmp_df = analyse_results(system, show_charts = False)\n  tmp_df['num_agents'] = num_agents\n  tmp_dfs.append(tmp_df)\n```"]
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Building Knowledge Graphs with LLM Graph Transformer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Building Knowledge Graphs with LLM Graph Transformer</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/building-knowledge-graphs-with-llm-graph-transformer-a91045c49b59?source=collection_archive---------0-----------------------#2024-11-05">https://towardsdatascience.com/building-knowledge-graphs-with-llm-graph-transformer-a91045c49b59?source=collection_archive---------0-----------------------#2024-11-05</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="a953" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">A deep dive into LangChain’s implementation of graph construction with LLMs</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://bratanic-tomaz.medium.com/?source=post_page---byline--a91045c49b59--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Tomaz Bratanic" class="l ep by dd de cx" src="../Images/d5821aa70918fcb3fc1ff0013497b3d5.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*SnWQP0l4Vg9577WAErbjfw.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--a91045c49b59--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://bratanic-tomaz.medium.com/?source=post_page---byline--a91045c49b59--------------------------------" rel="noopener follow">Tomaz Bratanic</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--a91045c49b59--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">17 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Nov 5, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">10</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/c100d65f7368e26e05871fc243e2c8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KHns0-DJoCjfzxyr"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Building knowledge graph. Image by ChatGPT.</figcaption></figure><p id="e3ae" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Creating graphs from text is incredibly exciting, but definitely challenging. Essentially, it’s about converting unstructured text into structured data. While this approach has been around for some time, it gained significant traction with the advent of Large Language Models (LLMs), bringing it more into the mainstream.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk ny"><img src="../Images/391f15d81764d9d695809c24cb771da0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qgT2hBiA3DA1Y3qu.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Extracting entities and relationships from text to construct a knowledge graph. Image by author.</figcaption></figure><p id="7805" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In the image above, you can see how information extraction transforms raw text into a knowledge graph. On the left, multiple documents show unstructured sentences about individuals and their relationships with companies. On the right, this same information is represented as a graph of entities and their connections, showing who worked at or founded various organizations.</p><p id="f132" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">But why would you want to extract structured information from text and represent it as a graph? One key reason is to power retrieval-augmented generation (RAG) applications. While using text embedding models over unstructured text is an useful approach, it can fall short when it comes to answering <a class="af nz" href="https://medium.com/neo4j/knowledge-graphs-llms-multi-hop-question-answering-322113f53f51" rel="noopener">complex, multi-hop questions</a> that require understanding connections across multiple entities or question where <a class="af nz" href="https://medium.com/neo4j/limitations-of-text-embeddings-in-rag-applications-b060020b543b" rel="noopener">structured operations like filtering, sorting, and aggregation</a> is required. By extracting structured information from text and constructing knowledge graphs, you not only organize data more effectively but also create a powerful framework for understanding complex relationships between entities. This structured approach makes it much easier to retrieve and leverage specific information, expanding the types of questions you can answer while providing greater accuracy.</p><p id="2d2d" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Around a year ago, I began <a class="af nz" href="https://medium.com/@bratanic-tomaz/constructing-knowledge-graphs-from-text-using-openai-functions-096a6d010c17" rel="noopener">experimenting with building graphs using LLMs</a>, and due to the growing interest, we decided to integrate this capability into LangChain as the <a class="af nz" href="https://python.langchain.com/docs/how_to/graph_constructing/" rel="noopener ugc nofollow" target="_blank">LLM Graph Transformer</a>. Over the past year, we’ve gained valuable insights and introduced new features, which we’ll be showcasing in this blog post.</p><p id="2377" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The code is available on <a class="af nz" href="https://github.com/tomasonjo/blogs/blob/master/llm/llm_graph_transformer_in_depth.ipynb" rel="noopener ugc nofollow" target="_blank">GitHub</a>.</p><h1 id="4cd3" class="oa ob fq bf oc od oe gq of og oh gt oi oj ok ol om on oo op oq or os ot ou ov bk">Setting up Neo4j environment</h1><p id="4c3e" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">We will use Neo4j as the underlying graph store, which comes with out-of-the box graph visualizations. The easiest way to get started is to use a free instance of<a class="af nz" href="https://neo4j.com/cloud/platform/aura-graph-database/" rel="noopener ugc nofollow" target="_blank"> Neo4j Aura</a>, which offers cloud instances of the Neo4j database. Alternatively, you can set up a local instance of the Neo4j database by downloading the<a class="af nz" href="https://neo4j.com/download/" rel="noopener ugc nofollow" target="_blank"> Neo4j Desktop</a> application and creating a local database instance.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="74ee" class="pf ob fq pc b bg pg ph l pi pj">from langchain_community.graphs import Neo4jGraph<br/><br/>graph = Neo4jGraph(<br/>    url="bolt://54.87.130.140:7687",<br/>    username="neo4j",<br/>    password="cables-anchors-directories",<br/>    refresh_schema=False<br/>)</span></pre><h1 id="cd77" class="oa ob fq bf oc od oe gq of og oh gt oi oj ok ol om on oo op oq or os ot ou ov bk">LLM Graph Transformer</h1><p id="d71d" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">The LLM Graph Transformer was designed to provide a flexible framework for building graphs using any LLM. With so many different providers and models available, this task is far from simple. Fortunately, LangChain steps in to handle much of the standardization process. As for the LLM Graph Transformer itself, it’s like two cats stacked in a trench coat —with the ability to operate in two completely independent modes.</p></div></div><div class="mr"><div class="ab cb"><div class="lm pk ln pl lo pm cf pn cg po ci bh"><figure class="mm mn mo mp mq mr pq pr paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pp"><img src="../Images/6657e49d4e353000a1cc75cda74536e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*aCSCXuvrOB90jRQ0mNZtSA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">LLM Graph Transformer consists of two separate modes of extracting graphs from text. Image by user.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="cd41" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The LLM Graph Transformer operates in two distinct modes, each designed to generate graphs from documents using an LLM in different scenarios.</p><ol class=""><li id="10cf" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ps pt pu bk"><strong class="ne fr">Tool-Based Mode (Default):</strong> When the LLM supports structured output or function calling, this mode leverages the <a class="af nz" href="https://python.langchain.com/docs/how_to/structured_output/" rel="noopener ugc nofollow" target="_blank">LLM’s built-in </a><code class="cx pv pw px pc b"><a class="af nz" href="https://python.langchain.com/docs/how_to/structured_output/" rel="noopener ugc nofollow" target="_blank">with_structured_output</a></code><a class="af nz" href="https://python.langchain.com/docs/how_to/structured_output/" rel="noopener ugc nofollow" target="_blank">to use tools</a>. The tool specification defines the output format, ensuring that entities and relationships are extracted in a structured, predefined manner. This is depicted on the left side of the image, where code for the Node and Relationship classes is shown.</li><li id="521e" class="nc nd fq ne b go py ng nh gr pz nj nk nl qa nn no np qb nr ns nt qc nv nw nx ps pt pu bk"><strong class="ne fr">Prompt-Based Mode (Fallback):</strong> In situations where the LLM doesn’t support tools or function calls, the LLM Graph Transformer falls back to a purely prompt-driven approach. This mode uses few-shot prompting to define the output format, guiding the LLM to extract entities and relationships in a text-based manner. The results are then parsed through a custom function, which converts the LLM’s output into a JSON format. This JSON is used to populate nodes and relationships, just as in the tool-based mode, but here the LLM is guided entirely by prompting rather than structured tools. This is shown on the right side of the image, where an example prompt and resulting JSON output are provided.</li></ol><p id="af3a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">These two modes ensure that the LLM Graph Transformer is adaptable to different LLMs, allowing it to build graphs either directly using tools or by parsing output from a text-based prompt.</p><p id="203f" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><em class="qd">Note that you can use prompt-based extraction even with models that support tools/functions by setting the attribute </em><code class="cx pv pw px pc b"><em class="qd">ignore_tools_usage=True</em></code><em class="qd">.</em></p><h2 id="5215" class="qe ob fq bf oc qf qg qh of qi qj qk oi nl ql qm qn np qo qp qq nt qr qs qt qu bk">Tool-based extraction</h2><p id="aa01" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">We initially chose a tool-based approach for extraction since it minimized the need for extensive prompt engineering and custom parsing functions. In LangChain, the <code class="cx pv pw px pc b">with_structured_output</code> method allows you to extract information using tools or functions, with output defined either through a JSON structure or a Pydantic object. Personally, I find Pydantic objects clearer, so we opted for that.</p><p id="7aa6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We start by defining a <code class="cx pv pw px pc b">Node</code> class.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="2ee6" class="pf ob fq pc b bg pg ph l pi pj">class Node(BaseNode):<br/>    id: str = Field(..., description="Name or human-readable unique identifier")<br/>    label: str = Field(..., description=f"Available options are {enum_values}")<br/>    properties: Optional[List[Property]]</span></pre><p id="d85a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Each node has an <code class="cx pv pw px pc b">id</code>, a <code class="cx pv pw px pc b">label</code>, and optional <code class="cx pv pw px pc b">properties</code>. For brevity, I haven’t included full descriptions here. Describing ids as human-readable unique identifier is important since some LLMs tend to understand ID properties in more traditional way like random strings or incremental integers. Instead we want the name of entities to be used as id property. We also limit the available label types by simply listing them in the <code class="cx pv pw px pc b">label</code>description. Additionally, LLMs like OpenAI’s, support an <code class="cx pv pw px pc b">enum</code> parameter, which we also use.</p><p id="89be" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Next, we take a look at the <code class="cx pv pw px pc b">Relationship</code> class</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="1ee2" class="pf ob fq pc b bg pg ph l pi pj">class Relationship(BaseRelationship):<br/>    source_node_id: str<br/>    source_node_label: str = Field(..., description=f"Available options are {enum_values}")<br/>    target_node_id: str<br/>    target_node_label: str = Field(..., description=f"Available options are {enum_values}")<br/>    type: str = Field(..., description=f"Available options are {enum_values}")<br/>    properties: Optional[List[Property]]</span></pre><p id="8d46" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This is the second iteration of the <code class="cx pv pw px pc b">Relationship</code> class. Initially, we used a nested <code class="cx pv pw px pc b">Node</code> object for the source and target nodes, but we quickly found that nested objects reduced the accuracy and quality of the extraction process. So, we decided to flatten the source and target nodes into separate fields—for example, <code class="cx pv pw px pc b">source_node_id</code> and <code class="cx pv pw px pc b">source_node_label</code>, along with <code class="cx pv pw px pc b">target_node_id</code> and <code class="cx pv pw px pc b">target_node_label</code>. Additionally, we define the allowed values in the descriptions for node labels and relationship types to ensure the LLMs adhere to the specified graph schema.</p><p id="ab6a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The tool-based extraction approach enables us to define properties for both nodes and relationships. Below is the class we used to define them.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="8c16" class="pf ob fq pc b bg pg ph l pi pj">class Property(BaseModel):<br/>    """A single property consisting of key and value"""<br/>    key: str = Field(..., description=f"Available options are {enum_values}")<br/>    value: str</span></pre><p id="006c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Each <code class="cx pv pw px pc b">Property</code> is defined as a key-value pair. While this approach is flexible, it has its limitations. For instance, we can't provide a unique description for each property, nor can we specify certain properties as mandatory while others optional, so all properties are defined as optional. Additionally, properties aren't defined individually for each node or relationship type but are instead shared across all of them.</p><p id="84bd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We’ve also implemented a <a class="af nz" href="https://github.com/langchain-ai/langchain-experimental/blob/main/libs/experimental/langchain_experimental/graph_transformers/llm.py#L72" rel="noopener ugc nofollow" target="_blank">detailed system prompt</a> to help guide the extraction. In my experience, though, the function and argument descriptions tend to have a greater impact than the system message.</p><p id="4a55" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Unfortunately, at the moment, there is no simple way to customize function or argument descriptions in LLM Graph Transformer.</p><h2 id="eba5" class="qe ob fq bf oc qf qg qh of qi qj qk oi nl ql qm qn np qo qp qq nt qr qs qt qu bk">Prompt-based extraction</h2><p id="2a25" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">Since only a few commercial LLMs and LLaMA 3 support native tools, we implemented a fallback for models without tool support. You can also set <code class="cx pv pw px pc b">ignore_tool_usage=True</code> to switch to a prompt-based approach even when using a model that supports tools.</p><p id="e4ab" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Most of the prompt engineering and examples for the prompt-based approach were contributed by <a class="af nz" href="https://www.linkedin.com/in/geraldus-wilsen/" rel="noopener ugc nofollow" target="_blank">Geraldus Wilsen</a>.</p><p id="4011" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With the prompt-based approach, we have to define the output structure directly in the prompt. You can find the <a class="af nz" href="https://github.com/langchain-ai/langchain-experimental/blob/main/libs/experimental/langchain_experimental/graph_transformers/llm.py#L206" rel="noopener ugc nofollow" target="_blank">whole prompt here</a>. In this blog post, we’ll just do a high-level overview. We start by defining the system prompt.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="d829" class="pf ob fq pc b bg pg ph l pi pj">You are a top-tier algorithm designed for extracting information in structured formats to build a knowledge graph. Your task is to identify the entities and relations specified in the user prompt from a given text and produce the output in JSON format. This output should be a list of JSON objects, with each object containing the following keys:<br/><br/>- **"head"**: The text of the extracted entity, which must match one of the types specified in the user prompt.<br/>- **"head_type"**: The type of the extracted head entity, selected from the specified list of types.<br/>- **"relation"**: The type of relation between the "head" and the "tail," chosen from the list of allowed relations.<br/>- **"tail"**: The text of the entity representing the tail of the relation.<br/>- **"tail_type"**: The type of the tail entity, also selected from the provided list of types.<br/><br/>Extract as many entities and relationships as possible. <br/><br/>**Entity Consistency**: Ensure consistency in entity representation. If an entity, like "John Doe," appears multiple times in the text under different names or pronouns (e.g., "Joe," "he"), use the most complete identifier consistently. This consistency is essential for creating a coherent and easily understandable knowledge graph.<br/><br/>**Important Notes**:<br/>- Do not add any extra explanations or text.</span></pre><p id="6fde" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In the prompt-based approach, a key difference is that we ask the LLM to extract only relationships, not individual nodes. This means we won’t have any <em class="qd">isolated nodes</em>, unlike with the tool-based approach. Additionally, because models lacking native tool support typically perform worse, we do not allow extraction any properties — whether for nodes or relationships, to keep the extraction output simpler.</p><p id="2d3a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Next, we add a couple of few-shot examples to the model.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="a70b" class="pf ob fq pc b bg pg ph l pi pj">examples = [<br/>    {<br/>        "text": (<br/>            "Adam is a software engineer in Microsoft since 2009, "<br/>            "and last year he got an award as the Best Talent"<br/>        ),<br/>        "head": "Adam",<br/>        "head_type": "Person",<br/>        "relation": "WORKS_FOR",<br/>        "tail": "Microsoft",<br/>        "tail_type": "Company",<br/>    },<br/>    {<br/>        "text": (<br/>            "Adam is a software engineer in Microsoft since 2009, "<br/>            "and last year he got an award as the Best Talent"<br/>        ),<br/>        "head": "Adam",<br/>        "head_type": "Person",<br/>        "relation": "HAS_AWARD",<br/>        "tail": "Best Talent",<br/>        "tail_type": "Award",<br/>    },<br/>...<br/>]</span></pre><p id="ba68" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this approach, there’s currently no support for adding custom few-shot examples or extra instructions. The only way to customize is by modifying the entire prompt through the <code class="cx pv pw px pc b">prompt</code>attribute. Expanding customization options is something we’re actively considering.</p><p id="da00" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Next, we’ll take a look at defining the graph schema.</p><h1 id="48e1" class="oa ob fq bf oc od oe gq of og oh gt oi oj ok ol om on oo op oq or os ot ou ov bk">Defining the graph schema</h1><p id="1f6e" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">When using the LLM Graph Transformer for information extraction, defining a graph schema is essential for guiding the model to build meaningful and structured knowledge representations. A well-defined graph schema specifies the types of nodes and relationships to be extracted, along with any attributes associated with each. This schema serves as a blueprint, ensuring that the LLM consistently extracts relevant information in a way that aligns with the desired knowledge graph structure.</p><p id="311b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this blog post, we’ll use the opening paragraph of <a class="af nz" href="https://en.wikipedia.org/wiki/Marie_Curie" rel="noopener ugc nofollow" target="_blank">Marie Curie’s Wikipedia page</a> for testing with an added sentence at the end about Robin Williams.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="0a70" class="pf ob fq pc b bg pg ph l pi pj">from langchain_core.documents import Document<br/><br/>text = """<br/>Marie Curie, 7 November 1867 – 4 July 1934, was a Polish and naturalised-French physicist and chemist who conducted pioneering research on radioactivity.<br/>She was the first woman to win a Nobel Prize, the first person to win a Nobel Prize twice, and the only person to win a Nobel Prize in two scientific fields.<br/>Her husband, Pierre Curie, was a co-winner of her first Nobel Prize, making them the first-ever married couple to win the Nobel Prize and launching the Curie family legacy of five Nobel Prizes.<br/>She was, in 1906, the first woman to become a professor at the University of Paris.<br/>Also, Robin Williams.<br/>"""<br/>documents = [Document(page_content=text)]</span></pre><p id="424e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We’ll also be using GPT-4o in all examples.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="1cf3" class="pf ob fq pc b bg pg ph l pi pj">from langchain_openai import ChatOpenAI<br/>import getpass<br/>import os<br/><br/>os.environ["OPENAI_API_KEY"] = getpass.getpass("OpenAI api key")<br/><br/>llm = ChatOpenAI(model='gpt-4o')</span></pre><p id="1b35" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To start, let’s examine how the extraction process works without defining any graph schema.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="7e2f" class="pf ob fq pc b bg pg ph l pi pj">from langchain_experimental.graph_transformers import LLMGraphTransformer<br/><br/>no_schema = LLMGraphTransformer(llm=llm)</span></pre><p id="e9ae" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now we can process the documents using the <code class="cx pv pw px pc b">aconvert_to_graph_documents</code> function, which is asynchronous. Using async with LLM extraction is recommended, as it allows for parallel processing of multiple documents. This approach can significantly reduce wait times and improve throughput, especially when dealing with multiple documents.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="4524" class="pf ob fq pc b bg pg ph l pi pj">data = await no_schema.aconvert_to_graph_documents(documents)</span></pre><p id="8e92" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The response from the LLM Graph Transformer will be a graph document, which has the following structure:</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="17d5" class="pf ob fq pc b bg pg ph l pi pj">[<br/>    GraphDocument(<br/>        nodes=[<br/>            Node(id="Marie Curie", type="Person", properties={}),<br/>            Node(id="Pierre Curie", type="Person", properties={}),<br/>            Node(id="Nobel Prize", type="Award", properties={}),<br/>            Node(id="University Of Paris", type="Organization", properties={}),<br/>            Node(id="Robin Williams", type="Person", properties={}),<br/>        ],<br/>        relationships=[<br/>            Relationship(<br/>                source=Node(id="Marie Curie", type="Person", properties={}),<br/>                target=Node(id="Nobel Prize", type="Award", properties={}),<br/>                type="WON",<br/>                properties={},<br/>            ),<br/>            Relationship(<br/>                source=Node(id="Marie Curie", type="Person", properties={}),<br/>                target=Node(id="Nobel Prize", type="Award", properties={}),<br/>                type="WON",<br/>                properties={},<br/>            ),<br/>            Relationship(<br/>                source=Node(id="Marie Curie", type="Person", properties={}),<br/>                target=Node(<br/>                    id="University Of Paris", type="Organization", properties={}<br/>                ),<br/>                type="PROFESSOR",<br/>                properties={},<br/>            ),<br/>            Relationship(<br/>                source=Node(id="Pierre Curie", type="Person", properties={}),<br/>                target=Node(id="Nobel Prize", type="Award", properties={}),<br/>                type="WON",<br/>                properties={},<br/>            ),<br/>        ],<br/>        source=Document(<br/>            metadata={"id": "de3c93515e135ac0e47ca82a4f9b82d8"},<br/>            page_content="\nMarie Curie, 7 November 1867 – 4 July 1934, was a Polish and naturalised-French physicist and chemist who conducted pioneering research on radioactivity.\nShe was the first woman to win a Nobel Prize, the first person to win a Nobel Prize twice, and the only person to win a Nobel Prize in two scientific fields.\nHer husband, Pierre Curie, was a co-winner of her first Nobel Prize, making them the first-ever married couple to win the Nobel Prize and launching the Curie family legacy of five Nobel Prizes.\nShe was, in 1906, the first woman to become a professor at the University of Paris.\nAlso, Robin Williams!\n",<br/>        ),<br/>    )<br/>]</span></pre><p id="8e7e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The graph document describes extracted <code class="cx pv pw px pc b">nodes</code> and <code class="cx pv pw px pc b">relationships</code> . Additionally, the source document of the extraction is added under the <code class="cx pv pw px pc b">source</code> key.</p><p id="eda4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We can use the Neo4j Browser to visualize the outputs, providing a clearer and more intuitive understanding of the data.</p></div></div><div class="mr"><div class="ab cb"><div class="lm pk ln pl lo pm cf pn cg po ci bh"><figure class="mm mn mo mp mq mr pq pr paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qv"><img src="../Images/a13874667bfc937faf32649450a465a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*KHHOsvYQasd5D_dBogF90A.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Visualization of two extraction passes over the same dataset without a defined graph schema. Image by author.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="0e35" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The image above shows two extraction passes over the same paragraph about Marie Curie. In this case, we used GPT-4 with tool-based extraction, which also allows for isolated nodes, as illustrated in the image. Because no graph schema was defined, the LLM determines at runtime what information to extract, which can lead to variations in the output, even from the same paragraph. As a result, some extractions are more detailed than others and may vary in structure, even for the same information. For instance, on the left, Marie is represented as the <code class="cx pv pw px pc b">WINNER</code>of the Nobel Prize, while on the right, she <code class="cx pv pw px pc b">WON</code>the Nobel Prize.</p><p id="5543" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, let’s try the same extraction using the prompt-based approach. For models that support tools, you can enable prompt-based extraction by setting the <code class="cx pv pw px pc b">ignore_tool_usage</code>parameter.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="6ae2" class="pf ob fq pc b bg pg ph l pi pj">no_schema_prompt = LLMGraphTransformer(llm=llm, ignore_tool_usage=True)<br/>data = await no_schema.aconvert_to_graph_documents(documents)</span></pre><p id="fe1c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Again, we can visualize two separate executions in Neo4j Browser.</p></div></div><div class="mr"><div class="ab cb"><div class="lm pk ln pl lo pm cf pn cg po ci bh"><figure class="mm mn mo mp mq mr pq pr paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qv"><img src="../Images/a68da1cdfec428b4b7f1d626e032f4eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*9KdbiplBQepP0Zi-9orn8w.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Visualization of two extraction passes over the same dataset without a defined graph schema using the prompt-based approach. Image by author.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="754b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With the prompt-based approach, we won’t see any isolated nodes. However, as with previous extractions, the schema can vary between runs, resulting in different outputs on the same input.</p><p id="7e11" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Next, let’s walk through how defining a graph schema can help produce more consistent outputs.</p><h2 id="f825" class="qe ob fq bf oc qf qg qh of qi qj qk oi nl ql qm qn np qo qp qq nt qr qs qt qu bk">Defining allowed nodes</h2><p id="88bc" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">Constraining the extracted graph structure can be highly beneficial, as it guides the model to focus on specific, relevant entities and relationships. By defining a clear schema, you improve consistency across extractions, making the outputs more predictable and aligned with the information you actually need. This reduces variability between runs and ensures that the extracted data follows a standardized structure, capturing expected information. With a well-defined schema, the model is less likely to overlook key details or introduce unexpected elements, resulting in cleaner, more usable graphs.</p><p id="7718" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We’ll start by defining the expected types of nodes to extract using the <code class="cx pv pw px pc b">allowed_nodes</code>parameter.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="daa9" class="pf ob fq pc b bg pg ph l pi pj">allowed_nodes = ["Person", "Organization", "Location", "Award", "ResearchField"]<br/>nodes_defined = LLMGraphTransformer(llm=llm, allowed_nodes=allowed_nodes)<br/>data = await allowed_nodes.aconvert_to_graph_documents(documents)</span></pre><p id="4117" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Here, we defined that the LLM should extract five types of nodes like <em class="qd">Person</em>, <em class="qd">Organization</em>, <em class="qd">Location</em>, and more. We visualize two separate executions in Neo4j Browser for comparison.</p></div></div><div class="mr"><div class="ab cb"><div class="lm pk ln pl lo pm cf pn cg po ci bh"><figure class="mm mn mo mp mq mr pq pr paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qv"><img src="../Images/4eb80ac824a94649476f98d7bd4cf60b.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*R6go1THavHe4pzmJDtEkng.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Visualization of two extraction passes with predefined node types. Image by author.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="035d" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">By specifying the expected node types, we achieve more consistent node extraction. However, some variation may still occur. For example, in the first run, “radioactivity” was extracted as a research field, while in the second, it was not.</p><p id="9ab0" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Since we haven’t defined relationships, their types can also vary across runs. Additionally, some extractions may capture more information than others. For instance, the <code class="cx pv pw px pc b">MARRIED_TO</code>relationship between Marie and Pierre isn’t present in both extractions.</p><p id="a55d" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, let’s explore how defining relationship types can further improve consistency.</p><h2 id="3759" class="qe ob fq bf oc qf qg qh of qi qj qk oi nl ql qm qn np qo qp qq nt qr qs qt qu bk">Defining allowed relationships</h2><p id="268e" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">As we’ve observed, defining only node types still allows for variation in relationship extraction. To address this, let’s explore how to define relationships as well. The first approach is to specify allowed relationships using a list of available types.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="8f16" class="pf ob fq pc b bg pg ph l pi pj">allowed_nodes = ["Person", "Organization", "Location", "Award", "ResearchField"]<br/>allowed_relationships = ["SPOUSE", "AWARD", "FIELD_OF_RESEARCH", "WORKS_AT", "IN_LOCATION"]<br/>rels_defined = LLMGraphTransformer(<br/>  llm=llm, <br/>  allowed_nodes=allowed_nodes,<br/>  allowed_relationships=allowed_relationships<br/>)<br/>data = await rels_defined.aconvert_to_graph_documents(documents)</span></pre><p id="c66b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let’s again examine two separate extractions.</p></div></div><div class="mr"><div class="ab cb"><div class="lm pk ln pl lo pm cf pn cg po ci bh"><figure class="mm mn mo mp mq mr pq pr paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qv"><img src="../Images/b8834e9764cd6bf340a7e99377b2dd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*A2WRAshWf46BW3iITdFzKA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Visualization of two extraction passes with predefined node and relationship types. Image by author.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="598c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With both nodes and relationships defined, our outputs become significantly more consistent. For example, Marie is always shown as winning an award, being the spouse of Pierre, and working at the University of Paris. However, since relationships are specified as a general list without restrictions on which nodes they can connect, some variation still occurs. For instance, the <code class="cx pv pw px pc b">FIELD_OF_RESEARCH</code>relationship might appear between a <code class="cx pv pw px pc b">Person</code>and a <code class="cx pv pw px pc b">ResearchField</code>, but sometimes it links an <code class="cx pv pw px pc b">Award</code>to a <code class="cx pv pw px pc b">ResearchField</code>. Additionally, since relationship directions aren’t defined, there may be differences in directional consistency.</p><p id="81ec" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To address the issues of not being able to specify which nodes a relationship can connect and enforcing relationship direction, we recently introduced a new option for defining relationships, as shown below.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="ef91" class="pf ob fq pc b bg pg ph l pi pj">allowed_nodes = ["Person", "Organization", "Location", "Award", "ResearchField"]<br/>allowed_relationships = [<br/>    ("Person", "SPOUSE", "Person"),<br/>    ("Person", "AWARD", "Award"),<br/>    ("Person", "WORKS_AT", "Organization"),<br/>    ("Organization", "IN_LOCATION", "Location"),<br/>    ("Person", "FIELD_OF_RESEARCH", "ResearchField")<br/>]<br/>rels_defined = LLMGraphTransformer(<br/>  llm=llm, <br/>  allowed_nodes=allowed_nodes,<br/>  allowed_relationships=allowed_relationships<br/>)<br/>data = await rels_defined.aconvert_to_graph_documents(documents)</span></pre><p id="d9a6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Rather than defining relationships as a simple list of strings, we now use a three-element tuple format, where the elements represents the source node, relationship type, and target node, respectively.</p><p id="92a3" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let’s visualize the results again.</p></div></div><div class="mr"><div class="ab cb"><div class="lm pk ln pl lo pm cf pn cg po ci bh"><figure class="mm mn mo mp mq mr pq pr paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qv"><img src="../Images/c26aee8a8356ce6ad2d431cf826e499d.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*ZyPOatXfYvo14In1bOuX2Q.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Visualization of two extraction passes with predefined node and advanced relationship types. Image by author.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="c63f" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Using the three-tuple approach provides a much more consistent schema for the extracted graph across multiple executions. However, given the nature of LLMs, there may still be some variation in the level of detail extracted. For instance, on the right side, Pierre is shown as winning the Nobel Prize, while on the left, this information is missing.</p><h2 id="cbf3" class="qe ob fq bf oc qf qg qh of qi qj qk oi nl ql qm qn np qo qp qq nt qr qs qt qu bk">Defining properties</h2><p id="dc59" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">The final enhancement we can make to the graph schema is to define properties for nodes and relationships. Here, we have two options. The first is setting either <code class="cx pv pw px pc b">node_properties</code>or <code class="cx pv pw px pc b">relationship_properties</code>to <code class="cx pv pw px pc b">true</code>allows the LLM to autonomously decide which properties to extract.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="3f7f" class="pf ob fq pc b bg pg ph l pi pj">allowed_nodes = ["Person", "Organization", "Location", "Award", "ResearchField"]<br/>allowed_relationships = [<br/>    ("Person", "SPOUSE", "Person"),<br/>    ("Person", "AWARD", "Award"),<br/>    ("Person", "WORKS_AT", "Organization"),<br/>    ("Organization", "IN_LOCATION", "Location"),<br/>    ("Person", "FIELD_OF_RESEARCH", "ResearchField")<br/>]<br/>node_properties=True<br/>relationship_properties=True<br/>props_defined = LLMGraphTransformer(<br/>  llm=llm, <br/>  allowed_nodes=allowed_nodes,<br/>  allowed_relationships=allowed_relationships,<br/>  node_properties=node_properties,<br/>  relationship_properties=relationship_properties<br/>)<br/>data = await props_defined.aconvert_to_graph_documents(documents)<br/>graph.add_graph_documents(data)</span></pre><p id="1b6e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let’s examine the results.</p></div></div><div class="mr"><div class="ab cb"><div class="lm pk ln pl lo pm cf pn cg po ci bh"><figure class="mm mn mo mp mq mr pq pr paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qw"><img src="../Images/a49d80b92ca86d853d8a4856a6f67e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*67pBQnABYi-bhvCfAb6dLA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Extracted node and relationship properties. Image by author.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="596a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We’ve enabled the LLM to add any node or relationship properties it considers relevant. For instance, it chose to include Marie Curie’s birth and death dates, her role as a professor at the University of Paris, and the fact that she won the Nobel Prize twice. These additional properties significantly enrich the extracted information.</p><p id="b8d5" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The second option we have is to define the node and relationship properties we want to extract.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="b2a0" class="pf ob fq pc b bg pg ph l pi pj">allowed_nodes = ["Person", "Organization", "Location", "Award", "ResearchField"]<br/>allowed_relationships = [<br/>    ("Person", "SPOUSE", "Person"),<br/>    ("Person", "AWARD", "Award"),<br/>    ("Person", "WORKS_AT", "Organization"),<br/>    ("Organization", "IN_LOCATION", "Location"),<br/>    ("Person", "FIELD_OF_RESEARCH", "ResearchField")<br/>]<br/>node_properties=["birth_date", "death_date"]<br/>relationship_properties=["start_date"]<br/>props_defined = LLMGraphTransformer(<br/>  llm=llm, <br/>  allowed_nodes=allowed_nodes,<br/>  allowed_relationships=allowed_relationships,<br/>  node_properties=node_properties,<br/>  relationship_properties=relationship_properties<br/>)<br/>data = await props_defined.aconvert_to_graph_documents(documents)<br/>graph.add_graph_documents(data)</span></pre><p id="27f3" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The properties are simply defined as two lists. Let’s see what the LLM extracted.</p></div></div><div class="mr"><div class="ab cb"><div class="lm pk ln pl lo pm cf pn cg po ci bh"><figure class="mm mn mo mp mq mr pq pr paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qx"><img src="../Images/e10e408dd76aaa10d841f25d6b30922b.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*d-Q417ckaKqx7Qi5qc_jGA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Extracted predefined node and relationship properties. Image by author.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="9a67" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The birth and death dates remain consistent with the previous extraction. However, this time, the LLM also extracted the start date of Marie’s professorship at the University of Paris.</p><p id="4668" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Properties indeed add valuable depth to the extracted information, though there are currently some limitations in this implementation:</p><ul class=""><li id="03b9" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx qy pt pu bk">Properties can only be extracted using the tool-based approach.</li><li id="4570" class="nc nd fq ne b go py ng nh gr pz nj nk nl qa nn no np qb nr ns nt qc nv nw nx qy pt pu bk">All properties are extracted as strings.</li><li id="9c7d" class="nc nd fq ne b go py ng nh gr pz nj nk nl qa nn no np qb nr ns nt qc nv nw nx qy pt pu bk">Properties can only be defined globally, not per node label or relationship type.</li><li id="4bf9" class="nc nd fq ne b go py ng nh gr pz nj nk nl qa nn no np qb nr ns nt qc nv nw nx qy pt pu bk">There is no option to customize property descriptions to guide the LLM for more precise extraction.</li></ul><h2 id="8dce" class="qe ob fq bf oc qf qg qh of qi qj qk oi nl ql qm qn np qo qp qq nt qr qs qt qu bk">Strict mode</h2><p id="232b" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">If you thought we had perfected a way to make the LLM follow the defined schema flawlessly, I have to set the record straight. While we invested considerable effort into prompt engineering, it’s challenging to get LLM, especially the less performant one, to adhere to instructions with complete accuracy. To tackle this, we introduced a post-processing step, called <code class="cx pv pw px pc b">strict_mode</code>, that removes any information not conforming to the defined graph schema, ensuring cleaner and more consistent results.</p><p id="c6db" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">By default, <code class="cx pv pw px pc b">strict_mode</code>is set to <code class="cx pv pw px pc b">True</code>, but you can disable it with the following code:</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="e6a1" class="pf ob fq pc b bg pg ph l pi pj">LLMGraphTransformer(<br/>  llm=llm, <br/>  allowed_nodes=allowed_nodes,<br/>  allowed_relationships=allowed_relationships,<br/>  strict_mode=False<br/>)</span></pre><p id="c243" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With strict mode turned off, you may get node or relationship types outside the defined graph schema, as LLMs can sometimes take creative liberties with output structure.</p><h1 id="828d" class="oa ob fq bf oc od oe gq of og oh gt oi oj ok ol om on oo op oq or os ot ou ov bk">Importing graph documents into graph database</h1><p id="73df" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">The extracted graph documents from the LLM Graph Transformer can be imported into graph databases like Neo4j for further analysis and applications using the <code class="cx pv pw px pc b">add_graph_documents</code> method. We’ll explore different options for importing this data to suit different use cases.</p><h2 id="edf7" class="qe ob fq bf oc qf qg qh of qi qj qk oi nl ql qm qn np qo qp qq nt qr qs qt qu bk"><strong class="al">Default import</strong></h2><p id="b764" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">You can import nodes and relationships into Neo4j using the following code.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="6b68" class="pf ob fq pc b bg pg ph l pi pj">graph.add_graph_documents(graph_documents)</span></pre><p id="8876" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This method straightforwardly imports all nodes and relationships from the provided graph documents. We’ve used this approach throughout the blog post to review the results of different LLM and schema configurations.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qz"><img src="../Images/670cba1162b9e041fba881433e0dc851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7SHr3aIKBRDqtEdPOaQNkQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Default import setting. Image by author.</figcaption></figure><h2 id="36ce" class="qe ob fq bf oc qf qg qh of qi qj qk oi nl ql qm qn np qo qp qq nt qr qs qt qu bk">Base entity label</h2><p id="e070" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">Most graph databases support indexes to optimize data import and retrieval. In Neo4j, indexes can only be set for specific node labels. Since we might not know all the node labels in advance, we can handle this by adding a secondary base label to each node using the <code class="cx pv pw px pc b">baseEntityLabel</code>parameter. This way, we can still leverage indexing for efficient importing and retrieval without needing an index for every possible node label in the graph.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="4da1" class="pf ob fq pc b bg pg ph l pi pj">graph.add_graph_documents(graph_documents, baseEntityLabel=True)</span></pre><p id="0cb4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As mentioned, using the <code class="cx pv pw px pc b">baseEntityLabel</code> parameter will result in each node having an additional <code class="cx pv pw px pc b">__Entity__</code> label.</p></div></div><div class="mr"><div class="ab cb"><div class="lm pk ln pl lo pm cf pn cg po ci bh"><figure class="mm mn mo mp mq mr pq pr paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ra"><img src="../Images/2c5f7c083ec1ad026b69ac274b98c052.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*UrplGZXwiRSusr28Iopbpw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Each node gets a secondary label using the baseEntityLabel parameter. Image by author.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><h2 id="85b0" class="qe ob fq bf oc qf qg qh of qi qj qk oi nl ql qm qn np qo qp qq nt qr qs qt qu bk">Include source documents</h2><p id="a82b" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">The final option is to also import the source documents for the extracted nodes and relationships. This approach lets us track which documents each entity appeared in. You can import the source documents using the <code class="cx pv pw px pc b">include_source</code> parameter.</p><pre class="mm mn mo mp mq pb pc pd bp pe bb bk"><span id="4148" class="pf ob fq pc b bg pg ph l pi pj">graph.add_graph_documents(graph_documents, include_source=True)</span></pre><p id="39e4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Upon inspecting the imported graph, we should see a result similar to this.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rb"><img src="../Images/c2cd17506e7328a3bfc5fe28cd56a00d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfP3JiuNNbClFwYAeSGHSg.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Imported source document. Image by author.</figcaption></figure><p id="e836" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this visualization, the source document is highlighted in blue, with all entities extracted from it connected by <code class="cx pv pw px pc b">MENTIONS</code>relationships. This mode allows you to build <a class="af nz" href="https://medium.com/neo4j/enhancing-the-accuracy-of-rag-applications-with-knowledge-graphs-ad5e2ffab663" rel="noopener">retrievers that utilize both structured and unstructured search approaches</a>.</p><h1 id="32a7" class="oa ob fq bf oc od oe gq of og oh gt oi oj ok ol om on oo op oq or os ot ou ov bk">Summary</h1><p id="ec99" class="pw-post-body-paragraph nc nd fq ne b go ow ng nh gr ox nj nk nl oy nn no np oz nr ns nt pa nv nw nx fj bk">In this post, we explored LangChain’s LLM Graph Transformer and its dual modes for building knowledge graphs from text. The tool-based mode, our primary approach, leverages structured output and function calling, which reduces prompt engineering and allows for property extraction. Meanwhile, the prompt-based mode is useful when tools aren’t available, relying on few-shot examples to guide the LLM. However, prompt-based extraction does not support property extraction and also yields no isolated nodes.</p><p id="5fa5" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We observed that defining a clear graph schema, including allowed node and relationship types, improves extraction consistency and performance. A constrained schema helps ensure that the output adheres to our desired structure, making it more predictable, reliable, and applicable. Whether using tools or prompts, the LLM Graph Transformer enables more organized, structured representations of unstructured data, enabling better RAG applications and multi-hop query handling.</p><p id="66d4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The code is available on <a class="af nz" href="https://github.com/tomasonjo/blogs/blob/master/llm/llm_graph_transformer_in_depth.ipynb" rel="noopener ugc nofollow" target="_blank">GitHub</a>. You can also try out the LLM Graph Transformer in a no-code environment using Neo4j’s hosted <strong class="ne fr">LLM Graph Builder</strong> application.</p><div class="rc rd re rf rg rh"><a href="https://llm-graph-builder.neo4jlabs.com/?source=post_page-----a91045c49b59--------------------------------" rel="noopener  ugc nofollow" target="_blank"><div class="ri ab ig"><div class="rj ab co cb rk rl"><h2 class="bf fr hw z io rm iq ir rn it iv fp bk">Neo4j graph builder</h2><div class="ro l"><h3 class="bf b hw z io rm iq ir rn it iv dx">No-code</h3></div><div class="rp l"><p class="bf b dy z io rm iq ir rn it iv dx">llm-graph-builder.neo4jlabs.com</p></div></div></div></a></div></div></div></div></div>    
</body>
</html>
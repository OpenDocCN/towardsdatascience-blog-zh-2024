- en: Callbacks and Pipeline structures in LangChain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/callbacks-and-pipeline-structures-in-langchain-925aa077227e?source=collection_archive---------6-----------------------#2024-04-16](https://towardsdatascience.com/callbacks-and-pipeline-structures-in-langchain-925aa077227e?source=collection_archive---------6-----------------------#2024-04-16)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Learn about the structure of LangChain pipelines, callbacks, how to create custom
    callbacks and integrate them into your pipelines for improved monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@RSK2327?source=post_page---byline--925aa077227e--------------------------------)[![Roshan
    Santhosh](../Images/2509f38bf7d5a40c453fa54575293f06.png)](https://medium.com/@RSK2327?source=post_page---byline--925aa077227e--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--925aa077227e--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--925aa077227e--------------------------------)
    [Roshan Santhosh](https://medium.com/@RSK2327?source=post_page---byline--925aa077227e--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--925aa077227e--------------------------------)
    ·11 min read·Apr 16, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks are an important functionality that helps with monitoring/debugging
    your pipelines. In this note, we cover the basics of callbacks and how to create
    custom ones for your use cases. More importantly, through examples, we also develop
    an understanding of the structure/componentization of LangChain pipelines and
    how that plays into the design of custom callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: This note assumes basic familiarity with LangChain and how pipelines in LangChain
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Structure of Callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn about the basics of callbacks in LangChain, we start with the [official
    documentation](https://python.langchain.com/docs/modules/callbacks/) where we
    can find the definition of the **BaseCallbackHandler** class.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/09298f9767c694b691d4567ee5fed0e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Image taken from official [langchain documentation](https://python.langchain.com/docs/modules/callbacks/)
  prefs: []
  type: TYPE_NORMAL
- en: '[BaseCallbackManager code](https://github.com/langchain-ai/langchain/blob/master/libs/core/langchain_core/callbacks/base.py)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see this is an abstract class that defines quite a few methods to
    cover various events in your LangChain pipeline. These methods can be grouped
    together into the following segments :'
  prefs: []
  type: TYPE_NORMAL
- en: LLM [start, end, error, new token]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chain [start, end, error]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tool [start, end, error]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Agent [action, finish]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have worked with LangChain pipelines before, the methods along with their
    provided descriptions should be mostly self explanatory. For example, the ***on_llm_start***
    callback is the event that gets triggered when the LangChain pipeline passes input
    to the LLM. And that ***on_llm_end*** is subsequently triggered when the LLM provides
    its final output.
  prefs: []
  type: TYPE_NORMAL
- en: '*NOTE : There are events triggers that can be used in addition to whats shown
    above. These can be found* [*here*](https://api.python.langchain.com/en/latest/runnables/langchain_core.runnables.base.RunnableSequence.html)*.
    These cover triggers relating to Retrievers, Prompts, ChatModel etc.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Understanding how Callbacks work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Callbacks are a very common programming concept that have been widely used for
    a while now, so the high level concept of how callbacks work is well understood.
    So in this post, we focus on the specific nuances of how callbacks work in LangChain
    and how we could use it to satisfy our specific use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in the mind the base Callback class that we saw in the previous section,
    we explore Callbacks in LangChain through a series of increasingly complex examples
    and in the process gain a better understanding of the structure of pipelines in
    LangChain. This would be a top-down approach to learning where we start with examples
    first and actual definitions later as I found that to be more useful personally
    for this specific topic.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start with a simple dummy chain that has 3 components : 2 prompts and a
    custom function to join them. I refer to this as a dummy example because its very
    unlikely that you would need two separate prompts to interact with each other,
    but it makes for an easier example to start with for understanding callbacks and
    LangChain pipelines.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a85491d7b3e8d386730736be9216aac8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 1 : Basic structure of LangChain pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing this in code would look like :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/feb48b47658516acf9ea930c09acb98c.png)'
  prefs: []
  type: TYPE_IMG
- en: Pipeline implementation for Example 1
  prefs: []
  type: TYPE_NORMAL
- en: The above code is pretty textbook stuff. The only possibly complex piece is
    the ***retrieve_text*** and ***RunnableLambda*** function thats being used here.
    The reason this is necessary is because the format of the output from ***qa_prompt1***
    is not compatible with the format of the output required by ***qa_prompt2.***
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the custom Callback**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ad6bc4c936d6251b991b066126236e51.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For our custom callback, we define a new subclass of BaseCallbackHandler called
    CustomCallback1 which defines the ***on_chain_start*** method. The method definition
    is straightforward as it simply takes the input values passed to it and saves
    it in 2 specific variables : ***chain_input*** and ***serialized_input***'
  prefs: []
  type: TYPE_NORMAL
- en: '**Invoking the custom callback**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/98c6c6878453f2bea6bfb157f45f84bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 1 : Invoking with pipeline with the custom callback'
  prefs: []
  type: TYPE_NORMAL
- en: 'The above code shows one of the possible ways to pass your custom callback
    to your pipeline : As a list of callback objects as the value to a corresponding
    key of ‘callbacks’. This also makes it easy to guess that *you can pass multiple
    callbacks to your LangChain pipeline.*'
  prefs: []
  type: TYPE_NORMAL
- en: Decoding the Callback/Pipeline Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now comes the interesting part. After we have defined the callbacks and passed
    it on to our pipeline, we now perform a deep dive into the callback outputs
  prefs: []
  type: TYPE_NORMAL
- en: We first look at the values stored in ***chain_input***
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/86a11c5f570e3a85f96289a9b62f2698.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 1 : Contents of chain_input variable of callback handler'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observations :**'
  prefs: []
  type: TYPE_NORMAL
- en: Though **there are 3 components in our chain, there are 4 values in *chain_input***.
    Which corresponds to the ***on_chain_start*** method being triggered 4 times instead
    of 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first two ***chain_input*** values/ on_chain_start triggers, the input
    is the same as the user provided input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We next look at the outputs of ***serialized_input***
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0d71d6c54bc40938b4099c2f89863fde.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Observations :**'
  prefs: []
  type: TYPE_NORMAL
- en: The first component is a ***RunnableSequence*** which is a component that wasnt
    added by the user but was automatically added by LangChain. The rest of the components
    correspond directly to the user-defined components in the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The full contents of serialized_input is extensive! While there is a definite
    structure to that content, its definitely out of scope for this post and possibly
    doesnt have much practical implications for an end user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we interpret these results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the most part, the outputs seen in the ***chain_input*** and ***serialized_input***
    make sense. Whether its the input values or the names/IDs of the components. The
    only largely unknown part is the ***RunnableSequence*** component, so we take
    a closer look at this.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, the full contents of ***serialized_input*** is extensive
    and not easy to digest. So to make things easier, we look at only the high level
    attributes described in ***serialized_input*** and try to intrepret the results
    through these attributes. For this, we make use of a custom debugging function
    called ***getChainBreakdown*** (code in notebook).
  prefs: []
  type: TYPE_NORMAL
- en: 'We call ***getChainBreakdown*** on all values of ***serialized_input*** and
    observe the output. Specifically for the first ***RunnableSequence*** element,
    we look at the keys of the kwargs dict : first, midde, last, name.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a6ccf5a1ef4250daa084ec5cff56725a.png)'
  prefs: []
  type: TYPE_IMG
- en: On closer inspection of the kwargs argument and their values, we see that they
    have the same structure as our previous pipeline components. In fact, **the first,
    middle and last components correspond exactly to the user-defined components of
    the pipeline.**
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3918083f2cf8c069ce8d73a234ec7894.png)'
  prefs: []
  type: TYPE_IMG
- en: Closer inspection of RunnableSequence kwargs values
  prefs: []
  type: TYPE_NORMAL
- en: 'The above details form the basis of the final conclusion that we make here.
    That the structure of the pipeline is like shown below :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/733df8d01a5d1285fc7c71ed85d20ba1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 1 : Structure of LangChain pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: We do make a bit of a leap here as the above flowchart was confirmed after going
    through a bunch of examples and observing the format in which these components
    are created internally by LangChain. So bear with me as we go through these other
    examples which will solidify the conclusion that we make here.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: With the above defined structure, the other pieces of the puzzle fit together
    quite well. Focusing on the chain_input values, lets map them to the components
    (with their ordering) defined above.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dd692e9be32631fa88cd061b0571b0c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 1 : Mapping chain_input values to pipeline components'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observations :**'
  prefs: []
  type: TYPE_NORMAL
- en: For RunnableSequence, as it acts like a wrapper for the whole pipeline, the
    input from the user acts as the input for the RunnableSequence component as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the first ChatPromptTemplate (qa_prompt1), as the first ‘true’ component
    of the pipeline, it receives the direct input from the user
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For RunnableLambda (retrieve_text), it receives as input the output from qa_prompt1,
    which is a Message object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the last ChatPromptTemplate (qa_prompt2), it receives as input the output
    from retrieve_text, which is a dict with ‘prompt’ as its single key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The above breakdown shows how the structure of the pipeline described above
    fits perfectly with the data seen in ***serialized_input*** and ***chain_input***
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 2**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the next example, we extend Example 1 by adding a LLM as the final step.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fcd60f4feaecfe05f96f2afcaaf932af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 2 : Pipeline definition'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the callback, since we have now added a LLM into the mix, we define a new
    custom callback that additionally defines the ***on_llm_start*** method. It has
    the same functionality as on_chain_start where the input arguments are saved into
    the callback object variables : ***chain_input*** and ***serialized_input***'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/afd7116322e83863c9057c4515c3d11c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 2 : New custom callback with added on_llm_start method'
  prefs: []
  type: TYPE_NORMAL
- en: Proposing the Pipeline structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this stage, instead of evaluating the callback variables, we switch things
    up and propose the potential structure of the pipeline. Given what we had learnt
    from the first example, the following should be the potential structure of the
    pipeline
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/25c4f818730b753f5f092f0f5f20adfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 2 : Proposed structure of pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: So we would have a ***RunnableSequence*** component as a wrapper for the pipeline.
    And additionally include a new ***ChatOpenAI*** object thats nested within the
    ***RunnableSequence*** component.
  prefs: []
  type: TYPE_NORMAL
- en: '**Validating proposed structure using data**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now look at the values of in the callback object to validate the above proposed
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: We first look at the values stored in ***chain_input***
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e5821967629f973e91c7862bca104b41.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 2 : chain_input values'
  prefs: []
  type: TYPE_NORMAL
- en: 'And then the ***serialized_input*** values :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e9819f105451d2ee4d17284071f5bb1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 2 : serialized_input values'
  prefs: []
  type: TYPE_NORMAL
- en: As well as a deeper inspection of the RunnableSequence components
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/39b910cc4e2d3d951bd01d0bcc4403e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 2 : Closer inspection of RunnableSequence kwargs values'
  prefs: []
  type: TYPE_NORMAL
- en: '**Observations :**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of ***serialized_input*** validate the activation/trigger sequence
    that was proposed in the pipeline structure : RunnableSequence -> ChatPromptTemplate(qa_prompt1)
    -> RunnableLambda(retrieve_text) -> ChatPromptTemplate(qa_prompt2) -> ChatOpenAI'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The values of ***chain_input*** also map correctly to the proposed structure.
    The only new addition is the fifth entry, which corresponds to the output from
    ***qa_prompt2***, which is fed as input to the ChatOpenAI object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The components of the RunnableSequence kwargs also verify the proposed structure
    as the new ‘last’ element is the ChatOpenAI object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By this stage, you should have an intuitive understanding of how LangChain pipelines
    are structured and when/how different callback events are triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Though we have only focused on Chain and LLM events so far, these translate
    well to the other Tool and Agent triggers as well
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Example 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the next example, we progress to a more complex chain involving a parallel
    implementation (RunnableParallel)
  prefs: []
  type: TYPE_NORMAL
- en: Chain/Callback Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The chain has a parallel implementation as its first block which computes two
    values : context and question, which are then passed on to a prompt template to
    create the final prompt. The parallel functionality is required because we need
    to pass both context and question to the prompt template at the same time, where
    the context is retrived from a different source while the question is provided
    by the user.'
  prefs: []
  type: TYPE_NORMAL
- en: For the context value, we use a static function ***get_data*** that returns
    the same piece of text (this is a dummy version of an actual retriever used in
    RAG applications).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/41d8affecbf0cbcce12300f47c983acb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 3 : Chain implementation'
  prefs: []
  type: TYPE_NORMAL
- en: For the callback implementation, we use the same callback as the first example,
    CustomCallback1
  prefs: []
  type: TYPE_NORMAL
- en: Decoding the Callback/Pipeline Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to previous examples, we start by looking at the outputs of ***chain_input***
    and ***serialized_input***
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a92432cbeb40d6a15dac6a227e83d2ac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 3 : chain_input values'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9ff2607608a8df2e0a2f9bbfbae4aa7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 3 : serialized_input values'
  prefs: []
  type: TYPE_NORMAL
- en: We also look do a deep dive into the ***RunnableSequence*** (index 0) and ***RunnableParallel***
    (index 1) components
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6cd911544c6a75f852469b21689410bd.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Observations :**'
  prefs: []
  type: TYPE_NORMAL
- en: Consistent with previous examples, the RunnableSequence acts as a wrapper to
    the whole pipeline. Its first component is the ***RunnableParallel*** component
    and its last component is the ***ChatPromptTemplate*** component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The RunnableParallel in turn encompasses two components : the ***RunnablePassthrough***
    and the ***RunnableLambda*** (***get_data***).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The inputs to the first 4 components : ***RunnableSequence***, ***RunnableParallel***,
    ***RunnablePassthrough*** and ***RunnableLambda*** (***get_data***) are the same
    : the provided user input. Only for the final ***ChatPromptTemplate*** component
    do we have a different input, which is a dict with question and context keys.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on these observations, we can infer the final structure of the pipeline
    as such :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dd8756214b5be8bafed7eec2f58d5bc1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 3 : Structure of LangChain pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Same as Example 3, but with an additional processing function for retrieving
    context
  prefs: []
  type: TYPE_NORMAL
- en: Chain/Callback Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/0ef17c0768f777f46bdc7111b72cb469.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 4 : Chain implementation'
  prefs: []
  type: TYPE_NORMAL
- en: Decoding the Callback/Pipeline Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to previous examples, we again look at the usual data points
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/89b0a6509f53fd7a8e67ef3354784c60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 4 : chain_input values'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8798ce2d935710f97f481fac0a1eaeff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 4 : serialized_input values'
  prefs: []
  type: TYPE_NORMAL
- en: We observe that there are now 2 RunnableSequence components in our pipeline.
    So for the next step, we deep dive into both of these RunnableSequence components
    to see its internal components
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/75d6cea7cc29c1a6cb021c70594d57aa.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Observations :**'
  prefs: []
  type: TYPE_NORMAL
- en: For the first ***RunnableSequence*** components, its components are the same
    as the previous example. Starts with ***RunnableParallel*** and ends with ***ChatPromptTemplate***
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the second ***RunnableSequence***, its first component is the ***RunnableLambda
    (get_data)*** component and the last component is the ***RunnableLambda (format_docs)***
    component. This is basically the part of the pipeline responsible for generating
    the ‘context’ value. So its possible for a LangChain pipeline to have multiple
    RunnableSequence components to it. Especially when you are creating ‘sub-pipelines’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this case, the creation of the ‘context’ value can be considered a pipeline
    by itself as it involves 2 different components chained together. So any such
    sub-pipelines in your primary pipeline will be wrapped up by a RunnableSequence
    component
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 3\. The values from chain_input also match up well with the pipeline components
    and their ordering (Not going to breakdown each component’s input here as it should
    be self-explanatory by now)
  prefs: []
  type: TYPE_NORMAL
- en: So based on the above observations, the following is the identified structure
    of this pipeline
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6b5a3c01eed6ad1e1e32a0ab06a5196d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Example 4 : Structure of LangChain pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objective of this post was to help develop an (intuitive) understanding
    of how LangChain pipelines are structured and how callback triggers are associated
    with the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: By going through increasingly complex chain implementations, we were able to
    understand the general structure of LangChain pipelines and how a callback can
    be used for retrieving useful information. Developing an understanding of how
    LangChain pipelines are structured will also help facilitate the debugging process
    when errors are encountered.
  prefs: []
  type: TYPE_NORMAL
- en: A very common use case for callbacks is retrieving intermediate steps and through
    these examples we saw how we can implement custom callbacks that track the input
    at each stage of the pipeline. Add to this our understanding of the structure
    of the LangChain pipelines, we can now easily pinpoint the input to each component
    of the pipeline and retrieve it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Notebook with code/examples](https://github.com/rsk2327/AI-Workbook/blob/3c92744030b79f849867b15fc19ee1e738b83eab/LangChain/Callback%20Deep%20Dive.ipynb)
    : Contains few additional examples not covered in this note.'
  prefs: []
  type: TYPE_NORMAL
- en: Unless specified otherwise, all images are created by the author.
  prefs: []
  type: TYPE_NORMAL
- en: '*In addition to Medium, I share my thoughts, ideas and other updates on* [*Linkedin*](https://www.linkedin.com/in/roshan-santhosh/)*.*'
  prefs: []
  type: TYPE_NORMAL

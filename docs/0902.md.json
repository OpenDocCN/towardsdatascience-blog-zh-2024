["```py\ndef F(x):\n  return -2*x**3+x**2+2.1\n\nx = np.arange(-5,5, 0.1)\ny = F(x)\n```", "```py\nimport geopandas as gdp\n\nshape = gpd.read_file('gadm41_CHE_0.shp')\nshape.plot()\n```", "```py\nimport pandas as pd\nfrom shapely.geometry import Point\n\ndf = pd.read_csv('3639866.csv')\n\npoints = list()\nfor i in range(len(df)):\n  point = Point(df.loc[i, 'LONGITUDE'], df.loc[i, 'LATITUDE'])\n  points.append(point)\n\ngdf = gpd.GeoDataFrame(geometry=points).set_crs(shape.crs)\n```", "```py\nfig, ax = plt.subplots(figsize=(16,9))\nshape.plot(ax=ax, color='black')\ngdf.plot(ax=ax, color='r', markersize=85)\nplt.show()\n```", "```py\nimport matplotlib.ticker as mticker\nimport cartopy.crs as ccrs\nfrom cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER\n\nLAT, LON = np.arange(45.75, 48, 0.1), np.arange(6, 10.81, 0.1)\n\nfig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(16, 9))\nshape.plot(ax=ax, color='grey')\ngdf.plot(ax=ax, color='r', markersize=85)\n\ngl = ax.gridlines(draw_labels=True,linewidth=2, color='black', alpha=0.5, linestyle='--')\ngl.xlocator = mticker.FixedLocator(LON)\ngl.ylocator = mticker.FixedLocator(LAT)\ngl.xformatter = LONGITUDE_FORMATTER\ngl.yformatter = LATITUDE_FORMATTER\nplt.show()\n```", "```py\ndef Euclidean(x1,x2,y1,y2):\n  return ((x1-x2)**2+(y1-y2)**2)**0.5\n\ndef NN(data, LAT, LON):\n  array = np.empty((LAT.shape[0], LON.shape[0]))\n\n  for i, lat in enumerate(LAT):\n    for j, lon in enumerate(LON):\n      idx = data.apply(lambda row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat), axis = 1).argmin() \n      array[i,j] = data.loc[idx, 'TAVG']\n  return array\n```", "```py\nidx = data.apply(lambda row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat), axis = 1).argmin()\n```", "```py\nt2m = NN(df, LAT, LON)\nds = xr.Dataset(\n    {'TAVG': (['lat', 'lon'], t2m)},\n    coords={'lat': LAT, 'lon': LON})\n```", "```py\nshape['new_column'] = 0\nsw = shape.dissolve(by='new_column')['geometry']\nrg = regionmask.mask_3D_geopandas(sw, lon_or_obj=ds.lon, lat=ds.lat)\n\nfig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(16, 9))\n#shape.plot(ax=ax, color='black')\nds.where(rg).TAVG.plot(ax=ax, alpha=0.6)\ngdf.plot(ax=ax, color='r', markersize=85)\nax.gridlines(draw_labels=True,linewidth=2, color='black', alpha=0.5, linestyle='--')\nplt.show()\n```", "```py\ndef IDW(data, LAT, LON, betta=2):\n  array = np.empty((LAT.shape[0], LON.shape[0]))\n\n  for i, lat in enumerate(LAT):\n    for j, lon in enumerate(LON):\n      weights = data.apply(lambda row: Euclidean(row.LONGITUDE, lon, row.LATITUDE, lat)**(-betta), axis = 1)\n      z = sum(weights*data.TAVG)/weights.sum()\n      array[i,j] = z\n  return array\n```", "```py\nfrom scipy.linalg import solve\nfrom itertools import product\nfrom sklearn.metrics import mean_squared_error as MSE\n\nclass OrdinaryKriging:\n    def __init__(self, lats, lons, values):\n        self.lats = lats\n        self.lons= lons\n        self.values = values\n\n        self.nugget_values = [0, 1, 2, 3, 4]\n        self.sill_values = [1, 2, 3, 4, 5]\n        self.range_values = [1, 2, 3, 4, 5]\n\n        # Generate all combinations of parameter values to fit\n        self.parameter_combinations = list(product(self.nugget_values, self.sill_values, self.range_values))\n        self.optimal_pars = None\n\n    def theoretical_variogram(self, h, nugget, sill, r):\n        return nugget + (sill-nugget) * (1-np.exp(-3*h/r))\n\n    def Euclidean(self, X, Y):\n        all_dists, point_dists = [], []\n        for x,y in zip(X, Y):\n          k = 0\n          for k in range(len(X)):\n            h = np.linalg.norm(np.array([x, y]) - np.array([X[k], Y[k]]))\n            point_dists.append(h)\n          all_dists.append(point_dists)\n          point_dists = []\n        return all_dists\n\n    def gamma(self):\n        distances = self.Euclidean(self.lats, self.lons)\n        differences = np.abs(self.values.reshape(-1,1) - self.values)\n        variogram_values = []\n        for h in np.unique(distances):\n            values_at_h = differences[(distances == h)]\n            variogram_values.append(np.mean(values_at_h**2))\n        return variogram_values, np.unique(distances)\n\n    def fit(self):\n        experimental_variogram, distances = self.gamma()\n        fit_metrics = []\n        for nugget, sill, range_ in self.parameter_combinations:\n            theoretical_variogram_values = self.theoretical_variogram(distances, nugget, sill, range_)\n            fit_metric = MSE(experimental_variogram, theoretical_variogram_values)\n            fit_metrics.append((nugget, sill, range_, fit_metric))\n\n        self.optimal_pars = min(fit_metrics, key=lambda x: x[3])[:3]\n\n    def predict(self, point):\n        points = np.array([(x,y) for x,y in zip(self.lats, self.lons)])\n        distances = np.linalg.norm(points - point, axis=1)\n        pars = list(self.optimal_pars)\n        pars.insert(0, distances)\n        weights = self.theoretical_variogram(*pars)\n        weights /= np.sum(weights)\n        return np.dot(weights, self.values)\n\nkriging = OrdinaryKriging(df.LATITUDE.values, df.LONGITUDE.values, df.TAVG.values)\n\nkriging.fit()\n```", "```py\ndef __init__(self, lats, lons, values):\n        self.lats = lats\n        self.lons= lons\n        self.values = values\n\n        self.nugget_values = [0, 1, 2, 3, 4]\n        self.sill_values = [1, 2, 3, 4, 5]\n        self.range_values = [1, 2, 3, 4, 5]\n\n        # Generate all combinations of parameter values to fit\n        self.parameter_combinations = list(product(self.nugget_values, self.sill_values, self.range_values))\n        self.optimal_pars = None\n```", "```py\ndef theoretical_variogram(self, h, nugget, sill, r):\n return nugget + (sill-nugget) * (1-np.exp(-3*h/r))\n```", "```py\ndef Euclidean(self, X, Y):\n        all_dists, point_dists = [], []\n        for x,y in zip(X, Y):\n          k = 0\n          for k in range(len(X)):\n            h = np.linalg.norm(np.array([x, y]) - np.array([X[k], Y[k]]))\n            point_dists.append(h)\n          all_dists.append(point_dists)\n          point_dists = []\n        return all_dists\n```", "```py\ndef fit(self):\n        experimental_variogram, distances = self.gamma()\n        fit_metrics = []\n        for nugget, sill, range_ in self.parameter_combinations:\n            theoretical_variogram_values = self.theoretical_variogram(distances, nugget, sill, range_)\n            fit_metric = MSE(experimental_variogram, theoretical_variogram_values)\n            fit_metrics.append((nugget, sill, range_, fit_metric))\n\n        self.optimal_pars = min(fit_metrics, key=lambda x: x[3])[:3]\n```", "```py\ndef predict(self, point):\n        points = np.array([(x,y) for x,y in zip(self.lats, self.lons)])\n        distances = np.linalg.norm(points - point, axis=1)\n        pars = list(self.optimal_pars)\n        pars.insert(0, distances)\n        weights = self.theoretical_variogram(*pars)\n        weights /= np.sum(weights)\n        return np.dot(weights, self.values)\n```", "```py\nrow, grid = [], []\nfor lat in LAT:\n  for lon in LON:\n    row.append(kriging.predict(np.array([lat, lon])))\n  grid.append(row)\n  row=[]\n\nds = xr.Dataset(\n    {'TAVG': (['lat', 'lon'], grid)},\n    coords={'lat': LAT, 'lon': LON})\n\nfig, ax = plt.subplots(subplot_kw=dict(projection=ccrs.PlateCarree()), figsize=(16, 9))\nds.where(rg).TAVG.plot(ax=ax, alpha=0.6)\ngdf.plot(ax=ax, color='r', markersize=85)\nax.gridlines(draw_labels=True,linewidth=2, color='black', alpha=0.5, linestyle='--')\nplt.show()\n```"]
- en: Algorithm-Agnostic Model Building with MLflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/algorithm-agnostic-model-building-with-mlflow-b106a5a29535?source=collection_archive---------0-----------------------#2024-08-10](https://towardsdatascience.com/algorithm-agnostic-model-building-with-mlflow-b106a5a29535?source=collection_archive---------0-----------------------#2024-08-10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A beginner-friendly step-by-step guide to creating generic ML pipelines using
    mlflow.pyfunc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://menawang.medium.com/?source=post_page---byline--b106a5a29535--------------------------------)[![Mena
    Wang, PhD](../Images/eac9fa55026f9fc119bc868439ff311b.png)](https://menawang.medium.com/?source=post_page---byline--b106a5a29535--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--b106a5a29535--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--b106a5a29535--------------------------------)
    [Mena Wang, PhD](https://menawang.medium.com/?source=post_page---byline--b106a5a29535--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--b106a5a29535--------------------------------)
    ¬∑8 min read¬∑Aug 10, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: One common challenge in MLOps is the hassle of migrating between various algorithms
    or frameworks. This beginner-friendly article helps you tackle the challenge by
    leveraging algorithm-agnostic model building using `mlflow.pyfunc`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why Agorithm-Agonostic Model Building?**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider this scenario: we have an sklearn model currently deployed in production
    for a particular use case. Later on, we find that a deep learning model performs
    even better. If the sklearn model was deployed in its native format, transitioning
    to the deep learning model could be a hassle ü§™ because the two model artifacts
    are very different.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/33a9e7864d65b8a617c6d295f3d2b53a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image generated by prompting Gemini
  prefs: []
  type: TYPE_NORMAL
- en: To address such a challenge, the `mlflow.pyfunc` model flavor provides a versatile
    and generic approach to building and deploying machine learning models in Python.
    üòé
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. Generic Model Building:** The `pyfunc` model flavor offers a uniform
    way to build models, regardless of the framework or library used for the build.'
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. Encapsulation of the ML Pipeline:** `pyfunc` allows us to encapsulate
    the model with its pre- and post-processing steps or other custom logic desirable
    during model consumption.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Unified Model Representation:** We can deploy a model, a machine learning
    pipeline, or any python function using `pyfunc` without worrying about the model''s
    underlying format. Such a unified representation simplifies model deployment,
    redeployment, and downstream scoring.'
  prefs: []
  type: TYPE_NORMAL
- en: Sounds interesting? If yes, this article is here to get you started with `mlflow.pyfunc`.
    ü•Ç
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, let‚Äôs go through a simple toy example of creating `mlflow.pyfunc` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we will define a `mlflow.pyfunc` class that encapsulates a machine learning
    pipeline (an estimator plus some preprocessing logic as an example). We will also
    train, log and load this ML pipeline for inference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, let‚Äôs take a deep dive into the encapsulated `mlflow.pyfunc` object,
    explore the rich metadata and artifacts automatically tracked for us by `mlflow`,
    and get a better grasp of the full power that `mlflow.pyfunc` offers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: üîó All code and config are available [on GitHub](https://github.com/MenaWANG/mlflow-demo/blob/main/pyfunc_basic.ipynb).
    üß∞
  prefs: []
  type: TYPE_NORMAL
- en: '{pyfunc} Simple Toy Model'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let‚Äôs create a simple toy `mlflow.pyfunc` model and then use it with
    the mlflow workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Create the model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 2: Log the model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 3: Load the logged model to perform the inference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the example above, you can create an `mlflow.pyfunc` model
    to implement any customed Python function you see fit for your ML solution, which
    doesn‚Äôt have to be an off-the-shelf machine learning algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: You can then log this model and load it later to perform the inference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**{pyfunc} Encapsulated XGBoost Pipeline**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let‚Äôs create an ML pipeline encapsulating an estimator with additional
    custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the example below, the `XGB_PIPELINE` class is a wrapper that integrates
    the estimator with preprocessing steps, which can be desirable for some MLOps
    implementations. Leveraging `mlflow.pyfunc`, this wrapper is estimator-agnostic
    and offers a uniform model representation. Specifically,
  prefs: []
  type: TYPE_NORMAL
- en: '`fit()`: Instead of using XGBoost''s native API (`xgboost.train()`), this class
    uses `.fit()`, which adheres to sklearn conventions, enabling straightforward
    integration into sklearn pipelines and ensuring consistency across different estimators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DMatrix()`: `DMatrix` is a core data structure in XGBoost that optimizes data
    for training and prediction. In this class, the step to transform a pandas DataFrame
    into a `DMatrix` is wrapped within the class, enabling seamless integration with
    pandas DataFrames like all other sklearn estimators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`predict()` : This is the `mlflow.pyfunc` model‚Äôs universal inference API.
    It is consistent for this ML pipeline, for the toy model above, for any machine
    learning algorithms or custom logic we wrap in an `mlflow.pyfunc` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, let‚Äôs train and log this model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The model has been logged successfully. ‚úå Ô∏èNow, let‚Äôs load it for inference-making.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Deep Dive into the Mlflow.pyfunc Object**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The above process is pretty smooth, isn‚Äôt it? This represents the basic functionality
    of the `mlflow.pyfunc` object. Now, let‚Äôs dive deeper to explore the full power
    that `mlflow.pyfunc` has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: '***1\. model_info***'
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, the `model_info` object returned by `mlflow.pyfunc.log_model()`
    is an instance of `mlflow.models.model.ModelInfo` class. It contains metadata
    and information about the logged model. For example
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/db3200cecb1423a55f817cd3fa348526.png)'
  prefs: []
  type: TYPE_IMG
- en: Some attributes of the model_info object
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to run `dir(model_info)` to explore further or check out [the source
    code](https://mlflow.org/docs/latest/_modules/mlflow/models/model.html) for all
    the attributes defined. The attribute I use the most is `model_uri`, which indicates
    where the logged model can be found within the `mlflow` tracking system.
  prefs: []
  type: TYPE_NORMAL
- en: '***2\. loaded_model***'
  prefs: []
  type: TYPE_NORMAL
- en: It is worthwhile clarifying that the `loaded_model` is not an instance of the
    `XGB_PIPELINE` class, but rather a wrapper object provided by `mlflow.pyfunc`
    for algorithm-agnostic inference making. As shown below, an error will be returned
    if you attempt to retrieve attributes of the `XGB_PIPELINE` class from the `loaded_model`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '***3\. unwrapped_model***'
  prefs: []
  type: TYPE_NORMAL
- en: All right, you may ask, then where is the trained instance of `XGB_PIPELINE`?
    Is it logged and retrievable through `mlflow`, too?
  prefs: []
  type: TYPE_NORMAL
- en: Don‚Äôt worry; it is kept safe for you to unwrap easily, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That‚Äôs how it is done. üòé With the `unwrapped_model`, you can access any properties
    or methods of your custom ML pipeline just like this! I sometimes add handy methods
    such as `explain_model` or `post_processing` in the custom pipeline, or include
    helpful attributes to trace the model training process and offer diagnostics ü§©‚Ä¶
    Well, I‚Äôd better stop here and leave those for the following articles. Suffice
    it to say, you can feel free to custom your ML pipeline for your use case and
    know that
  prefs: []
  type: TYPE_NORMAL
- en: You will have access to all these tailor-made methods and attributes for downstream
    use and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This tailor-made custom model will be wrapped within the uniform `mlflow.pyfunc`
    inference API and hence enjoy a smooth migration to other estimators if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***4\. Context***'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that there is a `context` parameter for the `predict` methods
    in both `mlflow.pyfunc` class defined above. But interestingly, this parameter
    is not required when we make predictions with the loaded model. Why‚ùì
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `loaded_model` above is a wrapper object provided by `mlflow`.
    If we use the unwrapped model instead, we need to define the context explicitly,
    as shown below; otherwise, the code will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So, what is this `context`? And what role does it play in the `predict` method?
  prefs: []
  type: TYPE_NORMAL
- en: The `context` is a `PythonModelContext` object that contains artifacts the`pyfunc`
    model can use when performing inference. It is created implicitly and automatically
    by the `log_method()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `mlruns` subfolder in your project repo, which is automatically
    created by `mlflow` when you log an `mlflow` model. Find the folder named after
    the model‚Äôs `run_id`. Inside, you‚Äôll find the model artifacts automatically logged
    for you, as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/19ac0e4424ede80aedef7fde2314054d.png)'
  prefs: []
  type: TYPE_IMG
- en: artifacts folder in a logged `mlflow.pyfunc` model
  prefs: []
  type: TYPE_NORMAL
- en: Pretty neat, isn‚Äôt it?üòÅ Feel free to explore these artifacts at your leisure;
    below are the screenshots of the `requirements` and `MLmodel` file from the folder
    FYR.
  prefs: []
  type: TYPE_NORMAL
- en: The `requiarements` below specifies the versions of dependencies required to
    recreate the environment for running the model.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/60ec4a56daa108ee438d8ae822f0220c.png)'
  prefs: []
  type: TYPE_IMG
- en: The `requirements.txt` file in the artifacts folder
  prefs: []
  type: TYPE_NORMAL
- en: The `MLmodel` doc below defines the metadata and configuration necessary to
    load and serve the model in YAML format.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7e4d7a6e8cc4576ae6e3e756c44c8ffa.png)'
  prefs: []
  type: TYPE_IMG
- en: The `MLmodel` file in the artifacts folder
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There you have it, the `mlflow.pyfunc` approach to model building. It is a lot
    of information, so let‚Äôs recap
  prefs: []
  type: TYPE_NORMAL
- en: '`mlflow.pyfunc` offers a unified model representation unaffected by the underlying
    framework or libraries used to build the model.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can even encapsulate rich custom logic into a `mlflow.pyfunc` model to tailor
    each use case while keeping the inference API consistent and unified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The underlying model can be unwrapped from the loaded `mlflow.pyfunc` model,
    allowing us to leverage more custom methods/attributes tailored for each use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An `mlflow.pyfunc` model object is logged with rich metadata and artifacts that
    are automatically tracked by `mlflow`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This unified `mlflow.pyfunc` model representation can streamline the process
    of experimenting and migrating between different algorithms to achieve optimal
    performance (more on this in the following articles, pls see below)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Next Steps**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have got the basics sorted, in the following articles, we can continue
    to discuss more advanced usage of `mlflow.pyfunc`. üòé Below are some topics from
    the top of my head; feel free to leave a comment and let me know what you would
    like to see. ü•∞
  prefs: []
  type: TYPE_NORMAL
- en: Leverage the uniform API to experiment with various algorithms and identify
    the optimal solution for a use case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hyperparameter tuning with `mlflow.pyfunc` custom models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulating custom logic into an `mlflow.pyfunc` ML pipeline to tailor model
    consumption and diagnostics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you enjoyed reading this article, follow me on [Medium](https://menawang.medium.com/).
    üòÅ
  prefs: []
  type: TYPE_NORMAL
- en: üíº[LinkedIn](https://www.linkedin.com/in/mena-ning-wang/) | üò∫[GitHub](https://github.com/MenaWANG)
    | üïäÔ∏è[Twitter/X](https://x.com/mena_wang)
  prefs: []
  type: TYPE_NORMAL
- en: Unless otherwise noted, all images are by the author.
  prefs: []
  type: TYPE_NORMAL

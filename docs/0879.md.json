["```py\ndef conv_block(x, kernels, kernel_size=(3, 3), strides=(1, 1), padding='same', is_bn=True, is_relu=True, n=2, l2_reg=1e-4):\n    for _ in range(1, n+1):\n        x = k.layers.Conv2D(filters=kernels, kernel_size=kernel_size,\n                            padding=padding, strides=strides,\n                            kernel_regularizer=tf.keras.regularizers.l2(l2_reg),\n                            kernel_initializer=k.initializers.he_normal(seed=42))(x)\n        if is_bn:\n            x = k.layers.BatchNormalization()(x)\n        if is_relu:\n            x = k.activations.relu(x)\n    return x\n\ndef unet3plus(input_shape, output_channels, config, depth=4, training=False, clm=False):\n\n    \"\"\" Prep \"\"\"\n    interp = config['interpolation']\n    input_layer = k.layers.Input(shape=input_shape, name=\"input_layer\")\n    xpre = preprocess(input_layer, output_channels)\n\n    \"\"\" Encoder \"\"\"\n    encoders = []\n    for i in range(depth+1):\n        if i == 0:\n            e = conv_block(xpre, config['filters']*(2**i), kernel_size=(config['kernel_size'], config['kernel_size']), l2_reg=config['l2_reg'])\n        else:\n            e = k.layers.MaxPool2D(pool_size=(2, 2))(encoders[i-1])\n            e = k.layers.Dropout(config['dropout'])(e, training=True)\n            e = conv_block(e, config['filters']*(2**i), kernel_size=(config['kernel_size'], config['kernel_size']), l2_reg=config['l2_reg'])\n        encoders.append(e)\n\n    \"\"\" Middle \"\"\"\n    cat_channels = config['filters']\n    cat_blocks = depth+1\n    upsample_channels = cat_blocks * cat_channels\n\n    \"\"\" Decoder \"\"\"\n    decoders = []\n    for d in reversed(range(depth+1)):\n        if d == 0 :\n            continue\n        loc_dec = []\n        decoder_pos = len(decoders)\n        for e in range(len(encoders)):\n            if d > e+1:\n                e_d = k.layers.MaxPool2D(pool_size=(2**(d-e-1), 2**(d-e-1)))(encoders[e])\n                e_d = k.layers.Dropout(config['dropout'])(e_d, training=True)\n                e_d = conv_block(e_d, cat_channels, kernel_size=(config['kernel_size'], config['kernel_size']), n=1, l2_reg=config['l2_reg'])\n            elif d == e+1:\n                e_d = conv_block(encoders[e], cat_channels, kernel_size=(config['kernel_size'], config['kernel_size']), n=1, l2_reg=config['l2_reg'])\n            elif e+1 == len(encoders):\n                e_d = k.layers.UpSampling2D(size=(2**(e+1-d), 2**(e+1-d)), interpolation=interp)(encoders[e])\n                e_d = k.layers.Dropout(config['dropout'])(e_d, training=True)\n                e_d = conv_block(e_d, cat_channels, kernel_size=(config['kernel_size'], config['kernel_size']), n=1, l2_reg=config['l2_reg'])\n            else:\n                e_d = k.layers.UpSampling2D(size=(2**(e+1-d), 2**(e+1-d)), interpolation=interp)(decoders[decoder_pos-1])\n                e_d = k.layers.Dropout(config['dropout'])(e_d, training=True)\n                e_d = conv_block(e_d, cat_channels, kernel_size=(config['kernel_size'], config['kernel_size']), n=1, l2_reg=config['l2_reg'])\n                decoder_pos -= 1\n            loc_dec.append(e_d)\n        de = k.layers.concatenate(loc_dec)\n        de = conv_block(de, upsample_channels, kernel_size=(config['kernel_size'], config['kernel_size']), n=1, l2_reg=config['l2_reg'])\n        decoders.append(de)\n\n    \"\"\" Final \"\"\"\n    d1 = decoders[len(decoders)-1]\n    d1 = conv_block(d1, output_channels, kernel_size=(config['kernel_size'], config['kernel_size']), n=1, is_bn=False, is_relu=False, l2_reg=config['l2_reg'])\n    outputs = [d1]\n\n    \"\"\" Deep Supervision \"\"\"\n    if training:\n        for i in reversed(range(len(decoders))):\n            if i == 0:\n                e = conv_block(encoders[len(encoders)-1], output_channels, kernel_size=(config['kernel_size'], config['kernel_size']), n=1, is_bn=False, is_relu=False, l2_reg=config['l2_reg'])\n                e = k.layers.UpSampling2D(size=(2**(len(decoders)-i), 2**(len(decoders)-i)), interpolation=interp)(e)\n                outputs.append(e)\n            else:\n                d = conv_block(decoders[i - 1], output_channels, kernel_size=(config['kernel_size'], config['kernel_size']), n=1, is_bn=False, is_relu=False, l2_reg=config['l2_reg'])\n                d = k.layers.UpSampling2D(size=(2**(len(decoders)-i), 2**(len(decoders)-i)), interpolation=interp)(d)\n                outputs.append(d)\n\n    if training:\n        for i in range(len(outputs)):\n            if i == 0:\n                continue\n            d_e = outputs[i]\n                d_e = k.layers.concatenate([out1, out2, out3])\n            outputs[i] = merge_output(input_layer, k.activations.linear(d_e), output_channels)\n\n    return tf.keras.Model(inputs=input_layer, outputs=outputs, name='UNet3Plus')\n```"]
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Python + Google Earth Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Python + Google Earth Engine</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/python-google-earth-engine-how-to-clean-mapbiomas-lulc-rasters-for-any-shapefile-in-brazil-05d13dcf2307?source=collection_archive---------6-----------------------#2024-07-10">https://towardsdatascience.com/python-google-earth-engine-how-to-clean-mapbiomas-lulc-rasters-for-any-shapefile-in-brazil-05d13dcf2307?source=collection_archive---------6-----------------------#2024-07-10</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="0c7e" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">How to clean MapBiomas LULC rasters for any shapefile in Brazil</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@HecVini?source=post_page---byline--05d13dcf2307--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Vinícius Hector" class="l ep by dd de cx" src="../Images/ac360b1e6a3748cf4b27be380e738d76.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*VC3K5Bulf1NQolXHhHuAOA.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--05d13dcf2307--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@HecVini?source=post_page---byline--05d13dcf2307--------------------------------" rel="noopener follow">Vinícius Hector</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--05d13dcf2307--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">21 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Jul 10, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">2</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/7822848d8ba780656641f63147518ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUkfN-pDb4c57U6egABJZg.gif"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Figure 1: Land Use and Land Cover in Porto Acre, AC (1985–2022). Self-made, using MapBiomas LULC Collection 8.</figcaption></figure><p id="92b9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">If you have ever worked with land use data in Brazil, you have certainly come across <strong class="ne fr">MapBiomas</strong>². Their remote sensing team developed an <a class="af ny" href="https://brasil.mapbiomas.org/en/visao-geral-da-metodologia/" rel="noopener ugc nofollow" target="_blank">algorithm</a> to classify land use for each 30m x 30m piece of territory across Brazil (and now for much of South America and Indonesia). Nine years later, they offer a variety of products, including MapBiomas LCLU (which we will explore here), MapBiomas Fire, MapBiomas Water, MapBiomas Irrigation, MapBiomas Infrastructure, etc.</p><p id="95b2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Their final products are provided as rasters. <strong class="ne fr"><em class="nz">But what are they, exactly?</em></strong></p><p id="2892" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A raster is an image where each pixel contains information about a specific location. Those images are typically saved as .tif files and are useful for gathering georeferenced data. In MapBiomas LCLU, for example, each pixel has a code that tells us how that piece of land is used for.</p><p id="8b0b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">There are many ways to acess and work with them. In this tutorial, we will learn how to save, clean, and plot <strong class="ne fr">MapBiomas Land Use Land Cover (LULC)</strong> rasters using <strong class="ne fr">Google Earth Engine’s Python API</strong>. First, we will demonstrate this process for a single location for one year. Then, we will build functions that can perform those tasks for multiple locations over multiple years in a standardized way.</p><p id="2b15" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This is just one method of accessing MapBiomas resources — others can be found <a class="af ny" href="https://brasil.mapbiomas.org/downloads/" rel="noopener ugc nofollow" target="_blank">here</a>. This approach is particularly useful if you need to work with limited areas for a few years, as it avoids using Google Earth Engine’s JavaScript editor (although MapBiomas has a great <a class="af ny" href="https://github.com/mapbiomas-brazil/user-toolkit" rel="noopener ugc nofollow" target="_blank">GEE toolkit</a> there). Note that you will need a Google Earth Engine and a Google Drive account for it. In a future post, we will learn how to download and clean MapBiomas data using their .tif files for the whole country.</p><p id="1de4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This tutorial is split into four sections:</p><ul class=""><li id="b4a6" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx oa ob oc bk"><strong class="ne fr">(1) Project Setup:</strong> what you need to run the code properly.</li><li id="901f" class="nc nd fq ne b go od ng nh gr oe nj nk nl of nn no np og nr ns nt oh nv nw nx oa ob oc bk"><strong class="ne fr">(2) Single Example:</strong> we are going to utilize GEE's Python API to store and process land use data for Acrelândia (AC) in 2022. This city was chosen as an example because it is in the middle of the so-called AMACRO region, the new deforestation frontier in Brazil.</li><li id="01c5" class="nc nd fq ne b go od ng nh gr oe nj nk nl of nn no np og nr ns nt oh nv nw nx oa ob oc bk"><strong class="ne fr">(3) Plot the Map:</strong> after saving and cleaning raw data, we will beautifully plot it on a choropleth map.</li><li id="bbe0" class="nc nd fq ne b go od ng nh gr oe nj nk nl of nn no np og nr ns nt oh nv nw nx oa ob oc bk"><strong class="ne fr">(4) Standardized Functions: </strong>we will build generic functions to do steps 2 and 3 for any location in any year. Then, we will use loops to run the algorithm sequentially and see LULC evolution since 1985 in Porto Acre, AC — another city with soaring deforestation in the middle of the Amazon’s AMACRO region.</li></ul><p id="eb1e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Comments are welcome! If you find any mistakes or have suggestions, please reach out via <a class="af ny" href="mailto:vinicius.hector@outlook.com" rel="noopener ugc nofollow" target="_blank">e-mail</a> or <a class="af ny" href="https://x.com/hec_vini" rel="noopener ugc nofollow" target="_blank">X</a>. I hope it helps!</p></div></div></div><div class="ab cb oi oj ok ol" role="separator"><span class="om by bm on oo op"/><span class="om by bm on oo op"/><span class="om by bm on oo"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h2 id="1ee7" class="oq or fq bf os ot ou ov ow ox oy oz pa nl pb pc pd np pe pf pg nt ph pi pj pk bk"><strong class="al"># 1. Project Setup</strong></h2><p id="9fde" class="pw-post-body-paragraph nc nd fq ne b go pl ng nh gr pm nj nk nl pn nn no np po nr ns nt pp nv nw nx fj bk">First of all, we need to load libraries. Make sure all of them are properly installed. Also, I am using Python 3.12.3.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="e298" class="pu or fq pr b bg pv pw l px py">## 1.1 Load libraries<br/><br/># If you need to install any library, run below:<br/># pip install library1 library2 library3 ...<br/><br/># Basic Libraries<br/>import os  # For file operations<br/>import gc  # For garbage collection, it avoids RAM memory issues<br/>import numpy as np  # For dealing with matrices<br/>import pandas as pd  # For dealing with dataframes<br/>import janitor  # For data cleaning (mainly column names)<br/>import numexpr  # For fast pd.query() manipulation<br/>import inflection  # For string manipulation<br/>import unidecode  # For string manipulation<br/><br/># Geospatial Libraries<br/>import geopandas as gpd  # For dealing with shapefiles<br/>import pyogrio  # For fast .gpkg file manipulation<br/>import ee  # For Google Earth Engine API<br/>import contextily as ctx  # For basemaps<br/>import folium  # For interactive maps<br/><br/># Shapely Objects and Geometry Manipulation<br/>from shapely.geometry import mapping, Polygon, Point, MultiPolygon, LineString  # For geometry manipulation<br/><br/># Raster Data Manipulation and Visualization<br/>import rasterio  # For raster manipulation<br/>from rasterio.mask import mask  # For raster data manipulation<br/>from rasterio.plot import show  # For raster data visualization<br/><br/># Plotting and Visualization<br/>import matplotlib.pyplot as plt  # For plotting and data visualization<br/>from matplotlib.colors import ListedColormap, Normalize  # For color manipulation<br/>import matplotlib.colors as colors  # For color manipulation<br/>import matplotlib.patches as mpatches  # For creating patch objects<br/>import matplotlib.cm as cm  # For colormaps<br/><br/># Data Storage and Manipulation<br/>import pyarrow  # For efficient data storage and manipulation<br/><br/># Video Making<br/>from moviepy.editor import ImageSequenceClip # For creating videos (section 4.7 only) - check this if you have issues: https://github.com/kkroening/ffmpeg-python</span></pre><p id="f2a2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Then, make sure you have a folder for this project. All resources and outputs will be saved there. This folder can be located on your local drive, a cloud-based storage solution, or in a specific folder on Google Drive where you will save the rasters retrieved using the GEE API.</p><p id="7f15" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">When running your code, make sure to change the address below to your project path. Windows users, always remember to use \\ instead of /.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="62e8" class="pu or fq pr b bg pv pw l px py"># 1.2 Set working directory <br/>project_path = 'path_to_your_project_folder' # Where you will save all outcomes and resources must be in<br/>os.chdir(project_path) # All resources on the project are relative to this path<br/><br/># 1.3 Further settings<br/>pd.set_option('compute.use_numexpr', True) # Use numexpr for fast pd.query() manipulation</span></pre><p id="d528" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Lastly, this function is useful for plotting geometries over OpenStreetMap (OSM). It is particularly helpful when working with unknown shapefiles to ensure accuracy and avoid mistakes.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="0f54" class="pu or fq pr b bg pv pw l px py">## 1.4 Set function to plot geometries over an OSM <br/>def plot_geometries_on_osm(geometries, zoom_start=10):<br/>    <br/>    # Calculate the centroid of all geometries to center the map<br/>    centroids = [geometry.centroid for geometry in geometries]<br/>    avg_x = sum(centroid.x for centroid in centroids) / len(centroids)<br/>    avg_y = sum(centroid.y for centroid in centroids) / len(centroids)<br/>    <br/>    # Create a folium map centered around the average centroid<br/>    map = folium.Map(location=[avg_y, avg_x], zoom_start=zoom_start)<br/>    <br/>    # Add each geometry to the map<br/>    for geometry in geometries:<br/>        geojson = mapping(geometry) # Convert the geometry to GeoJSON<br/>        folium.GeoJson(geojson).add_to(map)<br/>    <br/>    return map</span></pre><h2 id="4ce3" class="oq or fq bf os ot ou ov ow ox oy oz pa nl pb pc pd np pe pf pg nt ph pi pj pk bk"><strong class="al"># 2. Single Example: Acrelândia (AC) in 2022</strong></h2><p id="8606" class="pw-post-body-paragraph nc nd fq ne b go pl ng nh gr pm nj nk nl pn nn no np po nr ns nt pp nv nw nx fj bk">As an example to create intuition of the process, we will save, clean, and plot land use in <a class="af ny" href="https://en.wikipedia.org/wiki/Acrelândia" rel="noopener ugc nofollow" target="_blank">Acrelândia (AC)</a> in 2022. It is a city in the middle of the<strong class="ne fr"> AMACRO</strong> region (the three-state border of <strong class="ne fr">Am</strong>azonas, <strong class="ne fr">Ac</strong>re, and <strong class="ne fr">Ro</strong>ndônia), where the often untouched forest is being rapidly destroyed.</p><p id="8b3a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this section, I will explain step by step of the script, and then standardize the process to run it for multiple places over multiple years. Since saving large rasters using the API can be a slow process, I recommend using it only if you need to deal with a few or small areas for a few years. Large areas may take hours to save on Google Drive, so I recommend downloading the heavy LULC files for the whole country and then cleaning them, as we will do in a future post.</p><p id="1559" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To run the code, first download and save IBGE’s¹ <a class="af ny" href="https://www.ibge.gov.br/en/geosciences/territorial-organization/territorial-meshes/2786-np-municipal-mesh/18890-municipal-mesh.html?lang=en-GB" rel="noopener ugc nofollow" target="_blank">Brazilian cities shapefiles</a> (select Brazil &gt; Municipalities). Remember, you can use any shapefile in Brazil to perform this algorithm.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="967b" class="pu or fq pr b bg pv pw l px py">## 2.1 Get the geometry of the area of interest (Acrelândia, AC)<br/>brazilian_municipalities = gpd.read_file('municipios/file.shp', engine='pyogrio', use_arrow=True) # Read the shapefile - you can use any other shapefile here. Shapefiles must be in your project folder, as set in 1.2<br/>brazilian_municipalities = brazilian_municipalities.clean_names() # Clean the column names (remove special characters, spaces, etc.)<br/>brazilian_municipalities.crs = 'EPSG:4326' # Set the CRS to WGS84 (MapBiomas uses this CRS)<br/>brazilian_municipalities</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="58c6" class="pu or fq pr b bg pv pw l px py">## 2.2 Get geometry for Acrelândia, AC<br/>city = brazilian_municipalities.query('nm_mun == "Acrelândia"') # Filter the geometry for Acrelândia, AC (can be any other city or set of cities)<br/>city_geom = city.geometry.iloc[0] # Get the geometry of Acrelândia, AC<br/>city_geom # See the geometry shape</span></pre><p id="2ce7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Once we have the shapefile we want to study properly saved, we will create a bounding box around it to crop the MapBiomas full raster. Then, we will save it the GEE Python API.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="1d8f" class="pu or fq pr b bg pv pw l px py">## 2.3 Set the bounding box (bbox) for the area of interest<br/>bbox = city_geom.bounds # Get the bounding box of the geometry<br/>bbox = Polygon([(bbox[0], bbox[1]), (bbox[0], bbox[3]), (bbox[2], bbox[3]), (bbox[2], bbox[1])]) # Convert the bounding box to a Polygon<br/><br/>bbox_xmin = bbox.bounds[0] # Get the minimum x coordinate of the bounding box<br/>bbox_ymin = bbox.bounds[1] # Get the minimum y coordinate of the bounding box<br/>bbox_xmax = bbox.bounds[2] # Get the maximum x coordinate of the bounding box<br/>bbox_ymax = bbox.bounds[3] # Get the maximum y coordinate of the bounding box<br/><br/>bbox # See bbox around Acrelândia shape</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="6337" class="pu or fq pr b bg pv pw l px py"># Plot the bounding box and the geometry of Acrelandia over an OSM map<br/>plot_geometries_on_osm([bbox, city_geom], zoom_start=10) </span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qa"><img src="../Images/2ea9855047684a05c8a08518efb74cfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6mj-wwzQ2BQzyeooll6XA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Figure 2: Acrelândia, AC, and the bbox Around it Plotted Over OSM.</figcaption></figure><p id="6280" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, we will access the MapBiomas Google Earth Engine API. First, we need to <a class="af ny" href="https://dev.to/geedevs-nairobi/creating-an-earth-engine-cloud-project-4gja" rel="noopener ugc nofollow" target="_blank">create a cloud project on GEE</a> using a Google Account. Make sure you have enough space on your Google Drive account.</p><p id="a941" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Then, we need to authenticate the <a class="af ny" href="https://developers.google.com/earth-engine/guides/auth" rel="noopener ugc nofollow" target="_blank">GEE Python API</a> (only once). If you are a VSCode user, notice that the token insertion box appears in the top right corner of the IDE.</p><p id="c052" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">All images from the MapBiomas LULC Collection are available in the same asset. Notice that you can slightly modify this script to work with other assets in the <a class="af ny" href="https://developers.google.com/earth-engine/datasets" rel="noopener ugc nofollow" target="_blank">GEE catalog</a> and other MapBiomas collections.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="a23e" class="pu or fq pr b bg pv pw l px py">## 2.4 Acess MapBiomas Collection 8.0 using GEE API<br/># import ee - already imported at 1.1<br/><br/>ee.Authenticate() # Only for the first time <br/>ee.Initialize() # Run it every time you start a new session<br/><br/># Define the MapBiomas Collection 8.0 asset ID - retrieved from https://brasil.mapbiomas.org/en/colecoes-mapbiomas/<br/>mapbiomas_asset = 'projects/mapbiomas-workspace/public/collection8/mapbiomas_collection80_integration_v1'<br/><br/>asset_properties = ee.data.getAsset(mapbiomas_asset) # Check the asset's properties<br/>asset_properties # See properties</span></pre><p id="b233" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Here, each band represents the LULC data for a given year. Make sure that the code below is properly written. This selects the image for the desired year and then crops the raw raster for a bounding box around the region of interest (ROI) — Acrelândia, AC.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="17da" class="pu or fq pr b bg pv pw l px py">## 2.5 Filter the collection for 2022 and crop the collection to a bbox around Acrelândia, AC<br/>year = 2022<br/>band_id = f'classification_{year}' # bands (or yearly rasters) are named as classification_1985, classification_1986, ..., classification_2022<br/><br/>mapbiomas_image = ee.Image(mapbiomas_asset) # Get the images of MapBiomas Collection 8.0 <br/>mapbiomas2022 = mapbiomas_image.select(band_id) # Select the image for 2022<br/><br/>roi = ee.Geometry.Rectangle([bbox_xmin, bbox_ymin, bbox_xmax, bbox_ymax]) # Set the Region of Interest (ROI) to the bbox around Acrelândia, AC - set in 2.3<br/>image_roi = mapbiomas2022.clip(roi) # Crop the image to the ROI</span></pre><p id="e09e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, we save the cropped raster on Google Drive (in my case, into the ‘tutorial_mapbiomas_gee’ folder). Make sure you have created the destination folder in your drive before running.</p><p id="0372" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">I tried to save it locally, but it looks like you need to save GEE rasters at Google Drive (let me know if you know how to do it locally). This is the most time-consuming part of the code. For large ROIs, this might take hours. Check your GEE task manager to see if the rasters were properly loaded to the destination folder.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="dcfd" class="pu or fq pr b bg pv pw l px py">## 2.6 Export it to your Google Drive (ensure you have space there and that it is properly set up)<br/><br/># Obs 1: Recall you need to authenticate the session, as it was done on 2.4<br/># Obs 2: Ensure you have enough space on Google Drive. Free version only gives 15 Gb of storage.<br/><br/>export_task = ee.batch.Export.image.toDrive(<br/>    image=image_roi, # Image to export to Google Drive as a GeoTIFF <br/>    description='clipped_mapbiomas_collection8_acrelandia_ac_2022', # Task description<br/>    folder='tutorial_mapbiomas_gee', # Change this to the folder in your Google Drive where you want to save the file<br/>    fileNamePrefix='acrelandia_ac_2022', # File name (change it if you want to)<br/>    region=roi.getInfo()['coordinates'], # Region to export the image<br/>    scale=30,<br/>    fileFormat='GeoTIFF'<br/>)<br/><br/># Start the export task<br/>export_task.start()</span></pre><h2 id="1165" class="oq or fq bf os ot ou ov ow ox oy oz pa nl pb pc pd np pe pf pg nt ph pi pj pk bk"><strong class="al"># 3. Plot the Map</strong></h2><p id="626d" class="pw-post-body-paragraph nc nd fq ne b go pl ng nh gr pm nj nk nl pn nn no np po nr ns nt pp nv nw nx fj bk">Now we have a raster with LULC data for a bounding box around Acrelândia in 2022. This is saved at the address below (at Google Drive). First, let’s see how it looks.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="415c" class="pu or fq pr b bg pv pw l px py">## 3.1 Plot the orginal raster over a OSM <br/>file_path = 'path_of_exported_file_at_google_drive.tif' # Change this to the path of the exported file<br/><br/># Plot data<br/>with rasterio.open(file_path) as src:<br/>    data = src.read(1)<br/>    print(src.meta)<br/>    print(src.crs)<br/>    show(data)</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qb"><img src="../Images/06524a8466bf3e0a10ce156aa89dc35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*9UJBUTPddbgX6ouzLwCSrQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Figure 3: Cropped Raster of the bbox Around the ROI. Self-made, using MapBiomas LULC Collection 8.</figcaption></figure><p id="e016" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In MapBiomas LULC Collection 8, each pixel represents a specific land use type according to <a class="af ny" href="https://brasil.mapbiomas.org/wp-content/uploads/sites/4/2023/08/Legenda-Colecao-8-LEGEND-CODE.pdf" rel="noopener ugc nofollow" target="_blank">this list</a>. For instance, ‘3’ means ‘Natural Forest’, ‘15’ means ‘Pasture’, and ‘0’ means ‘No data’ (pixels in the raster not within the Brazilian borders).</p><p id="3e28" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We will explore the data we have before plotting it.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="6350" class="pu or fq pr b bg pv pw l px py">## 3.2 See unique values <br/>unique_values = np.unique(data)<br/>unique_values # Returns unique pixels values in the raster<br/><br/># 0 = no data, parts of the image outside Brazil</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="5b05" class="pu or fq pr b bg pv pw l px py">## 3.3 See the frequency of each class (except 0 - no data)<br/>unique_values, counts = np.unique(data[data != 0], return_counts=True) # Get the unique values and their counts (except zero)<br/>pixel_counts = pd.DataFrame({'value': unique_values, 'count': counts})<br/>pixel_counts['share'] = (pixel_counts['count'] / pixel_counts['count'].sum())*100<br/>pixel_counts </span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qc"><img src="../Images/1a4ff0903bb69502b4321c0381323bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*6ppIstukDHFveV3rYnzOsg.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Figure 4: Pixels Share in the bbox Around the ROI (excl. 0 = no data).</figcaption></figure><p id="aa61" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">At the end of the day, we are working with a large matrix in which each element represents how each tiny 30m x 30m piece of land is used.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="6148" class="pu or fq pr b bg pv pw l px py">## 3.4 See the actual raster (a matrix in which each element represents a pixel value - land use code in this case)<br/>data </span></pre><p id="c24e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, we need to organize our raster data. Instead of categorizing each pixel by exact land use, we will categorize them more broadly. We will divide pixels into<strong class="ne fr"> natural forest, natural non-forest vegetation, water, pasture, agriculture</strong>, and <strong class="ne fr">other</strong> uses. Specifically, we are interested in tracking the conversion of natural forest to pasture. To achieve this, we will reassign pixel values based on the <code class="cx qd qe qf pr b">mapbiomas_categories</code> dict below, which follows with MapBiomas' land use and land cover (LULC) categorization.</p><p id="51f6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The code below crops the raster to Acrelândia’s limits and reassigns pixels according to the <code class="cx qd qe qf pr b">mapbiomas_categories</code> dict. Then, it saves it as a new raster at ‘reassigned_raster_path’. Note that the old raster was saved on Google Drive (after being downloaded using GEE’s API), while the new one will be saved in the project folder (in my case, a OneDrive folder on my PC, as set in section 1.2). From here onwards, we will use only the reassigned raster to plot the data.</p><p id="c1c0" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><strong class="ne fr">This is the main part of the script</strong>. If you have doubts about what is happening here (cropping for Acrelândia and then reassigning pixels to broader categories), I recommend running it and printing results for every step.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="75d6" class="pu or fq pr b bg pv pw l px py">mapbiomas_categories = {<br/>    # Forest (= 3)<br/>    1:3, 3:3, 4:3, 5:3, 6:3, 49:3, # That is, values 1, 3, 4, 5, 6, and 49 will be reassigned to 3 (Forest)<br/>    # Other Non-Forest Natural Vegetation (= 10)<br/>    10:10, 11:10, 12:10, 32:10, 29:10, 50:10, 13:10, # That is, values 10, 11, 12, 32, 29, 50, and 13 will be reassigned to 10 (Other Non-Forest Natural Vegetation)<br/>    # Pasture (= 15)<br/>    15:15, <br/>    # Agriculture (= 18)<br/>    18:18, 19:18, 39:18, 20:18, 40:18, 62:18, 41:18, 36:18, 46:18, 47:18, 35:18, 48:18, 21:18, 14:18, 9:18, # That is, values 18, 19, 39, 20, 40, 62, 41, 36, 46, 47, 35, 48, 21, 14, and 9 will be reassigned to 18 (Agriculture)<br/>    # Water ( = 26)<br/>    26:26, 33:26, 31:26, # That is, values 26, 33, and 31 will be reassigned to 26 (Water)<br/>    # Other (= 22)<br/>    22:22, 23:22, 24:22, 30:22, 25:22, 27:22, # That is, values 22, 23, 24, 30, 25, and 27 will be reassigned to 22 (Other)<br/>    # No data (= 255)<br/>    0:255 # That is, values 0 will be reassigned to 255 (No data)<br/>}</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="988d" class="pu or fq pr b bg pv pw l px py">## 3.5 Reassing pixels values to the MapBiomas custom general categories and crop it to Acrelandia, AC limits<br/>original_raster_path = 'path_to_your_google_drive/tutorial_mapbiomas_gee/acrelandia_ac_2022.tif' <br/>reassigned_raster_path = 'path_to_reassigned_raster_at_project_folder' # Somewhere in the project folder set at 1.2<br/><br/>with rasterio.open(original_raster_path) as src:<br/>    raster_array = src.read(1)<br/>    out_meta = src.meta.copy() # Get metadata from the original raster<br/><br/><br/>    # 3.5.1. Crop (or mask) the raster to the geometry of city_geom (in this case, Acrelandia, AC) and thus remove pixels outside the city limits (will be assigned to no data = 255)<br/>    out_image, out_transform = rasterio.mask.mask(src, [city_geom], crop=True) <br/>    out_meta.update({<br/>        "height": out_image.shape[1],<br/>        "width": out_image.shape[2],<br/>        "transform": out_transform<br/>    }) # Update metadata to the new raster<br/>    raster_array = out_image[0] # Get the masked raster<br/><br/>    modified_raster = np.zeros_like(raster_array) # Base raster full of zeros to be modified<br/><br/><br/>    # 3.5.2. Reassign each pixel based on the mapbiomas_categories dictionary<br/>    for original_value, new_value in mapbiomas_categories.items():<br/>        mask = (raster_array == original_value) # Create a boolean mask for the original value (True = Replace, False = Don't replace)<br/>        modified_raster[mask] = new_value # Replace the original values with the new values, when needed (that is, when the mask is True)<br/><br/>    out_meta = src.meta.copy() # Get metadata from the original raster<br/><br/>out_meta.update(dtype=rasterio.uint8, count=1) # Update metadata to the new raster<br/><br/>with rasterio.open(reassigned_raster_path, 'w', **out_meta) as dst: # Write the modified raster to a new file at the reassigned_raster_path<br/>    dst.write(modified_raster.astype(rasterio.uint8), 1)</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="21d7" class="pu or fq pr b bg pv pw l px py">## 3.6 See the frequency of pixels in the reassigned raster<br/>with rasterio.open(reassigned_raster_path) as src:<br/>    raster_data = src.read(1)<br/>    unique_values = np.unique(raster_data)<br/>    total_non_zero = np.sum(raster_data != 255) # Count the total number of non-zero pixels<br/><br/>    for value in unique_values:<br/>        if value != 255:  # Exclude no data (= 255)<br/>            count = np.sum(raster_data == value) # Count the number of pixels with the value<br/>            share = count / total_non_zero # Calculate the share of the value<br/>            share = share.round(3) # Round to 3 decimal places<br/>            print(f"Value: {value}, Count: {count}, Share: {share}") </span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qg"><img src="../Images/5ed3ab6e51acc626ccb0055fa89bfb54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*quIsRtLARrNtASegZFTuuw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Figure 5: Pixels Share in the ROI (excl. 255 = no data).</figcaption></figure><p id="1d06" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now we plot the data with generic colors. We will enhance the map later, but this is just a first (or second?) look. Notice that I specifically set 255 (= no data, pixels outside Acrelândia) to be white for better visualization.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="aebf" class="pu or fq pr b bg pv pw l px py">## 3.7 Plot the reassigned raster with generic colors<br/>with rasterio.open(reassigned_raster_path) as src:<br/>    data = src.read(1) # Read the raster data<br/>    unique_values = np.unique(data) # Get the unique values in the raster<br/>    <br/>    plt.figure(figsize=(10, 8)) # Set the figure size<br/>    <br/>    cmap = plt.cm.viridis  # Using Viridis colormap<br/>    norm = Normalize(vmin=data.min(), vmax=26) # Normalize the data to the range of the colormap (max = 26, water)<br/>    <br/>    masked_data = np.ma.masked_where(data == 255, data) # Mask no data values (255)<br/>    plt.imshow(masked_data, cmap=cmap, norm=norm) # Plot the data with the colormap<br/>    <br/>    plt.colorbar(label='Value') # Add a colorbar with the values<br/>    <br/>    plt.show()</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qh"><img src="../Images/6f14dd03ef5f7bb566bdff487ded6666.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VNiSrwxIIyHIWehrCfmHtQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Figure 6: LULC in the ROI. Self-made, using MapBiomas LULC Collection 8.</figcaption></figure><p id="9012" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now it’s time to create a beautiful map. I have chosen Matplotlib because I want static maps. If you prefer interactive choropleths, you can use <a class="af ny" href="https://plotly.com/python/choropleth-maps/" rel="noopener ugc nofollow" target="_blank">Plotly</a>.</p><p id="9adc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">For further details on choropleths with Matplotlib, check <a class="af ny" href="https://matplotlib.org/stable/users/index.html" rel="noopener ugc nofollow" target="_blank">its documentation</a>, <a class="af ny" href="https://geopandas.org/en/stable/docs/user_guide/mapping.html" rel="noopener ugc nofollow" target="_blank">GeoPandas guide</a>, and the great Yan Holtz’s <a class="af ny" href="https://python-graph-gallery.com" rel="noopener ugc nofollow" target="_blank">Python Graph Gallery</a> — where I get much of the inspiration and tools for DataViz in Python. Also, for beautiful color palettes, <a class="af ny" href="https://coolors.co/" rel="noopener ugc nofollow" target="_blank">coolors.co</a> is an excellent resource.</p><p id="8be2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Make sure you have all data visualization libraries properly loaded to run the code below. I also tried to change the order of patches, but I didn’t know how to. <em class="nz">Let me know if you find out how to do it.</em></p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="c730" class="pu or fq pr b bg pv pw l px py">## 3.8 Plot the reassigned raster with custom colors<br/><br/># Define the colors for each class - notice you need to follow the same order as the values and must be numerically increasing or decreasing (still need to find out how to solve it)<br/>values = [3, 10, 15, 18, 22, 26, 255] # Values to be colored<br/>colors_list = ['#6a994e', '#a7c957', '#c32f27', '#dda15e', '#6c757d', '#0077b6','#FFFFFF'] # HEX codes of the colors used<br/>labels = ['Natural Forest', 'Other Natural Vegetation', 'Pasture', 'Agriculture', 'Others', 'Water', 'No data'] # Labels displayed on the legend<br/><br/>cmap = colors.ListedColormap(colors_list) # Create a colormap (cmap) with the colors<br/>bounds = values + [256] # Add a value to the end of the list to include the last color<br/>norm = colors.BoundaryNorm(bounds, cmap.N) # Normalize the colormap to the values<br/><br/>img = plt.imshow(raster_data, interpolation='nearest', cmap=cmap, norm=norm) # Plot the data with the colormap<br/><br/>legend_patches = [mpatches.Patch(color=colors_list[i], label=labels[i]) for i in range(len(values)-1)] # Create the legend patches withou the last one (255 = no data)<br/><br/># Create the legend<br/>plt.legend(handles = legend_patches, # Add the legend patches<br/>          bbox_to_anchor = (0.5, -0.02), # Place the legend below the plot<br/>          loc = 'upper center', # Place the legend in the upper center<br/>          ncol = 3, # Number of columns<br/>          fontsize = 9, # Font size<br/>          handlelength=1,# Length of the legend handles<br/>          frameon=False) # Remove the frame around the legend<br/><br/>plt.axis('off') # Remove the axis<br/>plt.title('Land Use in Acrelândia, AC (2022)', fontsize=20) # Add title<br/><br/>plt.savefig('figures/acrelandia_ac_2022.pdf', format='pdf', dpi=1800) # Save it as a PDF at the figures folder<br/>plt.show()</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qi"><img src="../Images/8c0bb758d78565f910f15ea165941f47.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*swg_2EAQMlvN6XxGuRttNA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Figure 7: Final map of LULC in the ROI. Self-made, using MapBiomas LULC Collection 8.</figcaption></figure><h2 id="d6d1" class="oq or fq bf os ot ou ov ow ox oy oz pa nl pb pc pd np pe pf pg nt ph pi pj pk bk"><strong class="al">4. Standardized Functions</strong></h2><p id="e088" class="pw-post-body-paragraph nc nd fq ne b go pl ng nh gr pm nj nk nl pn nn no np po nr ns nt pp nv nw nx fj bk">Now that we have built intuition on how to download, save, clean, and plot MapBiomas LULC rasters. It is time to <strong class="ne fr">generalize the process.</strong></p><p id="b999" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this section, we will define functions to automate these steps for any shape and any year. Then, we will execute these functions in a loop to analyze a specific city — Porto Acre, AC — from 1985 to 2022. Finally, we will make a video illustrating the LULC evolution in that area over the specified period.</p><p id="0e31" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">First, save a bounding box (bbox) around the Region of Interest (ROI). You only need to input the desired geometry and specify the year. This function will save the bbox raster around the ROI to your Google Drive.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="c94a" class="pu or fq pr b bg pv pw l px py">## 4.1 For a generic geometry in any year, save a bbox around the geometry to Google Drive<br/><br/>def get_mapbiomas_lulc_raster(geom, geom_name, year, folder_in_google_drive):<br/>    ee.Authenticate() # Only for the first time<br/>    ee.Initialize() # Run it every time you start a new session<br/>    <br/>    my_geom = geom<br/>    <br/>    bbox = my_geom.bounds # Get the bounding box of the geometry<br/>    bbox = Polygon([(bbox[0], bbox[1]), (bbox[0], bbox[3]), (bbox[2], bbox[3]), (bbox[2], bbox[1])]) # Convert the bounding box to a Polygon<br/><br/>    bbox_xmin = bbox.bounds[0] # Get the minimum x coordinate of the bounding box<br/>    bbox_ymin = bbox.bounds[1] # Get the minimum y coordinate of the bounding box<br/>    bbox_xmax = bbox.bounds[2] # Get the maximum x coordinate of the bounding box<br/>    bbox_ymax = bbox.bounds[3] # Get the maximum y coordinate of the bounding box<br/>    <br/>    mapbiomas_asset = 'projects/mapbiomas-workspace/public/collection8/mapbiomas_collection80_integration_v1'<br/>    band_id = f'classification_{year}'<br/><br/>    mapbiomas_image = ee.Image(mapbiomas_asset) # Get the images of MapBiomas Collection 8.0 <br/>    mapbiomas_data = mapbiomas_image.select(band_id) # Select the image for 2022<br/><br/>    roi = ee.Geometry.Rectangle([bbox_xmin, bbox_ymin, bbox_xmax, bbox_ymax]) # Set the Region of Interest (ROI) to the bbox around the desired geometry<br/>    image_roi = mapbiomas_data.clip(roi) # Crop the image to the ROI<br/>    <br/>    export_task = ee.batch.Export.image.toDrive(<br/>        image=image_roi, # Image to export to Google Drive as a GeoTIFF<br/>        description=f"save_bbox_around_{geom_name}_in_{year}", # Task description<br/>        folder=folder_in_google_drive, # Change this to the folder in your Google Drive where you want to save the file<br/>        fileNamePrefix=f"{geom_name}_{year}", # File name<br/>        region=roi.getInfo()['coordinates'], # Region to export the image<br/>        scale=30,<br/>        fileFormat='GeoTIFF'<br/>    )<br/>    export_task.start()  # Notice that uploading those rasters to Google Drive may take a while, specially for large areas</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="b02a" class="pu or fq pr b bg pv pw l px py"># Test it using Rio de Janeiro in 2022<br/>folder_in_google_drive = 'tutorial_mapbiomas_gee'<br/>rio_de_janeiro = brazilian_municipalities.query('nm_mun == "Rio de Janeiro"') <br/>rio_de_janeiro.crs = 'EPSG:4326' # Set the CRS to WGS84 (this project default one, change if needed)<br/>rio_de_janeiro_geom = rio_de_janeiro.geometry.iloc[0] # Get the geometry of Rio de Janeiro, RJ<br/><br/>teste1 = get_mapbiomas_lulc_raster(rio_de_janeiro_geom, 'rio_de_janeiro', 2022, folder_in_google_drive)</span></pre><p id="891c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Second, crop the raster to include only the pixels within the geometry and save it as a new raster.</p><p id="542b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">I chose to save it on Google Drive, but you can change `reassigned_raster_path` to save it anywhere else. If you change it, make sure to update the rest of the code accordingly.</p><p id="f389" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Also, you can reassign pixels as needed by modifying the <code class="cx qd qe qf pr b">mapbiomas_categories</code> dict. The left digit represents the original pixel values, and the right one represents the reassigned (new) values.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="f046" class="pu or fq pr b bg pv pw l px py">## 4.2 Crop the raster for the desired geometry<br/>def crop_mapbiomas_lulc_raster(geom, geom_name, year, folder_in_google_drive):<br/>    original_raster_path = f'path_to_your_google_drive/{folder_in_google_drive}/{geom_name}_{year}.tif'<br/>    reassigned_raster_path = f'path_to_your_google_drive/{folder_in_google_drive}/cropped_{geom_name}_{year}.tif'<br/>    <br/>    my_geom = geom<br/><br/>    mapbiomas_categories = {<br/>    # Forest (= 3)<br/>    1:3, 3:3, 4:3, 5:3, 6:3, 49:3,<br/>    # Other Non-Forest Natural Vegetation (= 10)<br/>    10:10, 11:10, 12:10, 32:10, 29:10, 50:10, 13:10,<br/>    # Pasture (= 15)<br/>    15:15,<br/>    # Agriculture (= 18)<br/>    18:18, 19:18, 39:18, 20:18, 40:18, 62:18, 41:18, 36:18, 46:18, 47:18, 35:18, 48:18, 21:18, 14:18, 9:18,<br/>    # Water ( = 26)<br/>    26:26, 33:26, 31:26,<br/>    # Other (= 22)<br/>    22:22, 23:22, 24:22, 30:22, 25:22, 27:22,<br/>    # No data (= 255)<br/>    0:255<br/>    } # You can change this to whatever categorization you want, but just remember to adapt the colors and labels in the plot<br/>    <br/>    with rasterio.open(original_raster_path) as src:<br/>        raster_array = src.read(1)<br/>        out_meta = src.meta.copy() # Get metadata from the original raster<br/><br/>        # Crop the raster to the geometry of my_geom and thus remove pixels outside the city limits (will be assigned to no data = 0)<br/>        out_image, out_transform = rasterio.mask.mask(src, [my_geom], crop=True) <br/>        out_meta.update({<br/>            "height": out_image.shape[1],<br/>            "width": out_image.shape[2],<br/>            "transform": out_transform<br/>        }) # Update metadata to the new raster<br/>        raster_array = out_image[0] # Get the masked raster<br/><br/>        modified_raster = np.zeros_like(raster_array) # Base raster full of zeros to be modified<br/><br/>        # Reassign each pixel based on the mapbiomas_categories dictionary<br/>        for original_value, new_value in mapbiomas_categories.items():<br/>            mask = (raster_array == original_value) # Create a boolean mask for the original value (True = Replace, False = Don't replace)<br/>            modified_raster[mask] = new_value # Replace the original values with the new values, when needed (that is, when the mask is True)<br/><br/>        out_meta = src.meta.copy() # Get metadata from the original raster<br/><br/>        out_meta.update(dtype=rasterio.uint8, count=1) # Update metadata to the new raster<br/><br/>    with rasterio.open(reassigned_raster_path, 'w', **out_meta) as dst: # Write the modified raster to a new file at the reassigned_raster_path<br/>        dst.write(modified_raster.astype(rasterio.uint8), 1)</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="e61a" class="pu or fq pr b bg pv pw l px py">teste2 = crop_mapbiomas_lulc_raster(rio_de_janeiro_geom, 'rio_de_janeiro', 2022, folder_in_google_drive)</span></pre><p id="16dd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now we see the frequency of each pixel in the cropped reassigned raster.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="4c3f" class="pu or fq pr b bg pv pw l px py">## 4.3 Plot the cropped raster<br/>def pixel_freq_mapbiomas_lulc_raster(geom_name, year, folder_in_google_drive):<br/>    reassigned_raster_path = f'path_to_your_google_drive/{folder_in_google_drive}/cropped_{geom_name}_{year}.tif'<br/>    <br/>    with rasterio.open(reassigned_raster_path) as src:<br/>        raster_data = src.read(1)<br/>        unique_values = np.unique(raster_data)<br/>        total_non_zero = np.sum(raster_data != 255) # Count the total number of non-zero pixels<br/><br/>    for value in unique_values:<br/>        if value != 255:  # Exclude no data (= 255)<br/>            count = np.sum(raster_data == value) # Count the number of pixels with the value<br/>            share = count / total_non_zero # Calculate the share of the value<br/>            share = share.round(3)<br/>            print(f"Value: {value}, Count: {count}, Share: {share}") </span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="a4a0" class="pu or fq pr b bg pv pw l px py">teste3 = pixel_freq_mapbiomas_lulc_raster('rio_de_janeiro', 2022, folder_in_google_drive)</span></pre><p id="97c0" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Lastly, we plot it on a map. You can change the arguments below to adjust traits like colors, labels, legend position, font sizes, etc. Also, there is an option to choose the format in which you want to save the data (usually PDF or PNG). PDFs are heavier and preserve resolution, while PNGs are lighter but have lower resolution.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="cff9" class="pu or fq pr b bg pv pw l px py">## 4.4 Plot the cropped raster<br/>def plot_mapbiomas_lulc_raster(geom_name, year, folder_in_google_drive,driver):<br/>    reassigned_raster_path = f'/Users/vhpf/Library/CloudStorage/GoogleDrive-vh.pires03@gmail.com/My Drive/{folder_in_google_drive}/cropped_{geom_name}_{year}.tif'<br/>    with rasterio.open(reassigned_raster_path) as src:<br/>        raster_data = src.read(1)<br/><br/>    # Define the colors for each class - notice you need to follow the same order as the values<br/>    values = [3, 10, 15, 18, 22, 26, 255] # Must be the same of the mapbiomas_categories dictionary<br/>    colors_list = ['#6a994e', '#a7c957', '#c32f27', '#dda15e', '#6c757d', '#0077b6','#FFFFFF'] # Set your colors<br/>    labels = ['Natural Forest', 'Other Natural Vegetation', 'Pasture', 'Agriculture', 'Others', 'Water', 'No data'] # Set your labels<br/><br/>    cmap = colors.ListedColormap(colors_list) # Create a colormap (cmap) with the colors<br/>    bounds = values + [256] # Add a value to the end of the list to include the last color<br/>    norm = colors.BoundaryNorm(bounds, cmap.N) # Normalize the colormap to the values<br/><br/>    img = plt.imshow(raster_data, interpolation='nearest', cmap=cmap, norm=norm) # Plot the data with the colormap<br/><br/>    legend_patches = [mpatches.Patch(color=colors_list[i], label=labels[i]) for i in range(len(values)-1)] # Create the legend patches without the last one (255 = no data)<br/><br/>    # Create the legend<br/>    plt.legend(handles = legend_patches, # Add the legend patches<br/>               bbox_to_anchor = (0.5, -0.02), # Place the legend below the plot<br/>               loc = 'upper center', # Place the legend in the upper center<br/>               ncol = 3, # Number of columns<br/>               fontsize = 9, # Font size<br/>               handlelength=1.5,# Length of the legend handles<br/>               frameon=False) # Remove the frame around the legend<br/><br/>    plt.axis('off') # Remove the axis<br/>    geom_name_title = inflection.titleize(geom_name)<br/>    plt.title(f'Land Use in {geom_name_title} ({year})', fontsize=20) # Add title<br/><br/>    saving_path = f'figures/{geom_name}_{year}.{driver}'<br/><br/>    plt.savefig(saving_path, format=driver, dpi=1800) # Save it as a .pdf or .png at the figures folder of your project<br/>    plt.show()</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="1764" class="pu or fq pr b bg pv pw l px py">teste4 = plot_mapbiomas_lulc_raster('rio_de_janeiro', 2022, folder_in_google_drive, 'png')</span></pre><p id="e6a6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Finally, here’s an example of how to use the functions and create a loop to get the LULC evolution for Porto Acre (AC) since 1985. That’s another city in the AMACRO region with soaring deforestation rates.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="546d" class="pu or fq pr b bg pv pw l px py">## 4.5 Do it in just one function - recall to save rasters (4.1) before<br/>def clean_mapbiomas_lulc_raster(geom, geom_name, year, folder_in_google_drive,driver):<br/>    crop_mapbiomas_lulc_raster(geom, geom_name, year, folder_in_google_drive)<br/>    plot_mapbiomas_lulc_raster(geom_name, year, folder_in_google_drive,driver)<br/>    print(f"MapBiomas LULC raster for {geom_name} in {year} cropped and plotted!")</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="3119" class="pu or fq pr b bg pv pw l px py">## 4.6 Run it for multiple geometries for multiple years<br/><br/>### 4.6.1 First, save rasters for multiple geometries and years<br/>cities_list = ['Porto Acre'] # Cities to be analyzed - check whether there are two cities in Brazil with the same name<br/>years = range(1985,2023) # Years to be analyzed (first year in MapBiomas LULC == 1985)<br/><br/>brazilian_municipalities = gpd.read_file('municipios/file.shp', engine='pyogrio', use_arrow=True) # Read the shapefile - you can use any other shapefile here<br/>brazilian_municipalities = brazilian_municipalities.clean_names()<br/>brazilian_municipalities.crs = 'EPSG:4326' # Set the CRS to WGS84 (this project default one, change if needed)<br/>selected_cities = brazilian_municipalities.query('nm_mun in @cities_list') # Filter the geometry for the selected cities<br/>selected_cities = selected_cities.reset_index(drop=True) # Reset the index<br/><br/>cities_ufs = [] # Create list to append the full names of the cities with their UF (state abbreviation, in portuguese)<br/>nrows = len(selected_cities)<br/>for i in range(nrows):<br/>    city = selected_cities.iloc[i]<br/>    city_name = city['nm_mun']<br/>    city_uf = city['sigla_uf']<br/>    cities_ufs.append(f"{city_name} - {city_uf}")</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="e2a1" class="pu or fq pr b bg pv pw l px py">folder_in_google_drive = 'tutorial_mapbiomas_gee' # Folder in Google Drive to save the rasters<br/>for city in cities_list:<br/>    for year in years:<br/>        city_geom = selected_cities.query(f'nm_mun == "{city}"').geometry.iloc[0] # Get the geometry of the city<br/>        geom_name = unidecode.unidecode(city) # Remove latin-1 characters from the city name - GEE doesn`t allow them<br/>        get_mapbiomas_lulc_raster(city_geom, geom_name, year, folder_in_google_drive) # Run the function for each city and year</span></pre><pre class="pz pq pr ps bp pt bb bk"><span id="8dbb" class="pu or fq pr b bg pv pw l px py">### 4.6.2 Second, crop and plot the rasters for multiple geometries and years - Make sure you have enough space in your Google Drive and all rasters are there<br/>for city in cities_list:<br/>    for year in years:<br/>        city_geom = selected_cities.query(f'nm_mun == "{city}"').geometry.iloc[0]<br/>        geom_name = unidecode.unidecode(city)<br/>        clean_mapbiomas_lulc_raster(city_geom, geom_name, year, folder_in_google_drive,'png') # Run the function for each city and year<br/>        gc.collect()</span></pre><p id="c006" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We will finish the tutorial by creating a short video showing the evolution of deforestation in the municipality over the last four decades. Note that you can extend the analysis to multiple cities and select specific years for the analysis. Feel free to customize the algorithm as needed.</p><pre class="mm mn mo mp mq pq pr ps bp pt bb bk"><span id="8437" class="pu or fq pr b bg pv pw l px py">## 4.7 Make a clip with LULC evolution<br/>img_folder = 'figures/porto_acre_lulc' # I created a folder to save the images of the LULC evolution for Porto Acre inside project_path/figures<br/>img_files = sorted([os.path.join(img_folder, f) for f in os.listdir(img_folder) if f.endswith('.png')]) # Gets all the images in the folder that  end with .png - make sure you only have the desired images in the folder<br/><br/>clip = ImageSequenceClip(img_files, fps=2)  # 2 FPS, 0.5 second between frames<br/>output_file = 'figures/clips/porto_acre_lulc.mp4' # Save clip at the clips folder<br/>clip.write_videofile(output_file, codec='libx264') # It takes a while to create the video (3m30s in my pc)</span></pre><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/7822848d8ba780656641f63147518ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUkfN-pDb4c57U6egABJZg.gif"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Figure 8: LULC in Porto Acre (AC) between 1985 and 2022. Self-made, using MapBiomas LULC Collection 8.</figcaption></figure></div></div></div><div class="ab cb oi oj ok ol" role="separator"><span class="om by bm on oo op"/><span class="om by bm on oo op"/><span class="om by bm on oo"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="e5fc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">I hope this tutorial saves you a lot of time when using MapBiomas LULC data. Remember, you can extend this analysis to cover multiple areas and select specific years according to your needs. Feel free to customize the algorithm to suit your specific requirements!</p></div></div></div><div class="ab cb oi oj ok ol" role="separator"><span class="om by bm on oo op"/><span class="om by bm on oo op"/><span class="om by bm on oo"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h2 id="34b8" class="oq or fq bf os ot ou ov ow ox oy oz pa nl pb pc pd np pe pf pg nt ph pi pj pk bk"><strong class="al">References</strong></h2><p id="47f3" class="pw-post-body-paragraph nc nd fq ne b go pl ng nh gr pm nj nk nl pn nn no np po nr ns nt pp nv nw nx fj bk">[1] MapBiomas Project — Collection 8 of the Annual Land Use and Land Cover Maps of Brazil, accessed on July 10, 2024 through the link: <a class="af ny" href="https://brasil.mapbiomas.org/en/#" rel="noopener ugc nofollow" target="_blank">https://brasil.mapbiomas.org/en/#</a></p><p id="fe5a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">[2] Instituto Brasileiro de Geografia e Estatística (IBGE). (2024). Malha Territorial [Data set]. Retrieved from <a class="af ny" href="https://www.ibge.gov.br/geociencias/organizacao-do-territorio/malhas-territoriais/15774-malhas.html?=&amp;t=acesso-ao-produto" rel="noopener ugc nofollow" target="_blank">https://www.ibge.gov.br/geociencias/organizacao-do-territorio/malhas-territoriais/15774-malhas.html?=&amp;t=acesso-ao-produto</a> on July 10, 2024.</p></div></div></div></div>    
</body>
</html>
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>An Introduction to Reinforcement Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>An Introduction to Reinforcement Learning</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://towardsdatascience.com/an-introduction-to-reinforcement-learning-995737d3f1d?source=collection_archive---------2-----------------------#2024-05-27">https://towardsdatascience.com/an-introduction-to-reinforcement-learning-995737d3f1d?source=collection_archive---------2-----------------------#2024-05-27</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="c3c6" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx"><em class="hd">A deep dive into the rudiments of reinforcement learning, including model-based and model-free methods</em></h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="he hf hg hh hi ab"><div><div class="ab hj"><div><div class="bm" aria-hidden="false"><a href="https://angjelinhila.medium.com/?source=post_page---byline--995737d3f1d--------------------------------" rel="noopener follow"><div class="l hk hl by hm hn"><div class="l ed"><img alt="Angjelin Hila" class="l ep by dd de cx" src="../Images/44d826eda81d6fb95ec9c65a1da5933d.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*5nDIujCgIoUt3RiIuaYaJA.jpeg"/><div class="ho by l dd de em n hp eo"/></div></div></a></div></div><div class="hq ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--995737d3f1d--------------------------------" rel="noopener follow"><div class="l hr hs by hm ht"><div class="l ed"><img alt="Towards Data Science" class="l ep by br hu cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="ho by l br hu em n hp eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hv ab q"><div class="ab q hw"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hx hy bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hz" data-testid="authorName" href="https://angjelinhila.medium.com/?source=post_page---byline--995737d3f1d--------------------------------" rel="noopener follow">Angjelin Hila</a></p></div></div></div><span class="ia ib" aria-hidden="true"><span class="bf b bg z dx">¬∑</span></span><p class="bf b hx hy dx"><button class="ic id ah ai aj ak al am an ao ap aq ar ie if ig" disabled="">Follow</button></p></div></div></span></div></div><div class="l ih"><span class="bf b bg z dx"><div class="ab cn ii ij ik"><div class="il im ab"><div class="bf b bg z dx ab in"><span class="io l ih">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hz ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--995737d3f1d--------------------------------" rel="noopener follow"><p class="bf b bg z ip iq ir is it iu iv iw bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="ia ib" aria-hidden="true"><span class="bf b bg z dx">¬∑</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">34 min read</span><div class="ix iy l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">¬∑</span></span></div><span data-testid="storyPublishDate">May 27, 2024</span></div></span></div></span></div></div></div><div class="ab cp iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo"><div class="h k w ea eb q"><div class="ke l"><div class="ab q kf kg"><div class="pw-multi-vote-icon ed io kh ki kj"><div class=""><div class="kk kl km kn ko kp kq am kr ks kt kj"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l ku kv kw kx ky kz la"><p class="bf b dy z dx"><span class="kl">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kk lb lc ab q ee ld le" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lf"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg></button></div></div></div><div class="ab q jp jq jr js jt ju jv jw jx jy jz ka kb kc kd"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap ie li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap ie ls lt le lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap ie ls lt le lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap ie ls lt le lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/6efc546a2ac8232ca42d0a0aa55498c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Z9Be9WHuN_b_Cca3DtFFA.jpeg"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Used on a creative commons license from: <a class="af nc" href="https://elifesciences.org/digests/57443/reconstructing-the-brain-of-fruit-flies#copyright" rel="noopener ugc nofollow" target="_blank">https://elifesciences.org/digests/57443/reconstructing-the-brain-of-fruit-flies#copyright</a></figcaption></figure><h2 id="1226" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">What is Reinforcement Learning?</h2><p id="b1b4" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">One path toward engineering intelligence lies with emulating biological organisms.</p><p id="88a8" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Biological organisms transduce information from the environment, process it (what cognitive science studies), and output behaviour conducive to survival. Such behaviours, at the most basic level, involve foraging for food, reproducing, and avoiding harm. They also involves the wide spectrum of human activity such as play, creativity, problem-solving, design and engineering, socializing, romance, and intellectual life.</p><p id="800c" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Now, how do we engineer a system that is able to do all of the above?</p><p id="55bc" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">If we were to model a simple organism as a function of some environment, we would need a model of the agent, the environment, and some function that moves that agent from some present state to some desired state.</p><p id="6699" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">In psychology, two major schools of thought purport to explain human behaviour: <em class="oz">behaviourism </em>and <em class="oz">cognitive science</em>. Behaviourists understand behaviour as a function of learning mechanisms, where learning can be attributed to output behaviour. Cognitive science, on the other hand, models agent interaction with the environment through the information-processing approach. In this approach, the agent transduces external stimuli into an internal representation initially by the senses and subsequently subjects it to layers of transformation and integration all the way up to thinking and reasoning faculties, before returning some behaviourial output. In the former approach, learning is understood largely as a function of environmental conditioning, whereas in the latter, mental representations are considered indispensable in predicting behaviour. Reinforcement learning borrows mostly from the behaviorist approach where environmental reward dictates the evolution of the agent within search space.</p><p id="b6b8" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk"><a class="af nc" href="https://en.wikipedia.org/wiki/Operant_conditioning" rel="noopener ugc nofollow" target="_blank">Operant conditioning</a>, the school of behaviorist psychology that reigned in the 1950s-60s, defined learning as the product of the environmental mechanisms of reward and punishment. Precursors to operant conditioning included the <a class="af nc" href="https://en.wikipedia.org/wiki/Law_of_effect" rel="noopener ugc nofollow" target="_blank">Law of Effect</a> proposed by Edward Thorndike which proposed that behaviors that produce satisfying effects are more likely to recur, whereas behaviors that produce dissatisfying effects less likely. B.F. Skinner operationalized effects in terms of reinforcement and punishment. Reinforcement increases the likelihood of the recurrence of a behavior, whether it be approach or removal of the inhibitory factor. Approach is termed positive reinforcement, and the reversal of avoidance, negative reinforcement. An example of positive reinforcement includes becoming good at a sport and winning often. An example of negative reinforcement includes removing the inhibitory stimulus, e.g. the school bully who taunts you during games. Operant conditioning predicts that you‚Äôre likely to repeat behaviours that receive the greatest reward. Punishment, on the other hand, consists of controlling the behavioural effect by either adding a negative consequence (positive punishment) or removing the reward associated with the behaviour (negative punishment). When fouling causes expulsion from the game, it illustrates positive punishment. When you perform poorly and lose games it illustrates negative punishment, which may cause avoidance of playing in the future.</p><p id="4012" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Much of the game of life in human society is replete with <em class="oz">secondary reinforcers</em> or socially constructed rewards and punishments that condition behaviour. These include money, grades, university admittance criteria, rules for winning and losing games, which build upon natural reinforcers that are closer to biological needs like food, reproduction, and social approbation.</p><p id="2133" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Memory plays an important role in learning because it enables the retention of prior experiences. Evidence shows that memory encodes the rewards and punishments more so than the content of the experience (Tyng et al., 2017). Subjects are likely to remember rewarding experiences fondly and thereby likely to repeat them, and negative experiences unfavourably, and likely to avoid them in the future. The mechanisms of memory are complicated and diverse, and evidence suggests that subjects play an active role in reshaping their memories by recalling them (Spens &amp; Burgess, 2024). This fact complicates the picture for behaviorism because the subject‚Äôs interpretation of an experience can be retrospectively modified and reframed, making prediction on conditioning principles alone difficult. Furthermore, rewards and punishments oversimplify the landscape of positive and negative affects, which comprises a complex terrain of valleys and troughs, nested dependencies, and is better modeled as a continuous spectrum rather than a binary space.</p><p id="5562" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">These complexities notwithstanding, reinforcement learning comprises an array of mathematical techniques that adapt the behavioural ontology of agent, environment, and rewards in order to model artificial intelligence. As we will see below, aspects of reinforcement learning emerge from control theory, whose precursors extend into physics and engineering, and other aspects emerge more directly from psychology and biology. Since both the objects of control theory and living systems comprise dynamical systems that must stay within an optimal range of far-from thermodynamic equilibrium, the underlying principles are amenable to the goals of reinforcement learning and artificial intelligence more broadly.</p><p id="c7e2" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Dynamic programming emerged chiefly from control theory as a mathematical optimization method that enables larger problems to be broken down recursively into sub-problems as a means of solving the larger problem. Generally speaking, recursion refers to a function that passes itself directly or indirectly as a parameter.</p><p id="68a4" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">In this article, we will focus chiefly on the elements of dynamic programming, with a focus on discrete and finite games. However, dynamic programming exhibits a variety of limitations that are in part addressed by model-free approaches to reinforcement learning and others by combining dynamic programming with artificial neural networks, once called <em class="oz">neurodynamic programming</em>. More broadly, the marriage of reinforcement learning and artificial neural networks is termed deep reinforcement learning. These models incorporate the strengths of deep learning within reinforcement learning techniques. The most popular of these algorithms include the <strong class="od fr">Deep Q-Networks (DQN)</strong>, which were introduced by <a class="af nc" href="https://deepmind.google/" rel="noopener ugc nofollow" target="_blank">DeepMind</a> in 2013. This family of algorithms leverages deep learning to approximate the Q-function. Since function-approximation is one of the shortcomings of reinforcement learning, these algorithms represent a major improvement of the reinforcement paradigm.</p><p id="20fe" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Other shortcomings addressed by <strong class="od fr">DQN </strong>include conferring flexibility in capturing nonlinear dynamics, admitting a much wider range of dimensions without becoming computationally intractable from the <em class="oz">curse of dimensionality</em>, and greater generalization capacity over the environment.</p><p id="bcd1" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Neurodynamic programming represents a step in the direction of leveraging the cognitive paradigm in psychology to address the shortcomings of the purely behaviourist approach. It is worth noting, however, that while scientific progress has been made in understanding the hierarchical organization and processing of lower-level perceptual information, the scaffolding of that information to thought and consciousness remains, more or less, scientifically elusive. For this reason, artificial neural networks (ANNs) as yet lack the complex generalization capacity of human intelligence which tends to learn with exponentially smaller samples than ANNs. We will discuss the implications of adopting the principles of reinforcement learning toward artificial general intelligence (AGI) in the last section of the article.</p><h2 id="cce5" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Decision Theory &amp; Control Theory</h2><p id="57ac" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">Before delving into the mathematical elements of dynamic programming and reinforcement learning, it is important to flesh out the relationship between the philosophical and mathematical branch of decision theory and reinforcement learning. While decision theory consists primarily of mathematical formalizations of rational choice theory, they overlap with the goals of reinforcement learning insofar as reinforcement learning seeks to scaffold its models into successful artificial agents that can interact with complex environments and information landscapes.</p><p id="bcff" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk"><strong class="od fr">Decision theory</strong>, also known as <strong class="od fr">choice theory</strong>, was developed in the 20th century at the heel of the growing formalization of <a class="af nc" href="https://plato.stanford.edu/entries/rationality-instrumental/" rel="noopener ugc nofollow" target="_blank">instrumental reason</a>. Specifically, it uses probability theory to quantify the probability of agent actions given their preferences. A crowning achievement of this formalization effort was the <a class="af nc" href="https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Morgenstern_utility_theorem" rel="noopener ugc nofollow" target="_blank"><strong class="od fr"><em class="oz">Von-Neumann-Morgenstern utility</em></strong></a><strong class="od fr"><em class="oz"> </em></strong>procedure. In a nutshell, the procedure states that agents tend to choose actions that maximize utility given the utility expectations of available choices.</p><p id="ab1f" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Control theory emerges from the fields of mechanical and electrical engineering and concerns optimizing the states and performance of dynamical systems relative to desired parameters, such as maintaining some steady-state temperature range. The essential mechanism consists of a controller that measures the desired variable and compares it to a set point, whose difference is fed as feedback for correction. The broad strokes of control theory mirror metabolic processes of living organisms, who maintain a set point of internal temperature against variable external conditions. The connection of control theory to decision theory is obvious: both rely on feedback from the environment to maintain or advance the state of the system toward some form of optimality.</p><p id="e44e" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Mathematically, subsets of both control and decision problems can be reduced to optimization problems solvable through dynamic programming. Dynamical programming solves general stochastic optimal control problems (afflicted by the <a class="af nc" href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" rel="noopener ugc nofollow" target="_blank"><strong class="od fr"><em class="oz">curse of dimensionality</em></strong> </a>‚Äî meaning that computational requirements grow exponentially with the number of state variables) by decomposing them into smaller sub-problems and computing the value function. As we demonstrate the rudiments of reinforcement learning, we will delve into the heart of dynamic programming: the recursive relationship between the state and value functions of the agent.</p><p id="d45c" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Reinforcement learning and decision theory overlap in defining a procedure for maximizing reward or utility. However, whereas utility is explicitly defined in decision theory, which aims to model economic behaviour, in reinforcement learning utility is substituted by cumulative reward. Different policies relative to different task goals can be applied toward maximizing cumulative reward, which, as we will see, depends on the inverse relationship between the polar directions of exploration and exploitation termed the <em class="oz">exploration-exploitation dilemma</em>.</p><p id="8783" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Let‚Äôs begin by outlining the ontology underlying reinforcement models.</p><h2 id="2c14" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">States, Actions &amp; Rewards</h2><p id="8646" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">Reinforcement learning leverages the theoretical apparatus of decision theory to construct models comprising agents, environments, and a dynamic evolution rule. The evolution rule permits an agent to pursue rewards within its environment, also termed <em class="oz">observation</em>.</p><p id="4b43" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The agent is defined as an output from the environment to a decision. We call a particular decision an action. The mapping from the present state of the network to an action is called the policy. The policy guides actions as mappings from states to outcomes.</p><p id="0135" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Formally, therefore, a policy is a function that maps <em class="oz">a state</em> to an <em class="oz">action</em>. It can be represented by the conditional probability of an action given the current state, where the Greek symbol ùõë<strong class="od fr"> </strong>stands for policy:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pa"><img src="../Images/a4965d65edbd1fab0ea23d52a505410b.png" data-original-src="https://miro.medium.com/v2/resize:fit:410/format:webp/1*2AuVFycyZk40AW4u3KimMg.png"/></div></figure><p id="481a" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Transition dynamics define the next state given the input reward as a probability distribution over all possible states and reward values:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pb"><img src="../Images/f1a6a4ad7ea89b2d60b2754eca35ed07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*V8XAeWxQs4UESETw-9ivDA.png"/></div></figure><p id="65a4" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The formula above defines the probability of the next state and reward pair as equal to the conditional probability of the next state<strong class="od fr"> <em class="oz">s‚Äô</em> </strong>and reward <strong class="od fr"><em class="oz">r</em> </strong>given the current state <strong class="od fr"><em class="oz">s</em> </strong>and action <strong class="od fr"><em class="oz">a</em></strong>.</p><p id="779c" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">An action changes the environment by accruing a reward. The reward, in turn, changes the <strong class="od fr">agent state</strong> or <strong class="od fr">observation</strong>. The reward input determines the future action outputs based on the <em class="oz">policy</em>.</p><p id="a4cc" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Generally, there are two types of policies:</p><blockquote class="pc pd pe"><p id="4dbb" class="ob oc oz od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk"><strong class="od fr"><em class="fq">Deterministic:</em> </strong>given present state/environment, there‚Äôs one and only one action the agent can take.</p><p id="cf86" class="ob oc oz od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk"><strong class="od fr"><em class="fq">Stochastic: </em></strong>given present state/environment, there are multiple actions an agent can take.</p></blockquote><p id="0e6f" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">A reward is typically formalized as a scalar value, x.</p><p id="eba5" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Given a particular reward, the agent is faced with an optimization dilemma: <em class="oz">should the agent maximize short-term rewards or cumulative rewards over its complete life history</em>?</p><p id="d885" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">This is known as the <a class="af nc" href="https://en.wikipedia.org/wiki/Exploration-exploitation_dilemma" rel="noopener ugc nofollow" target="_blank"><strong class="od fr">exploration-exploitation dilemma</strong></a>. In other words, the transition function should aim to optimize the trade-off between exploring the environment and exploiting the knowledge it has accumulated by reaping maximal reward.</p><p id="39ec" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Optimal solutions to the exploration-exploitation dilemma depend on the type of tasks we want the model to learn, which range from finite to undefined (continuously or discretely infinite). The game of chess, for example, can be formalized as an episodic task because it has a a finite configuration space and a predefined end-state of three possible outcomes: win, lose, draw. This means that optimal successor states given current states can be computed through deterministic transition dynamics, where for every state there is a single optimal action.</p><p id="8871" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">However, most tasks do not have a finite configuration space nor predefined end-states. We classify these as <strong class="od fr">continuous tasks</strong>, and optimize them through <strong class="od fr">model-free</strong> approaches. In model-free approaches, instead of computing the transition dynamics, the model samples from the environment in order to compute optimal successor states. Put differently, instead of planning its actions through foresight, it uses trial-and-error to learn about the environment.</p><p id="6707" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">There are generally two approaches to model-free reinforcement learning: <a class="af nc" href="https://en.wikipedia.org/wiki/Monte_Carlo_method" rel="noopener ugc nofollow" target="_blank"><strong class="od fr">Monte Carlo approach</strong></a><strong class="od fr"> </strong>and <a class="af nc" href="https://en.wikipedia.org/wiki/Temporal_difference_learning" rel="noopener ugc nofollow" target="_blank"><strong class="od fr">Temporal-difference learning</strong></a>. Since averages over sufficient samples converge to expectations, model-free approaches estimate expectations through sample means. Monte Carlo methods compute value functions by estimating the expected cumulative returns of a sufficiently large sample of state-action pairs. Some Monte-Carlo methods evaluate the value function only at the end of the task for episodic tasks. For continuous tasks, the definition of an episode varies and can be set by the designer such as based on time intervals.</p><p id="72e0" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Unlike Monte-Carlo search, Temporal-difference learning, meanwhile, estimate the value function incrementally by leveraging differences between time-steps. Because of the incremental approach of temporal-difference methods, they exhibit a lower variance from the actual expected value than Monte-Carlo methods who rely on sampling means.</p><p id="ca3d" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk"><strong class="od fr"><em class="oz">To recapitulate</em>:</strong> the agent navigates its environment through mappings from current state and action-space pairs to state-spaces. Transition dynamics compute all possible mappings for finite configuration spaces with predefined end-states. In lieu of a predefined end-state and finite state-spaces, model-free approaches continuously sample from the environment to find the best policy.</p><p id="1bc1" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Dynamic programming computes state-transition probabilities and expected reward from all state-action pairs. To understand how this process works, we need to understand Markov processes.</p><p id="165e" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Next we‚Äôre going to learn the mathematical model that enables the agent to compute the optimal successor state. As we discussed earlier, optimality resolves into the exploration-exploitation dilemma, which varies with the type of task we‚Äôre trying to model. Looking into the structure of rewards will help us understand this better.</p><h2 id="6dfa" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Quantifying Reward</h2><p id="ced3" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">We quantify reward in reinforcement learning through a scalar value accrued to the agent from the environment upon taking an action. The value of this reward indicates the immediate goodness of the action with respect to its end-goal.</p><p id="2842" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Cumulative reward, or <em class="oz">return</em>, on the other hand, refers to the sum of all hitherto accumulated rewards from the environment. The goal of the agent is not merely to optimize immediate reward but to optimize cumulative reward. The former represents myopic agents who maximize short-term gains, whereas the latter far-sighted agents who seek to maximize long-term gains.</p><p id="c628" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Since for the most part we want agents to maximize highest rewards sooner rather than later, discounting is introduced to incentivize current maximal reward over later maximal reward.</p><p id="613f" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">We quantify cumulative reward G with discounting by the expression below:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pf"><img src="../Images/f2c4acce8007ae4321599db32ae9de51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jV-2c1g_VueqLcidOhDZxg.png"/></div></div></figure><p id="cdf3" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Here, cumulative reward <strong class="od fr">G </strong>equals to the sum of products of a reward and its discount factor gamma ùú∏, which is always a value between 0 and 1: {0,1}. Gamma is incrementally exponentiated with each time-step, which means that across infinite time-steps gamma approaches zero.</p><p id="eb87" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">As gamma approaches 0, it incentivizes short-term gains, whereas if gamma approaches 1, it incentivizes long-term gains since across infinite iterations the reward sum will itself approach infinity.</p><p id="656e" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Because most tasks are bounded in time, gamma discounting imposes upper bounds on rewards when it is below the value of 1.</p><p id="408c" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The condensed equation for cumulative reward with discounting is given below, where G stands for the sum of expected rewards <em class="oz">R, </em>which is multiplied by the discounting factor, gamma. Cumulative reward is therefore computed as the sum of the reward and the discounting factor:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pg"><img src="../Images/44e62f6e99a708c217910ec297a8f62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*jSzQs3zv-7UjSaVd0uJrcg.png"/></div></figure><h2 id="28f0" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Markov Decision Process (MDP)</h2><p id="c33d" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">So far we‚Äôve discussed the probabilistic definition of the policy as a mapping from a state to an action, transition dynamics as the probability of moving from one state to another given reward, and the formula for how reward is calculated.</p><p id="1491" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Now, we‚Äôre going to step back a little and provide some supplementary theory that defines these probabilistic transition chains. We will start with something called a <strong class="od fr">Markov process</strong>. Markov processes are stochastic processes that satisfy the <strong class="od fr">Markov property. </strong>A stochastic process is a process that varies randomly. The Markov property states that <em class="oz">for every state, successor states are conditioned only by present states</em>.</p><p id="bc23" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Because prior states do not bear on future states, processes that satisfy the Markov property are called memoryless. Imagine a set of fixed destinations that recur daily as you leave your home to go work before returning home again. In other words, we have a cyclical process with a beginning and an end. Now further imagine that your decision to move from one destination to the next only depends on your current destination, not your previous history of destinations. Initially, every connected destination would have an equal distribution of probabilities. For example, if upon leaving home you have the option to drive or take the metro, we‚Äôd ascribe initial probabilities to each of these possible future states as 0.5. Over iterations of all possible routes these probabilities might stabilize to some frequency distribution with some routes skewing preferentially over others. (This type of probability is called empirical probability because it averages outcomes over possible events relative to a finite number of tests) That distribution equilibrium would be the Markov chain or process.</p><p id="2d63" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Now you‚Äôre probably thinking: how do you define events and states? Isn‚Äôt the world infinitely complex to be talking about fixed possible states and stable probability distributions?</p><p id="2f3b" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Quite true, but since we‚Äôre after a mathematical formalism of agents in environments, we need therefore to distinguish between the types of tasks or environments we are trying to model. To do this, we need to specify the representation of both <em class="oz">time steps</em> and <em class="oz">state spaces</em>, that is, the distributions of all possible states. The square matrix below provides a definition of Markov chains with respect to axes of <strong class="od fr">state-space </strong>and <strong class="od fr">time:</strong></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ph"><img src="../Images/fee2c33c281ecd124d0ffef43bbd67d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*DOT2EsItut9uWxqeWbAQsg.png"/></div></div></figure><p id="c045" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The state-space can be defined as countable/finite or continuous, where finite state-spaces describe all the possible configurations of the system through combinatorics, while continuous state-spaces describe all the possible configurations through a continuous function.</p><p id="50c2" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Finite and countably infinite spaces take integers or rational numbers as their measurable space, whereas continuous spaces take real numbers.</p><p id="3eda" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Likewise, the axis of time can be defined as discrete or continuous.</p><p id="5011" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Discrete-time processes count phase-transitions as discontinuous but can be modeled on either countable or uncountable state-spaces, where uncountable refers to infinite decimal expansions of real numbers. This is in fact how your computer counts time ‚Äî it does so in discrete steps. The interval between the steps varies across architectures, but a cycle is usually measured as the length of the time-step required to change a register state.</p><p id="d6b8" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Continuous-time chains count phase-transitions as continuous and can be modeled on countable or uncountable state-spaces.</p><p id="debd" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The term Markov process is typically reserved for continuous-time processes, whereas the term Markov chain describes a subset of those: discrete-time, stochastic control processes. In the rest of the article, we will focus on <em class="oz">discrete-time, finite state-spaces</em>.</p><p id="c46d" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">So far our Markov chains are very simplistic as they describe transitions between states with fixed probabilities. We‚Äôre missing two ingredients important for modelling behaviour in our ontology: <strong class="od fr"><em class="oz">actions</em> </strong>and <strong class="od fr"><em class="oz">rewards</em></strong>.</p><p id="5ac6" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Adducing rewards to transition probabilities constitute <strong class="od fr"><em class="oz">Markov Reward Processes</em></strong>. Markov Reward Processes assign a reward to each transition state, (defined as a positive or negative integer) thereby nudging the system toward some desired state. Recall our cumulative reward formula as the sum of expected rewards multiplied with some discounting factor. A Markov Reward Process allows us then to calculate the value of the state <strong class="od fr"><em class="oz">v(s)</em></strong> as the probability of cumulative reward G (where G is averaged over a large sample of iterations) given initial state S:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pi"><img src="../Images/da2bb307dc6da5b4bdfc6121f8abadc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*hjVapQkoRKyqSvGX7dOKiQ.png"/></div></figure><p id="757e" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The last variable we need to adduce in order to scaffold to <strong class="od fr"><em class="oz">Markov Decision Processes</em></strong> are actions. The agent begins with equally distributed probabilities of a set of possible actions and subsequently updates the transition function as a mapping from current state and action to the next state and reward. We‚Äôve ended up full-circle to the transition dynamics that we described earlier:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pb"><img src="../Images/f1a6a4ad7ea89b2d60b2754eca35ed07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*V8XAeWxQs4UESETw-9ivDA.png"/></div></figure><h2 id="cefc" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Dynamic Programming &amp; Bellman Optimality</h2><p id="0960" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">This brings us to the concept of dynamic programming, developed by Bellman (1957).</p><p id="b1ff" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Understanding dynamic programming will help us understand approximation methods like Monte Carlo Search and Temporal Difference, which do not require complete knowledge of the environment like dynamic programming does. These model-free methods approximate the deterministic policy of dynamic programming in lieu of perfect information. As such, they provide powerful mechanisms that approximate real-world learning.</p><p id="305b" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The core idea behind how dynamic programming searches and finds the optimal agent state concerns the relationship between the <strong class="od fr"><em class="oz">state-value function</em></strong> and the <strong class="od fr"><em class="oz">action-value function</em></strong>. These are recursively related.</p><p id="5653" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Let‚Äôs expound on these ideas with a relatable example. Let‚Äôs say that you are at a suboptimal state in your life and want to change this. Let‚Äôs further say that you have a tangible goal or place you would like to be in the future within some realistic time horizon. In order to arrive at the grand goal (here you can substitute anything: better job, start a family etc), you will need to take a series of smaller steps or actions that will be conducive to your desired outcome. Translated in the language of reinforcement learning, your current state will be assigned a value. Given your current state and value, you will take actions. These actions will also be evaluated with respect to your overall goal and current state. A good action will receive a higher valuation than a bad action. Feedback from the environment will determine the value of the action (how these are determined varies with the task). The evaluation of the state will affect the valuation of the available actions and successor states. And the evaluation of the actions will recursively affect the value of the current state. In other words, actions and states are dynamically connected through recursion.</p><p id="1685" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Now, in real life, your goal and the action-steps to get to that goal cannot be specified as a deterministic system with discrete time-steps and and a discrete state-space (though perhaps they could be approximated this way). Instead, dynamic programming assumes a specifiable environment much like the game of chess, where time-steps and action-spaces are abstracted as discrete and finite. The overlap with real life closes on the fact that a larger goal will be approached through optimization of smaller sub-goals conducive to that larger goal.</p><p id="e4e0" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Dynamic programming therefore will assume the following values: <strong class="od fr">(Œ©,A,ùí´)</strong>, where <strong class="od fr">Œ©</strong> represents the total of all possible states,<strong class="od fr"> A</strong> an action event as a subset of the finite sample space, and <strong class="od fr">P</strong> as the probability assigned to each action event by some policy function ùùÖ.</p><p id="d160" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Now, if you think back to our <em class="oz">deterministic transition dynamics</em>, since the sets of states, actions, and rewards are finite, any particular state and reward pair will have a probability of those values occurring given some prior state and action pair. These probabilities are specified as discrete probability distributions of random variables since the state space is discrete. We said that sequences consisting of states, actions, and rewards are Markov Decision Processes (MDPs) that seek to maximize expected cumulative reward over time, where reward is represented as a scalar value.</p><p id="f867" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk"><em class="oz">Now the question we need to address is how does a Markov Decision Process maximize cumulative reward given the assumptions we‚Äôve specified?</em><strong class="od fr"> </strong>The answer is provided by the <strong class="od fr">Bellman Optimality Equations</strong> which relate two functions: <strong class="od fr"><em class="oz">the state-value function</em></strong> and the <strong class="od fr"><em class="oz">action-value function</em></strong>.</p><h2 id="12c1" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">State-Value Function</h2><p id="f07a" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">The state-value function can be defined as the sum of the probabilities of all possible actions an agent can take under a policy ùùÖ, where, for each action, it‚Äôs value is determined by the sum of all weighted values of possible successor states.</p><p id="6015" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Put more simply, the state-value function defines the expected cumulative reward an agent can obtain starting from a particular state (s) by following policy ùùÖ.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pj"><img src="../Images/ed9537f25ec200181725548dcaa75472.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*DZFPUypp4fXct4-7SgfoPA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">State-value function</figcaption></figure><p id="4995" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The above equation contains two terms: <strong class="od fr">a)</strong> <em class="oz">the sum of the probabilities of all possible actions an agent can take in state (s) following policy ùùÖ</em>, and <strong class="od fr">b)</strong> <em class="oz">an inner sum for each possible action that computes the weighted values of all possible successor states</em>. The term within the square brackets computes the contributions of each action‚Äôs possible states as the sum of the immediate reward R(s, a, s‚Äô) and discounted reward by gamma factor ùõæ.</p><p id="de32" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Another way of expressing the state-value function is the following<strong class="od fr">:</strong></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pk"><img src="../Images/e4735f6270231dea8d334aa5089bd5bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/0*2HLKJGsbMwE3pvUz.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Source: Sutton</figcaption></figure><p id="ecc8" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The above formula defines the value of the next state as the expected return E<em class="oz">ùùÖ </em>computed as the conditional probability of getting reward <em class="oz">R</em> at time <em class="oz">t</em> given state <em class="oz">s </em>at time <em class="oz">t</em>. The reward R is calculated as the sum of products of expected returns in successor states and gamma discounting.</p><p id="348b" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">To help understand this better, imagine an agent in a 3 x 3 grid-world that has four possible actions ‚Äî <em class="oz">up, down, right, left</em><strong class="od fr"><em class="oz"> </em></strong>‚Äî available at each time-step.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pl"><img src="../Images/98f7736357b69aa644d9598e3f2d1bad.png" data-original-src="https://miro.medium.com/v2/resize:fit:246/format:webp/1*H2Cbplv4Dyx5jwl8UELy-w.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">State-space, where values represent rewards.</figcaption></figure><p id="3504" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">We initialize the state-values to 0, and use the Bellman equation for the state-value function to optimize the state-values given the distribution of rewards in the grid. We use <em class="oz">(row, col)</em> indexing to identify each position the grid.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pm"><img src="../Images/f02f7134fbb6f758b0da456370802ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:236/format:webp/1*NM0fweB3qsMPeI2iY8vI9A.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Initialized state-values prior to optimization.</figcaption></figure><p id="1a50" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Assuming that the policy is equally distributed across each action, and with a discounting factor of 0.9, the state-value function for the initial state (1,1), would be computed in the following way:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pn"><img src="../Images/454dc80cbd444d6dc16cd484d4889219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zad2IBwM5-RMXTv38V6iFw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">The value of state (1,1)</figcaption></figure><p id="e3cd" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The constants in each inner sum represent the rewards which are distributed in the grid according to some outcome we want the agent to achieve. The inner sums represent the immediate reward plus the product of the discounting factor and the cumulative value of the next state. The ratios in the outer sum represent the distribution of total probability given the number of actions. Since there are four possible actions, we can weight the inner sums initially by equally distributed probabilities summing into total probability. The state-value would then be computed for each possible state in the state-space and iterated until the sums converge to stable values.</p><h2 id="b9c5" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Action-Value Function</h2><p id="f8e3" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">As we saw the action-value function is embedded within the state-value function as its second term. This means that the action-value function computes the values of all the possible actions in state <em class="oz">(s)</em> as the sum of the immediate reward obtained from the transition from <em class="oz">(s) </em>to <em class="oz">(s‚Äô) </em>and the expected cumulative reward of the next state <em class="oz">(s‚Äô)</em> given the action, given by the formula below:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk po"><img src="../Images/6251ff1aecefc258f18326c452328603.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*uZIyelqWHBxC9AVndlrUEQ.png"/></div></figure><p id="7dba" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">In other words, the action value function computes the cumulative reward of taking action <em class="oz">a</em> in state <em class="oz">(s)</em>, where the expected return is the sum of the immediate state transition ‚Äî denoted by R(s, a,s‚Äô) ‚Äî and the discounted value of the cumulative reward of the next state s‚Äô‚Äî denoted by <em class="oz">ùõæ‚àëùùÖ</em>(a‚Äô|s‚Äô)Q(s‚Äô,a‚Äô).</p><p id="a5ee" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Another notation for formulating the action-value function is in terms of the expected return E given state and action pair (s, a) when following the optimal policy <em class="oz">ùùÖ:</em></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pp"><img src="../Images/6733812d0407777b7b25310fab2cbca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*9Au4MsyttJDEl7mHcZc4rg.png"/></div></figure><p id="9553" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The state-value functions and the action-value functions are related in the sense that the state-value function can be given by the policy and the action-value function Q(s,a).</p><blockquote class="pc pd pe"><p id="cb13" class="ob oc oz od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk"><strong class="od fr"><em class="fq">Therefore, each function contains itself as a parameter, albeit computing the successor transition state, as evinced by the formulas above. The formula for V(s) contains V(s‚Äô) and the formula for Q(s, a) contains Q(s‚Äô,a).</em></strong></p><p id="fa9c" class="ob oc oz od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk"><strong class="od fr"><em class="fq">Put differently, they contain each other within their parameters: the value of the state V(s) depends on the value of successor states computed through Q(s,a) and the value of the action Q(s,a) depends on the value of the successor state computed through V(s‚Äô).</em></strong></p></blockquote><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pq"><img src="../Images/8111aa8b4fa8505f9f85a8de520c4e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*RK4MvUXsG8eHEEorxJ9bCg.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Backup diagram for the state-value function. S represents the state, <em class="hd">ùùÖ the policy, black dots each available action, and arrows action-reward pairs transitioning to next state s‚Äô. Source: </em><a class="af nc" href="https://goodboychan.github.io/reinforcement_learning/2020/06/06/05-Policy-evaluation.html" rel="noopener ugc nofollow" target="_blank">https://goodboychan.github.io/reinforcement_learning/2020/06/06/05-Policy-evaluation.html</a></figcaption></figure><p id="e32d" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">As such, the action-value function and the state-value function are recursively related: the value of the action-state pairs determine the value of the state, which conversely determines the value of the action.</p><p id="6daf" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The state-value function takes as its prior the state, and yields an expected value E. The action value function takes as its prior state and action pairs, to compute the reward, the expected cumulative return E.</p><p id="4044" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The <strong class="od fr">Bellman Optimality Equations</strong> therefore express the recursive iteration of the state-value and action-value functions until they converge on optimal values. The Bellman Equation for the state-value function is expressed below:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pr"><img src="../Images/681778dfe0305d39e868e776e33e64b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:988/format:webp/1*rO4NWDc6c-oedHbEI84CdA.png"/></div></figure><p id="c98a" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">where the value of the current state is defined as the maximum reward of any possible action computed as the reward for taking action <strong class="od fr">a </strong>at state (<strong class="od fr">s)</strong> and the product of the value of the next action s‚Äô and its discount factor gamma.</p><p id="90a9" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The Bellman equation averages each all possible actions from the current state and weights them according to their probability of occurring.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ps"><img src="../Images/2350ca43f07a422e6d76ec7eb66ccdb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9Idzc9WMNvRkoKwg.png"/></div></div></figure><h2 id="bf74" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Model Free Methods: Monte Carlo &amp; Temporal Difference</h2><p id="bf81" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">The above example describes a deterministic model where the transition dynamics are known and can thus be perfectly computed. This is because we have complete knowledge of the environment.</p><p id="5329" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">However, for most tasks we don‚Äôt have complete knowledge of the environment. In lieu of this information, we cannot proceed with deterministic transition dynamics precisely because we cannot solve the dynamic programming equations. To overcome this problem, we can use techniques that borrow from statistics by inferring the state of the environment from a sample.</p><p id="f19c" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">In Monte Carlo methods, we approximate expected returns with the average of sample returns. As the sample approaches infinity, the average returns converge to the true value of expected returns. We do this by letting the agent run through an entire episode until termination before computing the value function. We then take <em class="oz">N</em> number of episode samples and use the mean to approximate the expected value of the target state. Now, as you might be already wondering, how an episode is defined varies with the task and purpose of the model. For example, in a game of chess we can define an episode as a run through an entire game or an arbitrary series of steps.</p><p id="509d" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">We can write the MC update rule as the following:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pt"><img src="../Images/31148e295cc8a431856d2b6f15cecfba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RgvZf46UAksck-6wQ_XkWQ.png"/></div></figure><p id="b5c0" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Where V(s) n+1 denotes the value of the next episode, S(s)n denotes the cumulative value of the state and G the value of the reward. We add the cumulative reward G to the state value and divide by the number of episodes or samples.</p><p id="74ce" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">We can algebraically rearrange the MC update rule to:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pu"><img src="../Images/813ba0814868e265d05b2830a0822db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WB3bX8osTgW39qiXoo0EIg.png"/></div></div></figure><p id="be29" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Unlike Monte Carlo methods, where we evaluate the value function only after each episode, with <strong class="od fr">Temporal Difference </strong>(TD) we evaluate the state value function after each time-step or increment. Since we start with no information about the environment, we have to initialize the values of V(s) to 0 or some other values, which will subsequently be updated with every time step.</p><p id="6b6a" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">We compute the value of the state in TD with two steps. First we compute the error of the step and next we use an update rule to change the value of the state. The error is given by the following difference formula:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pv"><img src="../Images/852bb36519b46bf2806382afa7e1cd25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*xtR8zZEKpKMGytX28sQfAA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">The error formula for TD time-step.</figcaption></figure><p id="b5b2" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Where, ùúπt stands for the error, R(t+1) the reward from the action, V(S t+1) the estimated value of the next state, and V(S) the value of the current state. The fact that TD uses the estimated value of the next state to evaluate the current state is called <strong class="od fr">bootsrapping</strong>. In effect, we subtract the value of the current state from the sum of the reward of the action and the product of the discounting factor and the value of the next state. This enables an immediate update of the value of the state with every time-step.</p><p id="bec5" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">By adding the observed discrepancy between the expected and observed reward ùúπ times ùõº (the learning rate) we close the discrepancy between observation and expectation:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pw"><img src="../Images/552a7d478c5afd3e49ba451b0df74af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*CuH_L3g4rShn1BfzbCzaoA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">The TD update rule for the value function.</figcaption></figure><p id="659c" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The role of ùõº determines the degree to which the TD algorithm learns, where ùõº is a real positive number. Typically, ùõº is set to values like [0.1, 0.01, 0.001]. A higher value ùõº ensures that the updates are more aggressive, whereas a lower value ensures more conservative updates. The value of ùõº affects the exploration-exploitation trade-off, where higher ùõº leans on exploration and lower ùõº leans on exploitation.</p><p id="451e" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">While both MC and TD methods proceed blindly without any prior knowledge of the environment, the merit of Temporal Difference is that it computes online updates at every time-step and the merit of Monte Carlo methods is unbiased estimation due to relying on sampling alone to estimate the value. A drawback of TD methods includes high bias, whereas a drawback of MC methods include overlooking important updates, and thereby higher variance. This suggests that the optimum between the two learning strategies must exist somewhere in between.</p><p id="1681" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The TD approach can be optimized by changing the single-step evaluation strategy to n-steps. As we will see, doing this enables compromising between TD and MC. When we evaluate the state value every n-steps, we do so by estimating n-steps into the future instead of after every step.</p><p id="66a6" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">A modified approach to n-step TD is TD(ùùÄ). TD(ùùÄ) methods use a parameter called <strong class="od fr"><em class="oz">eligibility traces</em></strong> to credit state-action pairs that occurred in the past. Instead of estimating n-steps into the future, eligibility traces assign credit to state-action pairs over multiple TD steps. Eligibility traces enable past state-action pairs to receive credit for contributing to observed-reward transitions. Eligibility traces are represented as vectors or matrices associated with each state-action pair. The eligibility trace for a time step is computed recursively as follows:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk px"><img src="../Images/d31d5d5fee276d703ea2cef7923e17f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*G45YDIsvGe5olvqhW3Ljzg.png"/></div></figure><p id="07af" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Where the lambda ùùÄ parameter controls the degree of bootstrapping. When ùùÄ =1, bootstrapping is eliminated and the update rule reduces to Monte Carlo. When ùùÄ = 0, it reduces to a TD time-step with bootstrapping termed TD(0). <em class="oz">TD(ùùÄ) generalizes TD and MC as a continuum where TD(0) denotes single step TD and TD(1) denotes the limit of extending TD to ‚àû steps, which reduces to MC.</em> As you can see from the formula, the eligibility trace parameter is computed recursively, wherein the value of the eligibility trace for the next time step takes as input the eligibility trace from the previous step. When E(s) = 0, bootstrapping is eliminated. The TD(ùùÄ) update rule is computed the same as the TD and MC update rule except by multiplying the eligibility trace to the error as shown below:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk py"><img src="../Images/f27702af2c30a52497b10c09dfb7c96d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*IFCfqQ44euv4K7TGrPFlKw.png"/></div></figure><h2 id="fd99" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Augmenting Reinforcement Learning with ANNs</h2><p id="f09f" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">Whether model-based or model-free, RL algorithms encounter scaling problems because of the curse of dimensionality, have trouble generalizing across different types of environments, and suffer from sample inefficiency.</p><p id="ca53" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Artificial Neural Networks (ANNs) provide a powerful method of rectifying some of the limits inherent within the RL architecture. In particular, ANNs improve sampling efficiency, environment generalization, and scaling problems caused by the curse of dimensionality. They reduce sample inefficiency through superior generalization capacity by virtue of the fact that they learn a general function from the data. This also enables them to scale better since the number of hidden layers and neurons per hidden layer can be increased. Too many hidden layers and neurons, however, can also lead to computational scaling problems (the curse of dimensionality is inescapable beyond certain ranges). They are further beset by the problem of the <em class="oz">non-stationarity of target states</em>, since traditionally ANNs require the ground truth (in the case of RL this amounts to <em class="oz">expected return</em>) to be set in advance, while RL algorithms find the optimal state through an update function, whether on-policy or off-policy.</p><p id="0d05" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Unlike traditional RL algorithms which rely on probabilistic transition rules, the application of ANNs to reinforcement learning uses function approximation to compute the state and state-action values. While any number of function approximation methods can be applied such as linear approximation and tile-coding, artificial neural networks constitute the most powerful technique due to their generalization power that leverages nonlinear function approximation.</p><p id="5b91" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Let‚Äôs look at two approaches that involve applying artificial neural networks to reinforcement learning: <strong class="od fr">Deep Q Learning (DQN) </strong>and <strong class="od fr">Deep Temporal Difference with eligibility traces (TD(ùùÄ))</strong>. Since we don‚Äôt know the target values in advance, MC or TD are used to create an estimate of the target state: the expected return. This is then used as the target value to be approximated by the function (really, the <em class="oz">gradient</em> which is the partial derivative of the error of the entire network with respect to the network parameter ùúÉ). ANNs approximate the target value by computing the error between the target estimate and the output and then computing the error through backpropagation and reducing it through an optimization algorithm. The most common optimization algorithm is a variation of gradient descent such as <strong class="od fr">stochastic gradient descent</strong>.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk pz"><img src="../Images/c5e7999c07ba8f2e019d9e979f46bbc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*g7K5jNfw0Ow634fb4IodBw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">In DQN the artificial neural network takes a state vector as input and outputs an action vector, where each value represents the action q-value.</figcaption></figure><h2 id="4b5c" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk"><strong class="al">Off-Policy DQN</strong></h2><p id="1874" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk"><strong class="od fr">Q-Learning</strong> is an off-policy version of <strong class="od fr">SARSA (States, Actions, Rewards, States‚Äô, Actions‚Äô)</strong>, where the next state-action pair <strong class="od fr">Q(s‚Äô, a‚Äô)</strong> is estimated by selecting the maximum estimated value of the next state. In other words, Q-Learning selects the maximum value of <strong class="od fr">Q(s‚Äô,a‚Äô) </strong>across actions available in the next state s‚Äô. This means that it doesn‚Äôt use the policy ùõë to learn Q(s‚Äô,a‚Äô). SARSA, on the other hand, is an on-policy method that selects an action from the previous action taken and an estimate of the next state-action pair, Q(s‚Äô,a‚Äô). This means that it uses the policy ùõë, namely the probability of an action given the state, to learn the Q-function.</p><p id="016b" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">In <strong class="od fr">Deep Q-Learning</strong>, the action-value function Q(a, s) is represented via Q(a,s, ùúÉ ) where ùúÉ represent the neural network parameters. Theta ùúÉ parameters are equivalent to weights <em class="oz">w</em> in neural networks, which are associated with connections between neurons. The weights determine the strength of the connections and are retroactively adjusted through backpropagation in order to minimize the error. DQN takes as input a high-dimensional representation of the environment and outputs a vector of action-values for each possible action. The expected return is typically approximated through an MC or TD approach. Backpropagation with an optimization function are then used to compute policy gradient and reduce the error by adjusting the policy network parameters ùúÉ.</p><p id="f5bb" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Because ANNs are highly sensitive to new information, it can cause catastrophic forgetting, where new information can overwrite previously written information. A method to manage catastrophic forgetting is to employ experience reply, a technique that stores past experiences and reuses them to train the network.</p><h2 id="f0e9" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk"><strong class="al">On-Policy Deep TD(ùùÄ)</strong></h2><p id="7bbd" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">ANNs can also be applied to <strong class="od fr">TD(Œª)</strong> methods, where the state observation is fed as input into an ANN, which then approximates the action-value function as output. Due to the on-policy nature of <strong class="od fr">TD(Œª)</strong>, Deep <strong class="od fr">TD(Œª)</strong> approaches are best suited for tasks that require long-term dependencies between states.</p><p id="51f4" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Training online learning methods like <strong class="od fr">TD(Œª) </strong>can be challenging because the distribution of the environment changes with every or n steps due to bootstrapping. This is called <em class="oz">nonstationarity </em>and impedes the convergence of the ANN parameters ùúÉ toward optimality. The interdependence of succeeding states in online learning can cause catastrophic forgetting, where the update interferes with past learning. Furthermore, the combination of eligibility traces which assign credit to past actions and ANNs can create additional complications in the backpropagation step.</p><p id="efd9" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">A way to mitigate these challenges involves utilizing a technique called <strong class="od fr">experience replay</strong>. Experience replay stores agent learned episodes as vectors of [s, a, r, s‚Äô] in a memory buffer. During training, the network samples from its memory buffer of stored learned vectors to update the network parameters. This provides the network with greater stability and makes it less prone to catastrophic interference from high-variance new experiences that result in a larger error or temporal difference between steps.</p><p id="6aae" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Deep <strong class="od fr">TD(Œª) </strong>algorithms have shown to excel in continuous control tasks where<strong class="od fr"> </strong>the state-space is continuous and the target unknown or unclear. These include continuous control tasks in robotics, autonomous cars, and financial markets.</p><h2 id="5cb7" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Reinforcement Learning and Artificial General Intelligence</h2><p id="eb96" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">What are the implications of reinforcement learning for artificial general intelligence?</p><p id="04f9" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Notwithstanding the fact that ‚Äúintelligence‚Äù is an ill-formed variable since it meshes disparate competencies into a single notion, what‚Äôs termed ‚Äúgeneral intelligence‚Äù sits on top of evolved competencies of living organisms, which require the transduction of worldly information for survival and reproduction. Intelligence, even in the human context, cannot be extricated from the contours of organismic viability. This isn‚Äôt, however, the orthodoxy. The general wisdom argues that intelligence is more akin to a program or software that computes inferences on the basis of available information.</p><p id="51ce" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The latter conception consists of two models, which are mistakenly thought of as competing. One model describes intelligence as following procedures, whereas the other describes intelligence as generalizing from data for optimal prediction. The former is generally much better understood, whereas the latter amounts to a cluster of techniques that reliably improve the strength of predictions. Animal intelligence is largely based on the latter model.</p><p id="6b30" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The most successful paradigm of the second model is deep learning through artificial neural networks. The chief advantage of ANN architectures is that they enable generalization from data without prior information or concepts, although this is not to be confused with unsupervised learning. ANNs first build a model through training and then make predictions on the basis of that model on new data. It is thought, therefore, that the brain does something similar (after factoring pre-training from evolution). However, there are currently two weaknesses within ANNs. The first weakness is that the goal or outcome has to be set by the human designer. An ANN cannot of its own accord conceive of goals. It cannot, a fortiriori, tell the difference between truth and falsity of its own accord. The human designer must supply the true outcome in order for the model to learn to approximate that outcome. The second weakness is that an ANN, without reinforcement learning, cannot search an environment to optimize its own state. For this reason, the combination of the generalization and predictive power of ANNs with the decision optimization power of reinforcement learning makes for a formidable amalgamation.</p><p id="7b14" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">It is on this basis that some have argued that reinforcement learning represents the clearest path toward artificial general intelligence (Sutton, 2014). The intuition behind this is clear: reinforcement learning comes closest to modelling living systems, which when enhanced with other successful architectures like transformers may lead to a model of AI that replicates (and exceeds!) all human capabilities.</p><p id="3297" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">However, if humans are the basis of general intelligence, then the conception of general intelligence cannot be one that divorces intelligence from survival constraints and some form of embodiment. On the other hand, if general intelligence can be defined without reference to living organisms, then it isn‚Äôt clear what it would look like ‚Äî purely abstract models escape satisfactory formalization despite attempts like Marcus Hutter‚Äôs <a class="af nc" href="https://en.wikipedia.org/wiki/AIXI" rel="noopener ugc nofollow" target="_blank">AIXI</a>. In the abstract, it can be conceived of some perfectly rational agent that solves problems by virtue of reasoning and computational power alone. The cleavage between information and embodiment is a gambit for a much wider discussion that is beyond the scope of this article. If interested, this <a class="af nc" href="https://evanthompson.me/wp-content/uploads/2012/11/pcs-life-and-mind.pdf" rel="noopener ugc nofollow" target="_blank">paper</a> provides a good starting point.</p><p id="a6e0" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">However, there are good reasons to doubt that reinforcement learning suffices for artificial general intelligence. Some reasons for this include the very definition of general intelligence. Most current AI researchers still rely on a behaviourist conception of intelligence without factoring explicit internal representations as necessary ingredients. And they have good reason to think so. Symbolic AI, in which hopes of general AI were pinned before the success of deep learning, proved to be a failure. Symbolic AI refers to approaches to artificial intelligence based primarily on explicitly coded logical rules and knowledge stores for optimal inference generation.</p><p id="6db0" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">The tension between symbolic AI and neural networks may, however, be unfounded. Many researchers believe that the quest for artificial general intelligence lies in combining these approaches in the right way. Reasons for thinking that neural nets approximate the native ontology of the brain include the fact that mathematical logic is not quite how the brain reasons: that is, it doesn‚Äôt compute necessary and sufficient conditions, or crisp membership, as much as graded membership, which is approximated by the likes of fuzzy logic and at which ANNs excel.</p><p id="4480" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Neural networks consist of a black-box hierarchical architecture of hidden layers parametrized to achieve the desired output through highly calibrated dynamic learning rates, activation functions, connection weights, and optimization algorithms calibrated to minimize error. Beyond highly calibrated hyperparameters like the above, the human designer does not understand how information is processed in the hidden layers. The assumption is that the same is the case with the brain, where information is not stored as combinations of discrete representational units (whether analog or imagistic) but as a vast, distributed architecture of billions of neurons. What we think of as linguistically structured thoughts are not internally represented in the brain that way at all: there‚Äôs no specific combination of neurons that stand for the word <em class="oz">being</em> or the sentence ‚Äú<em class="oz">Existence as determinate being is in essence being for another‚Äù</em> for example.</p><p id="a8ef" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Linguistic competence is instead embedded in a vast network of semantic connections and reproduction rules reinforced through experience and augmented by imagistic and analog representations. In other words, language and thought as we represent them reflectively, but also behaviourally in writing and speech, do not have brain analogues that mirror their explicit structure (in other words, isomorphic mapping between grammar and the native ontology of the brain), but are instead embedded in distributed networks of neural assemblies characterized by degrees of connectivity and connection strengths.</p><p id="afea" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">On the other hand, it seems that neural nets seem unable to instantiate the structured thought-processes that some argue are the seat of reason and human intelligence. After all, explicit reasoning constitutes the chief means of human intellectual achievement, and this does not appear to be something that current neural nets are able to replicate. A salient illustration comes from G√∂del‚Äôs Incompleteness Theorems, where a formal system alone cannot establish the truth of certain statements on the basis of proof alone. (<a class="af nc" href="https://angjelinhila.medium.com/alethic-limits-set-theory-entscheidungsproblem-turing-computability-ed0ed282b026" rel="noopener">If interested, check out this article that I wrote that explains Godel‚Äôs proof</a>). Meanwhile, the human subject can verify the truth of such a statement despite failure of axiomatic deduction. Foregoing the complicated and contested implications of this uncoupling of truth and proof for computation, it is additionally worth noting that the human agent actively pursues theories of the world, whereas current RL algorithms do so in a very rudimentary sense, though robotics will likely eventually advance toward similar capabilities. Meanwhile the linguistic state of the art, LLMs, regurgitate linguistically indistinguishable analogues to human speech and writing when prompted while exhibiting exponentially faster recall speeds and stores of information orders of magnitude larger. Much hangs in the balance of understanding this distinction: humans actively pursue theories of the world as well as other creative pursuits as part of their cultural programming, which co-opts mechanisms tailored toward survival and reproductive success. In other words, all human activity occurs within the basin of evolutionary constraints. As such, humans and all living organisms, constitute autonomous systems that replicate and endogenously reproduce their own identity conditions. Human and animal intelligence are therefore inextricable from the boundary conditions of survival, barring any measure of cultural independence from strict adaptationism (<a class="af nc" href="https://en.wikipedia.org/wiki/Sociobiology" rel="noopener ugc nofollow" target="_blank">a big topic which engenders wide disagreement</a>).</p><p id="cf8e" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Current AI does not approximate autonomous systems that endogenously propel themselves in the world. Nor do they generate their own environmental milieu and reconfigure their own search spaces in the way humans and other animals do. The absence of this constraint currently allows the human designer to set AI‚Äôs informational salience, e.g. text-generation, environmental detection etc. Even if the architecture evolves into a bona fide general problem-solving machine, unless it becomes capable of reflective awareness it cannot be said to possess general intelligence. Definitions of general intelligence canonically omit the variable of global awareness ‚Äî the equivalent to what the ancient Greeks termed <strong class="od fr"><em class="oz">nous</em></strong> ‚Äî as the hallmark of human intelligence. They do so because reflective and global awareness remain recalcitrant to reverse engineering and analysis into parts. For this reason, reflective awareness is dismissed as an ingredient of intelligence. However, admitting recalcitrance to current scientific explanation does not by the same token imply rejecting physicalism or an an endorsement of non-naturalism. Rather, it signals admission of lack of understanding. Given this gap in understanding, I hypothesize that reflective awareness is an extension of sentience which is a fundamental property of living organisms. In asserting this, I do not imply that autonomous systems cannot be engineered through means other than natural selection, though I leave open the possibility that they may remain opaque to scientific analysis in the foreseeable future. If reinforcement learning hopes to amount to general intelligence, the agent should posses as a prior a powerful architecture that not only hosts complex representations of the world, but maintains a global view from the inside of those very representations. This means that while model-world interactivity is indispensable to the task, the native architecture will require a complex hierarchical internal structure with capacities for multi-modal information processing and integration.</p><h2 id="2ee0" class="nd ne fq bf nf ng nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk"><strong class="al">Selected References</strong></h2><p id="78b1" class="pw-post-body-paragraph ob oc fq od b go oe of og gr oh oi oj no ok ol om ns on oo op nw oq or os ot fj bk">Mnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., Graves, A., Riedmiller, M., Fidjeland, A. K., Ostrovski, G., Petersen, S., Beattie, C., Sadik, A., Antonoglou, I., King, H., Kumaran, D., Wierstra, D., Legg, S., &amp; Hassabis, D. (2015). Human-level Control through Deep Reinforcement Learning. <em class="oz">Nature</em>, <em class="oz">518</em>(7540), 529‚Äì533. <a class="af nc" href="https://doi.org/10.1038/nature14236" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1038/nature14236</a></p><p id="8ca4" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Neftci, E. O., &amp; Averbeck, B. B. (2019, March 4). <em class="oz">Reinforcement learning in artificial and Biological Systems</em>. Nature News. <a class="af nc" href="https://www.nature.com/articles/s42256-019-0025-4" rel="noopener ugc nofollow" target="_blank">https://www.nature.com/articles/s42256-019-0025-4</a></p><p id="1b83" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Sharma, S. (2024, March 7). <em class="oz">Learning to Mix ùëõ-Step Returns: Generalizing ùúÜ-Returns for Deep Reinforcement Learning</em>. Ar5iv. <a class="af nc" href="https://ar5iv.labs.arxiv.org/html/1705.07445" rel="noopener ugc nofollow" target="_blank">https://ar5iv.labs.arxiv.org/html/1705.07445</a></p><p id="59ef" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Sanghi, Nimish. <em class="oz">Deep Reinforcement Learning with Python: With PYTORCH, Tensorflow and Openai Gym</em>. Apress, 2021.</p><p id="ec71" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Silver, D., Singh, S., Precup, D., &amp; Sutton, R. S. (2021). Reward is enough. <em class="oz">Artificial Intelligence</em>, <em class="oz">299</em>, 103535. <a class="af nc" href="https://doi.org/10.1016/j.artint.2021.103535" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1016/j.artint.2021.103535</a></p><p id="a03a" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Spens, E., &amp; Burgess, N. (2024, January 19). <em class="oz">A generative model of memory construction and consolidation</em>. Nature News. <a class="af nc" href="https://www.nature.com/articles/s41562-023-01799-z" rel="noopener ugc nofollow" target="_blank">https://www.nature.com/articles/s41562-023-01799-z</a></p><p id="d0e4" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Sutton, Richard S. <em class="oz">Introduction to Reinforcement Learning</em>. MIT Press.</p><p id="9927" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">Tyng, C. M., Amin, H. U., Saad, M. N. M., &amp; Malik, A. S. (2017, August 24). <em class="oz">The influences of emotion on learning and memory</em>. Frontiers in psychology. <a class="af nc" href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5573739/" rel="noopener ugc nofollow" target="_blank">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5573739/</a></p><p id="ae93" class="pw-post-body-paragraph ob oc fq od b go ou of og gr ov oi oj no ow ol om ns ox oo op nw oy or os ot fj bk">White, A., Modayil, J., &amp; Sutton, R. (2014). Surprise and Curiosity for Big Data Robotics. <em class="oz">Association for the Advancement of Artificial Intelligence</em>, 19‚Äì22.</p></div></div></div></div>    
</body>
</html>
["```py\n@step(num_workers=4)\nasync def filter_papers(self, ev: PaperEvent) -> FilteredPaperEvent:\n    llm = new_gpt4o_mini(temperature=0.0)\n    response = await process_citation(ev.paper, llm)\n    return FilteredPaperEvent(paper=ev.paper, is_relevant=response)\n```", "```py\nIS_CITATION_RELEVANT_PMT = \"\"\"\nYou help a researcher decide whether a paper is relevant to their current research topic: {topic}\nYou are given the title and abstract of a paper.\ntitle: {title}\nabstract: {abstract}\n\nGive a score indicating the relevancy to the research topic, where:\nScore 0: Not relevant\nScore 1: Somewhat relevant\nScore 2: Very relevant\n\nAnswer with integer score 0, 1 or 2 and your reason.\n\"\"\"\n\nclass IsCitationRelevant(BaseModel):\n    score: int\n    reason: str\n\nasync def process_citation(citation, llm):\n    program = FunctionCallingProgram.from_defaults(\n        llm=llm,\n        output_cls=IsCitationRelevant,\n        prompt_template_str=IS_CITATION_RELEVANT_PMT,\n        verbose=True,\n    )\n    response = await program.acall(\n        title=citation.title,\n        abstract=citation.summary,\n        topic=citation.topic,\n        description=\"Data model for whether the paper is relevant to the research topic.\",\n    )\n    return response\n```", "```py\n@step(pass_context=True)\nasync def paper2summary_dispatcher(\n    self, ctx: Context, ev: Paper2SummaryDispatcherEvent\n) -> Paper2SummaryEvent:\n    ctx.data[\"n_pdfs\"] = 0\n    for pdf_name in Path(ev.papers_path).glob(\"*.pdf\"):\n        img_output_dir = self.papers_images_path / pdf_name.stem\n        img_output_dir.mkdir(exist_ok=True, parents=True)\n        summary_fpath = self.paper_summary_path / f\"{pdf_name.stem}.md\"\n        ctx.data[\"n_pdfs\"] += 1\n        self.send_event(\n            Paper2SummaryEvent(\n                pdf_path=pdf_name,\n                image_output_dir=img_output_dir,\n                summary_path=summary_fpath,\n            )\n        )\n```", "```py\nSUMMARIZE_PAPER_PMT = \"\"\"\nYou are an AI specialized in summarizing scientific papers.\n Your goal is to create concise and informative summaries, with each section preferably around 100 words and \n limited to a maximum of 200 words, focusing on the core approach, methodology, datasets,\n evaluation details, and conclusions presented in the paper. After you summarize the paper,\n save the summary as a markdown file.\n\nInstructions:\n- Key Approach: Summarize the main approach or model proposed by the authors.\n Focus on the core idea behind their method, including any novel techniques, algorithms, or frameworks introduced.\n- Key Components/Steps: Identify and describe the key components or steps in the model or approach.\n Break down the architecture, modules, or stages involved, and explain how each contributes to the overall method.\n- Model Training/Finetuning: Explain how the authors trained or finetuned their model.\n Include details on the training process, loss functions, optimization techniques, \n and any specific strategies used to improve the modelâ€™s performance.\n- Dataset Details: Provide an overview of the datasets used in the study.\n Include information on the size, type and source. Mention whether the dataset is publicly available\n and if there are any benchmarks associated with it.\n- Evaluation Methods and Metrics: Detail the evaluation process used to assess the model's performance.\n Include the methods, benchmarks, and metrics employed.\n- Conclusion: Summarize the conclusions drawn by the authors. Include the significance of the findings, \nany potential applications, limitations acknowledged by the authors, and suggested future work.\n\nEnsure that the summary is clear and concise, avoiding unnecessary jargon or overly technical language.\n Aim to be understandable to someone with a general background in the field.\n Ensure that all details are accurate and faithfully represent the content of the original paper. \n Avoid introducing any bias or interpretation beyond what is presented by the authors. Do not add any\n information that is not explicitly stated in the paper. Stick to the content presented by the authors.\n\n\"\"\"\n```", "```py\n@step(pass_context=True)\nasync def gather_feedback_outline(\n    self, ctx: Context, ev: OutlineEvent\n) -> OutlineFeedbackEvent | OutlineOkEvent:\n    \"\"\"Present user the original paper summary and the outlines generated, gather feedback from user\"\"\"\n    print(f\"the original summary is: {ev.summary}\")\n    print(f\"the outline is: {ev.outline}\")\n    print(\"Do you want to proceed with this outline? (yes/no):\")\n    feedback = input()\n    if feedback.lower().strip() in [\"yes\", \"y\"]:\n        return OutlineOkEvent(summary=ev.summary, outline=ev.outline)\n    else:\n        print(\"Please provide feedback on the outline:\")\n        feedback = input()\n        return OutlineFeedbackEvent(\n            summary=ev.summary, outline=ev.outline, feedback=feedback\n        )\n```", "```py\n @step(pass_context=True)\nasync def slide_gen(\n    self, ctx: Context, ev: OutlinesWithLayoutEvent\n) -> SlideGeneratedEvent:\n    agent = ReActAgent.from_tools(\n        tools=self.azure_code_interpreter.to_tool_list() + [self.all_layout_tool],\n        llm=new_gpt4o(0.1),\n        verbose=True,\n        max_iterations=50,\n    )\n\n    prompt = (\n        SLIDE_GEN_PMT.format(\n            json_file_path=ev.outlines_fpath.as_posix(),\n            template_fpath=self.slide_template_path,\n            final_slide_fname=self.final_slide_fname,\n        )\n        + REACT_PROMPT_SUFFIX\n    )\n    agent.update_prompts({\"agent_worker:system_prompt\": PromptTemplate(prompt)})\n\n    res = self.azure_code_interpreter.upload_file(\n        local_file_path=self.slide_template_path\n    )\n    logging.info(f\"Uploaded file to Azure: {res}\")\n\n    response = agent.chat(\n        f\"An example of outline item in json is {ev.outline_example.json()},\"\n        f\" generate a slide deck\"\n    )\n    local_files = self.download_all_files_from_session()\n    return SlideGeneratedEvent(\n        pptx_fpath=f\"{self.workflow_artifacts_path}/{self.final_slide_fname}\"\n    )\n```", "```py\n@step(pass_context=True)\nasync def validate_slides(\n    self, ctx: Context, ev: SlideGeneratedEvent\n) -> StopEvent | SlideValidationEvent:\n    \"\"\"Validate the generated slide deck\"\"\"\n    ctx.data[\"n_retry\"] += 1\n    ctx.data[\"latest_pptx_file\"] = Path(ev.pptx_fpath).name\n    img_dir = pptx2images(Path(ev.pptx_fpath))\n    image_documents = SimpleDirectoryReader(img_dir).load_data()\n    llm = mm_gpt4o\n    program = MultiModalLLMCompletionProgram.from_defaults(\n        output_parser=PydanticOutputParser(SlideValidationResult),\n        image_documents=image_documents,\n        prompt_template_str=SLIDE_VALIDATION_PMT,\n        multi_modal_llm=llm,\n        verbose=True,\n    )\n    response = program()\n    if response.is_valid:\n        return StopEvent(\n            self.workflow_artifacts_path.joinpath(self.final_slide_fname)\n        )\n    else:\n        if ctx.data[\"n_retry\"] < self.max_validation_retries:\n            return SlideValidationEvent(result=response)\n        else:\n            return StopEvent(\n                f\"The slides are not fixed after {self.max_validation_retries} retries!\"\n            )\n```", "```py\nSLIDE_VALIDATION_PMT = \"\"\"\nYou are an AI that validates the slide deck generated according to following rules:\n- The slide need to have a front page \n- The slide need to have a final page (e.g. a 'thank you' or 'questions' page)\n- The slide texts are clearly readable, not cut off, not overflowing the textbox\n and not overlapping with other elements\n\nIf any of the above rules are violated, you need to provide the index of the slide that violates the rule,\n as well as suggestion on how to fix it. \n\n\"\"\"\n```", "```py\nclass SummaryAndSlideGenerationWorkflow(Workflow):\n    @step\n    async def summary_gen(\n        self, ctx: Context, ev: StartEvent, summary_gen_wf: SummaryGenerationWorkflow\n    ) -> SummaryWfReadyEvent:\n        print(\"Need to run reflection\")\n        res = await summary_gen_wf.run(user_query=ev.user_query)\n        return SummaryWfReadyEvent(summary_dir=res)\n\n    @step\n    async def slide_gen(\n        self, ctx: Context, ev: SummaryWfReadyEvent, slide_gen_wf: SlideGenerationWorkflow\n    ) -> StopEvent:\n        res = await slide_gen_wf.run(file_dir=ev.summary_dir)\n        return StopEvent()\n\nasync def run_workflow(user_query: str):\n    wf = SummaryAndSlideGenerationWorkflow(timeout=2000, verbose=True)\n    wf.add_workflows(\n        summary_gen_wf=SummaryGenerationWorkflow(timeout=800, verbose=True)\n    )\n    wf.add_workflows(slide_gen_wf=SlideGenerationWorkflow(timeout=1200, verbose=True))\n    result = await wf.run(\n        user_query=user_query,\n    )\n    print(result)\n\n@click.command()\n@click.option(\n    \"--user-query\",\n    \"-q\",\n    required=False,\n    help=\"The user query\",\n    default=\"powerpoint slides automation\",\n)\ndef main(user_query: str):\n    asyncio.run(run_workflow(user_query))\n\nif __name__ == \"__main__\":\n    draw_all_possible_flows(\n        SummaryAndSlideGenerationWorkflow, filename=\"summary_slide_gen_flows.html\"\n    )\n    main()\n```", "```py\n # Summary of \"LayoutGPT: Compositional Visual Planning and Generation with Large Language Models\"\n\n## Key Approach\nThe paper introduces LayoutGPT, a framework leveraging large language models (LLMs) for compositional visual planning and generation. The core idea is to utilize LLMs to generate 2D and 3D scene layouts from textual descriptions, integrating numerical and spatial reasoning. LayoutGPT employs a novel prompt construction method and in-context learning to enhance the model's ability to understand and generate complex visual scenes.\n\n## Key Components/Steps\n1\\. **Prompt Construction**: LayoutGPT uses detailed task instructions and CSS-like structures to guide the LLMs in generating layouts.\n2\\. **In-Context Learning**: Demonstrative exemplars are provided to the LLMs to improve their understanding and generation capabilities.\n3\\. **Numerical and Spatial Reasoning**: The model incorporates reasoning capabilities to handle numerical and spatial relationships in scene generation.\n4\\. **Scene Synthesis**: LayoutGPT generates 2D keypoint layouts and 3D scene layouts, ensuring spatial coherence and object placement accuracy.\n\n## Model Training/Finetuning\nLayoutGPT is built on GPT-3.5 and GPT-4 models, utilizing in-context learning rather than traditional finetuning. The training process involves providing the model with structured prompts and examples to guide its generation process. Loss functions and optimization techniques are not explicitly detailed, as the focus is on leveraging pre-trained LLMs with minimal additional training.\n\n## Dataset Details\nThe study uses several datasets:\n- **NSR-1K**: A new benchmark for numerical and spatial reasoning, created from MSCOCO annotations.\n- **3D-FRONT**: Used for 3D scene synthesis, containing diverse indoor scenes.\n- **HRS-Bench**: For evaluating color binding accuracy in generated scenes.\nThese datasets are publicly available and serve as benchmarks for evaluating the model's performance.\n\n## Evaluation Methods and Metrics\nThe evaluation involves:\n- **Quantitative Metrics**: Precision, recall, and F1 scores for layout accuracy, numerical reasoning, and spatial reasoning.\n- **Qualitative Analysis**: Visual inspection of generated scenes to assess spatial coherence and object placement.\n- **Comparative Analysis**: Benchmarking against existing methods like GLIGEN and ATISS to demonstrate improvements in layout generation.\n\n## Conclusion\nThe authors conclude that LayoutGPT effectively integrates LLMs for visual planning and scene generation, achieving state-of-the-art performance in 2D and 3D layout tasks. The framework's ability to handle numerical and spatial reasoning is highlighted as a significant advancement. Limitations include the focus on specific scene types and the need for further exploration of additional visual reasoning tasks. Future work suggests expanding the model's capabilities to more diverse and complex visual scenarios.\n```"]
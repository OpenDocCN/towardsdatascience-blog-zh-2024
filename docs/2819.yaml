- en: Building a Research Assistant That Can Write to Google Docs (Part 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/building-a-research-assistant-that-can-write-to-google-docs-part-2-ac9dcacff4ff?source=collection_archive---------9-----------------------#2024-11-20](https://towardsdatascience.com/building-a-research-assistant-that-can-write-to-google-docs-part-2-ac9dcacff4ff?source=collection_archive---------9-----------------------#2024-11-20)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/84311f1635442fb3094ebc3095549255.png)'
  prefs: []
  type: TYPE_IMG
- en: Dalle-3’s interpretation of “An AI assistant throwing documents to the wind
    over a clear blue ocean”. Image generated by the author.
  prefs: []
  type: TYPE_NORMAL
- en: A tool that might help with your homework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@rmartinshort?source=post_page---byline--ac9dcacff4ff--------------------------------)[![Robert
    Martin-Short](../Images/e3910071b72a914255b185b850579a5a.png)](https://medium.com/@rmartinshort?source=post_page---byline--ac9dcacff4ff--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--ac9dcacff4ff--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--ac9dcacff4ff--------------------------------)
    [Robert Martin-Short](https://medium.com/@rmartinshort?source=post_page---byline--ac9dcacff4ff--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--ac9dcacff4ff--------------------------------)
    ·12 min read·Nov 20, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '***This article is the second of a two part series where we use LangGraph and
    Tavily to build a simple research agent, which writes and refines short articles.
    To keep track of the plans, articles and comments it generates we add the ability
    to programmatically create and edit Google Docs. In the first article we built
    the agent. Now we will build the docs connection. You can find all the relevant
    code*** [***here***](https://github.com/rmartinshort/research_assist)***.***'
  prefs: []
  type: TYPE_NORMAL
- en: In [part 1 of this series](/building-a-research-agent-that-can-write-to-google-docs-part-1-4b49ea05a292)
    we discussed agents, and used tools from LangGraph and Tavily to build a minimal
    agent that can research, write, review and revise short articles. This is great
    for a demo, but what if we actually want to read those articles outside of a notebook?
    Or, more ambitiously, what if we can to make this agent into a tool that might
    actually be useful to someone learning about a new subject? This has the potential
    to become a full stack project, but here I will focus on just one interesting
    element — giving out system the ability to upload essays to Google Docs. Recall
    that we also save the intermediate steps that the agent takes in getting to the
    final answer too — probably its worth making a record of those as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. A minimal viable product**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In response to a question or topic prompt, our agent produces a long list of
    output. At a minimum, we’d like to dump this into a Google Doc with a title, and
    timestamp. We’d also like to control where in Google Drive this doc is to be written,
    and preferably have the option to create and name a folders so that our essays
    can be stored logically. We won’t focus too much on formatting here — although
    this is certainly possible using the Google Docs API — we are more interested
    in just getting the text into a place where someone would actually read it. Formatting
    could be a follow up, or simply left to the preference of the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a docs connection set up, there’s a whole host of more advanced
    things we could do with our essay — what about using an LLM to reformat them for
    a presentation and uploading that into a Google Slides deck? Or scraping some
    referenced data source and uploading that to Google Sheets? We could add this
    functionality as tools inside the control flow of our agent and have it decide
    what to do. Clearly there’s a lot of options here but its good to start small.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Connecting to Google Drive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start by writing some code to interact with Google Docs in some basic
    ways. Some setup is required first: You will need a Google Cloud account and a
    new project. You will then need to enable the Google Drive and Google Docs APIs.
    To create some credentials for this project, we will be using a [service account](https://cloud.google.com/iam/docs/service-account-overview#:~:text=A%20service%20account%20is%20a,is%20unique%20to%20the%20account.),
    which can be set up using the instructions [here](https://developers.google.com/zero-touch/guides/customer/quickstart/python-service-account).
    This process will create a private key in a `.json` file, which you store on your
    local machine. Next, it’s a good idea to make a “master folder” for this project
    in your Google Drive. When that’s done, you can add your service account to this
    folder and give it write permissions. Now your service account has the authorization
    to programmatically interact with the contents of that folder.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The code is set up like this because there are many GSuite APIs (drive, docs,
    sheets, slides etc) that we might want to use in future. They would all inherit
    from `GSuiteService` and have their `get_service` and `get_scopes` methods overwritten
    with the specific details of that API.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is all set up, you’re ready to interact with drive. This is a great
    [article](https://medium.com/@matheodaly.md/using-google-drive-api-with-python-and-a-service-account-d6ae1f6456c2)
    showing some of the main ways of doing so.
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, the way we’ll interact with drive is via methods of `GoogleDriveHelper`
    , which creates an instance of `GoogleDriveService` on initialization. We start
    with giving it the name of our master folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s say we want to create a project about the Voyager series of space
    probes, for example. We can get organized by setting up a folder for that inside
    the master folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This creates the folder and returns its ID, which we can use to create a document
    there. There might be multiple versions of this project, so we can also make relevant
    subfolders
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we’re ready to make a blank document, which we can also do with the drive
    service
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Under the hood, the drive helper is running the following code, which passes
    some metadata indicating that we want to make a document to the create method
    of `googleapiclient.discovery.build` (i.e. what comes out of running `GoogleDriveService().build()`
    )
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you might imagine, the Google Drive API has a lot of different functionality
    and options that we’re not covering here. The most comprehensive python wrapper
    for it that I’ve found is [this one](https://github.com/iterative/PyDrive2), which
    would be a good starting point if you want to explore further.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Writing to Google Docs**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve made a blank document, let’s fill it with the final essay! This
    is where the `GoogleDocsService` and `GoogleDocsHelper` come in. `GoogleDocsService`
    is very similar to `GoogleDriveService` , and also inherits from `GSuiteService`
    as we discussed in section 2\. `GoogleDocsHelper` contains some tools to write
    text and images to Google Docs. They’re very basic right now, but thats all we
    need for this project.
  prefs: []
  type: TYPE_NORMAL
- en: We can first use the agent we built in part 1 to write an essay about Voyager
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the various outputs of the agent are stored in its memory, which
    can be explored with the following. In the code, you can see that we’re using
    “user_id = 1” as a placeholder here, but in an application that has multiple users
    this id would allow the model to access the correct memory store.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The final report text can be found here, with the key names corresponding to
    the AgentState that we discussed in part 1\. It’s at index -3 because it’s followed
    by a call to the editor node (which said yes) and the accept node, which right
    now just returns “True”. The accept node could be easily be extended to actually
    write this report to a doc automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see how we can put this text in a google doc. Recall that in section 2
    we made a blank document with `doc_id` . There are two basic methods of `GoogleDocsHelper`
    which can do this. The first is designed to provide a title and basic metadata,
    which is just the date and time at which the document was written. The second
    will paste some text into the document.
  prefs: []
  type: TYPE_NORMAL
- en: The code shows how to control aspects of the position and formatting of the
    text, which can be a bit confusing. We define a list of requests containing instructions
    like `insertText` . When we insert text, we need to provide the index at which
    to start the insertion, which corresponds to a position in the document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about how indices are defined [here](https://developers.google.com/docs/api/concepts/structure#indexes).
    When multiple `insertText` calls, it appears to be easier to write the last piece
    of text first — for example in the code below `template` (which is the metadata
    that’s supposed to appear below the title) appears first in the list at index
    1\. Then we write `title` at index 1\. This results in `title` appearing first
    in the document and `template` appearing below. Note how we also need to specify
    the `startIndex` and `endIndex` of the `paragraphStyle` blocks in order to change
    the formatting of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Both methods in the code above return the end index of the current block of
    text so that it can be used as the start index of subsequent blocks to be appended.
    If you intend to get more creative with the style and formatting of documents,
    this [guide](https://developers.google.com/docs/api/concepts/document) will likely
    help.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen the underlying code, we can call it to write our final report
    to a document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now we have all the tools of docs at our disposal to edit, format and
    share the report that our agent generated. Interestingly, the agent formatted
    the text as markdown which is supported by Google Docs, but I was unable to find
    a way to get the document to automatically recognize this and convert the markdown
    into nice headers and subheaders. No doubt there is a way to do that and it would
    make the reports look much nicer.
  prefs: []
  type: TYPE_NORMAL
- en: After running the code above, the doc should look something like this.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dd497a4dcc365990a44e1855caaf2128.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of the document containing the agent-generated final report. Image
    generated by the author
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. What about the other agent outputs?**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should be able to write all the information thats stored in the agent memory
    to docs, which will allow us to easily browse through the results of each stage.
    A somewhat hacky way to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is going to make 7 documents, and we’ll take a look at some example screenshots
    below
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e354c6d90ddac665527ba3f8e7124e08.png)'
  prefs: []
  type: TYPE_IMG
- en: Outputs from the running the code above. Image generated by the author
  prefs: []
  type: TYPE_NORMAL
- en: The initial plan outlines the structure of the report. It’s interesting that
    the model seems to favor lots of short sections, which I think is appropriate
    given the prompt request to make it concise and digestible to a general readership.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3a7eb62fe4a38648c0866643ef27dede.png)![](../Images/9b48c7b1ec4952ca764da720e9929c35.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshots of part of the initial plan and research documents written by the
    code snippet above. Images generated by the author.
  prefs: []
  type: TYPE_NORMAL
- en: At the research phase, Tavily search is called and returns small chunks of nicely
    formatted text relevant to the queries that were used. Some of these chunks are
    truncated and this document is not especially readable, but it gives a good sense
    of the type of information that is passing from the research node to the write
    node.
  prefs: []
  type: TYPE_NORMAL
- en: At the review phase, we get an eloquent criticism of the first version of the
    essay. Typically these reviews are structured similarly to the initial plan and
    make a lot of very general recommendations such as “consider using more descriptive
    titles” or “this section could be expanded to include more examples”. If we compare
    the actual reports before and after the reviews, we typically see only minor changes
    to the stucture and some additional details in each of the sections. The extent
    to which this actually improves the quality of the text is debatable, but from
    trying it out on a few examples I am convinced that it does help.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a1dd4e1dc0e37f1c84a80d1535b14765.png)![](../Images/0184229a9da34e4de535a5b1c7c25d0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshots of part of the review and editor response documents written by the
    code snippet above. Images generated by the author.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we get the editor’s judgement on the post-review draft. The prompt
    I am currently using makes the editor rather lenient, so it usually says something
    to the effect of whats shown here. With some prompt tweaks we could encourage
    it to send more reports back to review if desirable.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for this article and this mini series. Thanks for reading and I hope
    you find some of this useful for your own projects. There are lots of potential
    extensions here in terms of making the research agent more robust, a proper evaluation
    of its outputs and better integrations with Docs (or other GSuite APIs). Please
    let me know if you have any other cool ideas!
  prefs: []
  type: TYPE_NORMAL
- en: The author is unaffiliated with any of the tools discussed in this article.
  prefs: []
  type: TYPE_NORMAL

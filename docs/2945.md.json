["```py\nimport requests_cache\nfrom urllib.parse import urljoin\nfrom typing import Union, Optional\nfrom pathlib import Path\n\nclass SleeperClient:\n    def __init__(self, cache_path: str = '../.cache'):\n\n        # config\n        self.cache_path = cache_path\n        self.session = requests_cache.CachedSession(\n            Path(cache_path) / 'api_cache', \n            backend='sqlite',\n            expire_after=60 * 60 * 24,\n        )\n\n        ...\n\n    def _get_json(self, path: str, base_url: Optional[str] = None) -> dict:\n        url = urljoin(base_url or self.base_url, path)\n        return self.session.get(url).json()\n\n    def get_player_stats(self, player_id: Union[str, int], season: Optional[int] = None, group_by_week: bool = False):\n        return self._get_json(\n            f'stats/nfl/player/{player_id}?season_type=regular&season={season or self.nfl_state[\"season\"]}{\"&grouping=week\" if group_by_week else \"\"}',\n            base_url=self.stats_url,\n        )\n```", "```py\n# file: fantasy_chatbot/league.py\n\ndef get_player_id_fuzzy_search(self, player_name: str) -> tuple[str, str]:\n  # will need a simple search engine to go from player name to player id without needing exact matches. returns the player_id and matched player name as a tuple\n  nearest_name = process.extract(query=player_name, choices=self.player_names, scorer=fuzz.WRatio, limit=1)[0]\n  return self.player_name_to_id[nearest_name[0]], self.player_names[nearest_name[2]]\n\n# example usage in a tool\ndef get_player_news(self, player_name: Annotated[str, \"The player's name.\"]) -> str:\n    \"\"\"\n    Get recent news about a player for the most up-to-date analysis and injury status.\n    Use this whenever naming a player in a potential deal, as you should always have the right context for a recommendation.\n    If sources are provided, include markdown-based link(s)\n    (e.g. [Rotoballer](https://www.rotoballer.com/player-news/saquon-barkley-has-historic-night-sunday/1502955) )\n    at the bottom of your response to provide proper attribution\n    and allow the user to learn more.\n    \"\"\"\n    player_id, player_name = self.get_player_id_fuzzy_search(player_name)\n    # news\n    news = self.client.get_player_news(player_id, limit=3)\n    player_news = f\"Recent News about {player_name}\\n\\n\"\n    for n in news:\n        player_news += f\"**{n['metadata']['title']}**\\n{n['metadata']['description']}\"\n        if analysis := n['metadata'].get('analysis'):\n            player_news += f\"\\n\\nAnalysis:\\n{analysis}\"\n        if url := n['metadata'].get('url'):\n            # markdown link to source\n            player_news += f\"\\n[{n['source'].capitalize()}]({url})\\n\\n\"\n\n   return player_news\n```", "```py\ndef write_memory(state: MessagesState, config: RunnableConfig, store: BaseStore):\n    \"\"\"Reflect on the chat history and save a memory to the store.\"\"\"\n\n    # get the username from the config\n    username = config[\"configurable\"][\"username\"]\n\n    # retrieve existing memory if available\n    namespace = (\"memory\", username)\n    existing_memory = store.get(namespace, \"user_memory\")\n\n    # format the memories for the instruction\n    if existing_memory and existing_memory.value:\n        memory_dict = existing_memory.value\n        formatted_memory = (\n            f\"Team Name: {memory_dict.get('team_name', 'Unknown')}\\n\"\n            f\"Current Concerns: {memory_dict.get('current_concerns', 'Unknown')}\"\n            f\"Other Details: {memory_dict.get('other_details', 'Unknown')}\"\n        )\n    else:\n        formatted_memory = None\n\n    system_msg = CREATE_MEMORY_INSTRUCTION.format(memory=formatted_memory)\n\n    # invoke the model to produce structured output that matches the schema\n    new_memory = llm_with_structure.invoke([SystemMessage(content=system_msg)] + state['messages'])\n\n    # overwrite the existing user profile\n    key = \"user_memory\"\n    store.put(namespace, key, new_memory)\n```", "```py\n# from docker-compose.yml\n\nlanggraph-api:\n    image: \"fantasy-chatbot\"\n    ports:\n        - \"8123:8000\"\n    healthcheck:\n        test: curl --request GET --url http://localhost:8000/ok\n        timeout: 1s\n        retries: 5\n        interval: 5s\n    depends_on:\n        langgraph-redis:\n            condition: service_healthy\n        langgraph-postgres:\n            condition: service_healthy\n    env_file: \"../.env\"\n    environment:\n        REDIS_URI: redis://langgraph-redis:6379\n        POSTGRES_URI: postgres://postgres:postgres@langgraph-postgres:5432/postgres?sslmode=disable// file: fantasy-football-agent-stack.ts\n```", "```py\n// fantasy-football-agent-stack.ts\n\nconst apiImageAsset = new DockerImageAsset(this, 'apiImageAsset', {\n  directory: path.join(__dirname, '../../fantasy_chatbot'),\n  file: 'api.Dockerfile',\n  platform: assets.Platform.LINUX_AMD64,\n});\nconst apiContainer = taskDefinition.addContainer('langgraph-api', {\n  containerName: 'langgraph-api',\n  image: ecs.ContainerImage.fromDockerImageAsset(apiImageAsset),\n  portMappings: [{\n    containerPort: 8000,\n  }],\n  environment: {\n    ...dotenvMap,\n    REDIS_URI: 'redis://127.0.0.1:6379',\n    POSTGRES_URI: 'postgres://postgres:postgres@127.0.0.1:5432/postgres?sslmode=disable'\n  },\n  logging: ecs.LogDrivers.awsLogs({\n    streamPrefix: 'langgraph-api',\n  }),\n});\n\napiContainer.addContainerDependencies(\n  {\n    container: redisContainer,\n    condition: ecs.ContainerDependencyCondition.HEALTHY,\n  },\n  {\n    container: postgresContainer,\n    condition: ecs.ContainerDependencyCondition.HEALTHY,\n  },\n)\n```"]
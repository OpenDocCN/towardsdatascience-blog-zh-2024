<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Intuitive Temporal DataFrame Filtration</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Intuitive Temporal DataFrame Filtration</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/intuitive-temporal-dataframe-filtration-fa9d5da734b3?source=collection_archive---------8-----------------------#2024-05-27">https://towardsdatascience.com/intuitive-temporal-dataframe-filtration-fa9d5da734b3?source=collection_archive---------8-----------------------#2024-05-27</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="0078" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Get rid of your ineffective code for filtering time series data</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://namiyousef96.medium.com/?source=post_page---byline--fa9d5da734b3--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Yousef Nami" class="l ep by dd de cx" src="../Images/09a0baa3fe20c858ace5b7923b7c753a.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*IN_--RyIZ0tD773le7QDVg.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--fa9d5da734b3--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://namiyousef96.medium.com/?source=post_page---byline--fa9d5da734b3--------------------------------" rel="noopener follow">Yousef Nami</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--fa9d5da734b3--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">10 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">May 27, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj la lb ab q ee lc ld" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="le"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lf k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lg an ao ap id lh li lj" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lk cn"><div class="l ae"><div class="ab cb"><div class="ll lm ln lo lp lq ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj mk"><img src="../Images/1bdedd7a197a2764d9cb5c875fee21d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Scc7dCprJHDb9S1ejkrInA@2x.jpeg"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Photo by <a class="af nb" href="https://unsplash.com/@kmuza" rel="noopener ugc nofollow" target="_blank">Carlos Muza</a> on <a class="af nb" href="https://unsplash.com/photos/laptop-computer-on-glass-top-table-hpjSkU2UYSU" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="97dc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Every time I work with time series data, I end up writing complex and non-reusable code to filter it. Whether I’m doing simple filtering techniques like removing weekends, or more complex ones like removing specific time windows, I always resort to writing a quick and dirty function that works for the specific thing that I’m filtering in the moment, but never again.</p><p id="a976" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">I finally decided to break that horrible cycle by writing a processor that allows me to filter time series no matter how complex the condition using very simple and concise inputs.</p><p id="2810" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Just an example of how it works in practice:</p><ul class=""><li id="56d1" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">On weekdays, I want to remove &lt; 6 am and ≥ 8 pm, and on weekends I want to remove &lt; 8 am and ≥ 10 pm</li></ul><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="c510" class="of og fq oc b bg oh oi l oj ok"><br/>df = pl.DataFrame(<br/>   {"date": [<br/>      # -- may 24th is a Friday, weekday<br/>      '2024-05-24 00:00:00',  # &lt; 6 am, should remove<br/>      '2024-05-24 06:00:00',  # not &lt; 6 am, should keep<br/>      '2024-05-24 06:30:00',  # not &lt; 6 am, should keep<br/>      '2024-05-24 20:00:00',  # &gt;= 8 pm, should remove<br/><br/>      # -- may 25th is a Saturday, weekend<br/>      '2024-05-25 00:00:00',  # &lt; 8 am, should remove<br/>      '2024-05-25 06:00:00',  # &lt; 8 am, should remove<br/>      '2024-05-25 06:30:00',  # &lt; 8 am, should remove<br/>      '2024-05-25 20:00:00',  # not &gt;= 10 pm, should keep<br/><br/>      ]<br/>   }<br/>).with_columns(pl.col("date").str.strptime(pl.Datetime, "%Y-%m-%d %H:%M:%S"))</span></pre><ul class=""><li id="8777" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Without processor: expressive, but verbose and non-reusable</li></ul><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="541e" class="of og fq oc b bg oh oi l oj ok">df.filter(   <br/>    pl.Expr.not_(<br/>        (<br/>            (pl.col("date").dt.weekday() &lt; 6)<br/>            .and_(<br/>                (pl.col("date").dt.hour() &lt; 6)<br/>                .or_(pl.col("date").dt.hour() &gt;= 20)<br/>            )<br/>        )<br/>        .or_(<br/>            (pl.col("date").dt.weekday() &gt;= 6)<br/>            .and_(<br/>                (pl.col("date").dt.hour() &lt; 8)<br/>                .or_(pl.col("date").dt.hour() &gt;= 22)<br/>            )<br/>        )<br/>    )<br/>)</span></pre><ul class=""><li id="ca04" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">With processor: equally as expressive, concise and reusable</li></ul><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="c21c" class="of og fq oc b bg oh oi l oj ok">processor = FilterDataBasedOnTime(<br/>    "date", time_patterns=[<br/>        "&lt;6wd&lt;6h",<br/>        "&lt;6wd&gt;=20h",<br/>        "&gt;=6wd&lt;8h",<br/>        "&gt;=6wd&gt;=22h",<br/>    ]<br/>)<br/>processor.transform(df)</span></pre><p id="44d6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this article I’ll explain how I came up with this solution, starting with the string format I chose to define filter conditions, followed by a design of the processor itself. Towards the end of the article, I’ll describe how this pipeline can be used alongside other pipelines to enable complex time series processing with only a few lines of code.</p><p id="5456" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">If you’re interested in the code only, skip to the end of the article for a link to the repository.</p></div></div></div><div class="ab cb ol om on oo" role="separator"><span class="op by bm oq or os"/><span class="op by bm oq or os"/><span class="op by bm oq or"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="c0ac" class="ot og fq bf ou ov ow gq ox oy oz gt pa pb pc pd pe pf pg ph pi pj pk pl pm pn bk">Expressive, Concise and Flexible Time Conditions?</h1><p id="5f24" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">This was by far the hardest part of this task. Filtering time series based on time is conceptually easy, but it’s much harder to do with code. My initial thought was to use a string pattern that is most intuitive to myself:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="bcbe" class="of og fq oc b bg oh oi l oj ok"># -- remove values between 6 am (inclusive) and 2 pm (exclusive)<br/>pattern = '&gt;=06:00,&lt;14:00'</span></pre><p id="215c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">However with this, we immediately run into a problem: we lose flexibility. This is because <code class="cx pt pu pv oc b">06:00</code> is ambiguous, as it could mean <code class="cx pt pu pv oc b">min:sec</code> or <code class="cx pt pu pv oc b">hr:min</code> . So we’d almost always have to define the date format a-priori.</p><p id="77a0" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This prevents us from allowing complex filtering techniques, such as filtering a specific time ON specific days (e.g. only remove values in <code class="cx pt pu pv oc b">[6am, 2pm)</code> on a Saturday).</p><p id="22cc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Extending my pattern to something resembling <a class="af nb" href="https://crontab.guru/" rel="noopener ugc nofollow" target="_blank">cron</a> would not help either:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="2d08" class="of og fq oc b bg oh oi l oj ok"># cronlike pattern<br/>pattern = ‘&gt;=X-X-X 06:00:X, &lt;X-X-X 20:00:X’</span></pre><p id="ba00" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The above can help with selecting specific months or years, but doesn’t allow flexibility of things like weekdays. Further, it is not very expressive with all the X’s and it’s really verbose.</p><p id="7a9a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">I knew that I needed a pattern that allows chaining of individual time series components or units. Effectively something that is just like an if-statement:</p><ul class=""><li id="1db0" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">IF day == Saturday</li><li id="9f18" class="nc nd fq ne b go pw ng nh gr px nj nk nl py nn no np pz nr ns nt qa nv nw nx ny nz oa bk">AND time ≥ 06:00</li><li id="e8f5" class="nc nd fq ne b go pw ng nh gr px nj nk nl py nn no np pz nr ns nt qa nv nw nx ny nz oa bk">AND time &lt; 14:00</li></ul><p id="d5ef" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">So then I thought, why not use a pattern where you can add any conditions to a time-components, with the implicit assumption that they are all AND conditions?</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="44ff" class="of og fq oc b bg oh oi l oj ok"># -- remove values in [6am, 2pm) on Saturday<br/>pattern = 'day==6,time&gt;=06:00,time&lt;14:00'</span></pre><p id="46b5" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now we have a pattern that is expressive, however it can still be ambiguous, since <code class="cx pt pu pv oc b">time</code> implicitly assumes a date fomat. So I decided to go further:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="ecbd" class="of og fq oc b bg oh oi l oj ok"># -- remove values in [6am, 2pm) on Saturday<br/>pattern = 'day==6,hour&gt;=6,hour&lt;14'</span></pre><p id="7ef8" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now to make it less verbose, I borrowed the Polars duration string <a class="af nb" href="https://docs.pola.rs/py-polars/html/reference/dataframe/api/polars.DataFrame.group_by_dynamic.html" rel="noopener ugc nofollow" target="_blank">format</a> (this is the equivalent of “frequency” if you are more familiar with Pandas), and viola:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="22ba" class="of og fq oc b bg oh oi l oj ok"># -- remove values in [6am, 2pm) on Saturday<br/>pattern = '==6wd,&gt;=6h,&lt;14h'</span></pre><h2 id="4ded" class="qb og fq bf ou qc qd qe ox qf qg qh pa nl qi qj qk np ql qm qn nt qo qp qq qr bk">What About Time Conditions that Need the OR Operator?</h2><p id="73f2" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">Let’s consider a different condition: to filter anything LESS than 6 am (inclusive) and &gt; 2 pm (exclusive). A pattern like below would fail:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="b103" class="of og fq oc b bg oh oi l oj ok"># -- remove values in (-inf, 6am], and (2pm, inf)<br/>pattern = '&lt;=6h,&gt;14h'</span></pre><p id="f936" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Since we’d read it as: ≤ 6 am AND &gt; 2 pm</p><p id="f74c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">No such value exists that satisfies these two conditions!</p><p id="89b6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">But the solution to this is simple: apply AND conditions within a pattern, and apply OR conditions across different patterns. So:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="7771" class="of og fq oc b bg oh oi l oj ok"># -- remove values in (-inf, 6am], and (2pm, inf)<br/>patterns = ['&lt;=6h', '&gt;14h']</span></pre><p id="327c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Would be read as: ≤ 6 am OR &gt; 2pm</p><h2 id="5822" class="qb og fq bf ou qc qd qe ox qf qg qh pa nl qi qj qk np ql qm qn nt qo qp qq qr bk">Why not allow OR statements within a pattern?</h2><p id="de54" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">I did consider adding support for an OR statement within the pattern, e.g. using <code class="cx pt pu pv oc b">|</code> or alternatively to let <code class="cx pt pu pv oc b">,</code> denote the difference between a “left” and “right” condition. However, I found that these would be adding unnecessary complexity to parsing the pattern, without making the code any more expressive.</p><p id="2692" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">I much prefer it simple: within a pattern we apply AND, across patterns we apply OR.</p><h2 id="8258" class="qb og fq bf ou qc qd qe ox qf qg qh pa nl qi qj qk np ql qm qn nt qo qp qq qr bk">Edge Cases</h2><p id="0fa3" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">There is one edge-cases worth discussing here. The “if-statement” like pattern doesn’t always work.</p><p id="44ee" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let’s consider filtering timestamps &gt; 06:00. If we simply defined:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="2a3c" class="of og fq oc b bg oh oi l oj ok"># -- pattern to remove values &gt; 06:00<br/>pattern = '&gt;6h'</span></pre><p id="d3e3" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Then do we interpret this as:</p><ul class=""><li id="f5ae" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">Remove all values where <code class="cx pt pu pv oc b">hour&gt;6</code></li><li id="0381" class="nc nd fq ne b go pw ng nh gr px nj nk nl py nn no np pz nr ns nt qa nv nw nx ny nz oa bk">Or remove all values where <code class="cx pt pu pv oc b">time&gt;06:00</code> ?</li></ul><p id="9a58" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The latter makes more sense, but the current pattern doesn’t allow us to express that. So to explicitly state that we which to include timestamps greater than the 6th hour of the day, we must add what I call the cascade operator:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="016d" class="of og fq oc b bg oh oi l oj ok"># -- pattern to remove values &gt; 06:00<br/>pattern = '&gt;6h*'</span></pre><p id="1497" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Which would be read as:</p><ul class=""><li id="0b1e" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">hour &gt; 6</li><li id="7933" class="nc nd fq ne b go pw ng nh gr px nj nk nl py nn no np pz nr ns nt qa nv nw nx ny nz oa bk">OR (hour == 6 AND any(minute, second, millisecond, etc… &gt; 0)</li></ul><p id="d99a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Which would be an accurate condition to capture time&gt;06:00!</p></div></div></div><div class="ab cb ol om on oo" role="separator"><span class="op by bm oq or os"/><span class="op by bm oq or os"/><span class="op by bm oq or"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="92fb" class="ot og fq bf ou ov ow gq ox oy oz gt pa pb pc pd pe pf pg ph pi pj pk pl pm pn bk">The Code</h1><p id="30db" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">Here I highlight important design bits to create a processor for filtering time series data.</p><h2 id="306e" class="qb og fq bf ou qc qd qe ox qf qg qh pa nl qi qj qk np ql qm qn nt qo qp qq qr bk">Parsing Logic</h2><p id="35e7" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">Since the pattern is quite simple, parsing it is really easy. All we need to do is loop over each pattern and keep track of the operator characters. What remains is then a list of operators, and a list of durations that they are applied to.</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="2e5d" class="of og fq oc b bg oh oi l oj ok"># -- code for parsing a time pattern, e.g. "==7d&lt;7h"<br/>pattern = pattern.replace(" ", "")<br/>operator = ""<br/>operators = []<br/>duration_string = ""<br/>duration_strings = []<br/>for char in pattern:<br/>    if char in {"&gt;", "&lt;", "=", "!"}:<br/>        operator += char<br/>        if duration_string:<br/>            duration_strings.append(duration_string)<br/>            duration_string = ""<br/>    else:<br/>        duration_string += char<br/>        if operator:<br/>            operators.append(operator)<br/>            operator = ""<br/>duration_strings.append(duration_string)</span></pre><p id="d851" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now for each operator and duration string, we can extract metadata that helps us make the actual boolean rules later on.</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="daeb" class="of og fq oc b bg oh oi l oj ok"># -- code for extracting metadata from a parsed pattern<br/><br/># -- mapping to convert each operator to the Polars method<br/>OPERATOR_TO_POLARS_METHOD_MAPPING = {<br/>    "==": "eq",<br/>    "!=": "ne",<br/>    "&lt;=": "le",<br/>    "&lt;": "lt",<br/>    "&gt;": "gt",<br/>    "&gt;=": "ge",<br/>}<br/><br/>operator_method = (<br/>    OPERATOR_TO_POLARS_METHOD_MAPPING[operator]<br/>)<br/><br/># -- identify cascade operations<br/>if duration_string.endswith("*"):<br/>    duration_string = duration_string[:-1]<br/>    how = "cascade"<br/>else:<br/>    how = "simple"<br/><br/># -- extract a polars duration, e.g. 7d7h into it's components: [(7, "d"), (7, "h")]<br/>polars_duration = PolarsDuration(duration=duration_string)<br/>decomposed_duration = polars_duration.decomposed_duration<br/><br/># -- ensure that cascade operator only applied to durations that accept it<br/>if how == "cascade" and any(<br/>    unit not in POLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING<br/>    for _, unit in decomposed_duration<br/>):<br/>    raise ValueError(<br/>        (<br/>            "You requested a cascade condition on an invalid "<br/>            "duration. Durations supporting cascade: "<br/>            f"{list(POLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING.keys())}"<br/>        )<br/>    )<br/><br/>rule_metadata = {<br/>    "operator": operator_method,<br/>    "decomposed_duration": decomposed_duration,<br/>    "how": how,<br/>}</span></pre><p id="ea35" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We now have, for each pattern, dictionaries for how to define the rules for each of it’s components. So if we went for a complicated example:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="a30f" class="of og fq oc b bg oh oi l oj ok">pattern = '==1m&gt;6d6h' # remove if month = Jan, and day &gt; 6 and hour &gt; 6<br/><br/># parsed pattern<br/><br/>[<br/>   [<br/>      {<br/>         "operator": "eq",<br/>         "decomposed_duration": [(1, "m")],<br/>         "how": "simple"<br/>      },<br/>      { <br/>         "operator": "gt",<br/>         "decomposed_duration": [(6, "d"), (6, "h")],<br/>         "how": "simple"<br/>      }<br/>   ]<br/>]</span></pre><p id="9222" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Notice that a single pattern can be split into multiple metadata dicts because it can be composed of multiple durations and operations.</p><h2 id="6244" class="qb og fq bf ou qc qd qe ox qf qg qh pa nl qi qj qk np ql qm qn nt qo qp qq qr bk">Creating Rules from metadata</h2><p id="1ec9" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">Having created metadata for each pattern, now comes the fun part of creating Polars rules!</p><p id="2153" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Remember that within each pattern, we apply an AND condition, but across patterns we apply an OR condition. So in the simplest case, we need a wrapper that can take a list of all the metadata for a specific pattern, then apply the and condition to it. We can store this expression in a list alongside the expressions for all the other patterns, before applying the OR condition.</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="f233" class="of og fq oc b bg oh oi l oj ok"># -- dictionary to contain each unit along with the polars method to extract it's value<br/>UNIT_TO_POLARS_METHOD_MAPPING = {<br/>        "d": "day",<br/>        "h": "hour",<br/>        "m": "minute",<br/>        "s": "second",<br/>        "ms": "millisecond",<br/>        "us": "microsecond",<br/>        "ns": "nanosecond",<br/>        "wd": "weekday",<br/>}<br/><br/>patterns = ["==6d&lt;6h6s"]<br/>patterns_metadata = get_rule_metadata_from_patterns(patterns)<br/><br/># -- create an expression for the rule pattern<br/>pattern_metadata = patterns_metadata[0]  # list of length two<br/><br/># -- let's consider the condition for ==6d<br/>condition = pattern_metadata[0]<br/><br/>decomposed_duration = condition["decomposed_duration"]  # [(6, 'd')]<br/>operator = condition["operator"]  # eq<br/>conditions = [<br/>    getattr(  # apply the operator method, e.g. pl.col("date").dt.hour().eq(value)<br/>        getattr(  # get the value of the unit, e.g. pl.col("date").dt.hour()<br/>            pl.col(time_column).dt,  <br/>            UNIT_TO_POLARS_METHOD_MAPPING[unit], <br/>        )(),<br/>        operator,<br/>    )(value) for value, unit in decomposed_duration  # for each unit separately<br/>]<br/><br/># -- finally, we aggregate the separate conditions using an AND condition<br/>final_expression = conditions.pop()<br/>for expression in conditions:<br/>    final_expression = getattr(final_expression, 'and_')(expression)</span></pre><p id="41bc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This looks complex… but we can convert bits of it into functions and the final code looks quite clean and readable:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="87dd" class="of og fq oc b bg oh oi l oj ok">rules = []  # list to store expressions for each time pattern<br/>for rule_metadata in patterns_metadata:<br/>    rule_expressions = []<br/>    for condition in rule_metadata:<br/>        how = condition["how"]<br/>        decomposed_duration = condition["decomposed_duration"]<br/>        operator = condition["operator"]<br/>        if how == "simple":<br/>            expression = generate_polars_condition(  # function to do the final combination of expressions<br/>                [<br/>                    self._generate_simple_condition(<br/>                        unit, value, operator<br/>                    )  # this is the complex "getattr" code<br/>                    for value, unit in decomposed_duration<br/>                ],<br/>                "and_",<br/>            )<br/>        rule_expressions.append(expression)<br/><br/>    rule_expression = generate_polars_condition(<br/>        rule_expressions, "and_"<br/>    )<br/>    rules.append(rule_expression)<br/><br/>overall_rule_expression = generate_polars_condition(<br/>    rules, "or_"<br/>).not_()  # we must negate because we're filtering!</span></pre><h2 id="3072" class="qb og fq bf ou qc qd qe ox qf qg qh pa nl qi qj qk np ql qm qn nt qo qp qq qr bk">Creating Rules for the cascade operator</h2><p id="8cda" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">In the above code, I had an if condition only for the “simple” conditions… how do we do the cascade conditions?</p><p id="7413" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Remember from our discussion above that a pattern of “&gt;6h*” means:</p><blockquote class="qs"><p id="7c4d" class="qt qu fq bf qv qw qx qy qz ra rb nx dx">hour &gt; 6 OR (hour == 6 AND any(min, s, ms, etc… &gt; 0)</p></blockquote><p id="2707" class="pw-post-body-paragraph nc nd fq ne b go rc ng nh gr rd nj nk nl re nn no np rf nr ns nt rg nv nw nx fj bk">So what we need, is to know for each unit, what the subsequent smaller units are.</p><p id="94b7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">E.g. if I had “&gt;6d*”, I should know to include “hour” in my <strong class="ne fr">any</strong> condition, thus:</p><blockquote class="qs"><p id="0286" class="qt qu fq bf qv qw qx qy qz ra rb nx dx">day &gt; 6 OR (day == 6 AND any(hr, min, s, ms, etc… &gt; 0)</p></blockquote><p id="a3b1" class="pw-post-body-paragraph nc nd fq ne b go rc ng nh gr rd nj nk nl re nn no np rf nr ns nt rg nv nw nx fj bk">This is easily achieved using a dictionary that maps each unit to its “next” smaller unit. E.g.: day → hour, hour → second, etc…</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="73b6" class="of og fq oc b bg oh oi l oj ok">POLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING = {<br/>    "y": {"next": "mo", "start": 1},<br/>    "mo": {"next": "d", "start": 1},<br/>    "d": {"next": "h", "start": 0},<br/>    "wd": {"next": "h", "start": 0},<br/>    "h": {"next": "m", "start": 0},<br/>    "m": {"next": "s", "start": 0},<br/>    "s": {"next": "ms", "start": 0},<br/>    "ms": {"next": "us", "start": 0},<br/>    "us": {"next": "ns", "start": 0},<br/>}</span></pre><p id="5f70" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The start value is necessary because the any condition isn’t always &gt; 0. Because if I want to filter any values &gt; February, then 2023–02–02 should be a part of it, but not 2023–02–01.</p><p id="2bcb" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With this dictionary in mind, we can then easily create the any condition:</p><pre class="ml mm mn mo mp ob oc od bp oe bb bk"><span id="6b97" class="of og fq oc b bg oh oi l oj ok"># -- pattern example: &gt;6h* cascade<br/>simple_condition = self._generate_simple_condition(<br/>    unit, value, operator<br/>)  # generate the simple condition, e.g. hour&gt;6<br/>all_conditions = [simple_condition]<br/>if operator == "gt":  # cascade only affects &gt; operator<br/>    equality_condition = self._generate_simple_condition(<br/>        unit, value, "eq"<br/>    )  # generate hour==6<br/>    child_unit_conditions = []<br/>    child_unit_metadata = (<br/>        POLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING.get(unit, None)<br/>    )  # get the next smallest unit, e.g. minute<br/>    while child_unit_metadata is not None:<br/>        start_value = child_unit_metadata["start"]<br/>        child_unit = child_unit_metadata["next"]<br/>        child_unit_condition = self._generate_simple_condition(<br/>            child_unit, start_value, "gt"<br/>        )  # generate minute &gt; 0<br/>        child_unit_conditions.append(child_unit_condition)<br/>        child_unit_metadata = (<br/>            POLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING.get(<br/>                child_unit, None<br/>            )<br/>        )  # now go on to seconds, and so on...<br/><br/>    cascase_condition = generate_polars_condition(<br/>        [<br/>            equality_condition,  # and condition for the hour unit<br/>            generate_polars_condition(child_unit_conditions, "or_"),  # any condition for all the child units<br/>        ],<br/>        "and_",<br/>    )<br/><br/>    all_conditions.append(cascase_condition)<br/><br/># -- final condition is hour&gt;6 AND the cascade condition<br/>overall_condition = generate_polars_condition(all_conditions, "or_")</span></pre></div></div></div><div class="ab cb ol om on oo" role="separator"><span class="op by bm oq or os"/><span class="op by bm oq or os"/><span class="op by bm oq or"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="0653" class="ot og fq bf ou ov ow gq ox oy oz gt pa pb pc pd pe pf pg ph pi pj pk pl pm pn bk">The Bigger Picture</h1><p id="6d07" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">A processor like this isn’t just useful for ad-hoc analysis. It can be a core component your data processing pipelines. One really useful use case for me is to use it along with resampling. An easy filtering step would enable me to easy calculate metrics on time series with regular disruptions, or regular downtimes.</p><p id="86fc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Further, with a few simple modifications I can extend this processor to allow easy labelling of my time series. This allows me to add regressors to bits that I know behave differently, e.g. if I’m modelling a time series that jumps at specific hours, I can add a step regressor to only those parts.</p></div></div></div><div class="ab cb ol om on oo" role="separator"><span class="op by bm oq or os"/><span class="op by bm oq or os"/><span class="op by bm oq or"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="4ff8" class="ot og fq bf ou ov ow gq ox oy oz gt pa pb pc pd pe pf pg ph pi pj pk pl pm pn bk">Concluding Remarks</h1><p id="5290" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">In this article I outlined a processor that enables easy, flexible and concise time series filtration on Polars datasets. The logic discussed can be extended to your favourite data frame processing library, such as Pandas with some minor changes.</p><p id="fc57" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Not only is the processor useful for ad-hoc time series analysis, but it can be the backbone of data processing if chained with other operations such as resampling, or if used to create extra features for modelling.</p><p id="943f" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">I’ll conclude with some extensions that I have in mind to make the code even better:</p><ul class=""><li id="4d24" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny nz oa bk">I’m thinking of creating a short cut to define “weekend”, e.g. “==we”. This way I don’t wouldn’t need to explicitly define “&gt;=6wd” which can be less clear</li><li id="77fd" class="nc nd fq ne b go pw ng nh gr px nj nk nl py nn no np pz nr ns nt qa nv nw nx ny nz oa bk">With proper design, I think it is possible to enable the addition of custom time identifiers. For example “==eve” to denote evening, the time for which can be user defined.</li><li id="d90a" class="nc nd fq ne b go pw ng nh gr px nj nk nl py nn no np pz nr ns nt qa nv nw nx ny nz oa bk">I’m definitely going to add support for simply labelling the data, as opposed to filtering it</li><li id="659c" class="nc nd fq ne b go pw ng nh gr px nj nk nl py nn no np pz nr ns nt qa nv nw nx ny nz oa bk">And I’m going to add support for being able to define the boundaries as “keep”, e.g. instead of defining [“&lt;6h”, “&gt;=20hr”] I can do [“&gt;=6h&lt;20hr”]</li></ul><h2 id="6934" class="qb og fq bf ou qc qd qe ox qf qg qh pa nl qi qj qk np ql qm qn nt qo qp qq qr bk">Where to find the code</h2><p id="b4b7" class="pw-post-body-paragraph nc nd fq ne b go po ng nh gr pp nj nk nl pq nn no np pr nr ns nt ps nv nw nx fj bk">This project is in its infancy, so items may move around. As of 23.05.2024, you can find the <code class="cx pt pu pv oc b">FilterDataBasedOnTime</code> under <code class="cx pt pu pv oc b">mix_n_match/main.py</code> .</p><div class="rh ri rj rk rl rm"><a href="https://github.com/namiyousef/mix-n-match?source=post_page-----fa9d5da734b3--------------------------------" rel="noopener  ugc nofollow" target="_blank"><div class="rn ab ig"><div class="ro ab co cb rp rq"><h2 class="bf fr hw z io rr iq ir rs it iv fp bk">GitHub - namiyousef/mix-n-match: repository for processing dataframes</h2><div class="rt l"><h3 class="bf b hw z io rr iq ir rs it iv dx">repository for processing dataframes. Contribute to namiyousef/mix-n-match development by creating an account on…</h3></div><div class="ru l"><p class="bf b dy z io rr iq ir rs it iv dx">github.com</p></div></div><div class="rv l"><div class="rw l rx ry rz rv sa lq rm"/></div></div></a></div></div></div></div><div class="ab cb ol om on oo" role="separator"><span class="op by bm oq or os"/><span class="op by bm oq or os"/><span class="op by bm oq or"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="1f88" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><em class="sb">All code, data and images by author unless specified otherwise</em></p></div></div></div></div>    
</body>
</html>
["```py\nnp.random.seed(42)\nX = np.random.normal(1, 4.5, 10000)\ny = np.piecewise(X, [X < -2,(X >= -2) & (X < 2), X >= 2], [lambda X: 2*X + 5, lambda X: 7.3*np.sin(X), lambda X: -0.03*X**3 + 2]) + np.random.normal(0, 1, X.shape)\n```", "```py\nclass ANN(nn.Module):\n    def __init__(self, input_size, N, output_size):\n        super().__init__()\n        self.net = nn.Sequential()\n        self.net.add_module(name='Layer_1', module=nn.Linear(input_size, N, bias=False))\n        self.net.add_module(name='Tanh',module=nn.Tanh())\n        self.net.add_module(name='Layer_2',module=nn.Linear(N, output_size, bias=False))\n\n    def forward(self, x):\n        return self.net(x)\n```", "```py\nW1, W2 = np.arange(-2, 2, 0.05), np.arange(-2, 2, 0.05)\nLOSS = np.zeros((len(W1), len(W2)))\nfor i, w1 in enumerate(W1):\n    model.net._modules['Layer_1'].weight.data = torch.tensor([[w1]], dtype=torch.float32)\n\n    for j, w2 in enumerate(W2):\n        model.net._modules['Layer_2'].weight.data = torch.tensor([[w2]], dtype=torch.float32)\n\n        model.eval()\n        total_loss = 0\n        with torch.no_grad():\n            for x, y in test_loader:\n                preds = model(x.reshape(-1, 1))\n                total_loss += loss(preds, y).item()\n\n        LOSS[i, j] = total_loss / len(test_loader)\n```", "```py\nmodel = ANN(1,1,1)\nepochs = 25\nlr = 1e-2\n\noptimizer = optim.SGD(model.parameters(),lr =lr)\n\nmodel.net._modules['Layer_1'].weight.data = torch.tensor([[-1]], dtype=torch.float32)\nmodel.net._modules['Layer_2'].weight.data = torch.tensor([[-1]], dtype=torch.float32)\n\nerrors, weights_1, weights_2 = [], [], []\n\nmodel.eval()\nwith torch.no_grad():\n    total_loss = 0\n    for x, y in test_loader:\n        preds = model(x.reshape(-1,1))\n        error = loss(preds, y)\n        total_loss += error.item()\nweights_1.append(model.net._modules['Layer_1'].weight.data.item())\nweights_2.append(model.net._modules['Layer_2'].weight.data.item())\nerrors.append(total_loss / len(test_loader))\n\nfor epoch in tqdm(range(epochs)):\n    model.train()\n\n    for x, y in train_loader:\n        pred = model(x.reshape(-1,1))\n        error = loss(pred, y)\n        optimizer.zero_grad()\n        error.backward()\n        optimizer.step()\n\n    model.eval()\n    test_preds, true = [], []\n    with torch.no_grad():\n        total_loss = 0\n        for x, y in test_loader:\n            preds = model(x.reshape(-1,1))\n            error = loss(preds, y)\n            test_preds.append(preds)\n            true.append(y)\n\n            total_loss += error.item()\n    weights_1.append(model.net._modules['Layer_1'].weight.data.item())\n    weights_2.append(model.net._modules['Layer_2'].weight.data.item())\n    errors.append(total_loss / len(test_loader))\n```", "```py\nimport plotly.graph_objects as go\nimport plotly.io as pio\n\nplotly_template = pio.templates[\"plotly_dark\"]\nfig = go.Figure(data=[go.Surface(z=LOSS, x=W1, y=W2)])\n\nfig.update_layout(\n    title='Loss Surface',\n    scene=dict(\n        xaxis_title='w1',\n        yaxis_title='w2',\n        zaxis_title='Loss',\n        aspectmode='manual',\n        aspectratio=dict(x=1, y=1, z=0.5),\n        xaxis=dict(showgrid=False), \n        yaxis=dict(showgrid=False), \n        zaxis=dict(showgrid=False), \n    ),\n    width=800,\n    height=800\n)\n\nfig.add_trace(go.Scatter3d(x=weights_2, y=weights_1, z=errors,\n                               mode='lines+markers',\n                              line=dict(color='red', width=2),\n                              marker=dict(size=4, color='yellow') ))\nfig.show()\n```"]
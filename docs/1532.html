<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>A Step-By-Step Guide to Building a Programming Language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>A Step-By-Step Guide to Building a Programming Language</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-step-by-step-guide-to-building-a-programming-language-5f5b84246991?source=collection_archive---------0-----------------------#2024-06-19">https://towardsdatascience.com/a-step-by-step-guide-to-building-a-programming-language-5f5b84246991?source=collection_archive---------0-----------------------#2024-06-19</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="78cd" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Building a programming language from scratch in a few hours</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@physboom?source=post_page---byline--5f5b84246991--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Matthew Chak" class="l ep by dd de cx" src="../Images/88881eb5a7c8f08c15555bc8c3c613d3.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*mIH-jXvH_AeExbLqQxTJxw.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--5f5b84246991--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@physboom?source=post_page---byline--5f5b84246991--------------------------------" rel="noopener follow">Matthew Chak</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--5f5b84246991--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">17 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Jun 19, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj la lb ab q ee lc ld" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="le"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lf k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lg an ao ap id lh li lj" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lk cn"><div class="l ae"><div class="ab cb"><div class="ll lm ln lo lp lq ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj mk"><img src="../Images/c544cad7b26dd0bb3008c29eb2dba5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Wbe0ZXbiAqrRSNGimHEPw.jpeg"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Trees: The Hierarchical Heart of Computer Science. Source: <a class="af nb" href="https://unsplash.com/@jeremybishop" rel="noopener ugc nofollow" target="_blank">Jeremy Bishop on Unsplash</a></figcaption></figure><p id="2ad7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The world is full of programming languages with all kinds of different use cases. Most of these languages, though, are built for very general purposes — sometimes, we may want to design a language to fit a very specific use case (e.g. Facebook designed React to make it easier to develop their web applications, and Apple recently developed <a class="af nb" href="https://github.com/apple/pkl" rel="noopener ugc nofollow" target="_blank">Pkl</a>, a language designed to make configurations easier. There are many more examples of this in various fields). As such, knowing how to build a programming language is a useful skill to have in your belt.</p><p id="9f6f" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this article, we will build an interpreted programming language from scratch and learn a little bit about both the lambda calculus and programming languages as a whole along the way. The language we build here will be fairly esoteric, but the process should hopefully give you an idea of how to design your own use-case-specific languages (and teach you useful information about how programming languages function under the hood).</p><h1 id="2344" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">The Game Plan</h1><p id="1de9" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Since we’re building an interpreted language¹, our overarching flow will look something like this:</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj oz"><img src="../Images/9f171ab3d352f80924bec9732bde250b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i4odTJsCKvS_xRmvo-43ZA.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The broad flow chart for our language</figcaption></figure><p id="b182" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Basically, we start with some <strong class="ne fr">concrete syntax</strong> (code) written in our <strong class="ne fr">target language </strong>(the language that we are trying to write), pass it to some <strong class="ne fr">parser</strong> that converts it to an <strong class="ne fr">abstract syntax tree</strong> (a tree representation of the code that’s easy to work with), and then pass that to an <strong class="ne fr">interpreter</strong> that “runs” the abstract syntax tree to give us a final result. Note that the parser and interpreter are written in some already existing <strong class="ne fr">host language</strong> — C’s original parser and compiler, for instance, were written in assembly.</p><p id="ce97" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><em class="pa">** Note: My use of “parser” here encapsulates the entire parsing process. Usually, lexing is done prior to “parsing”, but in this case parsing is just the process of taking concrete syntax to abstract syntax, whatever that may look like.</em></p><p id="5f67" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As an example, consider the following specification for a simple language for basic arithmetic:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="50eb" class="pf nz fq pc b bg pg ph l pi pj">EXPR = number<br/>       | EXPR + EXPR<br/>       | EXPR - EXPR<br/>       | EXPR * EXPR<br/>       | EXPR / EXPR<br/>       | (EXPR)</span></pre><p id="1daa" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The above, by the way, is an <strong class="ne fr">EBNF </strong>for a <strong class="ne fr">context-free grammar²</strong>. I won’t delve too deeply into what this means here, but all programming languages written in a form like this are parse-able in polynomial time via the CYK algorithm. For this EBNF, something like <code class="cx pk pl pm pc b">(4 + 4) * 3</code> is a valid program, but something like <code class="cx pk pl pm pc b">def f(x): return 5; f(5)</code> is not.</p><p id="d2b9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Suppose we are now given the concrete syntax <code class="cx pk pl pm pc b">(4 + 4) * 3</code> . After parsing, we should get an abstract syntax tree (AST) like this:</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj pn"><img src="../Images/6bd4ba20c268ed4ff1093f4a20ce1820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAC-3aq242nLyzijC0OmhA.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">AST for our concrete syntax</figcaption></figure><p id="6528" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Then our interpreter will start at the root and recursively go down the tree until we get our answer, namely 24.</p><p id="aa11" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Note quickly that this grammar is <strong class="ne fr">ambiguous</strong> — for instance, how should the expression <code class="cx pk pl pm pc b">4 + 4 * 3</code> parse? It could either parse as the above (that is, <code class="cx pk pl pm pc b">(4 + 4) * 3</code>), or it could also parse as <code class="cx pk pl pm pc b">4 + (4 * 3)</code> — neither parsing is inherently more “correct” in the way that we have specified the language, as both are valid parse trees. In cases like this, the parser will have to arbitrarily make a decision about how to parse our language.</p><h1 id="b202" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Designing our Syntax</h1><p id="4422" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">By the flow chart, our first step should logically be to design our concrete syntax. What you choose to make your syntax is completely up to you. I decided to create <em class="pa">EmojiLang</em>, a (horrible) language that ensures an extremely colorful screen while you are typing. The grammar is below:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="b64c" class="pf nz fq pc b bg pg ph l pi pj">grammar EmojiLang;<br/><br/>program: '🏃‍♂️🏃‍♂️🏃‍♂️' expr '🛑🛑🛑' EOF;<br/><br/>expr: '(' (ID<br/>         | atom<br/>         | ifCond<br/>         | anonFunctionDefn<br/>         | funApplication<br/>         | varAssignment<br/>         | READ_FLOAT<br/>         | READ_STRING<br/>         | printExpr<br/>         | sequentialOp<br/>         | baseComputation) ')';<br/><br/>atom: NUMBER | BOOLEAN | STRING;<br/>ifCond: '🤔' cond=expr '❓' ontrue=expr ':' onfalse=expr;<br/>anonFunctionDefn: '🧑‍🏭' arg=ID '⚒️' body=expr;<br/>funApplication: '🏭' fun=expr arg=expr;<br/>varAssignment: '📦' var=ID '🔜' val=expr;<br/>printExpr: '🖨️' expr;<br/>sequentialOp: '📋' first=expr second=expr;<br/>baseComputation: left=expr op=('➕' | '➖' | '✖️' | '➗' | '🟰' | '≤') right=expr;<br/><br/><br/>ID: [a-zA-Z_][a-zA-Z0-9_]*;<br/>NUMBER: [0-9]+ ('.' [0-9]+)?;<br/>BOOLEAN: '👍' | '👎';<br/>STRING: '"' ~[\r\n"]* '"';<br/>READ_FLOAT: '🔢';<br/>READ_STRING: '🔤';<br/><br/><br/>WHITESPACE: [ \t\r\n]+ -&gt; skip;<br/>COMMENT: '😴' .*? '⏰' -&gt; skip;<br/>LINE_COMMENT: '🥱' ~[\r\n]* -&gt; skip;</span></pre><p id="e3dd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><em class="pa">** Note: the above specification is written to be used in a tool called ANTLR, we’ll get back to this very soon.</em></p><p id="3d08" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This language is, of course, ridiculous, but it is interesting for a couple of reasons. Firstly, all of our expressions are required to be parenthesized. This makes it extremely annoying to code, but also makes our grammar non-ambiguous. Secondly, notice how we can only define anonymous functions — there is no equivalent syntax for something like <code class="cx pk pl pm pc b">def</code> in Python. Finally, all functions in this language (except for the base computations) have <em class="pa">exactly one argument</em>. We’ll explore the implications of the last two design decisions when we play around with our language in a bit.</p><h1 id="2c8a" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Parsing</h1><p id="a7cd" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">We can, of course, write our own parser. Luckily though, there are tools that can parse arbitrary context-free grammars. For this tutorial, we will use <strong class="ne fr">ANTLR (</strong>you can download it <a class="af nb" href="https://www.antlr.org/" rel="noopener ugc nofollow" target="_blank">here</a>). ANTLR is a very nice and easy-to-use tool that takes grammar specifications like the above and creates parsers in a variety of target languages (in this tutorial, we will be using Python).</p><p id="d344" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Using it is fairly simple, just follow the following steps:</p><ol class=""><li id="79fb" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx po pp pq bk">Download the ANTLR Java binaries from <a class="af nb" href="https://www.antlr.org/download.html" rel="noopener ugc nofollow" target="_blank">here</a></li><li id="282a" class="nc nd fq ne b go pr ng nh gr ps nj nk nl pt nn no np pu nr ns nt pv nv nw nx po pp pq bk">Create a .g4 file (like the above) for your grammar. Note that ANTLR can’t actually handle emojis very well, so if you plan to use emojis in your language, run the following python script to demojify your grammar:</li></ol><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="0fde" class="pf nz fq pc b bg pg ph l pi pj">import emoji<br/>import sys<br/><br/>def demojify_file(input_file, output_file):<br/>    with open(input_file, "r", encoding="utf-8") as f:<br/>        input_text = f.read()<br/><br/>    input_text = emoji.demojize(input_text)<br/>    <br/>    with open(output_file, "w", encoding="utf-8") as f:<br/>        f.write(input_text)<br/>        <br/>if __name__ == "__main__":<br/>    input_file = sys.argv[1]<br/>    output_file = sys.argv[2]<br/>    demojify_file(input_file, output_file)</span></pre><p id="6175" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">3. Run <code class="cx pk pl pm pc b">java -Xmx500M -cp &lt;path_to_antlr.jar&gt; org.antlr.v4.Tool -Dlanguage=Python3 &lt;your_grammar.g4&gt;</code> to generate your parser</p><p id="9a9a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">You can then import the generated parsing files and use them as follows:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="c445" class="pf nz fq pc b bg pg ph l pi pj">from antlr4 import *<br/>from EmojiLangLexer import EmojiLangLexer<br/>from EmojiLangParser import EmojiLangParser<br/>from EmojiLangListener import EmojiLangListener<br/>import emoji<br/><br/>if __name__ == "__main__":<br/>    input_file = sys.argv[1]<br/>    with open(input_file, "r", encoding="utf-8") as f:<br/>        input_text = f.read()<br/><br/>    input_text = emoji.demojize(input_text)<br/>    input_stream = InputStream(input_text)<br/>    lexer = EmojiLangLexer(input_stream)<br/>    token_stream = CommonTokenStream(lexer)<br/>    parser = EmojiLangParser(token_stream)<br/>    tree = parser.program()<br/>    <br/>    if parser.getNumberOfSyntaxErrors() &gt; 0:<br/>        exit(1)</span></pre><p id="7ab5" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">You probably won’t have to do the demojizing step in which case you can use antlr4’s <code class="cx pk pl pm pc b">FileStream</code> instead of the <code class="cx pk pl pm pc b">InputStream</code> , but it really doesn’t matter. Now, we have a very nice abstract syntax tree that’s easy to work with, and we can move on to the hard part — interpreting³</p><h1 id="a4bf" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Building an Interpreter</h1><p id="0e70" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Because we are working with trees, our interpreter will naturally be a recursive entity. We do have some choices though on how exactly we implement some of its features. For this tutorial, we will build an interpreter that uses <strong class="ne fr">environments</strong> that bind variables to addresses and then a mutable <strong class="ne fr">store</strong> that maps addresses to values. This idea is fairly common, though not ubiquitous, and it allows us to maintain proper scope and support variable mutation. For ease of implementation, we will also make our interpreter return a common value structure.</p><h2 id="ff96" class="pw nz fq bf oa px py pz od qa qb qc og nl qd qe qf np qg qh qi nt qj qk ql qm bk">Values, Stores, and the Environment</h2><p id="eb9f" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">First, let’s define what our interpreter can output. We have three obvious base cases in our EBNF (namely booleans, strings, and numbers) so let’s create value objects for those:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="c643" class="pf nz fq pc b bg pg ph l pi pj">class Value:<br/>    def __init__(self, value):<br/>        self.value = value<br/>        <br/>    def __str__(self) -&gt; str:<br/>        return str(self.value)<br/>        <br/>class NumValue(Value):<br/>    def __init__(self, value: float):<br/>        super().__init__(value)<br/>        <br/>class StringValue(Value):<br/>    def __init__(self, value: str):<br/>        super().__init__(value)<br/>        <br/>class BoolValue(Value):<br/>    def __init__(self, value: bool):<br/>        super().__init__(value) </span></pre><p id="7cd9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To store mappings of variables to values, we will also create an environment and a store:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="004b" class="pf nz fq pc b bg pg ph l pi pj">class EnvLookupException(Exception):<br/>    pass<br/>        <br/>class Environment:<br/>    def __init__(self):<br/>        self.vars = {}<br/>        <br/>    def set_var(self, name, addr: int):<br/>        self.vars[name] = addr<br/>        <br/>    def get_var(self, name):<br/>        if name not in self.vars:<br/>            raise EnvLookupException(f"Variable {name} not found in environment")<br/>        return self.vars[name]<br/>    <br/>    def copy(self):<br/>        new_env = Environment()<br/>        new_env.vars = self.vars.copy()<br/>        return new_env<br/>    <br/>class Store:<br/>    def __init__(self):<br/>        self.store = []<br/>        <br/>    def alloc(self, value: Value):<br/>        self.store.append(value)<br/>        return len(self.store) - 1<br/>    <br/>    def get(self, addr: int):<br/>        if addr &gt;= len(self.store):<br/>            raise EnvLookupException(f"Address {addr} not found in store")<br/>        return self.store[addr]<br/>    <br/>    def set(self, addr: int, value: Value):<br/>        if addr &gt;= len(self.store):<br/>            raise EnvLookupException(f"Address {addr} not found in store")<br/>        self.store[addr] = value</span></pre><p id="cf7e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Effectively, our environment will store variable → address bindings, and our store will hold address → value bindings. The store is perhaps not necessary with our current feature set, but if we allowed for mutation for pass-by-reference variables, it would be useful⁴.</p><p id="54e1" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Ideally, we’d also like to pass functions as variables, so we need one more value to represent them. To do this, we create a <strong class="ne fr">closure</strong>, which contains the function’s parameter, body, and the environment that it was created in:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="7b6f" class="pf nz fq pc b bg pg ph l pi pj">class ClosureValue(Value):<br/>    # Body should be an antlr4 tree<br/>    def __init__(self, param: str, body: object, env: 'Environment'):<br/>        super().__init__(None)<br/>        self.param = param<br/>        self.body = body<br/>        self.env = env<br/>        <br/>    def __str__(self) -&gt; str:<br/>        return f"&lt;function&gt;"</span></pre><p id="9e1e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">You may reasonably ask about why we need the environment stored in the function. Suppose instead that we had a function value like this:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="bd3f" class="pf nz fq pc b bg pg ph l pi pj">class FunctionValue(Value):<br/>    # Body should be an antlr4 tree<br/>    def __init__(self, param: str, body: object):<br/>        super().__init__(None)<br/>        self.param = param<br/>        self.body = body<br/>        <br/>    def __str__(self) -&gt; str:<br/>        return f"&lt;function&gt;"</span></pre><p id="f3f8" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, suppose that we had code equivalent to the following in our language:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="2077" class="pf nz fq pc b bg pg ph l pi pj"># ----------------<br/># ENV MUST PERSIST<br/># ----------------<br/>def f(x):<br/>  def g(y):<br/>    return x + y<br/>  return g(x)<br/><br/>print((f(4))(5)) # 9<br/><br/># ----------------<br/># ENV MUST CLEAR<br/># ----------------<br/>def f2(x):<br/>  return x + y<br/><br/>def g2(y):<br/>  return f(5)<br/><br/>print(f(4)) # Should crash</span></pre><p id="d092" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To ensure that <code class="cx pk pl pm pc b">y</code> is still in scope for <code class="cx pk pl pm pc b">g</code> in the top case, we would have to implement dynamic scoping (scope where variables are added to the environment as the program runs without being cleared) without closures, meaning that the bottom code would actually run and print <code class="cx pk pl pm pc b">9</code>. For the bottom code to properly crash though, we can’t implement dynamic scope. Thus we want the functions to effectively remember what environment they were created in — hence why we add environments to our closure class⁵.</p><h2 id="d4fa" class="pw nz fq bf oa px py pz od qa qb qc og nl qd qe qf np qg qh qi nt qj qk ql qm bk">The Interpreter</h2><p id="915a" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Now, we are ready to write our actual interpreter. In ANTLR, our interpreter will extend the <code class="cx pk pl pm pc b">EmojiLangListener</code> class. We will also need to create a top-level environment and give the interpreter a store:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="11ae" class="pf nz fq pc b bg pg ph l pi pj">class EmojiLangException(Exception):<br/>    pass<br/>        <br/>TOP_ENV = Environment()<br/><br/>class Interpreter(EmojiLangListener):<br/>    def __init__(self):<br/>        self.store = Store()</span></pre><p id="f1f9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, we need to create an interp method that handles all of our expression cases. It will end up looking something as follows:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="edf0" class="pf nz fq pc b bg pg ph l pi pj">def interp(self, prog, env: Environment) -&gt; Value:<br/>      if prog.ID():<br/>          return self.interp_id(prog.ID())<br/>      elif prog.atom():<br/>          return self.interp_atom(prog.atom())<br/>      elif prog.anonFunctionDefn():<br/>          return self.interp_function_defn(prog.anonFunctionDefn())<br/>      elif prog.READ_FLOAT():<br/>          return self.interp_read_float()<br/>      elif prog.READ_STRING():<br/>          return self.interp_read_string()<br/>      elif prog.printExpr():<br/>          return self.interp_print_expr()<br/>      elif prog.ifCond():<br/>          return self.interp_if(prog.ifCond(), env)<br/>      elif prog.sequentialOp():<br/>          return self.interp_sequential_op(prog.sequentialOp(), env)<br/>      elif prog.baseComputation():<br/>          return self.interp_base_computation(prog.baseComputation(), env)<br/>      elif prog.varAssignment():<br/>          return self.interp_var_assignment(prog.varAssignment(), env)<br/>      elif prog.funApplication():<br/>          return self.interp_fun_application(prog.funApplication(), env)</span></pre><p id="b483" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Our base cases (IDs, atoms, function definitions, reading, and printing) are fairly simple, so we can just write them in:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="8827" class="pf nz fq pc b bg pg ph l pi pj">def interp(self, prog, env: Environment) -&gt; Value:<br/>    if prog.ID():<br/>        return self.store.get(env.get_var(prog.ID().getText()))<br/>    elif prog.atom():<br/>        return self.interp_atom(prog.atom())<br/>    elif prog.anonFunctionDefn():<br/>        return ClosureValue(prog.anonFunctionDefn().arg.text, prog.anonFunctionDefn().body, env)<br/>    elif prog.READ_FLOAT():<br/>        try:<br/>            return NumValue(float(input("&gt; ")))<br/>        except ValueError:<br/>            raise EmojiLangException("Expected float input")<br/>    elif prog.READ_STRING():<br/>        return StringValue(input("&gt; "))<br/>    elif prog.printExpr():<br/>        value = self.interp(prog.printExpr().expr(), env)<br/>        if isinstance(value, StringValue):<br/>            # print without quotes<br/>            print(str(value)[1:-1])<br/>        else:<br/>            print(value)<br/>        return value<br/>    # ...<br/><br/>def interp_atom(self, atm):<br/>    if atm.NUMBER():<br/>        return NumValue(float(atm.NUMBER().getText()))<br/>    elif atm.BOOLEAN():<br/>        return BoolValue(atm.BOOLEAN().getText() == ":thumbs_up:")<br/>    elif atm.STRING():<br/>        return StringValue(atm.STRING().getText())<br/>    # THIS SHOULD NEVER HAPPEN<br/>    raise EmojiLangException(f"Unknown atom {atm.getText()}")</span></pre><p id="dcb0" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Our if condition is also fairly simple. We just need to interpret the condition and then return the result of interpreting the true case if it's true and the false case if its false. The code is thus just</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="9543" class="pf nz fq pc b bg pg ph l pi pj">def interp_if(self, if_cond, env: Environment):<br/>    cond = self.interp(if_cond.cond, env)<br/>    if not isinstance(cond, BoolValue):<br/>        raise EmojiLangException(f"Expected boolean when evaluating if condition, got {cond}")<br/>    return self.interp(if_cond.ontrue if cond.value else if_cond.onfalse, env)</span></pre><p id="f5dc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Sequential operations are similarly simple, they just need to interpret the first expression and then the second. We can thus replace the code in that block as follows:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="9ce9" class="pf nz fq pc b bg pg ph l pi pj">def interp(self, prog, env: Environment) -&gt; Value:<br/>  # ...<br/>  elif prog.sequentialOp():<br/>    self.interp(prog.sequentialOp().first, env)<br/>    return self.interp(prog.sequentialOp().second, env)<br/>  # ...</span></pre><p id="6fa9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Next are the base computations. This is a decent amount of code since we need to handle a lot of operations, but it’s not super complex:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="7aa0" class="pf nz fq pc b bg pg ph l pi pj">def interp_base_computation(self, base_computation, env: Environment):<br/>    left, right = self.interp(base_computation.left, env), self.interp(base_computation.right, env)<br/>    if base_computation.op.text == ":plus:":<br/>        if isinstance(left, NumValue) and isinstance(right, NumValue):<br/>            return NumValue(left.value + right.value)<br/>        elif isinstance(left, StringValue) and isinstance(right, StringValue):<br/>            return StringValue(left.value + right.value)<br/>        raise EmojiLangException(f"Cannot add {left} and {right}")<br/>    if base_computation.op.text == ":heavy_equals_sign:":<br/>        if type(left) != type(right):<br/>            return BoolValue(False)<br/>        if isinstance(left, ClosureValue):<br/>            raise EmojiLangException("Cannot compare functions")<br/>        return BoolValue(left.value == right.value)<br/>    <br/>    # NUMBERS ONLY COMPUTATIONS<br/>    if not isinstance(left, NumValue) or not isinstance(right, NumValue):<br/>        raise EmojiLangException(f"Expected numbers when evaluating base computation, got {left} and {right}")<br/>    if base_computation.op.text == ":minus:":<br/>        return NumValue(left.value - right.value)<br/>    elif base_computation.op.text == ":multiply:":<br/>        return NumValue(left.value * right.value)<br/>    elif base_computation.op.text == ":divide:":<br/>        if right.value == 0:<br/>            raise EmojiLangException("Division by zero")<br/>        return NumValue(left.value / right.value)<br/>    elif base_computation.op.text == "≤":<br/>        return BoolValue(left.value &lt;= right.value)   </span></pre><p id="13b3" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Perhaps this can also be cleaned up a bit with the use of e.g. dictionaries, but that’s not super important. Next we have variable assignments, which are also not too complicated. We have a couple choices here on what exactly we want it to do — namely, should it allow new variables to come into existence or only modify existing ones? I’ll choose the latter case, which makes our code look like this:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="7f92" class="pf nz fq pc b bg pg ph l pi pj">def interp_var_assignment(self, var_assign, env: Environment):<br/>    value = self.interp(var_assign.val, env)<br/>    addr = env.get_var(var_assign.var.text)<br/>    self.store.store[addr] = value<br/>    return value</span></pre><p id="07ac" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Finally, we have function applications. Here, we have to do four steps. First, we interpret the function we are calling to get our closure. Then, we interpret our argument. Then, we bind the argument into a copy of the closure’s environment. Finally, we interpret the closure’s body in the new environment. The code ends up looking as follows:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="9de0" class="pf nz fq pc b bg pg ph l pi pj">def interp_fun_application(self, fun_app, env: Environment):<br/>    closure = self.interp(fun_app.fun, env)<br/>    if not isinstance(closure, ClosureValue):<br/>        raise EmojiLangException(f"Expected function when evaluating function application, got {closure}")<br/>    arg = self.interp(fun_app.arg, env)<br/>    new_env = closure.env.copy()<br/>    new_env.set_var(closure.param, self.store.alloc(arg))<br/>    return self.interp(closure.body, new_env)</span></pre><p id="712a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, our interp is fully functional! We need only modify our main program to run it now on a program:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="babb" class="pf nz fq pc b bg pg ph l pi pj">if __name__ == "__main__":<br/>    input_file = sys.argv[1]<br/>    with open(input_file, "r", encoding="utf-8") as f:<br/>        input_text = f.read()<br/><br/>    # Preprocess input to replace emojis with demojized names<br/>    input_text = emoji.demojize(input_text)<br/><br/>    input_stream = InputStream(input_text)<br/>    lexer = EmojiLangLexer(input_stream)<br/>    token_stream = CommonTokenStream(lexer)<br/>    parser = EmojiLangParser(token_stream)<br/>    tree = parser.program()<br/>    <br/>    if parser.getNumberOfSyntaxErrors() &gt; 0:<br/>        exit(1)<br/>    <br/>    interpreter = Interpreter()<br/>    interpreter.interp(tree.expr(), TOP_ENV)</span></pre><h1 id="25eb" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Playing With Our Language</h1><p id="02b6" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">We are now finally ready to start writing programs in our language. Here’s a simple hello world program in the emoji language (EML):</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="55f3" class="pf nz fq pc b bg pg ph l pi pj">🏃‍♂️🏃‍♂️🏃‍♂️<br/>    (🖨️ ("Hello World!"))<br/>🛑🛑🛑</span></pre><p id="ecf3" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">And to run it, we just do</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="f732" class="pf nz fq pc b bg pg ph l pi pj">&gt; python emoji_lang.py helloworld.eml<br/>Hello World!</span></pre><p id="2eab" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">(the above, of course, assumes that the program is present in a file called <code class="cx pk pl pm pc b">helloworld.eml</code> )</p><h2 id="9ef5" class="pw nz fq bf oa px py pz od qa qb qc og nl qd qe qf np qg qh qi nt qj qk ql qm bk">Currying</h2><p id="4fe6" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Back in the first section, I noted that our programming language is interesting because functions can only take one argument. How then do we create an effect similar to multivariate functions? Consider, for instance, the following python code:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="f8bb" class="pf nz fq pc b bg pg ph l pi pj">def f(x, y):<br/>  return x + y<br/><br/>print(f(3, 4))</span></pre><p id="3238" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><code class="cx pk pl pm pc b">f</code> here has <strong class="ne fr">arity</strong> 2 — that is, it takes two arguments. We can, however, write equivalent code that only uses functions of arity one (except addition) as follows:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="96de" class="pf nz fq pc b bg pg ph l pi pj">def f(x):<br/>  def g(y):<br/>    return x + y<br/>  return g<br/><br/>print((f(3))(4))</span></pre><p id="424a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The above concept of turning higher arity functions into unary functions is called <strong class="ne fr">currying</strong>. It works for functions of any arity — for a function <em class="pa">f </em>of arity <em class="pa">n</em>, we can simply perform currying <em class="pa">n-1 </em>times. In emoji language, this allows us to write a program like this:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="4545" class="pf nz fq pc b bg pg ph l pi pj">🏃‍♂️🏃‍♂️🏃‍♂️<br/>    (📋<br/>        (🖨️ ("Enter two numbers to compute their sum."))<br/>        (🖨️<br/>            (🏭<br/>                (🏭 <br/>                    (🧑‍🏭 x ⚒️ <br/>                        (🧑‍🏭 y ⚒️<br/>                            ((x) ➕ (y))<br/>                        )<br/>                    )<br/>                (🔢))<br/>            (🔢))<br/>        )<br/>    )<br/>🛑🛑🛑</span></pre><p id="ee32" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">the Python translation of which is</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="e133" class="pf nz fq pc b bg pg ph l pi pj">print("Enter two numbers to compute their sum.")<br/>print(((lambda x: (lambda y: x + y)))(float(input()))(float(input())))</span></pre><p id="3cec" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Or, more legibly,</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="65ca" class="pf nz fq pc b bg pg ph l pi pj">print("Enter two numbers to compute their sum.")<br/><br/>def f(x):<br/>  def g(y):<br/>    return x + y<br/>  return g<br/><br/>x = float(input())<br/>y = float(input())<br/><br/>print(f(x)(y))</span></pre><p id="3e33" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Notice also how the first python iteration used no named functions. It turns out that we don’t really need them, though of course they are useful for readability. Then we get</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="830b" class="pf nz fq pc b bg pg ph l pi pj">&gt; python emoji_lang.py currying.eml<br/>Enter two numbers to compute their sum<br/>&gt; 4<br/>&gt; 5<br/>9.0</span></pre><h2 id="a814" class="pw nz fq bf oa px py pz od qa qb qc og nl qd qe qf np qg qh qi nt qj qk ql qm bk">Recursion</h2><p id="08b8" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">How do we do a loop or recursion in this language though? We have no syntax for <code class="cx pk pl pm pc b">for</code> or <code class="cx pk pl pm pc b">while</code> , and without names for functions, it may seem like recursion is impossible.</p><p id="8fb6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We can, however, do a neat little trick. Since functions are values, we can pass functions to <em class="pa">themselves</em> whenever we call them, thus allowing them to call themselves.</p><p id="ff82" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Take, for instance, the following python code:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="69b8" class="pf nz fq pc b bg pg ph l pi pj">n = int(input())<br/>while n &gt; 0:<br/>  print(n)<br/>  n -= 1</span></pre><p id="e25b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We can convert this to a recursive version using something like this⁶:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="c42a" class="pf nz fq pc b bg pg ph l pi pj">def while_loop(condition, body):<br/>  """<br/>  A recursive implementation of a while loop.<br/><br/>  Arguments<br/>  -------------<br/>  - condition: Some function of zero arguments that returns a boolean value<br/>  - body: Some function of zero arguments to run while the condition returns true<br/>  """<br/>  if condition():<br/>    body()<br/>    while_loop(condition, body)<br/>  else:<br/>    return False<br/><br/>class Box:<br/>    def __init__(self, n):<br/>        self.n = n<br/>    <br/>    def set_n(self, n):<br/>        self.n = n<br/>        <br/>    def get_n(self):<br/>        return self.n<br/>    <br/>n = Box(int(input()))<br/><br/>def body():<br/>    print(n.get_n())<br/>    n.set_n(n.get_n() - 1)<br/><br/>while_loop(lambda: n.get_n() &gt; 0, body)</span></pre><p id="d7db" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">But we do have a problem here — namely, notice how <code class="cx pk pl pm pc b">while_loop</code> calls itself. We can’t do that in our language with only anonymous functions, so how do we fix that? The answer is that we can do something like this:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="1737" class="pf nz fq pc b bg pg ph l pi pj">def while_loop(self, condition, body):<br/>  if condition():<br/>    body()<br/>    self(self, condition, body)<br/>  else:<br/>    return False<br/><br/># ...<br/># (define n as a box)<br/># ...<br/><br/>def body():<br/>    print(n.get_n())<br/>    n.set_n(n.get_n() - 1)<br/><br/>def call_while(loop_func, condition, body):<br/>    loop_func(loop_func, condition, body)<br/>    <br/>call_while(while_loop, lambda: n.get_n() &gt; 0, body)</span></pre><p id="944c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In effect, we make <code class="cx pk pl pm pc b">while_loop</code> take <em class="pa">itself</em> as a parameter. Then, we can call <code class="cx pk pl pm pc b">self</code> inside <code class="cx pk pl pm pc b">while_loop</code> , allowing <code class="cx pk pl pm pc b">while_loop</code> to call itself recursively.</p><p id="fd60" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We still, of course, need to lambda-fy and curry this for our language, so we need to make code equivalent to the following:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="b8fc" class="pf nz fq pc b bg pg ph l pi pj">(((lambda while_loop: <br/>    lambda n: <br/>        while_loop(while_loop)<br/>                  (lambda bogus: n.get_n() &gt; 0)<br/>                  (lambda bogus: print(n.get_n()) or n.set_n(n.get_n() - 1)))<br/>(lambda self:<br/>    lambda cond:<br/>        lambda body:<br/>            (body("BOGUS") or self(self)(cond)(body)) if cond("BOGUS") else False))<br/>(Box(int(input()))))</span></pre><p id="f0fb" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This is a bit of a doozy, but it does work. In emoji lang, this then becomes</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="570d" class="pf nz fq pc b bg pg ph l pi pj">🏃‍♂️🏃‍♂️🏃‍♂️<br/>    (🏭<br/>        (🏭<br/>            (🧑‍🏭 while ⚒️<br/>                (🧑‍🏭 n ⚒️<br/>                    (🏭 (🏭 (🏭 (while) (while))<br/>                        (🧑‍🏭 bogus ⚒️ (🤔 ((n) ≤ (0)) ❓ (👎) : (👍))))<br/>                        (🧑‍🏭 bogus ⚒️ (📋<br/>                            (🖨️ (n))<br/>                            (📦 n 🔜 ((n) ➖ (1)))<br/>                        )))<br/>                ))<br/>            😴<br/>                Below is our while function. Note that it takes<br/>                itself as an argument - this allows for recursion<br/>                (there are other ways to do this, but recursion via self<br/>                passing is fairly simple)<br/><br/>                ARGS: <br/>                1. self(itself)<br/>                2. condition_func (function of zero arguments that returns a boolean)<br/>                3. body (function of zero arguments that returns nothing to run while true)<br/><br/>                RETURNS:<br/>                false when finished<br/>            ⏰<br/>            (🧑‍🏭 self ⚒️<br/>                (🧑‍🏭 condition_func ⚒️<br/>                    (🧑‍🏭 body ⚒️<br/>                        (<br/>                            🤔 (🏭 (condition_func) ("BOGUS")) ❓ <br/>                                (📋 <br/>                                    (🏭 (body) ("BOGUS")) <br/>                                    (🏭 (🏭 (🏭 (self) (self))<br/>                                            (condition_func))<br/>                                            (body))) : <br/>                                (👎)<br/>                        ))))<br/>        )<br/>    (🔢))       <br/>🛑🛑🛑</span></pre><p id="fe78" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Then we get</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="aedd" class="pf nz fq pc b bg pg ph l pi pj">&gt; python emoji_lang.py while_loop.eml<br/>&gt; 4<br/>4.0<br/>3.0<br/>2.0<br/>1.0</span></pre><h2 id="c757" class="pw nz fq bf oa px py pz od qa qb qc og nl qd qe qf np qg qh qi nt qj qk ql qm bk">Bonus: The Y Combinator</h2><p id="15db" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">It’s somewhat annoying to pass in while to itself each time we want to call it, so what if we could create a version of while that already had itself curried? It turns out we can with something called the <strong class="ne fr">Y Combinator</strong>. The Y combinator is a function that looks as follows:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="06ed" class="pf nz fq pc b bg pg ph l pi pj">Y = lambda g: (lambda f: g(lambda arg: f(f)(arg))) (lambda f: g(lambda arg: f(f)(arg)))</span></pre><p id="3b6c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">It’s completely absurd, but it allows us to effectively “store” a function in itself. I won’t go into too much detail about it, but if you’d like to learn more I advise looking at <a class="af nb" href="https://www.playfulpython.com/y-combinator-in-python/" rel="noopener ugc nofollow" target="_blank">this excellent article</a></p><p id="20c4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With the combinator though, we can change our code to the following:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="c5c1" class="pf nz fq pc b bg pg ph l pi pj">🏃‍♂️🏃‍♂️🏃‍♂️<br/>    (🏭<br/>        (🏭<br/>            (🏭<br/>                (🧑‍🏭 y_combinator ⚒️<br/>                    (🧑‍🏭 while ⚒️<br/>                        (🧑‍🏭 n ⚒️<br/>                            (📋<br/>                                🥱y-combinate our while<br/>                                (📦 while 🔜 (🏭 (y_combinator) (while)))<br/>                                (🏭 (🏭 (while)<br/>                                        (🧑‍🏭 bogus ⚒️ (🤔 ((n) ≤ (0)) ❓ (👎) : (👍))))<br/>                                        (🧑‍🏭 bogus ⚒️ (📋<br/>                                                (🖨️ (n))<br/>                                                (📦 n 🔜 ((n) ➖ (1)))<br/>                                        ))<br/>                                )<br/>                            )<br/>                        )<br/>                    )<br/>                )<br/>                😴<br/>                    Our y combinator function - this allows for recursion without e.g. self passing<br/>                    by effectively currying the function and passing it to itself.<br/>                ⏰<br/>                (🧑‍🏭 fn_nr ⚒️<br/>                    (🏭<br/>                       (🧑‍🏭 cc ⚒️<br/>                            (🏭 (fn_nr) <br/>                                (🧑‍🏭 x ⚒️ (🏭 (🏭 (cc) (cc)) (x)))<br/>                            )<br/>                       )<br/>                       (🧑‍🏭 cc ⚒️<br/>                            (🏭 (fn_nr) <br/>                                (🧑‍🏭 x ⚒️ (🏭 (🏭 (cc) (cc)) (x)))<br/>                            )<br/>                       )<br/>                    )<br/>                )<br/>            )<br/>            (🧑‍🏭 while ⚒️<br/>                    (🧑‍🏭 condition_func ⚒️<br/>                        (🧑‍🏭 body ⚒️<br/>                            (<br/>                                🤔 (🏭 (condition_func) ("BOGUS")) ❓ <br/>                                    (📋 <br/>                                        (🏭 (body) ("BOGUS")) <br/>                                        (🏭 (🏭 (while)<br/>                                                (condition_func))<br/>                                                (body))) : <br/>                                    (👎)<br/>                            ))))<br/>        )  <br/>    (🔢))    <br/>🛑🛑🛑</span></pre><p id="aafe" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, notice how our call to while after it has been y-combinated⁷ only involves passing the condition and the body — we don’t need to pass itself. and we still get</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="5440" class="pf nz fq pc b bg pg ph l pi pj">&gt; python emoji_lang.py y_comb_while.eml<br/>&gt; 4<br/>4.0<br/>3.0<br/>2.0<br/>1.0</span></pre><h1 id="5cdd" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Conclusions</h1><p id="0ee7" class="pw-post-body-paragraph nc nd fq ne b go ou ng nh gr ov nj nk nl ow nn no np ox nr ns nt oy nv nw nx fj bk">Congratulations! You have now hopefully built your own programming language and coded some fun things in it. Though something like EmojiLang obviously doesn’t have much real use, you can imagine some cool use cases for building your own languages, e.g. by creating a super case-specific scripting language to speed up common tasks.</p><p id="a2a9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">If you’d like some challenges, try the following exercises:</p><p id="ada5" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><strong class="ne fr">Exercise 1: </strong>Build a simple parser and interpreter for the following language <em class="pa">without</em> using ANTLR. Ensure that parenthesis always take precedence, and that operations otherwise have equal precedence (e.g. <code class="cx pk pl pm pc b">4 + 4 * 3</code> should evaluate to <code class="cx pk pl pm pc b">24</code> , not <code class="cx pk pl pm pc b">16</code> )</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="83f2" class="pf nz fq pc b bg pg ph l pi pj">EXPR = number<br/>       | EXPR + EXPR<br/>       | EXPR - EXPR<br/>       | EXPR * EXPR<br/>       | EXPR / EXPR<br/>       | (EXPR)</span></pre><p id="0848" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><strong class="ne fr">Exercise 2:</strong> Modify your above code to add operator precedence</p><p id="bf4b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><strong class="ne fr">Exercise 3 (Tricky)</strong>: We don’t <em class="pa">have</em> to make all of our functions anonymous. Try implementing an interpreter for the following language (you can use ANTLR, but you’ll have to write your own .g4 file):</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="4683" class="pf nz fq pc b bg pg ph l pi pj">program = (FUNDEF | EXPR)* // one or more function definitions or expressions<br/><br/>// NOTE: &lt;something&gt; implies that something is a string<br/>// also, feel free to ignore whitespace or add semicolons or parenthesize<br/>// expressions/fundefs if you please<br/><br/>EXPR = number<br/>     | functionApplication<br/>     | computation<br/><br/>FUNDEF = 'def' &lt;name&gt; '(' &lt;args&gt;* '):' EXPR<br/><br/>functionApplication = &lt;name&gt; '(' EXPR* ')' // e.g. f(1, 2+2, g(3))<br/>computation = EXPR + EXPR<br/>             | EXPR - EXPR<br/>             | EXPR * EXPR<br/>             | EXPR / EXPR<br/>             | (EXPR)</span></pre><p id="d6d2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><strong class="ne fr">Exercise 4 (Easy →Very Very Hard):</strong> .g4 files for a ton of real languages can be found <a class="af nb" href="https://github.com/antlr/grammars-v4" rel="noopener ugc nofollow" target="_blank">here</a>. Implement an interpreter for any one of them.</p><p id="237b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><em class="pa">Please contact mchak@calpoly.edu for any inquiries</em></p><p id="0886" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><em class="pa">P.S. Thank you to Brian Jones, my CS 430 professor, for teaching me a lot of this stuff.</em></p><p id="5f90" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><em class="pa">All images by author unless otherwise stated.</em></p></div></div></div><div class="ab cb qn qo qp qq" role="separator"><span class="qr by bm qs qt qu"/><span class="qr by bm qs qt qu"/><span class="qr by bm qs qt"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><ol class=""><li id="bbb0" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx po pp pq bk">Compiled languages are slightly different. The generated abstract syntax tree is instead passed to a compiler that converts it to code in a different existing language (most commonly assembly). The outputted code can then be run.</li><li id="23e1" class="nc nd fq ne b go pr ng nh gr ps nj nk nl pt nn no np pu nr ns nt pv nv nw nx po pp pq bk">Technically, this isn’t actually in EBNF, but it’s close enough. If you’re curious, you can read more about the EBNF <a class="af nb" href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form" rel="noopener ugc nofollow" target="_blank">here</a></li><li id="3c04" class="nc nd fq ne b go pr ng nh gr ps nj nk nl pt nn no np pu nr ns nt pv nv nw nx po pp pq bk">Note: Some languages may perform some optimizations to the AST before passing it to the interpreter. We will not do that here.</li><li id="893c" class="nc nd fq ne b go pr ng nh gr ps nj nk nl pt nn no np pu nr ns nt pv nv nw nx po pp pq bk">We can still allow for mutation by using boxed values in our environment, but the store is more akin to what most languages do and is more intuitive, at least for me.</li><li id="d7c8" class="nc nd fq ne b go pr ng nh gr ps nj nk nl pt nn no np pu nr ns nt pv nv nw nx po pp pq bk">See <a class="af nb" href="https://cs.brown.edu/courses/cs173/2012/book/higher-order-functions.html#%28part._.Implementing_.Closures%29" rel="noopener ugc nofollow" target="_blank">7 Functions Anywhere (brown.edu)</a> for more info</li></ol><p id="16df" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">6. Note that we have to use a box here because Python’s environment doesn’t really work in the same way ours does, e.g. we can’t do this:</p><pre class="ml mm mn mo mp pb pc pd bp pe bb bk"><span id="9d80" class="pf nz fq pc b bg pg ph l pi pj"># ...<br/>def get_body_and_cond(inp):<br/>    n = inp<br/>    condition = lambda: n &gt; 0<br/>    <br/>    def body():<br/>        print(n)<br/>        n -= 1<br/>    return condition, body<br/>    <br/>c, b = get_body_and_cond(float(input()))<br/><br/>while_loop(c, b)</span></pre><p id="8004" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">7. Really, it has been Z-combinated since our language evaluates stuff eagerly, but the effect is the same</p></div></div></div></div>    
</body>
</html>
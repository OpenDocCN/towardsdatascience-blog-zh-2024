# 为什么大多数交叉验证可视化是错误的（以及如何修复它们）

> 原文：[https://towardsdatascience.com/why-most-cross-validation-visualizations-are-wrong-and-how-to-fix-them-bdbbba74e263?source=collection_archive---------0-----------------------#2024-11-16](https://towardsdatascience.com/why-most-cross-validation-visualizations-are-wrong-and-how-to-fix-them-bdbbba74e263?source=collection_archive---------0-----------------------#2024-11-16)

## 更好的机器学习可视化

## 停止使用移动的框！

[](https://medium.com/@samybaladram?source=post_page---byline--bdbbba74e263--------------------------------)[![Samy Baladram](../Images/715cb7af97c57601966c5d2f9edd0066.png)](https://medium.com/@samybaladram?source=post_page---byline--bdbbba74e263--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--bdbbba74e263--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--bdbbba74e263--------------------------------) [Samy Baladram](https://medium.com/@samybaladram?source=post_page---byline--bdbbba74e263--------------------------------)

·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--bdbbba74e263--------------------------------) ·阅读时长：10分钟·2024年11月16日

--

你知道那些在每个数据科学教程中出现的交叉验证图表吗？那些通过不同颜色的框在四处移动来解释我们如何拆分数据进行训练和测试的图表？像这样：

![](../Images/7310960c11e4e979706ce2dea8eedfbf.png)

你见过那个吗？图像由作者提供。

我也见过这些图表——多得数不清。这些图表非常常见——它们已经成为解释交叉验证的首选方式。但在我作为设计师和数据科学家看这些图表时，我注意到了一些有趣的事情。

> 当我们看到一个黄色框移动到不同的位置时，我们的大脑自动认为它是一个框在四处移动。

这就是我们大脑的工作方式——当我们看到类似的东西移动到新位置时，我们会认为它是同一个东西。（这其实也是卡通和动画能够有效工作的原因！）

![](../Images/293776fe285e9c1651b9ca1c65706411.png)

你可能认为动画版本更好，但现在你忍不住开始跟着蓝色框移动，并且渐渐忘记了这应该代表交叉验证的工作方式。来源：[维基百科](https://commons.wikimedia.org/wiki/File:LOOCV.gif)

但问题是：在这些图表中，每个新位置的框**应该显示不同的数据块**。因此，尽管我们的脑袋自然想要跟踪这些框，我们却必须告诉大脑，“不，不，那不是一个框在移动——它们是不同的框！”这就像我们在与大脑的自然工作方式作斗争，仅仅为了理解这个图表的含义。

作为一个同时从事设计和数据工作的人员，我开始思考：也许有更好的方法？如果我们能以一种更符合大脑处理信息方式的方式展示交叉验证呢？

![](../Images/a213cf03718d755a88bb08470f7d3abb.png)

所有可视化：作者使用Canva Pro创建。已优化移动设备显示；在桌面上可能显得过大。

# 交叉验证到底是关于什么的？

交叉验证是确保机器学习模型在现实世界中表现良好的方法。我们不是仅测试一次模型，而是使用数据的不同部分多次测试模型。这有助于我们理解模型在处理新数据时的表现。

事情是这样发生的：

1.  我们拿到数据

1.  将其分成若干组

1.  使用一些组进行训练，其他组进行测试

1.  用不同的分组重复这个过程

目标是可靠地理解我们模型的表现。这是核心思想——简单且实用。

（注：我们将在另一篇文章中讨论不同的验证技术及其应用。现在，我们先专注于理解基本概念以及为何当前的可视化方法需要改进。）

# 当前交叉验证图示有什么问题？

打开任何机器学习教程，你可能会看到这些类型的图示：

+   长方形框被分成不同的部分

+   箭头指示部分数据的移动

+   不同的颜色表示训练数据和测试数据

+   相同图示的多个版本并排显示

![](../Images/11bdeccff9e5426a2f8669b317c7faab.png)

当前，如果你搜索“交叉验证”，你看到的第一个图像就类似于这个。（图片由作者提供）

下面是此类图示存在的问题：

## **并不是每个人都以相同的方式看到颜色**

颜色在展示数据分割时会带来实际问题。有些人无法区分某些颜色，而其他人可能根本看不见颜色。当以黑白打印或在不同显示屏上查看时，颜色会发生变化，导致可视化失效。将颜色作为区分数据部分的主要方式意味着一些人由于色觉问题错过了重要信息。

![](../Images/e3c7aea8baea654253fbedde5e3dd811.png)

不是每个人看到的颜色都相同。图片由作者提供。

## **颜色使记忆变得更加困难**

关于颜色的另一个问题是，它看起来似乎有助于解释问题，但实际上会给大脑带来额外的负担。当我们为数据的不同部分使用不同的颜色时，我们必须主动记住每种颜色代表什么。这变成了一项记忆任务，而不是帮助我们理解实际概念。颜色与数据分割之间的关联并不是自然而明显的——这是我们需要学习并在试图理解交叉验证时保持跟踪的内容。

> 我们的大脑本能地不会将颜色与数据分割关联起来。

![](../Images/e4690d7c50d8de5d8855975b40cd0424.png)

这些是我们在前面图示中使用的颜色。为什么原始数据集是绿色的？然后分成蓝色和红色？

## **一次展示过多信息**

当前的图表也存在信息过载的问题。它们试图在一个图像中展示整个交叉验证过程，这就带来了不必要的复杂性。多个箭头、大量标签，所有的元素都在争夺注意力。当我们试图同时展示过程的每一个方面时，我们反而让理解每个独立部分变得更加困难。这个方法没有澄清概念，反而增加了我们需要首先解码的复杂层次。

![](../Images/3860f294e42aad31e7ef34a9bdaf9ccf.png)

标签太多，颜色太多，箭头太多，导致很难集中注意力。

## 误导性的移动

这些图表中的运动会对交叉验证的实际运作方式产生根本误解。当我们展示箭头和流动元素时，实际上是在暗示一个并不存在的顺序过程。交叉验证的分割并不需要按特定顺序进行——分割的顺序根本不影响结果。

这些图表还给人错误的印象，认为数据在交叉验证过程中是物理移动的。实际上，我们每次只是从原始数据集中选择不同的行。数据保持在原位，我们只是更改每次分割中用于测试的行。当图表显示数据在分割之间流动时，它们给过程增加了不必要的复杂性。

![](../Images/d8fa4ea0c53cc2aa618406d0c99e6f09.png)

虽然图表通常是从上到下流动的，但很难跟随操作的顺序。模型训练和计算结果的时间仍然不明确。训练什么时候进行？每个计算的结果是什么？

## 我们真正需要的是什么

我们需要这样的图表：

+   不要单纯依赖颜色来解释事物

+   清晰地分隔信息块

+   明确不同测试组是独立的

+   不要使用不必要的箭头和移动

让我们来解决这个问题。与其让我们的思维方式变得不同，为什么不创建一些看起来更自然的东西呢？

# 更好的交叉验证可视化方法

让我们尝试一些不同的方式。首先，这是大多数人看到的数据样子——一行行、列列的数字和索引。

![](../Images/08da329b59c04831295fa503a37cb6e4.png)

这是我在[关于分类算法的文章](https://medium.com/@samybaladram/list/classification-algorithms-b3586f0a772c)中使用的常见数据集。

受到这个结构的启发，下面是一个更有意义的图表。

![](../Images/e1633734844646b0c9a447fea09fde60.png)

更简单但清晰的交叉验证描绘。

下面是为什么这个设计在逻辑上更合理的原因：

1.  **真实数据结构：** 它与交叉验证中数据的实际工作方式一致。在实践中，我们是在选择数据集的不同部分，而不是移动数据。每一列显示了我们在每次测试中使用的具体分割。

1.  **独立划分：** 每个划分明确显示它是不同的数据。不同于移动的盒子，这可能会让你误以为“它是相同的测试集在移动”，这里显示 Split 2 使用的是与 Split 1 完全不同的数据。这与代码中实际发生的情况相符。

1.  **数据保护：** 通过保持所有折叠的列高度相同，我们展示了交叉验证的一个重要规则：你始终使用整个数据集。一些部分用于测试，剩余部分用于训练。每一条数据都会被使用，没有遗漏。

1.  **完整覆盖：** 从左到右，你可以轻松验证一个重要的交叉验证原则：数据集的每一部分将作为测试数据恰好使用一次。

1.  **三折简洁性：** 我们在这里专门使用三折交叉验证，因为：

    a. 它清晰地展示了关键概念，而不会让细节显得过于繁杂。

    b. 这个模式很容易理解：三个不同的折叠，三个测试集。足够简单，可以在脑海中跟踪每个折叠中哪些部分用于训练，哪些部分用于测试。

    c. 非常适合用于教学目的——添加更多的折叠（比如 5 或 10 个）会使得可视化变得更加杂乱，而不会增加概念上的价值。

    （注意：虽然在实践中 5 折或 10 折交叉验证可能更为常见，但三折交叉验证完全可以用来说明这一技术的核心概念。）

## 为了更清晰地显示索引

虽然上述概念是正确的，但考虑实际的行索引会使其更加清晰：

![](../Images/00368eec59269afee2665564b9803290.png)

这是一个增强版的变化，增加了细微的索引，使得更容易看出每个折叠对应的数据集的哪一部分。虚线帮助区分各个索引。

以下是这个视觉改进的一些原因：

+   与其说是“不同的部分”，我们可以看到，Fold 1 测试的是第 1 到第 4 行，Fold 2 测试的是第 5 到第 7 行，而 Fold 3 测试的是第 8 到第 10 行。

+   “完整覆盖”变得更为具体：第 1 到第 10 行每一行都恰好在测试集中出现一次。

+   训练集是明确的：当在第 1 到第 4 行进行测试时，我们在第 5 到第 10 行上进行训练。

+   数据独立性显而易见：测试集使用了不同的行范围（1–3，4–6，7–10）。

这种基于索引的视图并没有改变概念——它只是让它们变得更加具体，且更容易在代码中实现。无论你将其视为部分还是特定的行号，关键原则始终保持不变：独立的折叠、完整覆盖和使用所有数据。

## 添加一些颜色

如果你觉得黑白版本过于简单，这也是另一种可接受的选项：

![](../Images/cb7cf250b229c7400f322b84366f03c4.png)

这是简单图示的一种变化，给每个折叠的数字添加了颜色。

虽然在这个版本中使用颜色可能因为色盲和记忆负担等问题而看起来有些问题，但它仍然可以作为一个有用的教学工具，辅以更简单的版本。

主要原因是它**不仅仅使用颜色来显示信息**——行号（1–10）和折叠编号可以告诉你你需要了解的一切，颜色只是一个额外的辅助。

这意味着即使有人无法正确看到颜色或以黑白打印，他们仍然可以通过数字理解一切。虽然必须记住每种颜色的含义可能会让学习变得更加困难，但在这种情况下，你不需要记住颜色——它们只是作为额外的帮助提供给那些觉得它们有用的人，但你完全可以在没有颜色的情况下理解图表。

就像以前的版本一样，行号也通过准确显示数据如何被拆分来提供帮助，无论你是否关注颜色，都更容易理解交叉验证在实践中的运作方式。

> 即使你完全忽略颜色，视觉化仍然是完全功能性的且易于理解。

![](../Images/96381337f14683b33da41d5110ce0bcf.png)

尝试上面的挑战。对于有限数量的颜色，它有助于更快地跟踪位置的变化。

# 为什么这种方式更有效：从设计到数据

让我们从用户体验的角度以及数据科学的角度来看一下，为什么我们的新设计是有道理的。

**匹配思维模型：** 想一想你是如何向别人解释交叉验证的。你可能会说：“我们先用这些行进行测试，然后是这些行，再然后是这些行。”我们的视觉化现在完全符合我们思考和谈论这个过程的方式。我们不仅仅是为了美观，我们让它与现实匹配。

**数据结构的清晰性：** 通过将数据以带索引的列形式展示，我们揭示了数据集的实际结构。每行都有一个编号，每个编号仅出现在一个测试集里。这不仅是良好的设计，它还准确反映了我们的数据在代码中的组织方式。

![](../Images/a1a6c60195236d8940224e07615342ab.png)

即使是默认的交叉验证方式——洗牌，我们也可以通过更改索引让人们明白数据正在被洗牌。

**关注重要的内容：** 我们以前展示交叉验证的方式让我们关注移动的部分。但在交叉验证中，真正重要的不是这些，真正重要的是：

+   我们在测试哪些行？

+   我们是否在使用所有的数据？

+   每行是否仅被用作一次测试？

我们的新设计可以一目了然地回答这些问题。

**基于索引的理解：** 我们不再显示抽象的彩色框，而是显示实际的行索引。当你编写交叉验证代码时，你正在处理这些索引。现在，视觉化与代码相匹配——折叠1使用行1-4，折叠2使用行5-7，以此类推。

![](../Images/043d42a32e5df5fd0f4bc6f3d408ba2a.png)

使用类似的图示，我们还可以展示如何进行留一法交叉验证。每次测试集只使用一个数据点！拆分编号和选择的测试集索引也很好地匹配。

**清晰的数据流：** 布局展示了数据从左到右流动：这是你的数据集，这是它是如何被分割的，这是每个分割的样子。它与交叉验证的逻辑步骤匹配，而且也更容易查看。

![](../Images/c23f34808ce42cb3b8f8f14364010915.png)

阐明箭头的作用，表示训练与测试过程，可以更清楚地展示交叉验证中有多少模型以及它们的输出是什么。你可能会注意到，分割之间没有连接元素的箭头。

# 结论：当可视化与你的代码相匹配时

这是我们关于重新绘制交叉验证图表所学到的内容：

**让你的代码与传统匹配：** 我们通常遵循传统的展示方式，仅仅因为大家都这样做。但交叉验证实际上是关于选择不同的行数据进行测试，那么为什么不直接展示这一点呢？当你的可视化与你的代码相匹配时，理解也会自然而然地跟随而来。

**数据结构很重要：** 通过展示索引和实际数据分割，我们揭示了交叉验证的真实工作原理，同时也提供了更清晰的图像。每一行都有其位置，每一个分割都有其目的，你可以精确追踪每个步骤中发生的事情。

**简洁有其目的：** 事实证明，展示更少的内容实际上可以解释更多。通过专注于核心部分——哪些行用于测试，以及何时使用——我们不仅简化了可视化，还突出了在交叉验证中真正重要的内容。

展望未来，这种思维可以应用于许多数据科学概念。在制作下一个可视化之前，问问自己：

+   这是否展示了代码中实际发生的事情？

+   是否可以追踪数据流？

+   我们是在展示结构，还是仅仅是在遵循传统？

> 好的可视化不是遵循规则——它是展示真相。有时候，最清晰的真相也是最简单的。

## 关于插图

除非另有说明，所有图像均由作者创作，并结合了来自Canva Pro的授权设计元素。

𝙎𝙚𝙚 𝙢𝙤𝙧𝙚 𝙈𝙤𝙙𝙚𝙡 𝙀𝙫𝙖𝙡𝙪𝙖𝙩𝙞𝙤𝙣 & 𝙊𝙥𝙩𝙞𝙢𝙞𝙯𝙖𝙩𝙞𝙤𝙣 𝙝𝙚𝙧𝙚:

![Samy Baladram](../Images/835013c69e08fec04ad9ca465c2adf6c.png)

[Samy Baladram](https://medium.com/@samybaladram?source=post_page-----bdbbba74e263--------------------------------)

## 模型评估与优化

[查看列表](https://medium.com/@samybaladram/list/model-evaluation-optimization-331287896864?source=post_page-----bdbbba74e263--------------------------------)3个故事![](../Images/18fa82b1435fa7d5571ee54ae93a6c62.png)![](../Images/c95e89d05d1de700c631c342cd008de0.png)![](../Images/30e20e1a8ba3ced1e77644b706acd18d.png)

𝙔𝙤𝙪 𝙢𝙞𝙜𝙝𝙩 𝙖𝙡𝙨𝙤 𝙡𝙞𝙠𝙚:

![Samy Baladram](../Images/835013c69e08fec04ad9ca465c2adf6c.png)

[Samy Baladram](https://medium.com/@samybaladram?source=post_page-----bdbbba74e263--------------------------------)

## 分类算法

[查看列表](https://medium.com/@samybaladram/list/classification-algorithms-b3586f0a772c?source=post_page-----bdbbba74e263--------------------------------)8 个故事！[](../Images/f95c1a80b88fe6220b18cd3b2a83a30d.png)![](../Images/6ea70d9d2d9456e0c221388dbb253be8.png)![](../Images/7221f0777228e7bcf08c1adb44a8eb76.png)

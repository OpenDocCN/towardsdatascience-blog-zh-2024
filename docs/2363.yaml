- en: Nine Rules for Running Rust on WASM WASI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WASM WASI上运行Rust的九条规则
- en: 原文：[https://towardsdatascience.com/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a?source=collection_archive---------1-----------------------#2024-09-28](https://towardsdatascience.com/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a?source=collection_archive---------1-----------------------#2024-09-28)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a?source=collection_archive---------1-----------------------#2024-09-28](https://towardsdatascience.com/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a?source=collection_archive---------1-----------------------#2024-09-28)
- en: Practical Lessons from Porting `range-set-blaze` to this Container-Like Environment
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将`range-set-blaze`移植到这种容器化环境中的实践经验
- en: '[](https://medium.com/@carlmkadie?source=post_page---byline--550cd14c252a--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page---byline--550cd14c252a--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--550cd14c252a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--550cd14c252a--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page---byline--550cd14c252a--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlmkadie?source=post_page---byline--550cd14c252a--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page---byline--550cd14c252a--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--550cd14c252a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--550cd14c252a--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page---byline--550cd14c252a--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--550cd14c252a--------------------------------)
    ·13 min read·Sep 28, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--550cd14c252a--------------------------------)
    ·13分钟阅读·2024年9月28日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/b2aeccd7db0b3d1c20858eb872f60daf.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b2aeccd7db0b3d1c20858eb872f60daf.png)'
- en: 'Rust Running on a Container-Like Environment — Source: [https://openai.com/dall-e-2/](https://openai.com/dall-e-2/).
    All other figures from the author.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似容器的环境中运行Rust —— 来源：[https://openai.com/dall-e-2/](https://openai.com/dall-e-2/)。其他所有图表来自作者。
- en: Do you want your Rust code to run everywhere — from large servers to web pages,
    robots, and even watches? In this first of three articles [[1](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a),
    [2](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1),
    [3](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)],
    I’ll detail the steps to make that happen.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你想让你的Rust代码在任何地方运行吗——从大型服务器到网页、机器人，甚至是手表？在这三篇文章中的第一篇[[1](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a),
    [2](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1),
    [3](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)]，我将详细描述实现这一目标的步骤。
- en: Running Rust in constrained environments presents challenges. Your code may
    not have access to a complete operating system such as Linux, Windows, or macOS.
    You may have limited (or no) access to files, networks, time, random numbers,
    and even memory. We’ll explore workarounds and solutions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在受限环境中运行Rust会遇到许多挑战。你的代码可能无法访问完整的操作系统，如Linux、Windows或macOS。你可能无法（或根本无法）访问文件、网络、时间、随机数，甚至是内存。我们将探讨一些解决方法和应对策略。
- en: This first article focuses on running code on “WASM WASI”, a container-like
    environment. We’ll see that WASM WASI may (or may not) be useful in its own right.
    However, it is valuable as a first step toward running Rust in browsers or embedded
    systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章的重点是如何在“WASM WASI”这个类似容器的环境中运行代码。我们将看到，WASM WASI可能（也可能不）在自身上具有实际用途。然而，它作为在浏览器或嵌入式系统中运行Rust的第一步，仍然具有价值。
- en: 'Porting code to run on WASM WASI requires many steps and choices. Navigating
    these choices can be time consuming. Missing a step can lead to failure. We’ll
    reduce this complication by offering nine rules, which we’ll explore in detail:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码移植到WASM WASI上需要许多步骤和选择。做出这些选择可能非常耗时。错过一个步骤可能导致失败。我们将通过提供九条规则来简化这一过程，我们将在接下来的内容中详细探讨这些规则：
- en: 'Prepare for disappointment: WASM WASI is easy, but — for now — mostly useless
    — except as a steppingstone.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为失望做好准备：WASM WASI很简单，但——目前——基本无用——除非作为一个垫脚石。
- en: Understand Rust targets.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解Rust的目标平台。
- en: Install the `wasm32-wasip1` target and WASMTIME, then create “Hello, WebAssembly!”.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`wasm32-wasip1`目标和WASMTIME，然后创建“Hello, WebAssembly！”。
- en: Understand conditional compilation.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解条件编译。
- en: Run regular tests but with the WASM WASI target.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行常规测试，但使用 WASM WASI 目标。
- en: Understand Cargo features.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解 Cargo 特性。
- en: 'Change the things you can: dependency issues by choosing Cargo features, 64-bit/32-bit
    issues.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变你能改变的事物：通过选择 Cargo 特性解决依赖问题，64位/32位问题。
- en: 'Accept that you cannot change everything: Networking, Tokio, Rayon, etc.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受你不能改变一切：网络、Tokio、Rayon 等等。
- en: Add WASM WASI to your CI (continuous integration) tests.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 WASM WASI 添加到你的 CI（持续集成）测试中。
- en: 'Aside: These articles are based on a three-hour workshop that I presented at
    [RustConf24](https://rustconf.com/programs/#755) in Montreal. Thanks to the participants
    of that workshop. A special thanks, also, to the volunteers from the Seattle Rust
    Meetup who helped test this material. These articles replace [an article I wrote
    last year](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2)
    with updated information.'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 顺便说一句：这些文章基于我在 [RustConf24](https://rustconf.com/programs/#755) 会议上提供的三小时研讨会。感谢参加该研讨会的所有人。同时，特别感谢来自西雅图
    Rust Meetup 的志愿者们，他们帮助测试了这篇材料。这些文章替代了我去年写的 [一篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2)，并提供了更新的信息。
- en: Before we look at the rules one by one, let’s define our terms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们逐条查看规则之前，先定义一下术语。
- en: '**Native:** Your home OS (Linux, Windows, macOS)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Native**：你的本地操作系统（Linux、Windows、macOS）'
- en: '**Standard library (std)**: Provides Rust’s core functionality — `Vec`, `String`,
    file input/output, networking, time.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准库 (std)**：提供 Rust 的核心功能——`Vec`、`String`、文件输入/输出、网络、时间等。'
- en: '**WASM**: WebAssembly (WASM) is a binary instruction format that runs in most
    browsers (and beyond).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WASM**：WebAssembly（WASM）是一种二进制指令格式，可以在大多数浏览器中运行（以及其他平台）。'
- en: '**WASI**: WebAssembly System Interface (WASI) allows outside-the-browser WASM
    to access file I/O, networking (not yet), and time handling.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WASI**：WebAssembly 系统接口（WASI）允许非浏览器环境中的 WASM 访问文件 I/O、网络（尚未支持）和时间处理。'
- en: '**no_std**: Instructs a Rust program not to use the full standard library,
    making it suitable for small, embedded devices or highly resource-constrained
    environments.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**no_std**：指示 Rust 程序不使用完整的标准库，使其适用于小型嵌入式设备或资源受限的环境。'
- en: '**alloc**: Provides heap memory allocation capabilities (`Vec`, `String`, etc.)
    in `no_std` environments, essential for dynamically managing memory.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**alloc**：在 `no_std` 环境中提供堆内存分配功能（`Vec`、`String` 等），对动态管理内存至关重要。'
- en: With these terms in mind, we can visualize the environments we want our code
    to run in as a Venn diagram of progressively tighter constraints. This article
    details how to move from native to WASM WASI. [The second article](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1)
    tells how to then move to WASM in the Browser. The [final article](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)
    covers running Rust in `no_std` environments, both with and without `alloc`, ideal
    for embedded systems.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些术语，我们可以将代码运行的环境想象成一个渐进收紧约束的维恩图。本文详细介绍了如何从本地环境迁移到 WASM WASI。[第二篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1)
    讲述了如何进一步迁移到浏览器中的 WASM。[最后一篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)
    涵盖了在 `no_std` 环境中运行 Rust 的方法，包括带有和不带 `alloc` 的情况，非常适合嵌入式系统。
- en: '![](../Images/867094390e12910af5d9c304494db513.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/867094390e12910af5d9c304494db513.png)'
- en: Based on my experience with `[range-set-blaze](https://github.com/CarlKCarlK/range-set-blaze)`,
    a data structure project, here are the decisions I recommend, described one at
    a time. To avoid wishy-washiness, I’ll express them as rules.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我在数据结构项目 [range-set-blaze](https://github.com/CarlKCarlK/range-set-blaze)
    的经验，以下是我推荐的决策，逐条描述。为了避免模糊不清，我将它们表述为规则。
- en: 'Rule 1: Prepare for disappointment: WASM WASI is easy, but — for now — mostly
    useless — except as a steppingstone.'
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 1：为失望做好准备：WASM WASI 很简单，但——目前——大多数情况下没什么用——除非作为一个跳板。
- en: 'In 2019, Docker co-creator Solomon Hykes [tweeted](https://x.com/solomonstre/status/1111004913222324225):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 2019年，Docker 联合创始人 Solomon Hykes [在推特上发文](https://x.com/solomonstre/status/1111004913222324225)：
- en: If WASM+WASI existed in 2008, we wouldn’t have needed to created Docker. That’s
    how important it is. Webassembly on the server is the future of computing. A standardized
    system interface was the missing link. Let’s hope WASI is up to the task.
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果2008年就有WASM+WASI，我们就不需要创建Docker了。这就是它的重要性。服务器上的WebAssembly是计算的未来。一个标准化的系统接口是缺失的环节。希望WASI能胜任这一任务。
- en: 'Today, if you follow technology news, you’ll see optimistic headlines like
    these:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，如果你关注技术新闻，你会看到像这样的乐观标题：
- en: '![](../Images/480c34163ac2f64c108340b17c9a2b74.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/480c34163ac2f64c108340b17c9a2b74.png)'
- en: If WASM WASI were truly ready and useful, everyone would already be using it.
    The fact that we keep seeing these headlines suggests it’s not yet ready. In other
    words, they wouldn’t need to keep insisting that WASM WASI is ready if it really
    were.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 WASM WASI 真的是已经准备好并且有用，大家早就已经在使用它了。我们不断看到这些标题，表明它还没有准备好。换句话说，如果 WASM WASI
    真的是准备好的，他们就不需要一直坚持说它准备好了。
- en: 'As of WASI Preview 1, here is how things stand: You can access some file operations,
    environment variables, and have access to time and random number generation. However,
    there is no support for networking.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 WASI Preview 1，情况如下：你可以访问某些文件操作、环境变量，并能访问时间和随机数生成。然而，尚不支持网络功能。
- en: WASM WASI *might* be useful for certain AWS Lambda-style web services, but even
    that’s uncertain. Because wouldn’t you prefer to compile your Rust code natively
    and run twice as fast at half the cost compared to WASM WASI?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: WASM WASI *可能* 对某些类似 AWS Lambda 风格的 Web 服务有用，但即便如此也不确定。因为如果 WASM WASI 真的有用，你不想将你的
    Rust 代码本地编译并以比 WASM WASI 快两倍且成本减半的方式运行吗？
- en: Maybe WASM WASI is useful for plug ins and extensions. In genomics, I have a
    Rust extension for Python, which I compile for 25 different combinations (5 versions
    of Python across 5 OS targets). Even with that, I don’t cover every possible OS
    and chip family. Could I replace those OS targets with WASM WASI? No, it would
    be too slow. Could I add WASM WASI as a sixth “catch-all” target? Maybe, but if
    I really need portability, I’m already required to support Python and should just
    use Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 也许 WASM WASI 对插件和扩展有用。在基因组学中，我有一个为 Python 编写的 Rust 扩展，我为 25 个不同的组合（5 个 Python
    版本跨 5 个操作系统目标）编译它。即便如此，我也没有覆盖所有可能的操作系统和芯片系列。我能用 WASM WASI 替换这些操作系统目标吗？不行，它会太慢。我可以将
    WASM WASI 作为第六个“万用”目标吗？也许可以，但如果我真的需要可移植性，我已经需要支持 Python，最好直接使用 Python。
- en: So, what is WASM WASI good for? Right now, its main value lies in being a step
    toward running code in the browser or on embedded systems.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，WASM WASI 到底有什么用呢？现在，它的主要价值在于它是朝着在浏览器或嵌入式系统上运行代码迈出的一步。
- en: 'Rule 2: Understand Rust targets.'
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 2：了解 Rust 目标。
- en: In Rule 1, I mentioned “OS targets” in passing. Let’s look deeper into Rust
    targets — essential information not just for WASM WASI, but also for general Rust
    development.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则 1 中，我稍微提到过“操作系统目标”。现在，让我们更深入地了解 Rust 目标——这是关于 WASM WASI 的关键信息，也适用于一般的 Rust
    开发。
- en: 'On my Windows machine, I can compile a Rust project to run on Linux or macOS.
    Similarly, from a Linux machine, I can compile a Rust project to target Windows
    or macOS. Here are the commands I use to add and check the Linux target to a Windows
    machine:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 Windows 机器上，我可以将 Rust 项目编译为在 Linux 或 macOS 上运行。同样，从 Linux 机器上，我也可以将 Rust
    项目编译为目标 Windows 或 macOS。以下是我用来在 Windows 机器上添加和检查 Linux 目标的命令：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Aside: While `cargo check` verifies that the code compiles, building a fully
    functional executable requires additional tools. To cross-compile from Windows
    to Linux (GNU), you’ll also need to install the Linux GNU C/C++ compiler and the
    corresponding toolchain. That can be tricky. Fortunately, for the WASM targets
    we care about, the required toolchain is easy to install.'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁白：虽然 `cargo check` 可以验证代码是否编译成功，但构建一个完全功能的可执行文件还需要额外的工具。要从 Windows 编译到 Linux（GNU），你还需要安装
    Linux GNU 的 C/C++ 编译器和相应的工具链。这可能会有些棘手。幸运的是，对于我们关心的 WASM 目标，所需的工具链是很容易安装的。
- en: 'To see all the targets that Rust supports, use the command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Rust 支持的所有目标，请使用以下命令：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It will list over 200 targets including `x86_64-unknown-linux-gnu`, `wasm32-wasip1`,
    and `wasm32-unknown-unknown`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它将列出超过 200 个目标，包括 `x86_64-unknown-linux-gnu`、`wasm32-wasip1` 和 `wasm32-unknown-unknown`。
- en: 'Target names contain up to four parts: CPU family, vendor, OS, and environment
    (for example, GNU vs LVMM):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目标名称包含最多四个部分：CPU 系列、厂商、操作系统和环境（例如，GNU 与 LVMM）：
- en: '![](../Images/106509d86795e2a7eb85e55a4162ad49.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/106509d86795e2a7eb85e55a4162ad49.png)'
- en: Target Name parts — figure from author
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目标名称部分 — 图示来自作者
- en: Now that we understand something of targets, let’s go ahead and install the
    one we need for WASM WASI.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对目标有所了解，让我们继续安装我们需要的 WASM WASI 目标。
- en: 'Rule 3: Install the wasm32-wasip1 target and WASMTIME, then create “Hello,
    WebAssembly!”.'
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 3：安装 wasm32-wasip1 目标和 WASMTIME，然后创建“Hello, WebAssembly！”。
- en: To run our Rust code on WASM outside of a browser, we need to target `wasm32-wasip1`
    (32-bit WebAssembly with WASI Preview 1). We’ll also install WASMTIME, a runtime
    that allows us to run WebAssembly modules outside of the browser, using WASI.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在浏览器外运行我们的 Rust 代码，我们需要针对 `wasm32-wasip1`（具有 WASI Preview 1 的 32 位 WebAssembly）进行编译。我们还将安装
    WASMTIME，这是一个运行时，允许我们在浏览器外使用 WASI 运行 WebAssembly 模块。
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To test our setup, let’s create a new “Hello, WebAssembly!” Rust project using
    `cargo new`. This initializes a new Rust package:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的设置，让我们使用 `cargo new` 创建一个新的“Hello, WebAssembly!” Rust 项目。这将初始化一个新的 Rust
    包：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Edit `src/main.rs` to read:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `src/main.rs` 使其如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Aside: We’ll look deeper into the `#[cfg(...)]` attribute, which enables conditional
    compilation, in Rule 4.'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：我们将在规则 4 中更深入地研究 `#[cfg(...)]` 属性，它支持条件编译。
- en: Now, run the project with `cargo run`, and you should see `Hello, world!` printed
    to the console.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行项目命令 `cargo run`，你应该看到 `Hello, world!` 被打印到控制台。
- en: Next, create a `.cargo/config.toml` file, which specifies how Rust should run
    and test the project when targeting WASM WASI.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `.cargo/config.toml` 文件，指定当目标为 WASM WASI 时，Rust 应如何运行和测试该项目。
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Aside: This `.cargo/config.toml` file is different from the main `Cargo.toml`
    file, which defines your project’s dependencies and metadata.'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附注：这个 `.cargo/config.toml` 文件不同于主 `Cargo.toml` 文件，后者定义了项目的依赖项和元数据。
- en: 'Now, if you say:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你说：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see `Hello, WebAssembly!`. Congratulations! You’ve just successfully
    run some Rust code in the container-like WASM WASI environment.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到 `Hello, WebAssembly!`。恭喜！你刚刚成功地在类似容器的 WASM WASI 环境中运行了一些 Rust 代码。
- en: 'Rule 4: Understand conditional compilation.'
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 4：理解条件编译。
- en: 'Now, let’s investigate `#[cfg(...)]`—an essential tool for conditionally compiling
    code in Rust. In Rule 3, we saw:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们研究 `#[cfg(...)]` —— 这是 Rust 中用于条件编译代码的一个重要工具。在规则 3 中，我们看到：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `#[cfg(...)]` lines tell the Rust compiler to include or exclude certain
    code items based on specific conditions. A “code item” refers to a unit of code
    such as a function, statement, or expression.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`#[cfg(...)]` 行告诉 Rust 编译器根据特定条件包含或排除某些代码项。“代码项”指的是代码单元，如函数、语句或表达式。'
- en: 'With `#[cfg(…)]` lines, you can conditionally compile your code. In other words,
    you can create different versions of your code for different situations. For example,
    when compiling for the `wasm32` target, the compiler ignores the `#[cfg(not(target_arch
    = "wasm32"))]` block and only includes the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `#[cfg(…)]` 行，你可以条件性地编译你的代码。换句话说，你可以为不同的情况创建不同版本的代码。例如，当为 `wasm32` 目标编译时，编译器会忽略
    `#[cfg(not(target_arch = "wasm32"))]` 块，只包含以下内容：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You specify conditions via expressions, for example, `target_arch = "wasm32"`.
    Supported keys include `target_os` and `target_arch`. See the Rust Reference for
    [the full list](https://doc.rust-lang.org/reference/conditional-compilation.html#set-configuration-options)
    of supported keys. You can also create expressions with Cargo features, which
    we will learn about in Rule 6.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过表达式指定条件，例如 `target_arch = "wasm32"`。支持的键包括 `target_os` 和 `target_arch`。请参阅
    Rust 参考文档中的[完整列表](https://doc.rust-lang.org/reference/conditional-compilation.html#set-configuration-options)的支持键。你还可以使用
    Cargo 特性创建表达式，我们将在规则 6 中学习。
- en: 'You may combine expressions with the logical operators `not`, `any`, and `all`.
    Rust’s conditional compilation doesn’t use traditional `if...then...else` statements.
    Instead, you must use `#[cfg(...)]` and its negation to handle different cases:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用逻辑运算符 `not`、`any` 和 `all` 组合表达式。Rust 的条件编译不使用传统的 `if...then...else` 语句。相反，你必须使用
    `#[cfg(...)]` 及其否定来处理不同的情况：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To conditionally compile an entire file, place `#![cfg(...)]` at the top of
    the file. (Notice the “!”). This is useful when a file is only relevant for a
    specific target or configuration.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 若要条件性地编译整个文件，将 `#![cfg(...)]` 放置在文件的顶部。（注意“！”）。当文件仅与特定目标或配置相关时，这非常有用。
- en: You can also use `cfg` expressions in `Cargo.toml` to conditionally include
    dependencies. This allows you to tailor dependencies to different targets. For
    example, this says “depend on Criterion with Rayon when not targeting `wasm32`”.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `Cargo.toml` 中使用 `cfg` 表达式来条件性地包含依赖项。这使你能够根据不同的目标定制依赖项。例如，这表示“当不针对 `wasm32`
    时，依赖于 Criterion 和 Rayon”。
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Aside: For more information on using `cfg` expressions in `Cargo.toml`, see
    my article: [Nine Rust Cargo.toml Wats and Wat Nots](https://medium.com/towards-data-science/nine-rust-cargo-toml-wats-and-wat-nots-1e5e02e41648):
    Master Cargo.toml formatting rules and avoid frustration | *Towards Data Science
    (medium.com)*.'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附言：关于如何在 `Cargo.toml` 中使用 `cfg` 表达式的更多信息，请参见我的文章：[九个 Rust Cargo.toml 的注意事项与误区](https://medium.com/towards-data-science/nine-rust-cargo-toml-wats-and-wat-nots-1e5e02e41648)：掌握
    Cargo.toml 格式规则，避免沮丧 | *Towards Data Science (medium.com)*。
- en: 'Rule 5: Run regular tests but with the WASM WASI target.'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 5：定期运行测试，但使用 WASM WASI 目标。
- en: It’s time to try to run *your* project on WASM WASI. As described in Rule 3,
    create a `.cargo/config.toml` file for your project. It tells Cargo how to run
    and test your project on WASM WASI.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候尝试在 WASM WASI 上运行 *你的* 项目了。如规则 3 中所述，为你的项目创建一个 `.cargo/config.toml` 文件。它告诉
    Cargo 如何在 WASM WASI 上运行和测试你的项目。
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, [your project — like all good code — should already contain tests](https://doc.rust-lang.org/rust-by-example/testing.html).
    My `range-set-blaze` project includes, for example, this test:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，[你的项目——像所有优秀的代码一样——应该已经包含了测试](https://doc.rust-lang.org/rust-by-example/testing.html)。我的
    `range-set-blaze` 项目就包括了例如这样的测试：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s now attempt to run your project’s tests on WASM WASI. Use the following
    command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试在 WASM WASI 上运行你项目的测试。使用以下命令：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If this works, you may be done — but it probably won’t work. When I try this
    on `range-set-blaze`, I get this error message that complains about using Rayon
    on WASM.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这能正常工作，你可能就完成了——但它可能不会正常工作。当我在 `range-set-blaze` 上尝试时，我得到一个错误消息，抱怨在 WASM 上使用
    Rayon。
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To fix this error, we must first understand Cargo features.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个错误，我们必须首先理解 Cargo 特性。
- en: 'Rule 6: Understand Cargo features.'
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 6：了解 Cargo 特性。
- en: To resolve issues like the Rayon error in Rule 5, it’s important to understand
    how Cargo features work.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决规则 5 中的 Rayon 错误，理解 Cargo 特性的工作原理非常重要。
- en: 'In `Cargo.toml`, an optional `[features]` section allows you to define different
    configurations, or versions, of your project depending on which features are enabled
    or disabled. For example, here is a simplified part of the `Cargo.toml` file from
    the [Criterion benchmarking project](https://github.com/bheisler/criterion.rs/blob/master/Cargo.toml):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cargo.toml` 中，一个可选的 `[features]` 部分允许你根据启用或禁用的特性定义项目的不同配置或版本。例如，这是来自 [Criterion
    基准测试项目](https://github.com/bheisler/criterion.rs/blob/master/Cargo.toml) 的简化版
    `Cargo.toml` 文件的一部分：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This defines four Cargo features: `rayon`, `plotters`, `html_reports`, and
    `cargo_bench_support`. Since each feature can be included or excluded, these four
    features create 16 possible configurations of the project. Note also the special
    default Cargo feature.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了四个 Cargo 特性：`rayon`、`plotters`、`html_reports` 和 `cargo_bench_support`。由于每个特性可以被包含或排除，这四个特性会创建
    16 种可能的项目配置。还要注意特殊的默认 Cargo 特性。
- en: A Cargo feature can include other Cargo features. In the example, the special
    `default` Cargo feature includes three other Cargo features — `rayon`, `plotters`,
    and `cargo_bench_support`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Cargo 特性可以包含其他 Cargo 特性。在这个例子中，特殊的 `default` Cargo 特性包含了三个其他 Cargo 特性——`rayon`、`plotters`
    和 `cargo_bench_support`。
- en: A Cargo feature can include a dependency. The `rayon` Cargo feature above includes
    the `rayon` crate as a dependent package.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Cargo 特性可以包含一个依赖项。上面的 `rayon` Cargo 特性包含了 `rayon` crate 作为一个依赖包。
- en: 'Moreover, dependent packages may have their own Cargo features. For example,
    the `plotters` Cargo feature above includes the `plotters` dependent package with
    the following Cargo features enabled: `svg_backend`, `area_series`, and `line_series`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，依赖包可能有自己的 Cargo 特性。例如，上述 `plotters` Cargo 特性包含了 `plotters` 依赖包，并启用了以下 Cargo
    特性：`svg_backend`、`area_series` 和 `line_series`。
- en: 'You can specify which Cargo features to enable or disable when running `cargo
    check`, `cargo build`, `cargo run`, or `cargo test`. For instance, if you’re working
    on the Criterion project and want to check only the `html_reports` feature without
    any defaults, you can run:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定在运行 `cargo check`、`cargo build`、`cargo run` 或 `cargo test` 时启用或禁用哪些 Cargo
    特性。例如，如果你正在处理 Criterion 项目，并希望仅检查 `html_reports` 特性而不使用任何默认特性，你可以运行：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command tells Cargo not to include any Cargo features by default but to
    specifically enable the `html_reports` Cargo feature.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令告诉 Cargo 默认不包含任何 Cargo 特性，而是特别启用 `html_reports` Cargo 特性。
- en: 'Within your Rust code, you can include/exclude code items based on enabled
    Cargo features. The syntax uses `#cfg(…)`, as per Rule 4:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Rust 代码中，你可以根据启用的 Cargo 特性来包含/排除代码项。语法使用 `#cfg(…)`，遵循规则 4：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this understanding of Cargo features, we can now attempt to fix the `Rayon`
    error we encountered when running tests on WASM WASI.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对Cargo特性的理解，我们现在可以尝试修复在WASM WASI上运行测试时遇到的`Rayon`错误。
- en: 'Rule 7: Change the things you can: dependency issues by choosing Cargo features,
    64-bit/32-bit issues.'
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则7：改变你能改变的事情：通过选择Cargo特性来解决依赖问题，64位/32位问题。
- en: 'When we tried running `cargo test --target wasm32-wasip1`, part of the error
    message stated: `Criterion ... Rayon cannot be used when targeting wasi32\. Try
    disabling default features.` This suggests we should disable Criterion’s `rayon`
    Cargo feature when targeting WASM WASI.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行`cargo test --target wasm32-wasip1`时，错误信息的部分内容是：`Criterion ... Rayon
    cannot be used when targeting wasi32\. Try disabling default features.` 这表明我们应该在针对WASM
    WASI时禁用Criterion的`rayon` Cargo特性。
- en: 'To do this, we need to make two changes in our `Cargo.toml`. First, we need
    to disable the `rayon` feature from Criterion in the `[dev-dependencies]` section.
    So, this starting configuration:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要在`Cargo.toml`中进行两个更改。首先，我们需要在`[dev-dependencies]`部分禁用Criterion的`rayon`特性。所以，这个初始配置：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: becomes this, where we explicitly turn off the default features for Criterion
    and then enable all the Cargo features except `rayon`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 变成这样，我们显式地关闭了Criterion的默认特性，然后启用了除了`rayon`以外的所有Cargo特性。
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, to ensure `rayon` is still used for non-WASM targets, we add it back
    in with a conditional dependency in `Cargo.toml` as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了确保`rayon`在非WASM目标下仍然可用，我们通过在`Cargo.toml`中添加条件依赖来将其重新启用，如下所示：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In general, when targeting WASM WASI, you may need to modify your dependencies
    and their Cargo features to ensure compatibility. Sometimes this process is straightforward,
    but other times it can be challenging — or even impossible, as we’ll discuss in
    Rule 8.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当目标是WASM WASI时，你可能需要修改依赖项及其Cargo特性以确保兼容性。有时这个过程很简单，但有时也会充满挑战——甚至是无法解决的，正如我们将在第8条规则中讨论的那样。
- en: 'Aside: In the [third article](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)
    in this series — about `no_std` and embedded — we go deeper into strategies for
    fixing dependencies.'
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁注：在本系列的[第三篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)中——关于`no_std`和嵌入式——我们深入探讨了修复依赖项的策略。
- en: After running the tests again, we move past the previous error, only to encounter
    a new one, which is progress!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次运行测试后，我们越过了之前的错误，遇到了一个新的错误，这也算是进步！
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The compiler complains that `u32::MAX as usize + 1` overflows. On 64-bit Windows
    the expression doesn’t overflow because `usize` is the same as `u64` and can hold
    `u32::MAX as usize + 1`. WASM, however, is a 32-bit environment so `usize` is
    the same as `u32` and the expression is one too big.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器抱怨`u32::MAX as usize + 1`溢出。在64位Windows上，这个表达式不会溢出，因为`usize`与`u64`相同，能够容纳`u32::MAX
    as usize + 1`。然而，WASM是一个32位环境，所以`usize`与`u32`相同，导致表达式超出了限制。
- en: The fix here is to replace `usize` with `u64`, ensuring that the expression
    doesn’t overflow. More generally, the compiler won’t always catch these issues,
    so it’s important to review your use of `usize` and `isize`. If you’re referring
    to the size or index of a Rust data structure, `usize` is correct. However, if
    you’re dealing with values that exceed 32-bit limits, you should use `u64` or
    `i64`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的修复是将`usize`替换为`u64`，确保表达式不会溢出。更一般来说，编译器不会总是捕捉到这些问题，因此审查你使用`usize`和`isize`是很重要的。如果你在引用Rust数据结构的大小或索引，`usize`是正确的。然而，如果你处理的是超过32位限制的值，应该使用`u64`或`i64`。
- en: '**Aside**: In a 32-bit environment, a Rust array, `Vec`, `BTreeSet`, etc.,
    can theoretically hold up to 2³²−1 = 4,294,967,295 elements. However, this is
    only a theoretical limit based on addressable memory.'
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**旁注**：在32位环境中，Rust数组、`Vec`、`BTreeSet`等理论上可以容纳最多2³²−1 = 4,294,967,295个元素。然而，这只是基于可寻址内存的理论限制。'
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Aside Aside**: The actual maximum number of elements is even more limited.
    [Rust limits our allocations to an](https://doc.rust-lang.org/std/primitive.pointer.html#method.offset)
    `[isize](https://doc.rust-lang.org/std/primitive.pointer.html#method.offset)`,
    so 2³¹−1 (about 2 billion) bytes. If each element is, for example, 2 bytes, we
    can have at most about 1 billion elements.'
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**旁注 旁注**：实际的最大元素数量更加有限。[Rust将我们的分配限制为](https://doc.rust-lang.org/std/primitive.pointer.html#method.offset)一个`[isize](https://doc.rust-lang.org/std/primitive.pointer.html#method.offset)`，因此是2³¹−1（大约20亿）字节。如果每个元素是例如2字节，我们最多可以有约10亿个元素。'
- en: So, we’ve fixed the dependency issue and addressed a `usize` overflow. But can
    we fix everything? Unfortunately, the answer is no.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们修复了依赖项问题并解决了`usize`溢出问题。但是，我们能修复所有问题吗？不幸的是，答案是否定的。
- en: 'Rule 8: Accept that you cannot change everything: Networking, Tokio, Rayon,
    etc.'
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 8：接受你不能改变所有东西：网络、Tokio、Rayon 等等。
- en: WASM WASI Preview 1 (the current version) supports file access (within a specified
    directory), reading environment variables, and working with time and random numbers.
    However, its capabilities are limited compared to what you might expect from a
    full operating system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: WASM WASI Preview 1（当前版本）支持文件访问（在指定的目录内）、读取环境变量、以及处理时间和随机数。然而，与你期望的完整操作系统相比，它的功能是有限的。
- en: If your project requires access to networking, asynchronous tasks with Tokio,
    or multithreading with Rayon, Unfortunately, these features aren’t supported in
    Preview 1.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目需要访问网络、使用 Tokio 进行异步任务，或使用 Rayon 进行多线程操作，不幸的是，这些功能在 Preview 1 版本中不被支持。
- en: Fortunately, WASM WASI Preview 2 is expected to improve upon these limitations,
    offering more features, including better support for networking and possibly asynchronous
    tasks.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，预计 WASM WASI Preview 2 将在这些限制方面有所改进，提供更多功能，包括更好的网络支持，甚至可能支持异步任务。
- en: 'Rule 9: Add WASM WASI to your CI (continuous integration) tests.'
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 9：将 WASM WASI 添加到你的 CI（持续集成）测试中。
- en: 'So, your tests pass on WASM WASI, and your project runs successfully. Are you
    done? Not quite. Because, as I like to say:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你的测试在 WASM WASI 上通过了，项目也成功运行。就这样结束了吗？还不完全。因为，正如我喜欢说的：
- en: If it’s not in CI, it doesn’t exist.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它不在 CI 中，那就意味着它不存在。
- en: Continuous integration (CI) is a system that can automatically run your tests
    every time you update your code, ensuring that your code continues to work as
    expected. By adding WASM WASI to your CI, you can guarantee that future changes
    won’t break your project’s compatibility with the WASM WASI target.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（CI）是一种系统，它可以在你每次更新代码时自动运行测试，确保你的代码按预期继续工作。通过将 WASM WASI 集成到 CI 中，你可以确保未来的更改不会破坏你的项目与
    WASM WASI 目标的兼容性。
- en: 'In my case, my project is hosted on GitHub, and I use GitHub Actions as my
    CI system. Here’s the configuration I added to `.github/workflows/ci.yml` to test
    my project on WASM WASI:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我的项目托管在 GitHub 上，使用 GitHub Actions 作为 CI 系统。以下是我添加到 `.github/workflows/ci.yml`
    中的配置，用来在 WASM WASI 上测试我的项目：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By integrating WASM WASI into CI, I can confidently add new code to my project.
    CI will automatically test that all my code continues to support WASM WASI in
    the future.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 WASM WASI 集成到 CI 中，我可以自信地向我的项目中添加新代码。CI 会自动测试我的所有代码，确保它在未来仍然支持 WASM WASI。
- en: 'So, there you have it — nine rules for porting your Rust code to WASM WASI.
    Here is what surprised me about porting to WASM WASI:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，事情就是这样 —— 将 Rust 代码移植到 WASM WASI 的九条规则。这里是我在移植到 WASM WASI 时的惊讶之处：
- en: '**The Bad:**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**缺点：**'
- en: Running on WASM WASI offers little utility today. It, however, holds the potential
    to be useful tomorrow.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前在 WASM WASI 上运行的实用性较低。然而，它有潜力在未来变得有用。
- en: 'In Rust, there’s a common saying: “If it compiles, it works.” Unfortunately,
    this doesn’t always hold true for WASM WASI. If you use an unsupported feature,
    like networking, the compiler won’t catch the error. Instead, it will fail at
    runtime. For example, this code compiles and runs on WASM WASI but always returns
    an error because networking isn’t supported.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rust 中，有一句常见的说法：“如果它能编译，就说明它能工作。” 不幸的是，这对于 WASM WASI 并不总是成立。如果你使用了一个不被支持的特性，比如网络功能，编译器不会捕捉到错误。相反，它会在运行时失败。例如，这段代码在
    WASM WASI 上能编译并运行，但由于不支持网络功能，它总是返回错误。
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**The Good:**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点：**'
- en: Running on WASM WASI is a good first step toward [running your code in the browser](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1)
    and on embedded systems.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 WASM WASI 上运行是朝着在 [浏览器中运行代码](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1)
    和嵌入式系统上运行迈出的第一步。
- en: You can run Rust code on WASM WASI without needing to port to `no_std`. (Porting
    to `no_std` is the topic of the [third article](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)
    of this series.)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 WASM WASI 上运行 Rust 代码，而不需要移植到 `no_std`。（移植到 `no_std` 是本系列的 [第三篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)
    讨论的话题。）
- en: You can run standard Rust tests on WASM WASI, making it easy to verify your
    code.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 WASM WASI 上运行标准的 Rust 测试，这使得验证你的代码变得容易。
- en: The `.cargo/config.toml` file and Rust’s `--target` option make it incredibly
    straightforward to configure and run your code on different targets—including
    WASM WASI.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cargo/config.toml` 文件和 Rust 的 `--target` 选项使得在不同的目标平台上配置和运行代码变得异常简单，包括 WASM
    WASI。'
- en: Stay tuned! In [the next article](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1),
    you’ll see how to port your Rust code to run on WASM in the browser — an ability
    I find super useful. After that, the [final article](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)
    will explain porting code to embedded systems, which I find incredibly cool.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 敬请关注！在[下一篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1)中，你将看到如何将Rust代码移植到浏览器中的WASM运行——这项能力我觉得非常有用。之后，[最后一篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)将讲解如何将代码移植到嵌入式系统，我觉得这非常酷。
- en: '*Aside:* Interested in future articles? *Please* [*follow me on Medium*](https://medium.com/@carlmkadie)*.
    I write about Rust and Python, scientific programming, machine learning, and statistics.
    I tend to write about one article per month.*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*附注：* 对未来的文章感兴趣吗？*请* [*在Medium上关注我*](https://medium.com/@carlmkadie)*。我写关于Rust和Python、科学编程、机器学习和统计学的文章。我通常每月写一篇文章。*'

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Practical Computer Simulations for Product Analysts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Practical Computer Simulations for Product Analysts</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/practical-computer-simulations-for-product-analysts-fe61e2b577f5?source=collection_archive---------8-----------------------#2024-05-24">https://towardsdatascience.com/practical-computer-simulations-for-product-analysts-fe61e2b577f5?source=collection_archive---------8-----------------------#2024-05-24</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="ba97" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Part 3: Modelling Ops queues</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://miptgirl.medium.com/?source=post_page---byline--fe61e2b577f5--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Mariya Mansurova" class="l ep by dd de cx" src="../Images/b1dd377b0a1887db900cc5108bca8ea8.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*7fFHr8XBAuR_SgJknIyODA.png"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--fe61e2b577f5--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://miptgirl.medium.com/?source=post_page---byline--fe61e2b577f5--------------------------------" rel="noopener follow">Mariya Mansurova</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--fe61e2b577f5--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">23 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">May 24, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">2</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div></div></div><div class="mj"><div class="ab cb"><div class="lm mk ln ml lo mm cf mn cg mo ci bh"><figure class="ms mt mu mv mw mj mx my paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq mr"><img src="../Images/71a5c5982659d4e38fd756c9ae246157.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*Xmn9BZIEDQdiPyJ72ojenw.jpeg"/></div></div><figcaption class="ne nf ng mp mq nh ni bf b bg z dx">Image by DALL-E 3</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="d8d3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Today, I would like to show you an example of the discrete-event simulation approach. We will model the Customer Support team and decide what strategy to use to improve its performance. But first, let me share a bit of my personal story.</p><p id="f3f1" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">I first learned about discrete simulations at university. One of my subjects was <a class="af of" href="https://en.wikipedia.org/wiki/Queueing_theory" rel="noopener ugc nofollow" target="_blank">Queueing theory</a>, and to get a final grade for it, I had to implement the airport simulation and calculate some KPIs. Unfortunately, I missed all the seminars because I was already working full-time, so I had no idea about the theory behind this topic and how to approach it.</p><p id="6978" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">I was determined to get an excellent mark, so I found a book, read it, understood the basics and spent a couple of evenings on implementation. It was pretty challenging since I hadn’t been coding for some time, but I figured it out and got my A grade.</p><p id="ffaf" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">At this point (as often happens with students), I had a feeling that this information wouldn't be helpful for my future work. However, later, I realised that many analytical tasks can be solved with this approach. So, I would like to share it with you.</p><p id="c507" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">One of the most apparent use cases for agent-based simulations is Operational analytics. Most products have customer support where clients can get help. A CS team often looks at such metrics as:</p><ul class=""><li id="d372" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk"><strong class="nl fr"><em class="oj">average resolution time</em></strong> — how much time passed from the customer reaching out to CS and getting the first answer,</li><li id="b3f8" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><strong class="nl fr"><em class="oj">size of the queue</em></strong> that shows how many tasks we have in a backlog right now.</li></ul><p id="5e10" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Without a proper model, it may be tricky to understand how our changes (i.e. introducing night shifts or just increasing the number of agents) will affect the KPIs. Simulations will help us do it.</p><p id="f723" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">So, let’s not waste our time and move on.</p><h1 id="7eea" class="op oq fq bf or os ot gq ou ov ow gt ox oy oz pa pb pc pd pe pf pg ph pi pj pk bk">Basics of simulations and modelling</h1><p id="d908" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">Let’s start from the very beginning. We will be modelling<em class="oj"> </em><strong class="nl fr"><em class="oj">the system</em></strong>. The system is a collection of entities (for example, people, servers or even mechanical tools) that interact with each other to achieve some logical goal (i.e. answering a customer question or passing border control in an airport).</p><p id="1bc6" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">You could define the system with the needed granularity level, depending on your research goal. For example, in our case, we would like to investigate how the changes to agents’ efficiency and schedules could affect average CS ticket resolution time. So, the system will be just a set of agents. However, if we would like to model the possibility of outsourcing some tickets to different outsourcing companies, we will need to include these partners in our model.</p><p id="d0cd" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The system is described by a set of variables — for example, the number of tickets in a queue or the number of agents working at the moment in time. These variables define <strong class="nl fr"><em class="oj">the system state</em></strong>.</p><p id="428f" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">There are two types of systems:</p><ul class=""><li id="6104" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk"><strong class="nl fr"><em class="oj">discrete</em></strong><em class="oj"> — </em>when the system state changes instantaneously, for example, the new ticket has been added to a queue or an agent has finished their shift.</li><li id="6127" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><strong class="nl fr"><em class="oj">continuous — </em></strong>when the system is constantly evolving<em class="oj">. </em>One such example is a flying plane, in which coordinates, velocity, height, and other parameters change all the time during flight.</li></ul><p id="9d08" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">For our task, we can treat the system as discrete and use <strong class="nl fr"><em class="oj">the</em></strong><em class="oj"> </em><strong class="nl fr"><em class="oj">discrete-event simulation approach</em></strong>. It's a case when the system can change at only a countable number of points in time. These time points are where events occur and instantly change the system state.</p><p id="51c4" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">So, the whole approach is based on events. We will generate and process events one by one to simulate how the system works. We can use the concept of a timeline to structure events.</p><p id="92ca" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Since this process is dynamic, we need to keep track of the current value of simulated time and be able to advance it from one value to another. The variable in a simulation model that shows the current time is often called <strong class="nl fr"><em class="oj">the simulation clock</em></strong>.</p><p id="1af5" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We also need a mechanism to advance simulated time. There are two approaches to advance time:</p><ul class=""><li id="a4e4" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk"><strong class="nl fr"><em class="oj">next-event time advance</em></strong> — we are moving from one event timestamp to the next one,</li><li id="faa9" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><strong class="nl fr"><em class="oj">fixed-increment time advance</em></strong> — we select the period, for example, 1 minute, and shift clocks each time for this period.</li></ul><p id="4e73" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">I think the first approach is easier to understand, implement and debug. So, I will stick to it for this article.</p><p id="9567" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let's review a simple example to understand how it works. We will discuss a simplified case of the CS tickets queue.</p><p id="8e48" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We start the simulation, initialising the simulation clock. Sometimes, people use zero as the initial value. I prefer to use real-life data and the actual date times.</p><p id="10fb" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Here's the initial state of our system. We have two events on our timeline related to two incoming customer requests.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq pq"><img src="../Images/dd95b05f1a22997ef9e856012f5d64c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3WAFyOR5SKmdOVsB4h60Kg.png"/></div></div></figure><p id="f78d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The next step is to advance the simulation clock to the first event on our timeline — the customer request at 9:15.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq pr"><img src="../Images/31f4bc945689d456b0ed1715677cc691.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-l9f7IDPkEONput4ayEAkQ.png"/></div></div></figure><p id="e4a3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It's time to process this event. We should find an agent to work on this request, assign the request to them, and generate an event to finish the task. Events are the main drivers of our simulation, so it's okay if one event creates another one.</p><p id="1bab" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Looking at the updated timeline, we can see that the most imminent event is not the second customer request but the completion of the first task.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq ps"><img src="../Images/39e090293ad9228610e4c0829fc9c08c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2hxHKm9xitCZIOe2HF3XbQ.png"/></div></div></figure><p id="d687" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">So, we need to advance our clock to 9:30 and process the next event. The completion of the request won't create new events, so after that, we will move to the second customer request.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq pt"><img src="../Images/cef08b7308d87f030a8239ecdf7ccdd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u92w-3YzNVTsX396LHoRdg.png"/></div></div></figure><p id="9c80" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We will repeat this process of moving from one event to another until the end of the simulation.</p><p id="05c7" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">To avoid never-ending processes, we need to define the stopping criteria. In this case, we can use the following logic: if no more events are on the timeline, we should stop the simulation. In this simplified example, our simulation will stop after finishing the second task.</p><p id="a548" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We've discussed the theory of discrete event simulations and understood how it works. Now, it's time to practice and implement this approach in code.</p><h1 id="1cd2" class="op oq fq bf or os ot gq ou ov ow gt ox oy oz pa pb pc pd pe pf pg ph pi pj pk bk">The program architecture</h1><h2 id="f1b7" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Objective-oriented programming</h2><p id="44fe" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">In my day-to-day job, I usually use a procedural programming paradigm. I create functions for some repetitive tasks, but rather than that, my code is quite linear. It's pretty standard approach for data-wrangling tasks.</p><p id="e872" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In this example, we would use <a class="af of" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank">Objective-Oriented Programming</a>. So, let's spend some time revising this topic if you haven’t used classes in Python before or need a refresher.</p><p id="8f85" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">OOP is based on the concept of objects. Objects consist of data (some features that are called attributes) and actions (functions or methods). The whole program describes the interactions between different objects. For example, if we have an object representing a CS agent, it can have the following properties:</p><ul class=""><li id="4dc9" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk"><strong class="nl fr"><em class="oj">attributes</em></strong>: name, date when an agent started working, average time they spend on tasks or current status (<code class="cx ql qm qn qo b">"out of office"</code>, <code class="cx ql qm qn qo b">"working on task"</code> or <code class="cx ql qm qn qo b">"free"</code>).</li><li id="f84d" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><strong class="nl fr"><em class="oj">methods</em></strong>: return the name, update the status or start processing a customer request.</li></ul><p id="901a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">To represent such an object, we can use Python classes. Let's write a simple class for a CS agent.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="2b19" class="qs oq fq qo b bg qt qu l qv qw">class CSAgent:<br/>  # initialising class<br/>  def __init__(self, name, average_handling_time):<br/>      # saving parameters mentioned during object creation<br/>      self.name = name  <br/>      self.average_handling_time = average_handling_time<br/>      # specifying constant value<br/>      self.role = 'CS agent'<br/>      print('Created %s with name %s' % (self.role, self.name))<br/><br/>  def get_name(self):<br/>    return self.name<br/><br/>  def get_handling_time(self):<br/>    return self.average_handling_time<br/><br/>  def update_handling_time(self, average_handling_time):<br/>    print('Updating time from %.2f to %.2f' % (self.average_handling_time, <br/>      average_handling_time))<br/>    self.average_handling_time = average_handling_time</span></pre><p id="2be4" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This class defines each agent's name, average handling time, and role. I've also added a couple of functions that can return internal variables following the incapsulation pattern. Also, we have the <code class="cx ql qm qn qo b">update_handling_time</code> function that allows us to update the agent’s performance.</p><p id="84ae" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We've created a class (an object that explains any kind of CS agent). Let's make an instance of the object — the agent John Doe.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="6071" class="qs oq fq qo b bg qt qu l qv qw">john_agent = CSAgent('John Doe', 12.3)<br/># Created CS agent with name John Doe</span></pre><p id="6580" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">When we created an instance of the class, the function <code class="cx ql qm qn qo b">__init__</code> was executed. We can use <code class="cx ql qm qn qo b">__dict__</code> property to present class fields as a dictionary. It often can be handy, for example, if you want to convert a list of objects into a data frame.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="5367" class="qs oq fq qo b bg qt qu l qv qw">print(john_agent.__dict__)<br/># {'name': 'John Doe', 'average_handling_time': 12.3, 'role': 'CS agent'}</span></pre><p id="b1c5" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We can try to execute a method and update the agent’s performance.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="4e32" class="qs oq fq qo b bg qt qu l qv qw">john_agent.update_handling_time(5.4)<br/># Updating time from 12.30 to 5.40<br/><br/>print(john_agent.get_handling_time())<br/># 5.4</span></pre><p id="aba4" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">One of the fundamental concepts of OOP that we will use today is inheritance. Inheritance allows us to have a high-level ancestor class and use its features in the descendant classes. Imagine we want to have not only CS agents but also KYC agents. We can create a high-level <code class="cx ql qm qn qo b">Agent</code> class with common functionality and define it only once for both KYC and CS agents.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="9910" class="qs oq fq qo b bg qt qu l qv qw">class Agent:<br/>  # initialising class<br/>  def __init__(self, name, average_handling_time, role):<br/>    # saving parameters mentioned during object creation<br/>    self.name = name  <br/>    self.average_handling_time = average_handling_time<br/>    self.role = role<br/>    print('Created %s with name %s' % (self.role, self.name))<br/><br/>  def get_name(self):<br/>    return self.name<br/><br/>  def get_handling_time(self):<br/>    return self.average_handling_time<br/><br/>  def update_handling_time(self, average_handling_time):<br/>    print('Updating time from %.2f to %.2f' % (self.average_handling_time, <br/>      average_handling_time))<br/>    self.average_handling_time = average_handling_time</span></pre><p id="4054" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Now, we can create separate classes for these agent types and define slightly different <code class="cx ql qm qn qo b">__init__</code> and <code class="cx ql qm qn qo b">get_job_description</code> functions.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="b454" class="qs oq fq qo b bg qt qu l qv qw">class KYCAgent(Agent):<br/>  def __init__(self, name, average_handling_time):<br/>    super().__init__(name, average_handling_time, 'KYC agent')<br/><br/>  def get_job_description(self):<br/>    return 'KYC (Know Your Customer) agents help to verify documents'<br/><br/>class CSAgent(Agent):<br/>  def __init__(self, name, average_handling_time):<br/>    super().__init__(name, average_handling_time, 'CS agent')<br/><br/>  def get_job_description(self):<br/>    return 'CS (Customer Support) answer customer questions and help resolving their problems'</span></pre><p id="ecc0" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">To specify inheritance, we mentioned the base class in brackets after the current class name. With <code class="cx ql qm qn qo b">super()</code> , we can call the base class methods, for example, <code class="cx ql qm qn qo b">__init__</code> to create an object with a custom <code class="cx ql qm qn qo b">role</code> value.</p><p id="6aeb" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let's create objects and check whether they work as expected.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="dd0f" class="qs oq fq qo b bg qt qu l qv qw">marie_agent = KYCAgent('Marie', 25)<br/>max_agent = CSAgent('Max', 10)<br/><br/>print(marie_agent.__dict__)<br/># {'name': 'Marie', 'average_handling_time': 25, 'role': 'KYC agent'}<br/>print(max_agent.__dict__)<br/># {'name': 'Max', 'average_handling_time': 10, 'role': 'CS agent'}</span></pre><p id="0117" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let's update Marie's handling time. Even though we haven’t implemented this function in the <code class="cx ql qm qn qo b">KYCAgent</code> class, it uses the implementation from the base class and works quite well.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="1859" class="qs oq fq qo b bg qt qu l qv qw">marie_agent.update_handling_time(22.5)<br/># Updating time from 25.00 to 22.50</span></pre><p id="77e3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We can also call the methods we defined in the classes.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="410d" class="qs oq fq qo b bg qt qu l qv qw">print(marie_agent.get_job_description())<br/># KYC (Know Your Customer) agents help to verify documents<br/><br/>print(max_agent.get_job_description())<br/># CS (Customer Support) answer customer questions and help resolving their problems</span></pre><p id="233c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">So, we've covered the basics of the Objective-oriented paradigm and Python classes. I hope it was a helpful refresher.</p><p id="2326" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Now, it’s time to return to our task and the model we need for our simulation.</p><h2 id="66b6" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Architecture: classes</h2><p id="0165" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">If you haven’t used OOP a lot before, switching your mindset from procedures to objects might be challenging. It takes some time to make this mindset shift.</p><p id="f54c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">One of the life hacks is to use real-world analogies (i.e. it's pretty clear that an agent is an object with some features and actions).</p><p id="54ce" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Also, don't be afraid to make a mistake. There are better or worse program architectures: some will be easier to read and support over time. However, there are a lot of debates about the best practices, even among mature software engineers, so I wouldn’t bother trying to make it perfect too much for analytical ad-hoc research.</p><p id="2e98" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let's think about what objects we need in our simulation:</p><ul class=""><li id="72df" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk"><code class="cx ql qm qn qo b">System</code> — the most high-level concept we have in our task. The system will represent the current state and execute the simulation.</li><li id="bd3b" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">As we discussed before, the system is a collection of entities. So, the next object we need is <code class="cx ql qm qn qo b">Agent</code> . This class will describe agents working on tasks.</li><li id="4886" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">Each agent will have its schedule: hours when this agent is working, so I've isolated it into a separate class <code class="cx ql qm qn qo b">Schedule</code>.</li><li id="62c3" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">Our agents will be working on customer requests. So, it's a no-brainer— we need to represent them in our system. Also, we will store a list of processed requests in the <code class="cx ql qm qn qo b">System</code> object to get the final stats after the simulation.</li><li id="bba4" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">If no free agent picks up a new customer request, it will be put into a queue. So, we will have a <code class="cx ql qm qn qo b">RequestQueue</code> as an object to store all customer requests with the FIFO logic (First In, First Out).</li><li id="a1d9" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">The following important concept is <code class="cx ql qm qn qo b">TimeLine</code> that represents the set of events we need to process ordered by time.</li><li id="23b8" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">TimeLine</code> will include events, so we will also create a class <code class="cx ql qm qn qo b">Event</code> for them. Since we will have a bunch of different event types that we need to process differently, we can leverage the OOP inheritance. We will discuss event types in more detail in the next section.</li></ul><p id="aaca" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">That's it. I’ve put all the classes and links between them into a diagram to clarify it. I use such charts to have a high-level view of the system before starting the implementation — it helps to think about the architecture early on.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq qx"><img src="../Images/b29d63495089da7a70b25081a396022f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqRY9_evp9PzJXLTnYO-mw.png"/></div></div></figure><p id="b9a9" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">As you might have noticed, the diagram is not super detailed. For example, it doesn’t include all field names and methods. It's intentional. This schema will be used as a helicopter view to guide the development. So, I don't want to spend too much time writing down all the field and method names because these details might change during the implementation.</p><h2 id="911f" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Architecture: event types</h2><p id="c97f" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">We've covered the program architecture, and now it's time to think about the main drivers of our simulation — events.</p><p id="87ed" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let's discuss what events we need to generate to keep our system working.</p><ul class=""><li id="16c4" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk">The event I will start with is the "<em class="oj">Agent Ready</em>" event. It shows that an agent starts their work and is ready to pick up a task (if we have any waiting in the queue).</li><li id="684f" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">We need to know when agents start working. These working hours can depend on an agent and the day of the week. Potentially, we might even want to change the schedules during the simulation. It's pretty challenging to create all "<em class="oj">Agent Ready</em>" events when we initialise the system (especially since we don't know how much time we need to finish the simulation). So, I propose a recurrent "<em class="oj">Plan Agents Schedule</em>" event to create ready-to-work events for the next day.</li><li id="0dde" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">The other essential event we need is a "<em class="oj">New Customer Request</em>" — an event that shows that we got a new CS contact, and we need to either start working on it or put it in a queue.</li><li id="8d6d" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">The last event is "<em class="oj">Agent Finished Task</em>", which shows that the agent finished the task he was working on and is potentially ready to pick up a new task.</li></ul><p id="e999" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">That's it. These four events are enough to run the whole simulation.</p><p id="6413" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Similar to classes, there are no right or wrong answers for system modelling. You might use a slightly different set of events. For example, you can add a "<em class="oj">Start Task</em>" event to have it explicitly.</p><h1 id="196e" class="op oq fq bf or os ot gq ou ov ow gt ox oy oz pa pb pc pd pe pf pg ph pi pj pk bk">Implementation</h1><blockquote class="qy qz ra"><p id="fabc" class="nj nk oj nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">You can find the full implementation on <a class="af of" href="https://github.com/miptgirl/miptgirl_medium/blob/main/simulations/queue_simulation.ipynb" rel="noopener ugc nofollow" target="_blank">GitHub</a>.</p></blockquote><p id="5de2" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We've defined the high-level structure of our solution, so we are ready to start implementing it. Let’s start with the heart of our simulation — the system class.</p><h2 id="5c39" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Initialising the system</h2><p id="02ef" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">Let's start with the <code class="cx ql qm qn qo b">__init__</code> method for the system class.</p><p id="5e1e" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">First, let's think about the parameters we would like to specify for the simulation:</p><ul class=""><li id="7b04" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk"><code class="cx ql qm qn qo b">agents</code> — set of agents that will be working in the CS team,</li><li id="5812" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">queue</code> — the current queue of customer requests (if we have any),</li><li id="e6f0" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">initial_date</code> — since we agreed to use the actual timestamps instead of relative ones, I will specify the date when we start simulations,</li><li id="8842" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">logging</code> — flag that defines whether we would like to print some info for debugging,</li><li id="8adc" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">customer_requests_df</code> — data frame with information about the set of customer requests we would like to process.</li></ul><p id="abee" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Besides input parameters, we will also create the following internal fields:</p><ul class=""><li id="6643" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk"><code class="cx ql qm qn qo b">current_time</code> — the simulation clock that we will initialise as 00:00:00 of the initial date specified,</li><li id="b805" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">timeline</code> object that we will use to define the order of events,</li><li id="789b" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">processed_request</code> — an empty list where we will store the processed customer requests to get the data after simulation.</li></ul><p id="349d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It's time to take the necessary actions to initialise a system. There are only two steps left:</p><ul class=""><li id="b5d4" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk">Plan agents work for the first day. I’ll generate and process a corresponding event with an initial timestamp.</li><li id="37d0" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">Load customer requests by adding corresponding "<em class="oj">New Customer Request</em>" events to the timeline.</li></ul><p id="4d6a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Here's the code that does all these actions to initialise the system.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="747b" class="qs oq fq qo b bg qt qu l qv qw">class System:<br/>  def __init__(self, agents, queue, initial_date,<br/>  customer_requests_df, logging = True):<br/>    initial_time = datetime.datetime(initial_date.year, initial_date.month, <br/>      initial_date.day, 0, 0, 0)<br/>    self.agents = agents<br/>    self.queue = RequestQueue(queue)<br/>    self.logging = logging<br/>    self.current_time = initial_time<br/>    <br/>    self._timeline = TimeLine()<br/>    self.processed_requests = []<br/>  <br/>    initial_event = PlanScheduleEvent('plan_agents_schedule', initial_time)<br/>    initial_event.process(self)<br/>    self.load_customer_request_events(customer_requests_df)</span></pre><p id="7fc5" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It's not working yet since it has links to non-implemented classes and methods, but we will cover it all one by one.</p><h2 id="406d" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Timeline</h2><p id="004d" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">Let's start with the classes we used in the system definition. The first one is <code class="cx ql qm qn qo b">TimeLine</code> . The only field it has is the list of events. Also, it implements a bunch of methods:</p><ul class=""><li id="57bb" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk">adding events (and ensuring that they are ordered chronologically),</li><li id="4a88" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">returning the next event and deleting it from the list,</li><li id="cf46" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">telling how many events are left.</li></ul><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="1366" class="qs oq fq qo b bg qt qu l qv qw">class TimeLine:<br/>  def __init__(self):<br/>    self.events = []<br/><br/>  def add_event(self, event:Event):<br/>    self.events.append(event)<br/>    self.events.sort(key = lambda x: x.time)<br/>      <br/>  def get_next_item(self):<br/>    if len(self.events) == 0:<br/>      return None<br/>    return self.events.pop(0)<br/><br/>  def get_remaining_events(self):<br/>    return len(self.events)</span></pre><h2 id="563d" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Customer requests queue</h2><p id="7082" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">The other class we used in initialisation is <code class="cx ql qm qn qo b">RequestQueue</code>.</p><p id="fa16" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">There are no surprises: the request queue consists of customer requests. Let's start with this building block. We know each request's creation time and how much time an agent will need to work on it.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="b0aa" class="qs oq fq qo b bg qt qu l qv qw">class CustomerRequest:<br/>  def __init__(self, id, handling_time_secs, creation_time):<br/>    self.id = id<br/>    self.handling_time_secs = handling_time_secs<br/>    self.creation_time = creation_time<br/><br/>  def __str__(self):<br/>    return f'Customer Request {self.id}: {self.creation_time.strftime("%Y-%m-%d %H:%M:%S")}'</span></pre><p id="117f" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It's a simple data class that contains only parameters. The only new thing here is that I've overridden the <code class="cx ql qm qn qo b">__str__</code> method to change the output of a print function. It's pretty handy for debugging. You can compare it yourself.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="3d43" class="qs oq fq qo b bg qt qu l qv qw">test_object = CustomerRequest(1, 600, datetime.datetime(2024, 5, 1, 9, 42, 1))<br/># without defining __str__<br/>print(test_object)<br/># &lt;__main__.CustomerRequest object at 0x280209130&gt;<br/><br/># with custom __str__<br/>print(test_object)<br/># Customer Request 1: 2024-05-01 09:42:01</span></pre><p id="1c8d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Now, we can move on to the requests queue. Similarly to the timeline, we've implemented methods to add new requests, calculate requests in the queue and get the subsequent request from the queue.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="fe72" class="qs oq fq qo b bg qt qu l qv qw">class RequestQueue:<br/>  def __init__(self, queue = None):<br/>    if queue is None:<br/>      self.requests = []<br/>    else: <br/>      self.requests = queue<br/><br/>  def get_requests_in_queue(self):<br/>    return len(self.requests)<br/><br/>  def add_request(self, request):<br/>    self.requests.append(request)<br/><br/>  def get_next_item(self):<br/>    if len(self.requests) == 0:<br/>      return None<br/>    return self.requests.pop(0)</span></pre><h2 id="b442" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Agents</h2><p id="3c39" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">The other thing we need to initialise the system is agents. First, each agent has a schedule — a period when they are working depending on a weekday.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="65a8" class="qs oq fq qo b bg qt qu l qv qw">class Schedule:<br/>  def __init__(self, time_periods):<br/>    self.time_periods = time_periods<br/><br/>  def is_within_working_hours(self, dt):<br/>    weekday = dt.strftime('%A')<br/>    <br/>    if weekday not in self.time_periods:<br/>      return False<br/><br/>    hour = dt.hour<br/>    time_periods = self.time_periods[weekday]<br/>    for period in time_periods:<br/>      if (hour &gt;= period[0]) and (hour &lt; period[1]):<br/>        return True<br/>    return False</span></pre><p id="ffc3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The only method we have for a schedule is whether at the specified moment the agent is working or not.</p><p id="1a1c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let's define the agent class. Each agent will have the following attributes:</p><ul class=""><li id="9fed" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk"><code class="cx ql qm qn qo b">id</code> and <code class="cx ql qm qn qo b">name</code> — primarily for logging and debugging purposes,</li><li id="5ff0" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">schedule</code> — the agent’s schedule object we’ve just defined,</li><li id="c6ee" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">request_in_work</code> — link to customer request object that shows whether an agent is occupied right now or not.</li><li id="7204" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">effectiveness</code> — the coefficient that shows how efficient the agent is compared to the expected time to solve the particular task.</li></ul><p id="be9d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We have the following methods implemented for agents:</p><ul class=""><li id="3fb5" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk">understanding whether they can take on a new task (whether they are free and still working),</li><li id="4763" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">start and finish processing the customer request.</li></ul><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="828c" class="qs oq fq qo b bg qt qu l qv qw">class Agent:<br/>  def __init__(self, id, name, schedule, effectiveness = 1):<br/>    self.id = id<br/>    self.schedule = schedule<br/>    self.name = name<br/>    self.request_in_work = None<br/>    self.effectiveness = effectiveness<br/><br/>  def is_ready_for_task(self, dt):<br/>    if (self.request_in_work is None) and (self.schedule.is_within_working_hours(dt)):<br/>      return True<br/>    return False<br/><br/>  def start_task(self, customer_request):<br/>    self.request_in_work = customer_request<br/>    customer_request.handling_time_secs = int(round(self.effectiveness * customer_request.handling_time_secs))<br/><br/>  def finish_task(self):<br/>    self.request_in_work = None</span></pre><h2 id="22c9" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Loading initial customer requests to the timeline</h2><p id="df70" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">The only thing we are missing from the system <code class="cx ql qm qn qo b">__init__</code> function (besides the events processing that we will discuss in detail a bit later) is <code class="cx ql qm qn qo b">load_customer_request_events</code> function implementation. It's pretty straightforward. We just need to add it to our <code class="cx ql qm qn qo b">System</code> class.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="baa8" class="qs oq fq qo b bg qt qu l qv qw">class System:<br/>  def load_customer_request_events(self, df):<br/>    # filter requests before the start of simulation<br/>    filt_df = df[df.creation_time &gt;= self.current_time]<br/>    if filt_df.shape[0] != df.shape[0]:<br/>      if self.logging:<br/>        print('Attention: %d requests have been filtered out since they are outdated' % (df.shape[0] - filt_df.shape[0]))<br/><br/>    # create new customer request events for each record<br/>    for rec in filt_df.sort_values('creation_time').to_dict('records'):<br/>      customer_request = CustomerRequest(rec['id'], rec['handling_time_secs'], <br/>        rec['creation_time'])<br/><br/>      self.add_event(NewCustomerRequestEvent(<br/>        'new_customer_request', rec['creation_time'],<br/>         customer_request<br/>      ))</span></pre><p id="9d45" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Cool, we've figured out the primary classes. So, let's move on to the implementation of the events.</p><h2 id="161a" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Processing events</h2><p id="b8c4" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">As discussed, I will use the inheritance approach and create an <code class="cx ql qm qn qo b">Event</code> class. For now, it implements only <code class="cx ql qm qn qo b">__init__</code> and <code class="cx ql qm qn qo b">__str__</code> functions, but potentially, it can help us provide additional functionality for all events.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="3795" class="qs oq fq qo b bg qt qu l qv qw">class Event:<br/>  def __init__(self, event_type, time):<br/>    self.type = event_type<br/>    self.time = time<br/><br/>  def __str__(self):<br/>    if self.type == 'agent_ready_for_task':<br/>      return '%s (%s) - %s' % (self.type, self.agent.name, self.time)<br/>    return '%s - %s' % (self.type, self.time)</span></pre><p id="4825" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Then, I implement a separate subclass for each event type that might have a bit different initialisation. For example, for the <code class="cx ql qm qn qo b">AgentReady</code> event, we also have an <code class="cx ql qm qn qo b">Agent</code> object. More than that, each Event class implements <code class="cx ql qm qn qo b">process</code> method that takes <code class="cx ql qm qn qo b">system</code> as an input.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="5b1f" class="qs oq fq qo b bg qt qu l qv qw"><br/>class AgentReadyEvent(Event):<br/>  def __init__(self, event_type, time, agent):<br/>    super().__init__(event_type, time)<br/>    self.agent = agent<br/><br/>  def process(self, system: System):<br/>    # get next request from the queue<br/>    next_customer_request = system.queue.get_next_item()<br/><br/>    # start processing request if we had some<br/>    if next_customer_request is not None:<br/>      self.agent.start_task(next_customer_request)<br/>      next_customer_request.start_time = system.current_time<br/>      next_customer_request.agent_name = self.agent.name<br/>      next_customer_request.agent_id = self.agent.id<br/><br/>      if system.logging:<br/>        print('&lt;%s&gt; Agent %s started to work on request %d' % (system.current_time, <br/>          self.agent.name, next_customer_request.id))<br/>      <br/>      # schedule finish processing event<br/>      system.add_event(FinishCustomerRequestEvent('finish_handling_request', <br/>        system.current_time + datetime.timedelta(seconds = next_customer_request.handling_time_secs), <br/>        next_customer_request, self.agent)) <br/><br/>class PlanScheduleEvent(Event):<br/>  def __init__(self, event_type, time):<br/>    super().__init__(event_type, time)<br/><br/>  def process(self, system: System):     <br/>    if system.logging:<br/>        print('&lt;%s&gt; Scheeduled agents for today' % (system.current_time))<br/>    current_weekday = system.current_time.strftime('%A')<br/>    <br/>    # create agent ready events for all agents working on this weekday<br/>    for agent in system.agents:<br/>      if current_weekday not in agent.schedule.time_periods:<br/>        continue<br/>            <br/>      for time_periods in agent.schedule.time_periods[current_weekday]:<br/>        system.add_event(AgentReadyEvent('agent_ready_for_task', <br/>          datetime.datetime(system.current_time.year, system.current_time.month, <br/>          system.current_time.day, time_periods[0], 0, 0), <br/>          agent))<br/><br/>    # schedule next planning<br/>    system.add_event(PlanScheduleEvent('plan_agents_schedule', system.current_time + datetime.timedelta(days = 1)))<br/><br/>class FinishCustomerRequestEvent(Event):<br/>  def __init__(self, event_type, time, customer_request, agent):<br/>    super().__init__(event_type, time)<br/>    self.customer_request = customer_request<br/>    self.agent = agent<br/><br/>  def process(self, system):<br/>    self.agent.finish_task()<br/>    # log finish time<br/>    self.customer_request.finish_time = system.current_time<br/>    # save processed request<br/>    system.processed_requests.append(self.customer_request)<br/><br/>    if system.logging:<br/>      print('&lt;%s&gt; Agent %s finished request %d' % (system.current_time, self.agent.name, self.customer_request.id))<br/><br/>    # pick up the next request if agent continue working and we have something in the queue<br/>    if self.agent.is_ready_for_task(system.current_time):<br/>      next_customer_request = system.queue.get_next_item()<br/>      if next_customer_request is not None:<br/>        self.agent.start_task(next_customer_request)<br/>        next_customer_request.start_time = system.current_time<br/>        next_customer_request.agent_name = self.agent.name<br/>        next_customer_request.agent_id = self.agent.id<br/><br/>        if system.logging:<br/>            print('&lt;%s&gt; Agent %s started to work on request %d' % (system.current_time, <br/>              self.agent.name, next_customer_request.id))<br/>        system.add_event(FinishCustomerRequestEvent('finish_handling_request', <br/>          system.current_time + datetime.timedelta(seconds = next_customer_request.handling_time_secs), <br/>          next_customer_request, self.agent)) <br/><br/>class NewCustomerRequestEvent(Event):<br/>  def __init__(self, event_type, time, customer_request):<br/>    super().__init__(event_type, time)<br/>    self.customer_request = customer_request<br/><br/>  def process(self, system: System):<br/>    # check whether we have a free agent<br/>    assigned_agent = system.get_free_agent(self.customer_request)<br/>    <br/>    # if not put request in a queue<br/>    if assigned_agent is None:<br/>      system.queue.add_request(self.customer_request)<br/>      if system.logging:<br/>          print('&lt;%s&gt; Request %d put in a queue' % (system.current_time, self.customer_request.id))<br/>    # if yes, start processing it<br/>    else:<br/>      assigned_agent.start_task(self.customer_request)<br/>      self.customer_request.start_time = system.current_time<br/>      self.customer_request.agent_name = assigned_agent.name<br/>      self.customer_request.agent_id = assigned_agent.id<br/>      if system.logging:<br/>          print('&lt;%s&gt; Agent %s started to work on request %d' % (system.current_time, assigned_agent.name, self.customer_request.id))<br/>      system.add_event(FinishCustomerRequestEvent('finish_handling_request', <br/>        system.current_time + datetime.timedelta(seconds = self.customer_request.handling_time_secs), <br/>        self.customer_request, assigned_agent))</span></pre><p id="79b6" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">That's actually it with the events processing business logic. The only bit we need to finish is to put everything together to run our simulation.</p><h2 id="48c6" class="pu oq fq bf or pv pw px ou py pz qa ox ns qb qc qd nw qe qf qg oa qh qi qj qk bk">Putting all together in the system class</h2><p id="0c50" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">As we discussed, the <code class="cx ql qm qn qo b">System</code> class will be in charge of running the simulations. So, we will put the remaining nuts and bolts there.</p><p id="33a9" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Here's the remaining code. Let me briefly walk you through the main points:</p><ul class=""><li id="76d3" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk"><code class="cx ql qm qn qo b">is_simulation_finished</code> defines the stopping criteria for our simulation — no requests are in the queue, and no events are in the timeline.</li><li id="cd7c" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">process_next_event</code> gets the next event from the timeline and executes <code class="cx ql qm qn qo b">process</code> for it. There's a slight nuance here: we might end up in a situation where our simulation never ends because of recurring "<em class="oj">Plan Agents Schedule</em>" events. That's why, in case of processing such an event type, I check whether there are any other events in the timeline and if not, I don't process it since we don't need to schedule agents anymore.</li><li id="d9cb" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk"><code class="cx ql qm qn qo b">run_simulation</code> is the function that rules our world, but since we have quite a decent architecture, it's a couple of lines: we check whether we can finish the simulation, and if not, we process the next event.</li></ul><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="88bc" class="qs oq fq qo b bg qt qu l qv qw">class System:<br/>  # defines the stopping criteria<br/>  def is_simulation_finished(self):<br/>    if self.queue.get_requests_in_queue() &gt; 0: <br/>      return False<br/>    if self._timeline.get_remaining_events() &gt; 0:<br/>      return False<br/>    return True<br/>    <br/>  # wrappers for timeline methods to incapsulate this logic<br/>  def add_event(self, event):<br/>    self._timeline.add_event(event)<br/><br/>  def get_next_event(self):<br/>    return self._timeline.get_next_item()<br/>  <br/>  # returns free agent if we have one<br/>  def get_free_agent(self, customer_request):<br/>    for agent in self.agents:<br/>      if agent.is_ready_for_task(self.current_time):<br/>        return agent<br/><br/>  # finds and processes the next event<br/>  def process_next_event(self):<br/>    event = self.get_next_event()<br/>    if self.logging:<br/>      print('# Processing event: ' + str(event))<br/>    if (event.type == 'plan_agents_schedule') and self.is_simulation_finished():<br/>      if self.logging:<br/>        print("FINISH")<br/>    else:<br/>      self.current_time = event.time        <br/>      event.process(self)<br/><br/>  # main function<br/>  def run_simulation(self):<br/>    while not self.is_simulation_finished():<br/>      self.process_next_event()</span></pre><p id="7ff8" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It was a long journey, but we've done it. Amazing job! Now, we have all the logic we need. Let's move on to the funny part and use our model for analysis.</p><blockquote class="qy qz ra"><p id="f544" class="nj nk oj nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">You can find the full implementation on <a class="af of" href="https://github.com/miptgirl/miptgirl_medium/blob/main/simulations/queue_simulation.ipynb" rel="noopener ugc nofollow" target="_blank">GitHub</a>.</p></blockquote><h1 id="8b14" class="op oq fq bf or os ot gq ou ov ow gt ox oy oz pa pb pc pd pe pf pg ph pi pj pk bk">Analysis</h1><p id="9165" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">I will use a synthetic Customer Requests dataset to simulate different Ops setups.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rb"><img src="../Images/3766fb4263d15047736abfe15e6b3b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHzuapYZiNl1eH22QH8KVg.png"/></div></div></figure><p id="4352" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">First of all, let's run our system and look at metrics. I will start with 15 agents who are working regular hours.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="eebe" class="qs oq fq qo b bg qt qu l qv qw"># initialising agents<br/>regular_work_week = Schedule(<br/>  {<br/>    'Monday': [(9, 12), (13, 18)],<br/>    'Tuesday': [(9, 12), (13, 18)],<br/>    'Wednesday': [(9, 12), (13, 18)],<br/>    'Thursday': [(9, 12), (13, 18)],<br/>    'Friday': [(9, 12), (13, 18)]<br/>  }<br/>)<br/><br/>agents = []<br/>for id in range(15):<br/>  agents.append(Agent(id + 1, 'Agent %s' % id, regular_work_week))<br/><br/># inital date<br/>system_initial_date = datetime.date(2024, 4, 8)<br/><br/># initialising the system <br/>system = System(agents, [], system_initial_date, backlog_df, logging = False)<br/><br/># running the simulation <br/>system.run_simulation()</span></pre><p id="669c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">As a result of the execution, we got all the stats in <code class="cx ql qm qn qo b">system.processed_requests</code>. Let's put together a couple of helper functions to analyse results easier.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="d430" class="qs oq fq qo b bg qt qu l qv qw"># convert results to data frame and calculate timings<br/>def get_processed_results(system):<br/>  processed_requests_df = pd.DataFrame(list(map(lambda x: x.__dict__, system.processed_requests)))<br/>  processed_requests_df = processed_requests_df.sort_values('creation_time')<br/>  processed_requests_df['creation_time_hour'] = processed_requests_df.creation_time.map(<br/>      lambda x: x.strftime('%Y-%m-%d %H:00:00')<br/>  )<br/><br/>  processed_requests_df['resolution_time_secs'] = list(map(<br/>      lambda x, y: int(x.strftime('%s')) - int(y.strftime('%s')),<br/>      processed_requests_df.finish_time,<br/>      processed_requests_df.creation_time<br/>  ))<br/><br/>  processed_requests_df['waiting_time_secs'] = processed_requests_df.resolution_time_secs - processed_requests_df.handling_time_secs<br/><br/>  processed_requests_df['waiting_time_mins'] = processed_requests_df['waiting_time_secs']/60<br/>  processed_requests_df['handling_time_mins'] = processed_requests_df.handling_time_secs/60<br/>  processed_requests_df['resolution_time_mins'] = processed_requests_df.resolution_time_secs/60<br/>  return processed_requests_df<br/><br/><br/># calculating queue size with 5 mins granularity<br/>def get_queue_stats(processed_requests_df):<br/>  queue_stats = []<br/><br/>  current_time = datetime.datetime(system_initial_date.year, system_initial_date.month, system_initial_date.day, 0, 0, 0)<br/>  while current_time &lt;= processed_requests_df.creation_time.max() + datetime.timedelta(seconds = 300):<br/>    queue_size = processed_requests_df[(processed_requests_df.creation_time &lt;= current_time) &amp; (processed_requests_df.start_time &gt; current_time)].shape[0]<br/>    queue_stats.append(<br/>      {<br/>          'time': current_time,<br/>          'queue_size': queue_size<br/>      }<br/>    )<br/><br/>    current_time = current_time + datetime.timedelta(seconds = 300)<br/><br/>  return pd.DataFrame(queue_stats)</span></pre><p id="b321" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Also, let's make a couple of charts and calculate weekly metrics.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="3536" class="qs oq fq qo b bg qt qu l qv qw">def analyse_results(system, show_charts = True):<br/>  processed_requests_df = get_processed_results(system)<br/>  queue_stats_df = get_queue_stats(processed_requests_df)<br/><br/>  stats_df = processed_requests_df.groupby('creation_time_hour').aggregate(<br/>      {'id': 'count', 'handling_time_mins': 'mean', 'resolution_time_mins': 'mean',<br/>       'waiting_time_mins': 'mean'}<br/>  )<br/>  <br/>  if show_charts:<br/>    fig = px.line(stats_df[['id']], <br/>      labels = {'value': 'requests', 'creation_time_hour': 'request creation time'},<br/>      title = '&lt;b&gt;Number of requests created&lt;/b&gt;')<br/>    fig.update_layout(showlegend = False)<br/>    fig.show()<br/><br/>    fig = px.line(stats_df[['waiting_time_mins', 'handling_time_mins', 'resolution_time_mins']], <br/>      labels = {'value': 'time in mins', 'creation_time_hour': 'request creation time'},<br/>      title = '&lt;b&gt;Resolution time&lt;/b&gt;')<br/>    fig.show()<br/><br/>    fig = px.line(queue_stats_df.set_index('time'), <br/>      labels = {'value': 'number of requests in queue'},<br/>      title = '&lt;b&gt;Queue size&lt;/b&gt;')<br/>    fig.update_layout(showlegend = False)<br/>    fig.show()<br/><br/><br/>  processed_requests_df['period'] = processed_requests_df.creation_time.map(<br/>      lambda x: (x - datetime.timedelta(x.weekday())).strftime('%Y-%m-%d')<br/>  )<br/>  queue_stats_df['period'] = queue_stats_df['time'].map(<br/>      lambda x: (x - datetime.timedelta(x.weekday())).strftime('%Y-%m-%d')<br/>  )<br/><br/>  period_stats_df = processed_requests_df.groupby('period')\<br/>    .aggregate({'id': 'count', 'handling_time_mins': 'mean',<br/>      'waiting_time_mins': 'mean', <br/>      'resolution_time_mins': 'mean'})\<br/>    .join(queue_stats_df.groupby('period')[['queue_size']].mean())<br/><br/>  return period_stats_df<br/><br/># execution<br/>analyse_results(system)</span></pre><p id="f651" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Now, we can use this function to analyse the simulation results. Apparently, 15 agents are not enough for our product since, after three weeks, we have 4K+ requests in a queue and an average resolution time of around ten days. Customers would be very unhappy with our service if we had just 15 agents.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rc"><img src="../Images/f8de16ff06157ff13f33a00afa3c4fc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fvxEwcqbnBo0qcyf2ZR5VQ.png"/></div></div></figure><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rd"><img src="../Images/febfa76237f01782abdc2d85c423424c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1PiPcjuMzXzcQgyb-iU2oQ.png"/></div></div></figure><p id="9bb3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let's find out how many agents we need to be able to cope with the demand. We can run a bunch of simulations with the different number of agents and compare results.</p><pre class="ms mt mu mv mw qp qo qq bp qr bb bk"><span id="8e2c" class="qs oq fq qo b bg qt qu l qv qw">tmp_dfs = []<br/><br/>for num_agents in tqdm.tqdm(range(15, 105, 5)):<br/>  agents = []<br/>  for id in range(num_agents):<br/>    agents.append(Agent(id + 1, 'Agent %s' % id, regular_work_week))<br/>  system = System(agents, [], system_initial_date, backlog_df, logging = False)<br/>  system.run_simulation()<br/><br/>  tmp_df = analyse_results(system, show_charts = False)<br/>  tmp_df['num_agents'] = num_agents<br/>  tmp_dfs.append(tmp_df)</span></pre><p id="693b" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We can see that from ~25–30 agents, metrics for different weeks are roughly the same, so there's enough capacity to handle incoming requests and queue is not growing week after week.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq re"><img src="../Images/e010166cb7d3325c2b92f2992fa55b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*umzsQ1Y-cFN9rFdyiKF4mA.png"/></div></div></figure><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rc"><img src="../Images/eefc26c7547bf7a3d19eda50a903becc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHNBE8P2Y5uzabfURwGbyA.png"/></div></div></figure><p id="7fe2" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">If we model the situation when we have 30 agents, we can see that the queue is empty from 13:50 till the end of the working day from Tuesday to Friday. Agents spend Monday processing the huge queue we are gathering during weekends.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rf"><img src="../Images/28e8e206ea36958c081ae0b870719357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*emgs4jOObPZu7jtu94DZlQ.png"/></div></div></figure><p id="8d61" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">With such a setup, the average resolution time is 500.67 minutes, and the average queue length is 259.39.</p><p id="8385" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let's try to think about the possible improvements for our Operations team:</p><ul class=""><li id="0268" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk">we can hire another five agents,</li><li id="9b51" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">we can start leveraging LLMs and reduce handling time by 30%,</li><li id="075a" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">we can shift agents' schedules to provide coverage during weekends and late hours.</li></ul><p id="b48b" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Since we now have a model, we can easily estimate all the opportunities and pick the most feasible one.</p><p id="ad2d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The first two approaches are straightforward. Let's discuss how we can shift the agents' schedules. All our agents are working from Monday to Friday from 9 to 18. Let's try to make their coverage a little bit more equally distributed.</p><p id="a86e" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">First, we can cover later and earlier hours, splitting agents into two groups. We will have agents working from 7 to 16 and from 11 to 20.</p><p id="2e56" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Second, we can split them across working days more evenly. I used quite a straightforward approach.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rg"><img src="../Images/58d97ada596f273dd5961143534c44e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7GOhAWuP2T5GrEJEUr-yA.png"/></div></div></figure><p id="34eb" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In reality, you can go even further and allocate fewer agents on weekends since we have way less demand. It can improve your metrics even further. However, the additional effect will be marginal.</p><p id="fe3d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">If we run simulations for all these scenarios, surprisingly, we will see that KPIs will be way better if we just change agents' schedules. If we hire five more people or improve agents' performance by 30%, we won't achieve such a significant improvement.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rh"><img src="../Images/feab62766dc8914d050a73e643a049f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0UHDenWPgSYefxwlXgvNdg.png"/></div></div></figure><p id="7bf7" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let's see how changes in agents' schedules affect our KPIs. Resolution time grows only for cases outside working hours (from 20 to 7), and queue size never reaches 200 cases.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq ri"><img src="../Images/60dc8a0dd103e62122945661f028ea08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zVwuwRzLqGtPk56-Dy2iYw.png"/></div></div></figure><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rj"><img src="../Images/ec4402a2bc799068f60099f32244c5d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2RSWcNwy--oDaES3ED0YEA.png"/></div></div></figure><p id="a83a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">That's an excellent result. Our simulation model has helped us prioritise operational changes instead of hiring more people or investing in LLM tool development.</p><p id="70e2" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We've discussed the basics of this approach in this article. If you want to dig deeper and use it in practice, here are a couple more suggestions that might be useful:</p><ul class=""><li id="12ed" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk">Before starting to use such models in production, it’s worth testing them. The most straightforward way is to model your current situation and compare the main KPIs. If they differ a lot, then your system doesn’t represent the real world well enough, and you need to make it more accurate before using it for decision-making.</li><li id="44c3" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">The current metrics are customer-focused. I've used average resolution time as the primary KPI to make decisions. In business, we also care about costs. So, it's worth looking at this task from an operational perspective as well, i.e. measure the percentage of time when agents don't have tasks to work on (which means we are paying them for nothing).</li><li id="64d4" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">In real life, there might be spikes (i.e. the number of customer requests has doubled because of a bug in your product), so I recommend you use such models to ensure that your CS team can handle such situations.</li><li id="7450" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">Last but not least, the model I've used was entirely deterministic (it returns the same result on every run), because handling time was defined for each customer request. To better understand metrics variability, you can specify the distribution of handling times (depending on the task type, day of the week, etc.) for each agent and get handling time from this distribution at each iteration. Then, you can run the simulation multiple times and calculate the confidence intervals of your metrics.</li></ul><h1 id="ab40" class="op oq fq bf or os ot gq ou ov ow gt ox oy oz pa pb pc pd pe pf pg ph pi pj pk bk">Summary</h1><p id="5b97" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk">So, let’s briefly summarise the main points we’ve discussed today:</p><ul class=""><li id="6c94" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe og oh oi bk">We’ve learned the basics of the discrete-event simulation approach that helps to model discrete systems with a countable number of events.</li><li id="eb4d" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">We’ve revised the object-oriented programming and classes in Python since this paradigm is more suitable for this task than the common procedural code data analysts usually use.</li><li id="220e" class="nj nk fq nl b go ok nn no gr ol nq nr ns om nu nv nw on ny nz oa oo oc od oe og oh oi bk">We’ve built the model of the CS team and were able to estimate the impact of different potential improvements on our KPIs (resolution time and queue size).</li></ul><blockquote class="qy qz ra"><p id="4ba6" class="nj nk oj nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Thank you a lot for reading this article. If you have any follow-up questions or comments, please leave them in the comments section.</p></blockquote><h1 id="2a17" class="op oq fq bf or os ot gq ou ov ow gt ox oy oz pa pb pc pd pe pf pg ph pi pj pk bk">Reference</h1><p id="d394" class="pw-post-body-paragraph nj nk fq nl b go pl nn no gr pm nq nr ns pn nu nv nw po ny nz oa pp oc od oe fj bk"><em class="oj">All the images are produced by the author unless otherwise stated.</em></p></div></div></div></div>    
</body>
</html>
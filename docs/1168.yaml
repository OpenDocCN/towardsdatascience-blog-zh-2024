- en: Routing in RAG-Driven Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/routing-in-rag-driven-applications-a685460a7220?source=collection_archive---------1-----------------------#2024-05-09](https://towardsdatascience.com/routing-in-rag-driven-applications-a685460a7220?source=collection_archive---------1-----------------------#2024-05-09)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Directing the application flow based on query intent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@ssmaameri?source=post_page---byline--a685460a7220--------------------------------)[![Sami
    Maameri](../Images/9e9892fe7d3cc53ad1c4d165145878ef.png)](https://medium.com/@ssmaameri?source=post_page---byline--a685460a7220--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--a685460a7220--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--a685460a7220--------------------------------)
    [Sami Maameri](https://medium.com/@ssmaameri?source=post_page---byline--a685460a7220--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--a685460a7220--------------------------------)
    ·9 min read·May 9, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Routing the control flow inside a RAG application based on the intent of the
    user’s query can help us create more useful and powerful Retrieval Augmented Generation
    (RAG) based applications.
  prefs: []
  type: TYPE_NORMAL
- en: The data we want to enable the user to interact with may well be coming from
    a diverse range of sources, such as from reports, documents, images, databases,
    and third party systems. For business-based RAG applications, we may want to enable
    the user to interact with information from a range of areas in the business also,
    such as from the sales, ordering and accounting systems.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this diverse range of data sources, the way the information is stored,
    and the way we want to interact with it, is likely to be diverse also. Some data
    may be stored in vector stores, some in SQL databases, and some we may need to
    access over API calls as it sits in third party systems.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/34159eb96b878359e44851c2335541d4.png)'
  prefs: []
  type: TYPE_IMG
- en: RAG system routing to different data sources based on the query intent
  prefs: []
  type: TYPE_NORMAL
- en: There could be different vector stores setup also for the same but of data,
    optimised for different query types. For example one vector store could be setup
    for answering summary type questions, and another for answering specific, directed
    type questions.
  prefs: []
  type: TYPE_NORMAL
- en: And we may want to route to **different component types** also, based on the
    question. For example we may want to pass the query to an Agent, VectorStore,
    or just directly to an LLM for processing, all based on the nature of the question
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e171242fbcc3f09ba6c6fd62dd48e126.png)'
  prefs: []
  type: TYPE_IMG
- en: Routing to different component types based on the user’s query
  prefs: []
  type: TYPE_NORMAL
- en: We may even want to customise the prompt templates depending on the question
    being asked.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/61f627b15df4c09e6ffcf469dcbd9b42.png)'
  prefs: []
  type: TYPE_IMG
- en: Routing via different prompt templates depending on the user query
  prefs: []
  type: TYPE_NORMAL
- en: All in all, there are numerous reasons we would want to change and direct the
    flow of the user’s query through the application. The more use cases our application
    is trying to fulfil, the more likely we are to have routing requirements throughout
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Routers are essentially just If/Else statements we can use to direct the control
    flow of the query.
  prefs: []
  type: TYPE_NORMAL
- en: What is interesting about them though is it that they **need to make their decisions
    based on natural language input**. So we are looking for a discrete output based
    on a natural language description.
  prefs: []
  type: TYPE_NORMAL
- en: And since a lot of the routing logic is based on using LLMs or machine learning
    algorithms, which are non-deterministic in nature, we cannot guarantee that a
    router will always 100% make the right choice. Add to that that we are unlikely
    to be able to predict all the different query variations that come into a router.
    However, using best practices and some testing we should be able to employ Routers
    to help create more powerful RAG applications.
  prefs: []
  type: TYPE_NORMAL
- en: Natural Language Routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will explore here a few of the natural language routers I have found that
    are implemented by some different RAG and LLM frameworks and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: LLM Completion Routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LLM Function Calling Routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic Routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero Shot Classification Routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language Classification Routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The diagram below gives a description of these routers, along with the frameworks/packages
    where they can be found.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram also includes Logical Routers, which I am defining as routers that
    work based on discrete logic such as conditions against string length, file names,
    integer values, e.t.c. In other words they are not based on having to understand
    the intent of a natural language query
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/78163855bb31bbb8345e6d141e77a57b.png)'
  prefs: []
  type: TYPE_IMG
- en: The different kinds of natural language routers
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore each of these routers in a little more detail
  prefs: []
  type: TYPE_NORMAL
- en: LLM Routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These leverage the decision making abilities of LLMs to select a route based
    on the user’s query.
  prefs: []
  type: TYPE_NORMAL
- en: LLM Completion Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These use an LLM completion call, asking the LLM to return a single word that
    best describes the query, from a list of word options you pass in to its prompt.
    This word can then be used as part of an If/Else condition to control the application
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: This is how the [LLM Selector router](https://docs.llamaindex.ai/en/stable/module_guides/querying/router/)
    from LlamaIndex works. And is also the example given for a router inside the [LangChain](https://python.langchain.com/docs/expression_language/how_to/routing/)
    docs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a code sample, based on the one provided in the LangChain docs,
    to make this a bit more clear. As you can see, coding up one of these on your
    own inside LangChain is pretty straight forward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: LLM Function Calling Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This leverages the function-calling ability of LLMs to pick a route to traverse.
    The different routes are set up as functions with appropriate descriptions in
    the LLM Function Call. Then, based on the query passed to the LLM, it is able
    to return the correct function (i.e route), for us to take.
  prefs: []
  type: TYPE_NORMAL
- en: This is how the [Pydantic Router](https://docs.llamaindex.ai/en/stable/module_guides/querying/router/)
    works inside LlamaIndex. And this is the way most Agents work also to select the
    correct tool to be used. They leverage the Function Calling abilities of LLMs
    in order to select the correct tool for the job based on the user’s query.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This router type leverages embeddings and similarity searches to select the
    best route to traverse.
  prefs: []
  type: TYPE_NORMAL
- en: Each route has a set of example queries associated with it, that become embedded
    and stored as vectors. The incoming query gets embedded also, and a similarity
    search is done against the other sample queries from the router. The route which
    belongs to the query with the closest match gets selected.
  prefs: []
  type: TYPE_NORMAL
- en: There is in fact a python package called [semantic-router](https://github.com/aurelio-labs/semantic-router)
    that does just this. Let’s look at some implementation details to get a better
    idea of how the whole thing works. These examples come straight out of that libraries
    GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s set up two routes, one for questions about politics, and another for general
    chitchat type questions. To each route, we assign a list of questions that might
    typically be asked in order to trigger that route. These example queries are referred
    to as *utterances*. These utterances will be embedded, so that we can use them
    for similarity searches against the user’s query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We assign OpenAI as the encoder, though any embedding library will work. And
    next we create our route layer using the routers and encoder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Then, when apply our query against the router layer, it returns the route that
    should be used for query
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: So, just to summarise again, this semantic router leverages embeddings and similarity
    searches using the user’s query to select the optimal route to traverse. This
    router type should be faster than the other LLM based routers also, since it requires
    just a single Index query to be processed, as oppose to the other types which
    require calls to an LLM.
  prefs: []
  type: TYPE_NORMAL
- en: Zero Shot Classification Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[“Zero-shot text classification](https://huggingface.co/tasks/zero-shot-classification)
    is a task in natural language processing where a model is trained on a set of
    labeled examples but is then able to classify new examples from previously unseen
    classes”. These routers leverage a Zero-Shot Classification model to assign a
    label to a piece of text, from a predefined set of labels you pass in to the router.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:** The [ZeroShotTextRouter](https://docs.haystack.deepset.ai/reference/routers-api#module-zero_shot_text_router)
    in Haystack, which leverages a Zero Shot Classification model from Hugging Face.
    Check out the [source code here](https://github.com/deepset-ai/haystack/blob/main/haystack/components/routers/zero_shot_text_router.py#L130)
    to see where the magic happens.'
  prefs: []
  type: TYPE_NORMAL
- en: Language Classification Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of router is able to identify the language that the query is in, and
    routes the query based on that. Useful if you require some sort of multilingual
    parsing abilities in your application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:** The [TextClassificationRouter](https://docs.haystack.deepset.ai/reference/routers-api#module-text_language_router)
    from Haystack. [It leverages the langdetect python library](https://github.com/deepset-ai/haystack/blob/main/haystack/components/routers/text_language_router.py#L90)
    to detect the language of of the text, which itself uses a [Naive Bayes](https://www.slideshare.net/shuyo/language-detection-library-for-java)
    algorithm to detect the language.'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This [article](https://betterprogramming.pub/unifying-llm-powered-qa-techniques-with-routing-abstractions-438e2499a0d0)
    from Jerry Liu, the Co-Founder of LlamaIndex, on routing inside RAG applications,
    suggests, among other options, a keyword router that would try to select a route
    by matching keywords between the query and routes list.
  prefs: []
  type: TYPE_NORMAL
- en: This Keyword router could be powered by an LLM also to identify keywords, or
    by some other keyword matching library. I have not been able to find any packages
    that implement this router type
  prefs: []
  type: TYPE_NORMAL
- en: Logical Routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These use logic checks against variables, such as string lengths, file names,
    and value comparisons to handle how to route a query. They are very similar to
    typical If/Else conditions used in programming.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, they are not based on having to understand the intent of a natural
    language query but can make their choice based on existing and discrete variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:** The [ConditionalRouter](https://docs.haystack.deepset.ai/docs/conditionalrouter)
    and [FileTypeRouter](https://docs.haystack.deepset.ai/docs/filetyperouter) from
    HayStack.'
  prefs: []
  type: TYPE_NORMAL
- en: Agents v.s Routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first sight, there is indeed a lot of similarities between routers and agents,
    and it might be difficult to distinguish how they are different.
  prefs: []
  type: TYPE_NORMAL
- en: The similarities exist because Agents do in fact perform routing as part of
    their flow. They use a routing mechanism in order to select the correct tool to
    use for the job. They often leverage function calling in order to select the correct
    tool, just like the **LLM Function Calling Routers** described above.
  prefs: []
  type: TYPE_NORMAL
- en: Routers are much more simple components than Agents though, often with the “simple”
    job of just routing a task to the correct place, as oppose to carrying out any
    of the logic or processing related to that task.
  prefs: []
  type: TYPE_NORMAL
- en: Agents on the other hand are often responsible for processing logic, including
    managing work done by the tools they have access to.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered here a few of the different natural language routers currently found
    inside different RAG and LLM frameworks and packages.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts and packages and libraries around routing are sure to increase
    as time goes on. When building a RAG application, you will find that at some point,
    not too far in, routing capabilities do become necessary in order to build an
    application that is useful for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Routers are these basic building blocks that allow you to route the natural
    language requests to your application to the right place, so that the user’s queries
    can be fulfilled as best as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '*Hope that was useful! Do* [*subscribe*](https://medium.com/@ssmaameri/subscribe)
    *to get a notification whenever a new article of mine comes out*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unless otherwise noted, all images are by the author. Icons used in the first
    image by* [*SyafriStudi*](https://www.flaticon.com/free-icons/open-book)*o,* [*Dimitry
    Miroliubovand*](https://www.flaticon.com/free-icons/png)*, and* [*Free Icons PNG*](https://www.freeiconspng.com/img/13315)'
  prefs: []
  type: TYPE_NORMAL

["```py\nnew_users_df = df.groupby('user_id', as_index = False).date.min()\\\n  .rename(columns = {'date': 'cohort'})\n\nnew_users_stats_df = new_users_df.groupby('cohort')[['user_id']].count()\\\n  .rename(columns = {'user_id': 'new_users'})\n```", "```py\npip install prophet\n```", "```py\npred_new_users_df = new_users_df.copy()\npred_new_users_df = pred_new_users_df.rename(\n  columns = {'new_users': 'y', 'cohort': 'ds'})\npred_new_users_df.ds = pd.to_datetime(pred_new_users_df.ds)\n```", "```py\nfrom prophet import Prophet\n\nm = Prophet()\nm.fit(pred_new_users_df)\n```", "```py\nfuture = m.make_future_dataframe(periods= 52, freq = 'W')\nforecast_df = m.predict(future)\nforecast_df.tail()[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]\n```", "```py\nm.plot(forecast_df) # forecast\nm.plot_components(forecast_df) # components\n```", "```py\nimport plotly.express as px\nimport plotly.io as pio\npio.templates.default = 'simple_white'\n\ndef make_prediction(tmp_df, param, param_name = '', periods = 52):\n    # pre-processing\n    df = tmp_df.copy()\n    date_param = df.index.name\n    df.index = pd.to_datetime(df.index)\n\n    train_df = df.reset_index().rename(columns = {date_param: 'ds', param: 'y'})\n\n    # model\n    m = Prophet()\n    m.fit(train_df)\n\n    future = m.make_future_dataframe(periods=periods, freq = 'W')\n    forecast = m.predict(future)\n    forecast = forecast[['ds', 'yhat']].rename(columns = {'ds': date_param, 'yhat': param + '_model'})\n\n    # join to actual data\n    forecast = forecast.set_index(date_param).join(df, how = 'outer')\n\n    # visualisation\n    fig = px.line(forecast, \n        title = '<b>Forecast:</b> ' + (param if param_name == '' else param_name),\n        labels = {'value': param if param_name == '' else param_name},\n        color_discrete_map = {param: 'navy', param + '_model': 'gray'}\n    )\n    fig.update_traces(mode='lines', line=dict(dash='dot'), \n        selector=dict(name=param + '_model'))\n    fig.update_layout(showlegend = False)\n    fig.show()\n\n    return forecast\n\nnew_forecast_df = make_prediction(new_users_stats_df, \n  'new_users', 'new users', periods = 75)\n```", "```py\n# adding cap to the initial data\n# it's not required to be constant\npred_new_users_df['cap'] = 100\n\n#specifying logistic growth\nm = Prophet(growth='logistic')\nm.fit(pred_new_users_df)\n\n# adding cap for the future\nfuture = m.make_future_dataframe(periods= 52, freq = 'W')\nfuture['cap'] = 100\nforecast_df = m.predict(future)\n```", "```py\nmodel_existing_users = df[df.date < '2023-04-02'].user_id.unique()\nraw_existing_df = df[df.user_id.isin(model_existing_users)]\n```", "```py\nexisting_model_df = raw_existing_df[raw_existing_df.date >= '2023-04-02']\\\n  .groupby('user_id', as_index = False).date.min()\\\n  .groupby('date', as_index = False).user_id.count()\\\n  .rename(columns = {'user_id': 'existing_users'})\n```", "```py\nactive_users_df = df.groupby('date')[['user_id']].nunique()\\\n    .rename(columns = {'user_id': 'active_users'})\n```", "```py\n active_forecast_df = make_prediction(active_users_df, \n    'active_users', 'active users')\n```", "```py\n# calculating YoYs\nactive_forecast_df['active_user_prev_year'] = active_forecast_df.active_users.shift(52)\nactive_forecast_df['yoy'] = active_forecast_df.active_users_model/\\\n  active_forecast_df.active_user_prev_year\n\nexisting_model_df = existing_model_df.rename(\n  columns = {'date': 'model_date', 'existing_users': 'model_existing_users'})\n\n# adjusting dates from 2023 to 2024\nexisting_model_df['date'] = existing_model_df.model_date.map(\n  lambda x: datetime.datetime.strptime(x, '%Y-%m-%d') + datetime.timedelta(364)\n)\n\nexisting_model_df = existing_model_df.set_index('date')\\\n   .join(active_forecast_df[['yoy']])\n\n# updating estimations\nexisting_model_df['existing_users'] = list(map(\n    lambda x, y: int(round(x*y)),\n    existing_model_df.model_existing_users,\n    existing_model_df.yoy\n))\n```", "```py\n# existing segment\nexisting_model_df = existing_model_df.reset_index()[['date', 'existing_users']]\\\n  .rename(columns = {'existing_users': 'users'})\nexisting_model_df['segment'] = 'existing'\n\n# new segment\nnew_model_df = new_forecast_df.reset_index()[['cohort', 'new_users_model']]\\\n  .rename(columns = {'cohort': 'date', 'new_users_model': 'users'})\nnew_model_df = new_model_df[(new_model_df.date >= '2024-03-31') \n  & (new_model_df.date < '2025-04-07')]\nnew_model_df['users'] = new_model_df.users.map(lambda x: int(round(x)))\nnew_model_df['segment'] = 'new'\n\n# combining everything\ndemand_model_df = pd.concat([existing_model_df, new_model_df])\n\n# visualisation\npx.area(demand_model_df.pivot(index = 'date', \n          columns = 'segment', values = 'users').head(15)[['new', 'existing']], \n    title = '<b>Demand</b>: modelling number of tests after launch',\n    labels = {'value': 'number of test'})\n```", "```py\nraw_demand_est_model_df = new_model_df.copy()\n```", "```py\ncapacity = 1000\n\ndemand_est_model_df = raw_demand_est_model_df.pivot(index = 'date', \n    columns = 'segment', values = 'users')\n\ndemand_est_model_df['total_demand'] = demand_est_model_df.sum(axis = 1)\ndemand_est_model_df['capacity'] = capacity\ndemand_est_model_df['remaining_capacity'] = demand_est_model_df.capacity \\\n    - demand_est_model_df.total_demand\n\ndemand_est_model_df.head()\n```", "```py\nimport plotly.graph_objects as go\n\ndef get_total_demand_model(raw_demand_est_model_df, capacity = 1000):\n    demand_est_model_df = raw_demand_est_model_df.pivot(index = 'date', \n        columns = 'segment', values = 'users')\n    demand_est_model_df['total_demand'] = demand_est_model_df.sum(axis = 1)\n    demand_est_model_df['capacity'] = capacity\n    demand_est_model_df['remaining_capacity'] = demand_est_model_df.capacity \\\n      - demand_est_model_df.total_demand\n\n    tmp_df = demand_est_model_df.drop(['total_demand', 'capacity', \n        'remaining_capacity'], axis = 1)\n    fig = px.area(tmp_df,\n                 title = '<b>Demand vs Capacity</b>',\n                  category_orders={'segment': ['new'] + list(sorted(filter(lambda x: x != 'new', tmp_df.columns)))},\n                 labels = {'value': 'tests'})\n    fig.add_trace(go.Scatter(\n        x=demand_est_model_df.index, y=demand_est_model_df.capacity, \n        name='capacity', line=dict(color='black', dash='dash'))\n    )\n\n    fig.show()\n    return demand_est_model_df\n\ndemand_plan_df = get_total_demand_model(raw_demand_est_model_df)\ndemand_plan_df.head()\n```", "```py\nexisting_model_df['num_week'] = list(range(existing_model_df.shape[0]))\nexisting_model_df = existing_model_df.set_index('num_week')\\\n    .drop(['date', 'segment'], axis = 1)\nexisting_model_df.head()\n```", "```py\ncohort = '2024-03-31'\ndemand_plan_df.loc[cohort].remaining_capacity/existing_model_df.iloc[0].users\n# 0.3638\n```", "```py\nfull_demand_1st_week = existing_model_df.iloc[0].users\nnext_group_share = demand_plan_df.loc[cohort].remaining_capacity/full_demand_1st_week\nnext_group_share = math.floor(20*next_group_share)/20\n# 0.35\n```", "```py\nenabled_user_share = 0\n\n# if we can process more customers than are left, update the number\nif next_group_share > 1 - enabled_user_share:\n    print('exceeded')\n    next_group_share = round(1 - enabled_user_share, 2)\n\nenabled_user_share += next_group_share\n# 0.35\n```", "```py\nrollout_plan = []\nrollout_plan.append(\n    {'launch_date': cohort, 'rollout_percent': next_group_share}\n)\n```", "```py\n# copy the model\nnext_group_demand_df = existing_model_df.copy().reset_index()\n\n# calculate the dates from cohort + week number\nnext_group_demand_df['date'] = next_group_demand_df.num_week.map(\n    lambda x: (datetime.datetime.strptime(cohort, '%Y-%m-%d') \\\n        + datetime.timedelta(7*x))\n)\n\n# adjusting demand by weight\nnext_group_demand_df['users'] = (next_group_demand_df.users * next_group_share).map(lambda x: int(round(x)))\n\n# labelling the segment\nnext_group_demand_df['segment'] = 'existing, cohort = %s' % cohort\n\n# updating the plan\nraw_demand_est_model_df = pd.concat([raw_demand_est_model_df, \n    next_group_demand_df.drop('num_week', axis = 1)])\n```", "```py\ndemand_plan_df = get_total_demand_model(raw_demand_est_model_df)\ndemand_plan_df.head()\n```", "```py\nrollout_plan\n# [{'launch_date': '2024-03-31', 'rollout_percent': 0.35},\n# {'launch_date': '2024-04-07', 'rollout_percent': 0.2},\n# {'launch_date': '2024-04-14', 'rollout_percent': 0.25},\n# {'launch_date': '2024-04-21', 'rollout_percent': 0.2}]\n```", "```py\nsim_df = df[df.date >= '2023-03-31']\n```", "```py\ndef days_diff(date1, date2):\n    return (datetime.datetime.strptime(date2, '%Y-%m-%d')\\\n        - datetime.datetime.strptime(date1, '%Y-%m-%d')).days\n```", "```py\nuser_id = 4861\nuser_events = sim_df[sim_df.user_id == user_id]\\\n    .sort_values('date')\\\n    .to_dict('records')\n\n# [{'user_id': 4861, 'date': '2023-04-09', 'module': 'pre-A1', 'lesson_num': 8},\n# {'user_id': 4861, 'date': '2023-04-16', 'module': 'pre-A1', 'lesson_num': 9},\n# {'user_id': 4861, 'date': '2023-04-23', 'module': 'pre-A1', 'lesson_num': 10},\n# {'user_id': 4861, 'date': '2023-04-23', 'module': 'pre-A1', 'lesson_num': 11},\n# {'user_id': 4861, 'date': '2023-04-30', 'module': 'pre-A1', 'lesson_num': 12},\n# {'user_id': 4861, 'date': '2023-05-07', 'module': 'pre-A1', 'lesson_num': 13}]\n```", "```py\ntmp_gen_tests = []\nlast_test_date = None\nlast_lesson_date = None\n```", "```py\nfor rec in user_events:\n  pass\n```", "```py\nif last_test_date is None: # initial test\n    last_test_date = rec['date']\n    # TBD saving the test info\n```", "```py\nif (rec['lesson_num'] == 100) and (days_diff(last_test_date, rec['date']) >= 30): \n    last_test_date = rec['date']\n    # TBD saving the test info\n```", "```py\nif (days_diff(last_lesson_date, rec['date']) >= 30): \n    last_test_date = rec['date']\n    # TBD saving the test info\n```", "```py\nimport tqdm\ntmp_gen_tests = []\n\nfor user_id in tqdm.tqdm(sim_raw_df.user_id.unique()):\n    # initialising variables\n    last_test_date = None\n    last_lesson_date = None\n\n    for rec in sim_raw_df[sim_raw_df.user_id == user_id].to_dict('records'):\n        # initial test\n        if last_test_date is None: \n            last_test_date = rec['date']\n            tmp_gen_tests.append(\n                {\n                    'user_id': rec['user_id'],\n                    'date': rec['date'],\n                    'trigger': 'initial test'\n                }\n            )\n        # finish module\n        elif (rec['lesson_num'] == 100) and (days_diff(last_test_date, rec['date']) >= 30): \n            last_test_date = rec['date']\n            tmp_gen_tests.append(\n                {\n                    'user_id': rec['user_id'],\n                    'date': rec['date'],\n                    'trigger': 'finished module'\n                })\n        # reactivation\n        elif (days_diff(last_lesson_date, rec['date']) >= 92):\n            last_test_date = rec['date']\n            tmp_gen_tests.append(\n                {\n                    'user_id': rec['user_id'],\n                    'date': rec['date'],\n                    'trigger': 'reactivation'\n                })\n        last_lesson_date = rec['date']\n```", "```py\nexist_model_upd_stats_df = exist_model_upd.pivot_table(\n    index = 'date', columns = 'trigger', values = 'user_id', \n    aggfunc = 'nunique'\n).fillna(0)\n\nexist_model_upd_stats_df = exist_model_upd_stats_df\\\n    .map(lambda x: int(round(x * 1.8)))\n```"]
["```py\nimport pandas as pd\n\ndf = pd.read_csv('dau_data.csv.gz', compression='gzip')\ndf['date'] = pd.to_datetime(df['date'])\ndf['registration_date'] = pd.to_datetime(df['registration_date'])\n\nprint(f'Shape: {df.shape}')\nprint(f'Total users: {df['user_id'].nunique()}')\nprint(f'Data range: [{df['date'].min()}, {df['date'].max()}]')\ndf.head()\n```", "```py\nShape: (667236, 3)\nTotal users: 51480\nData range: [2020-10-01 00:00:00, 2023-10-31 00:00:00]\n```", "```py\ndf.groupby('date').size()\\\n    .plot(title='DAU, historical')\n```", "```py\nPREDICTION_START = '2023-11-01'\nPREDICTION_END = '2024-12-31'\n```", "```py\nnew_users = df[df['date'] == df['registration_date']]\\\n    .groupby('date').size()\nnew_users.head()\n```", "```py\ndate\n2020-10-01    4\n2020-10-02    4\n2020-10-03    3\n2020-10-04    4\n2020-10-05    8\ndtype: int64\n```", "```py\nimport logging\nimport matplotlib.pyplot as plt\nfrom prophet import Prophet\n\n# suppress prophet logs\nlogging.getLogger('prophet').setLevel(logging.WARNING)\nlogging.getLogger('cmdstanpy').disabled=True\n\ndef predict_new_users(prediction_start, prediction_end, new_users_train, show_plot=True):\n    \"\"\"\n    Forecasts a time-seires for new users\n\n    Parameters\n    ----------\n    prediction_start : str\n        Date in YYYY-MM-DD format.\n    prediction_end : str\n        Date in YYYY-MM-DD format.\n    new_users_train : pandas.Series\n        Historical data for the time-series preceding the prediction period.\n    show_plot : boolean, default=True\n        If True, a chart with the train and predicted time-series values is displayed.\n    Returns\n    -------\n    pandas.Series\n        Series containing the predicted values.\n    \"\"\"\n    m = Prophet()\n\n    new_users_train = new_users_train\\\n        .loc[new_users_train.index < prediction_start]\n    new_users_prophet = pd.DataFrame({\n        'ds': new_users_train.index,\n        'y': new_users_train.values\n    })\n\n    m.fit(new_users_prophet)\n\n    periods = len(pd.date_range(prediction_start, prediction_end))\n    future = m.make_future_dataframe(periods=periods)\n    new_users_pred = m.predict(future)\n    if show_plot:\n        m.plot(new_users_pred)\n        plt.title('New users prediction');\n\n    new_users_pred = new_users_pred\\\n        .assign(yhat=lambda _df: _df['yhat'].astype(int))\\\n        .rename(columns={'ds': 'date', 'yhat': 'count'})\\\n        .set_index('date')\\\n        .clip(lower=0)\\\n        ['count']\n\n    return new_users_pred\n```", "```py\nnew_users_pred = predict_new_users(PREDICTION_START, PREDICTION_END, new_users)\n```", "```py\nnew_users_pred.tail(5)\n```", "```py\ndate\n2024-12-27    52\n2024-12-28    56\n2024-12-29    71\n2024-12-30    79\n2024-12-31    74\nName: count, dtype: int64\n```", "```py\nuser_id    date          registration_date\n1234567    2023-01-01    2023-01-01\n1234567    2023-01-03    2023-01-01\n```", "```py\nuser_id    date          is_active    registration_date\n1234567    2023-01-01    TRUE         2023-01-01\n1234567    2023-01-02    FALSE        2023-01-01\n1234567    2023-01-03    TRUE         2023-01-01\n1234567    2023-01-04    FALSE        2023-01-01\n1234567    2023-01-05    FALSE        2023-01-01\n...        ...           ...          ...\n1234567    2023-10-31    FALSE        2023-01-01\n```", "```py\nimport duckdb\n\nDATASET_START = '2020-11-01'\nDATASET_END = '2023-10-31'\nOBSERVATION_START = '2020-10-01'\n\nquery = f\"\"\"\nWITH\nfull_range AS (\n    SELECT\n        user_id, UNNEST(generate_series(greatest(registration_date, '{OBSERVATION_START}'), date '{DATASET_END}', INTERVAL 1 DAY))::date AS date\n    FROM (\n        SELECT DISTINCT user_id, registration_date FROM df\n    )\n),\ndau_full AS (\n    SELECT\n        fr.user_id,\n        fr.date,\n        df.date IS NOT NULL AS is_active,\n        registration_date\n    FROM full_range AS fr\n    LEFT JOIN df USING(user_id, date)\n),\nstates AS (\n    SELECT\n        user_id,\n        date,\n        is_active,\n        first_value(registration_date IGNORE NULLS) OVER (PARTITION BY user_id ORDER BY date) AS registration_date,\n        SUM(is_active::int) OVER (PARTITION BY user_id ORDER BY date ROWS BETWEEN 6 PRECEDING and 1 PRECEDING) AS active_days_back_6d,\n        SUM(is_active::int) OVER (PARTITION BY user_id ORDER BY date ROWS BETWEEN 29 PRECEDING and 1 PRECEDING) AS active_days_back_29d,\n        CASE\n            WHEN date = registration_date THEN 'new'\n            WHEN is_active = TRUE AND active_days_back_6d BETWEEN 1 and 6 THEN 'current'\n            WHEN is_active = TRUE AND active_days_back_6d = 0 AND IFNULL(active_days_back_29d, 0) > 0 THEN 'reactivated'\n            WHEN is_active = TRUE AND active_days_back_6d = 0 AND IFNULL(active_days_back_29d, 0) = 0 THEN 'resurrected'\n            WHEN is_active = FALSE AND active_days_back_6d > 0 THEN 'at_risk_wau'\n            WHEN is_active = FALSE AND active_days_back_6d = 0 AND ifnull(active_days_back_29d, 0) > 0 THEN 'at_risk_mau'\n            ELSE 'dormant'\n        END AS state\n    FROM dau_full\n)\nSELECT user_id, date, state FROM states\nWHERE date BETWEEN '{DATASET_START}' AND '{DATASET_END}'\nORDER BY user_id, date\n\"\"\"\nstates = duckdb.sql(query).df()\n```", "```py\nM = get_transition_matrix(transitions, '2022-11-01', '2023-10-31')\nM\n```", "```py\ndef get_state0(date):\n    query = f\"\"\"\n    SELECT state, count(*) AS cnt\n    FROM states\n    WHERE date = '{date}'\n    GROUP BY state\n    \"\"\"\n\n    state0 = duckdb.sql(query).df()\n    state0 = state0.set_index('state').reindex(states_order)['cnt']\n\n    return state0\n```", "```py\nstate0 = get_state0(DATASET_END)\nstate0\n```", "```py\nstate\nnew               20\ncurrent          475\nreactivated       15\nresurrected       19\nat_risk_wau      404\nat_risk_mau     1024\ndormant        49523\nName: cnt, dtype: int64\n```", "```py\ndef predict_dau(M, state0, start_date, end_date, new_users):\n    \"\"\"\n    Predicts DAU over a given date range.\n\n    Parameters\n    ----------\n    M : pandas.DataFrame\n        Transition matrix representing user state changes.\n    state0 : pandas.Series\n        counts of initial state of users.\n    start_date : str\n        Start date of the prediction period in 'YYYY-MM-DD' format.\n    end_date : str\n        End date of the prediction period in 'YYYY-MM-DD' format.\n    new_users : int or pandas.Series\n        The expected amount of new users for each day between `start_date` and `end_date`.\n        If a Series, it should have dates as the index.\n        If an int, the same number is used for each day.\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame containing the predicted DAU, WAU, and MAU for each day in the date range,\n        with columns for different user states and tot.\n    \"\"\"\n\n    dates = pd.date_range(start_date, end_date)\n    dates.name = 'date'\n    dau_pred = []\n    new_dau = state0.copy()\n    for date in dates:\n        new_dau = (M.transpose() @ new_dau).astype(int)\n        if isinstance(new_users, int):\n            new_users_today = new_users\n        else:\n            new_users_today = new_users.astype(int).loc[date] \n        new_dau.loc['new'] = new_users_today\n        dau_pred.append(new_dau.tolist())\n\n    dau_pred = pd.DataFrame(dau_pred, index=dates, columns=states_order)\n    dau_pred['dau'] = dau_pred['new'] + dau_pred['current'] + dau_pred['reactivated'] + dau_pred['resurrected']\n    dau_pred['wau'] = dau_pred['dau'] + dau_pred['at_risk_wau']\n    dau_pred['mau'] = dau_pred['dau'] + dau_pred['at_risk_wau'] + dau_pred['at_risk_mau']\n\n    return dau_pred\n```", "```py\ndau_pred = predict_dau(M, state0, PREDICTION_START, PREDICTION_END, new_users_pred)\ndau_pred\n```", "```py\nquery = f\"\"\"\nSELECT date, state, COUNT(*) AS cnt\nFROM states\nGROUP BY date, state\nORDER BY date, state;\n\"\"\"\n\ndau_true = duckdb.sql(query).df()\ndau_true['date'] = pd.to_datetime(dau_true['date'])\ndau_true = dau_true.pivot(index='date', columns='state', values='cnt')\ndau_true['dau'] = dau_true['new'] + dau_true['current'] + dau_true['reactivated'] + dau_true['resurrected']\ndau_true['wau'] = dau_true['dau'] + dau_true['at_risk_wau']\ndau_true['mau'] = dau_true['dau'] + dau_true['at_risk_wau'] + dau_true['at_risk_mau']\n```", "```py\ndau_true.head()\n```", "```py\npd.concat([dau_true['dau'], dau_pred['dau']])\\\n    .plot(title='DAU, historical & predicted');\nplt.axvline(PREDICTION_START, color='k', linestyle='--');\n```", "```py\ndef predict_dau_prophet(prediction_start, prediction_end, dau_true, show_plot=True):\n    # assigning peak days for the new year\n    holidays = pd.DataFrame({\n        'holiday': 'january_spike',\n        'ds': pd.date_range('2022-01-01', '2022-01-31', freq='D').tolist() + \\\n              pd.date_range('2023-01-01', '2023-01-31', freq='D').tolist(),\n        'lower_window': 0,\n        'upper_window': 40\n    })\n\n    m = Prophet(growth='logistic', holidays=holidays)\n    m.add_seasonality(name='monthly', period=30.5, fourier_order=3)\n    m.add_seasonality(name='yearly', period=365, fourier_order=3)\n\n    train = dau_true.loc[(dau_true.index < prediction_start) & (dau_true.index >= '2021-08-01')]\n    train_prophet = pd.DataFrame({'ds': train.index, 'y': train.values})\n    # removining outliers\n    train_prophet.loc[train_prophet['ds'].between('2022-06-07', '2022-06-09'), 'y'] = None\n    train_prophet['new_year_peak'] = (train_prophet['ds'] >= '2022-01-01') &\\\n                                     (train_prophet['ds'] <= '2022-02-14')\n    m.add_regressor('new_year_peak')\n    # setting logistic upper and lower bounds\n    train_prophet['cap'] = dau_true.max() * 1.1\n    train_prophet['floor'] = 0\n\n    m.fit(train_prophet)\n\n    periods = len(pd.date_range(prediction_start, prediction_end))\n    future = m.make_future_dataframe(periods=periods)\n    future['new_year_peak'] = (future['ds'] >= '2022-01-01') & (future['ds'] <= '2022-02-14')\n    future['cap'] = dau_true.max() * 1.1\n    future['floor'] = 0\n    pred = m.predict(future)\n\n    if show_plot:\n        m.plot(pred);\n\n    # converting the predictions to an appropriate format\n    pred = pred\\\n        .assign(yhat=lambda _df: _df['yhat'].astype(int))\\\n        .rename(columns={'ds': 'date', 'yhat': 'count'})\\\n        .set_index('date')\\\n        .clip(lower=0)\\\n        ['count']\\\n        .loc[lambda s: (s.index >= prediction_start) & (s.index <= prediction_end)]\n\n    return pred\n```", "```py\nfrom sklearn.metrics import mean_absolute_percentage_error\n\nmapes = []\nprediction_end = '2023-10-31'\nprediction_horizon = [3, 6, 12]\n\nfor offset in prediction_horizon:\n    prediction_start = pd.to_datetime(prediction_end) - pd.DateOffset(months=offset - 1)\n    prediction_start = prediction_start.replace(day=1)\n    prediction_end = '2023-10-31'\n    pred = predict_dau_prophet(prediction_start, prediction_end, dau_true['dau'], show_plot=False)\n    mape = mean_absolute_percentage_error(dau_true['dau'].reindex(pred.index), pred)\n    mapes.append(mape)\n\nmapes = pd.DataFrame({'horizon': prediction_horizon, 'MAPE': mapes})\nmapes\n```", "```py\nimport re\n\ndef make_prediction(prediction_start, prediction_end, new_users_mode='predict', transition_period='last_30d'):\n    prediction_start_minus_1d = pd.to_datetime(prediction_start) - pd.Timedelta('1d')\n    state0 = get_state0(prediction_start_minus_1d)\n\n    if new_users_mode == 'predict':\n        new_users_pred = predict_new_users(prediction_start, prediction_end, new_users, show_plot=False)\n    elif new_users_mode == 'true':\n        new_users_pred = new_users.copy()\n\n    if transition_period.startswith('last_'):\n        shift = int(re.search(r'last_(\\d+)d', transition_period).group(1))\n        transitions_start = pd.to_datetime(prediction_start) - pd.Timedelta(shift, 'd')\n        M = get_transition_matrix(transitions, transitions_start, prediction_start_minus_1d)\n        dau_pred = predict_dau(M, state0, prediction_start, prediction_end, new_users_pred)\n    else:\n        transitions_start = pd.to_datetime(prediction_start) - pd.Timedelta(240, 'd')\n        M_base = get_transition_matrix(transitions, transitions_start, prediction_start_minus_1d)\n        dau_pred = pd.DataFrame()\n\n        month_starts = pd.date_range(prediction_start, prediction_end, freq='1MS')\n        N = len(month_starts)\n\n        for i, prediction_month_start in enumerate(month_starts):\n            prediction_month_end = pd.offsets.MonthEnd().rollforward(prediction_month_start)\n            transitions_month_start = prediction_month_start - pd.Timedelta('365D')\n            transitions_month_end = prediction_month_end - pd.Timedelta('365D')\n\n            M_seasonal = get_transition_matrix(transitions, transitions_month_start, transitions_month_end)\n            if transition_period == 'smoothing':\n                i = min(i, 12)\n                M = M_seasonal * i / (N - 1)  + (1 - i / (N - 1)) * M_base\n            elif transition_period.startswith('seasonal_'):\n                seasonal_coef = float(re.search(r'seasonal_(0\\.\\d+)', transition_period).group(1))\n                M = seasonal_coef * M_seasonal + (1 - seasonal_coef) * M_base\n\n            dau_tmp = predict_dau(M, state0, prediction_month_start, prediction_month_end, new_users_pred)\n            dau_pred = pd.concat([dau_pred, dau_tmp])\n\n            state0 = dau_tmp.loc[prediction_month_end][states_order]\n\n    return dau_pred\n\ndef prediction_details(dau_true, dau_pred, show_plot=True, ax=None):\n    y_true = dau_true.reindex(dau_pred.index)['dau']\n    y_pred = dau_pred['dau']\n    mape = mean_absolute_percentage_error(y_true, y_pred) \n\n    if show_plot:\n        prediction_start = str(y_true.index.min().date())\n        prediction_end = str(y_true.index.max().date())\n        if ax is None:\n            y_true.plot(label='DAU true')\n            y_pred.plot(label='DAU pred')\n            plt.title(f'DAU prediction, {prediction_start} - {prediction_end}')\n            plt.legend()\n        else:\n            y_true.plot(label='DAU true', ax=ax)\n            y_pred.plot(label='DAU pred', ax=ax)\n            ax.set_title(f'DAU prediction, {prediction_start} - {prediction_end}')\n            ax.legend()\n    return mape\n```", "```py\nfig, axs = plt.subplots(3, 2, figsize=(15, 6))\nmapes = []\nprediction_end = '2023-10-31'\nprediction_horizon = [3, 6, 12]\n\nfor i, offset in enumerate(prediction_horizon):\n    prediction_start = pd.to_datetime(prediction_end) - pd.DateOffset(months=offset - 1)\n    prediction_start = prediction_start.replace(day=1)\n    args = {\n        'prediction_start': prediction_start,\n        'prediction_end': prediction_end,\n        'transition_period': 'last_365d'\n    }\n    for j, new_users_mode in enumerate(['predict', 'true']):\n        args['new_users_mode'] = new_users_mode\n        dau_pred = make_prediction(**args)\n        mape = prediction_details(dau_true, dau_pred, ax=axs[i, j])\n        mapes.append([offset, new_users_mode, mape])\n\nmapes = pd.DataFrame(mapes, columns=['horizon', 'new_users', 'MAPE'])\nplt.tight_layout()\n```", "```py\nmapes.pivot(index='horizon', columns='new_users', values='MAPE')\n```", "```py\ndau_component_cols = ['new', 'current', 'reactivated', 'resurrected']\n\ndau_pred = make_prediction('2023-08-01', '2023-10-31', new_users_mode='true', transition_period='last_365d')\nfigure, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 4))\n\ndau_pred[dau_component_cols]\\\n    .subtract(dau_true[dau_component_cols])\\\n    .reindex(dau_pred.index)\\\n    .plot(title='Prediction error by state', ax=ax1)\n\ndau_pred[['current']]\\\n    .subtract(dau_true[['current']])\\\n    .div(dau_true[['current']])\\\n    .reindex(dau_pred.index)\\\n    .plot(title='Relative prediction error (current state)', ax=ax2);\n```", "```py\nresult = []\n\nfor prediction_offset in prediction_horizon:\n    prediction_start = pd.to_datetime(prediction_end) - pd.DateOffset(months=prediction_offset - 1)\n    prediction_start = prediction_start.replace(day=1)\n\n    for transition_offset in range(1, 13):\n        dau_pred = make_prediction(\n            prediction_start, prediction_end, new_users_mode='true',\n            transition_period=f'last_{transition_offset*30}d'\n        )\n        mape = prediction_details(dau_true, dau_pred, show_plot=False)\n        result.append([prediction_offset, transition_offset, mape])\nresult = pd.DataFrame(result, columns=['prediction_period', 'transition_period', 'mape'])\n\nresult.pivot(index='transition_period', columns='prediction_period', values='mape')\\\n    .plot(title='MAPE by prediction and transition period');\n```", "```py\nresult = pd.DataFrame()\nfor transition_period in ['last_240d', 'seasonal_0.3', 'smoothing']:\n    result[transition_period] = make_prediction(\n        '2022-11-01', '2023-10-31',\n        'true',\n        transition_period\n    )['dau']\nresult['true'] = dau_true['dau']\nresult['true'] = result['true'].astype(int)\nresult.plot(title='DAU prediction by different transition matrices');\n```", "```py\nmape = pd.DataFrame()\nfor col in result.columns:\n    if col != 'true':\n        mape.loc[col, 'mape'] = mean_absolute_percentage_error(result['true'], result[col])\nmape\n```", "```py\ndau_pred = make_prediction(\n    PREDICTION_START, PREDICTION_END,\n    new_users_mode='predict',\n    transition_period='seasonal_0.3'\n)\ndau_true['dau'].plot(label='true')\ndau_pred['dau'].plot(label='seasonal_0.3')\nplt.title('DAU, historical & predicted')\nplt.axvline(PREDICTION_START, color='k', linestyle='--')\nplt.legend();\n```"]
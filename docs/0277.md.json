["```py\nimport pyarrow as pa\n\nseries = pd.Series(\n    [\n        {\"project\": \"pandas\", \"version\": \"2.2.0\"},\n        {\"project\": \"numpy\", \"version\": \"1.25.2\"},\n        {\"project\": \"pyarrow\", \"version\": \"13.0.0\"},\n    ],\n    dtype=pd.ArrowDtype(\n        pa.struct([\n            (\"project\", pa.string()),\n            (\"version\", pa.string()),\n        ])\n    ),\n)\n```", "```py\nseries.struct.field(\"project\")\n\n0     pandas\n1      numpy\n2    pyarrow\nName: project, dtype: string[pyarrow]\n```", "```py\nimport adbc_driver_postgresql.dbapi as pg_dbapi\n\ndf = pd.DataFrame(\n   [\n       [1, 2, 3],\n       [4, 5, 6],\n   ],\n   columns=['a', 'b', 'c']\n)\nuri = \"postgresql://postgres:postgres@localhost/postgres\"\nwith pg_dbapi.connect(uri) as conn:\n   df.to_sql(\"pandas_table\", conn, index=False)\n\n# for round-tripping\nwith pg_dbapi.connect(uri) as conn:\n   df2 = pd.read_sql(\"pandas_table\", conn)\n```", "```py\ndf = pd.DataFrame(dict(a=[1, 2, 3], b=[4, 5, 6]))\n\ndefault=pd.Series('default', index=df.index)\ndefault.case_when(\n    caselist=[\n        (df.a == 1, 'first'),\n        (df.a.gt(1) & df.b.eq(5), 'second'),\n    ],\n)\n```", "```py\ndf = pd.DataFrame({\"x\": [1, 2, 3]})\n\ndf[\"x\"][df[\"x\"] > 1] = 100\n```", "```py\nFutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when \nusing Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to \nupdate the original DataFrame or Series, because the intermediate object on which we are setting \nvalues will behave as a copy. A typical example is when you are setting values in a column of a \nDataFrame, like:\n\ndf[\"col\"][row_indexer] = value\n\nUse `df.loc[row_indexer, \"col\"] = values` instead, to perform the assignment in a single step and \nensure this keeps updating the original `df`.\n```", "```py\npd.options.mode.copy_on_write = \"warn\"\n```", "```py\npd.options.mode.copy_on_write = \"warn\"\n\ndf = pd.DataFrame({\"a\": [1, 2, 3]})\nview = df[\"a\"]\nview.iloc[0] = 100\n```", "```py\nFutureWarning: Setting a value on a view: behaviour will change in pandas 3.0.\nYou are mutating a Series or DataFrame object, and currently this mutation will\nalso have effect on other Series or DataFrame objects that share data with this\nobject. In pandas 3.0 (with Copy-on-Write), updating one Series or DataFrame object\nwill never modify another.\n```", "```py\npip install -U pandas\n```", "```py\nmamba install -c conda-forge pandas=2.2\n```"]
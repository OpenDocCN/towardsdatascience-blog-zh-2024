<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Nine Rules for Running Rust in the Browser</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Nine Rules for Running Rust in the Browser</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nine-rules-for-running-rust-in-the-browser-8228353649d1?source=collection_archive---------1-----------------------#2024-10-08">https://towardsdatascience.com/nine-rules-for-running-rust-in-the-browser-8228353649d1?source=collection_archive---------1-----------------------#2024-10-08</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="5363" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Practical lessons from porting range-set-blaze to WASM</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@carlmkadie?source=post_page---byline--8228353649d1--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Carl M. Kadie" class="l ep by dd de cx" src="../Images/9dbe27c76e9567136e5a7dc587f1fb15.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*RGViuuvF-_GQ-LXuVDQN7w.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--8228353649d1--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@carlmkadie?source=post_page---byline--8228353649d1--------------------------------" rel="noopener follow">Carl M. Kadie</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--8228353649d1--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">21 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Oct 8, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj la lb ab q ee lc ld" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="le"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lf k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lg an ao ap id lh li lj" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lk cn"><div class="l ae"><div class="ab cb"><div class="ll lm ln lo lp lq ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj mk"><img src="../Images/f6718aabbf0325b092e3b4437e3f96c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJMEk3SenNEuH7XyAUbEZQ.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Rust Running on the Browser — Source: <a class="af nb" href="https://openai.com/dall-e-2/" rel="noopener ugc nofollow" target="_blank">https://openai.com/dall-e-2/</a>. All other figures from the author.</figcaption></figure><p id="0c63" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Do you want your Rust code to run everywhere — from large servers to web pages, robots, and even watches? In this second of three articles [<a class="af nb" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a" rel="noopener">1</a>, <a class="af nb" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1" rel="noopener">2</a>, <a class="af nb" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e" rel="noopener">3</a>], I’ll show you how to use WebAssembly (WASM) to run your Rust code directly in the user’s browser.</p><p id="8c75" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With this technique, you can provide CPU-intensive, dynamic web pages from a — perhaps free — static web server. As a bonus, a user’s data never leaves their machine, avoiding privacy issues. For example, I offer a tool to search race results for friends, running club members, and teammates. To see the tool, go to <a class="af nb" href="https://carlkcarlk.github.io/race-results/matcher/" rel="noopener ugc nofollow" target="_blank">its web page</a>, and click “match”.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ny"><img src="../Images/138b2fdb5c996a8d2a16b26e4e50c943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*fVWhYH4sMcFk2Kiaa2vv2g.png"/></div></figure><blockquote class="nz oa ob"><p id="733b" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: To learn more about matching names, see <a class="af nb" href="https://medium.com/towards-data-science/use-bayes-theorem-to-find-distinctive-names-in-a-list-5acd8fe03c2b" rel="noopener">Use Bayes’ Theorem to Find Distinctive Names in a List</a> in <em class="fq">Towards Data Science.</em></p></blockquote><p id="80a1" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Running Rust in the browser presents challenges. Your code doesn’t have access to a full operating system like Linux, Windows, or macOS. You have no direct access to files or networks. You have only limited access to time and random numbers. We’ll explore workarounds and solutions.</p><p id="b199" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Porting code to WASM in the browser requires several steps and choices, and navigating these can be time-consuming. Missing a step can lead to failure. We’ll reduce this complication by offering nine rules, which we’ll explore in detail:</p><ol class=""><li id="cd37" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx od oe of bk">Confirm that your existing app works with WASM WASI and create a simple JavaScript web page.</li><li id="336c" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx od oe of bk">Install the <code class="cx ol om on oo b">wasm32-unknown-unknown</code> target, <code class="cx ol om on oo b">wasm-pack</code>, <code class="cx ol om on oo b">wasm-bindgen-cli</code>, and Chrome for Testing &amp; Chromedriver.</li><li id="43c0" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx od oe of bk">Make your project <code class="cx ol om on oo b">cdylib </code>(and <code class="cx ol om on oo b">rlib</code>), add <code class="cx ol om on oo b">wasm-bindgen</code> dependencies, and test.</li><li id="95af" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx od oe of bk">Learn what types <code class="cx ol om on oo b">wasm-bindgen</code> supports.</li><li id="026d" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx od oe of bk">Change functions to use supported types. Change files to generic <code class="cx ol om on oo b">BufRead</code>.</li><li id="e97e" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx od oe of bk">Adapt tests, skipping those that don’t apply.</li><li id="98c3" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx od oe of bk">Change to JavaScript-friendly dependencies, if necessary. Run tests.</li><li id="a804" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx od oe of bk">Connect your web page to your functions.</li><li id="e542" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx od oe of bk">Add <code class="cx ol om on oo b">wasm-pack</code> to your CI (continuous integration) tests.</li></ol><blockquote class="nz oa ob"><p id="2b7b" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: These articles are based on a three-hour workshop that I presented at <a class="af nb" href="https://rustconf.com/programs/#755" rel="noopener ugc nofollow" target="_blank">RustConf24</a> in Montreal. Thanks to the participants of that workshop. A special thanks, also, to the volunteers from the Seattle Rust Meetup who helped test this material. These articles replace <a class="af nb" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2" rel="noopener">an article I wrote last year</a> with updated information.</p></blockquote><p id="e337" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As with <a class="af nb" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a" rel="noopener">the first article in this series</a>, before we look at the rules one by one, let’s define our terms.</p><ul class=""><li id="5e5f" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk"><strong class="ne fr">Native:</strong> Your home OS (Linux, Windows, macOS)</li><li id="cd16" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk"><strong class="ne fr">Standard library (std)</strong>: Provides Rust’s core functionality — <code class="cx ol om on oo b">Vec</code>, <code class="cx ol om on oo b">String</code>, file input/output, networking, time.</li><li id="ede7" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk"><strong class="ne fr">WASM</strong>: WebAssembly (WASM) is a binary instruction format that runs in most browsers (and beyond).</li><li id="292d" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk"><strong class="ne fr">WASI</strong>: WebAssembly System Interface (WASI) allows outside-the-browser WASM to access file I/O, networking (not yet), and time handling.</li><li id="8bb6" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk"><strong class="ne fr">no_std</strong>: Instructs a Rust program not to use the full standard library, making it suitable for small, embedded devices or highly resource-constrained environments.</li><li id="d593" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk"><strong class="ne fr">alloc</strong>: Provides heap memory allocation capabilities (<code class="cx ol om on oo b">Vec</code>, <code class="cx ol om on oo b">String</code>, etc.) in <code class="cx ol om on oo b">no_std</code> environments, essential for dynamically managing memory.</li></ul></div></div></div><div class="ab cb oq or os ot" role="separator"><span class="ou by bm ov ow ox"/><span class="ou by bm ov ow ox"/><span class="ou by bm ov ow"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="aa3e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Based on my experience with <code class="cx ol om on oo b"><a class="af nb" href="https://github.com/CarlKCarlK/range-set-blaze" rel="noopener ugc nofollow" target="_blank">range-set-blaze</a></code>, a data structure project, here are the decisions I recommend, described one at a time. To avoid wishy-washiness, I’ll express them as rules.</p><h1 id="99c3" class="oy oz fq bf pa pb pc gq pd pe pf gt pg ph pi pj pk pl pm pn po pp pq pr ps pt bk">Rule 1: Confirm that your existing app works with WASM WASI and create a simple JavaScript web page.</h1><p id="83e6" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">Getting your Rust code to run in the browser will be easier if you meet two prerequisites:</p><ul class=""><li id="fea7" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Get your Rust code running in WASM WASI.</li><li id="9768" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk">Get some JavaScript to run in the browser.</li></ul><p id="2dbd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">For the first prerequisite, see <a class="af nb" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a" rel="noopener">Nine Rules for Running Rust on WASM WASI</a> in <em class="oc">Towards Data Science</em>. That article — the first article in this series — details how to move your code from your native operating system to WASM WASI. With that move, you will be halfway to running on WASM in the Browser.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj pz"><img src="../Images/c13b6ccb5fcff21890cb7aa324a1c097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tY9dG3h58NSfRgIj.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Environments in which we wish to run our code as a Venn diagram of progressively tighter constraints.</figcaption></figure><p id="8f1a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Confirm your code runs on WASM WASI via your tests:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="526d" class="qd oz fq oo b bg qe qf l qg qh">rustup target add wasm32-wasip1<br/>cargo install wasmtime-cli<br/>cargo test --target wasm32-wasip1</span></pre><p id="5431" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">For the second prerequisite, show that you can create some JavaScript code and run it in a browser. I suggest adding this <code class="cx ol om on oo b">index.html</code> file to the top level of your project:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="71fa" class="qd oz fq oo b bg qe qf l qg qh">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>    &lt;title&gt;Line Counter&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;h1&gt;Line Counter&lt;/h1&gt;<br/>    &lt;input type="file" id="fileInput" /&gt;<br/>    &lt;p id="lineCount"&gt;Lines in file: &lt;/p&gt;<br/>    &lt;script&gt;<br/>        const output = document.getElementById('lineCount');<br/>        document.getElementById('fileInput').addEventListener('change', (event) =&gt; {<br/>            const file = event.target.files[0];<br/>            if (!file) { output.innerHTML = ''; return } // No file selected<br/>            const reader = new FileReader();<br/>            // When the file is fully read<br/>            reader.onload = async (e) =&gt; {                <br/>                const content = e.target.result;<br/>                const lines = content.split(/\r\n|\n/).length;<br/>                output.textContent = `Lines in file: ${lines}`;<br/>            };<br/>            // Now start to read the file as text<br/>            reader.readAsText(file);<br/>        });<br/>    &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="35e0" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, serve this page to your browser. You can serve web pages via an editor extension. I use <a class="af nb" href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.live-server" rel="noopener ugc nofollow" target="_blank">Live Preview</a> for VS Code. Alternatively, you can install and use a standalone web server, such as <a class="af nb" href="https://github.com/TheWaWaR/simple-http-server" rel="noopener ugc nofollow" target="_blank">Simple Html Server</a>:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="ca99" class="qd oz fq oo b bg qe qf l qg qh">cargo install simple-http-server<br/>simple-http-server --ip 127.0.0.1 --port 3000 --index<br/># then open browser to http://127.0.0.1:3000</span></pre><p id="7004" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">You should now see a web page on which you can select a file. The JavaScript on the page counts the lines in the file.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qi"><img src="../Images/2e27c53e09c60f8cc65a412a17741755.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*5na_1RmA5qvuYKe65En6qQ.png"/></div></figure><p id="a667" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let’s go over the key parts of the JavaScript because later we will change it to call Rust.</p><blockquote class="nz oa ob"><p id="52f4" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: Must you learn JavaScript to use Rust in the browser? Yes and no. Yes, you’ll need to create at least some simple JavaScript code. No, you may not need to “learn”<strong class="ne fr"> </strong>JavaScript. I’ve found ChatGPT good enough to generate the simple JavaScript that I need.</p></blockquote><ul class=""><li id="de24" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">See what file the user chose. If none, just return:</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="5b8c" class="qd oz fq oo b bg qe qf l qg qh">const file = event.target.files[0];<br/>if (!file) { output.innerHTML = ''; return } // No file selected</span></pre><ul class=""><li id="6ba9" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Create a new <code class="cx ol om on oo b">FileReader </code>object, do some setup, and then read the file as text:</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="b51f" class="qd oz fq oo b bg qe qf l qg qh">const reader = new FileReader();<br/>// ... some setup ...<br/>// Now start to read the file as text<br/>reader.readAsText(file);</span></pre><ul class=""><li id="c1eb" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Here is the setup. It says: wait until the file is fully read, read its contents as a string, split the string into lines, and display the number of lines.</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="c1f3" class="qd oz fq oo b bg qe qf l qg qh">// When the file is fully read<br/>reader.onload = async (e) =&gt; {                <br/>    const content = e.target.result;<br/>    const lines = content.split(/\r\n|\n/).length;<br/>    output.textContent = `Lines in file: ${lines}`;<br/>    };</span></pre><p id="4ccd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With the prerequisites fulfilled, we turn next to installing the needed WASM-in-the-Browser tools.</p><h1 id="f65d" class="oy oz fq bf pa pb pc gq pd pe pf gt pg ph pi pj pk pl pm pn po pp pq pr ps pt bk">Rule 2: Install the <code class="cx ol om on oo b">wasm32-unknown-unknown</code> target, wasm-pack, <code class="cx ol om on oo b">wasm-bindgen-cli</code>, and Chrome for Testing &amp; Chromedriver.</h1><p id="e173" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">We start with something easy, installing these three tools:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="52e6" class="qd oz fq oo b bg qe qf l qg qh">rustup target add wasm32-unknown-unknown<br/>cargo install wasm-pack --force<br/>cargo install wasm-bindgen-cli --force</span></pre><p id="6e57" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The first line installs a new target, <code class="cx ol om on oo b">wasm32-unknown-unknown</code>. This target compiles Rust to WebAssembly without any assumptions about the environment the code will run in. The lack of assumptions makes it suitable to run in browsers. (For more on targets, see the <a class="af nb" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a" rel="noopener">previous article</a>’s Rule #2.)</p><p id="71a3" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The next two lines install <code class="cx ol om on oo b">wasm-pack</code> and <code class="cx ol om on oo b">wasm-bindgen-cli</code>, command-line utilities. The first builds, packages, and publishes into a form suitable for use by a web page. The second makes testing easier. We use <code class="cx ol om on oo b">--force</code> to ensure the utilities are up-to-date and mutually compatible.</p><p id="e453" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, we get to the annoying part, installing Chrome for Testing &amp; Chromedriver. Chrome for Testing is an automatable version of the Chrome browser. Chromedriver is a separate program that can take your Rust tests cases and run them inside Chrome for Testing.</p><p id="6d22" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Why is installing them annoying? First, the process is somewhat complex. Second, the version of Chrome for Testing must match the version of Chromedriver. Third, installing Chrome for Testing will conflict with your current installation of regular Chrome.</p><p id="d201" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With that background, here are my suggestions. Start by installing the two programs into a dedicated subfolder of your home directory.</p><ul class=""><li id="eb80" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Linux and WSL (Windows Subsystem for Linux):</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="32df" class="qd oz fq oo b bg qe qf l qg qh">cd ~<br/>mkdir -p ~/.chrome-for-testing<br/>cd .chrome-for-testing/<br/>wget https://storage.googleapis.com/chrome-for-testing-public/129.0.6668.70/linux64/chrome-linux64.zip<br/>wget https://storage.googleapis.com/chrome-for-testing-public/129.0.6668.70/linux64/chromedriver-linux64.zip<br/>unzip chrome-linux64.zip<br/>unzip chromedriver-linux64.zip</span></pre><ul class=""><li id="9533" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Windows (PowerShell):</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="e215" class="qd oz fq oo b bg qe qf l qg qh">New-Item -Path $HOME -Name ".chrome-for-testing" -ItemType "Directory"<br/>Set-Location -Path $HOME\.chrome-for-testing<br/>bitsadmin /transfer "ChromeDownload" https://storage.googleapis.com/chrome-for-testing-public/129.0.6668.70/win64/chrome-win64.zip $HOME\.chrome-for-testing\chrome-win64.zip<br/>bitsadmin /transfer "ChromeDriverDownload" https://storage.googleapis.com/chrome-for-testing-public/129.0.6668.70/win64/chromedriver-win64.zip $HOME\.chrome-for-testing\chromedriver-win64.zip<br/>Expand-Archive -Path "$HOME\.chrome-for-testing\chrome-win64.zip" -DestinationPath "$HOME\.chrome-for-testing"<br/>Expand-Archive -Path "$HOME\.chrome-for-testing\chromedriver-win64.zip" -DestinationPath "$HOME\.chrome-for-testing"</span></pre><blockquote class="nz oa ob"><p id="3696" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: I’m sorry but I haven’t tested any Mac instructions. Please see <a class="af nb" href="https://googlechromelabs.github.io/chrome-for-testing/" rel="noopener ugc nofollow" target="_blank">the Chrome for Testing web page</a> and then try to adapt the Linux method. If you let me know what works, I’ll update this section.</p></blockquote><p id="62de" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This installs version 129.0.6668.70, the stable version as of 9/30/2024. If you wish, check the <a class="af nb" href="https://googlechromelabs.github.io/chrome-for-testing/" rel="noopener ugc nofollow" target="_blank">Chrome for Testing Availability</a> page for newer stable versions.</p><p id="92ce" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Next, we need to add these programs to our <code class="cx ol om on oo b">PATH</code>. We can add them temporarily, meaning only for the current terminal session:</p><ul class=""><li id="e47e" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Linux and WSL (just for this session):</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="e697" class="qd oz fq oo b bg qe qf l qg qh">export PATH=~/.chrome-for-testing/chrome-linux64:~/.chrome-for-testing/chromedriver-linux64:$PATH</span></pre><ul class=""><li id="9d73" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Windows (just for this session):</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="73ca" class="qd oz fq oo b bg qe qf l qg qh"># PowerShell<br/>$env:PATH = "$HOME\.chrome-for-testing\chrome-win64;$HOME\.chrome-for-testing\chromedriver-win64;$PATH"<br/># or, CMD<br/>set PATH=%USERPROFILE%\.chrome-for-testing\chrome-win64;%USERPROFILE%\.chrome-for-testing\chromedriver-win64;%PATH%</span></pre><p id="a84b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Alternatively, we can add them to our <code class="cx ol om on oo b">PATH</code> permanently for all future terminal sessions. Understand that this may interfere with access to your regular version of Chrome.</p><p id="12e2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Linux and WSL (then restart your terminal):</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="baef" class="qd oz fq oo b bg qe qf l qg qh">echo 'export PATH=~/.chrome-for-testing/chrome-linux64:~/.chrome-for-testing/chromedriver-linux64:$PATH' &gt;&gt; ~/.bashrc</span></pre><p id="3797" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Windows (PowerShell, then restart your terminal):</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="37ea" class="qd oz fq oo b bg qe qf l qg qh">[System.Environment]::SetEnvironmentVariable("Path", "$HOME\.chrome-for-testing\chrome-win64;$HOME\.chrome-for-testing\chromedriver-win64;" + $env:PATH, [System.EnvironmentVariableTarget]::User)</span></pre><p id="2599" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Once installed, you can verify the installation with:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="b84a" class="qd oz fq oo b bg qe qf l qg qh">chromedriver --version</span></pre><blockquote class="nz oa ob"><p id="4a09" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: Can you skip installing and using Chrome for Testing and Chromedriver? Yes and no. If you skip them, you’ll still be able to create WASM from your Rust. Moreover, you’ll be able to call that WASM from JavaScript in a web page.</p><p id="4e34" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">However, your project — like all good code — should already contain tests. If you skip Chrome for Testing, you will not be able to run WASM-in-the-Browser test cases. Moreover, WASM in the Browser violates Rust’s “If it compiles, it works” principle. Specifically, if you use an unsupported feature, like file access, compiling to WASM won’t catch the error. Only test cases can catch such errors. This makes running test cases critically important.</p></blockquote><p id="57a5" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now that we have the tools to run tests in the browser, let’s try (and almost certainly fail) to run those tests.</p><h1 id="0247" class="oy oz fq bf pa pb pc gq pd pe pf gt pg ph pi pj pk pl pm pn po pp pq pr ps pt bk">Rule 3: Make your project <code class="cx ol om on oo b">cdylib </code>(and <code class="cx ol om on oo b">rlib</code>), add <code class="cx ol om on oo b">wasm-bindgen</code> dependencies, and test.</h1><p id="b153" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">The <code class="cx ol om on oo b">wasm-bindgen</code> package is a set of automatically generated bindings between Rust and JavaScript. It lets JavaScript call Rust.</p><p id="a919" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To prepare your code for WASM in the Browser, you’ll make your project a library project. Additionally, you’ll add and use <code class="cx ol om on oo b">wasm-bindgen</code> dependencies. Follow these steps:</p><ul class=""><li id="7452" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">If your project is executable, change it to a library project by renaming <code class="cx ol om on oo b">src/main.rs</code> to <code class="cx ol om on oo b">src/lib.rs</code>. Also, comment out your <code class="cx ol om on oo b">main</code> function.</li><li id="4c0e" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk">Make your project create both a static library (the default) and a dynamic library (needed by WASM). Specifically, edit <code class="cx ol om on oo b">Cargo.toml</code> to include:</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="eaff" class="qd oz fq oo b bg qe qf l qg qh">[lib]<br/>crate-type = ["cdylib", "rlib"]</span></pre><ul class=""><li id="89e5" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Add <code class="cx ol om on oo b">wasm-bindgen</code> dependencies:</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="6069" class="qd oz fq oo b bg qe qf l qg qh">cargo add wasm-bindgen<br/>cargo add wasm-bindgen-test --dev</span></pre><ul class=""><li id="1a5f" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Create or update <code class="cx ol om on oo b">.cargo/config.toml</code> (not to be confused with <code class="cx ol om on oo b">Cargo.toml</code>) to include:</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="02d1" class="qd oz fq oo b bg qe qf l qg qh">[target.wasm32-unknown-unknown]<br/>runner = "wasm-bindgen-test-runner"</span></pre><p id="09bb" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Next, what functions do you wish to be visible to JavaScript? Mark those functions with <code class="cx ol om on oo b">#[wasm_bindgen]</code> and make them <code class="cx ol om on oo b">pub</code> (public). At the top of the functions’ files, add <code class="cx ol om on oo b">use wasm_bindgen::prelude::*;</code>.</p><blockquote class="nz oa ob"><p id="fcd8" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: For now, your functions may fail to compile. We’ll address this issue in subsequent rules.</p></blockquote><p id="f2c3" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">What about tests? Everywhere you have a <code class="cx ol om on oo b">#[test]</code> add a <code class="cx ol om on oo b">#[wasm_bindgen_test]</code>. Where needed for tests, add this <code class="cx ol om on oo b">use</code> statement and a configuration statement:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="06ca" class="qd oz fq oo b bg qe qf l qg qh">use wasm_bindgen_test::wasm_bindgen_test;<br/>wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);</span></pre><p id="1825" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">If you like, you can try the preceding steps on a small, sample project. Install the sample project from GitHub:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="8b56" class="qd oz fq oo b bg qe qf l qg qh"># cd to the top of a work directory<br/>git clone --branch native_version --single-branch https://github.com/CarlKCarlK/rustconf24-good-turing.git good-turing<br/>cd good-turing<br/>cargo test<br/>cargo run pg100.txt</span></pre><p id="b6d7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Here we see all these changes on the small, sample project’s <code class="cx ol om on oo b">lib.rs</code>:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="bfbf" class="qd oz fq oo b bg qe qf l qg qh">// --- May fail to compile for now. ---<br/>use wasm_bindgen::prelude::*;<br/>// ...<br/>#[wasm_bindgen]<br/>pub fn good_turing(file_name: &amp;str) -&gt; Result&lt;(u32, u32), io::Error&gt; {<br/>    let reader = BufReader::new(File::open(file_name)?);<br/>    // ...<br/>}<br/>// fn main() {<br/>// ...<br/>// }<br/>#[cfg(test)]<br/>mod tests {<br/>    use wasm_bindgen_test::wasm_bindgen_test;<br/>    wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);<br/>    // ...<br/>    #[test]<br/>    #[wasm_bindgen_test]<br/>    fn test_process_file() {<br/>      let (prediction, actual) = good_turing("./pg100.txt").unwrap();<br/>      // ...<br/>    }<br/>}</span></pre><p id="eebe" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With these changes made, we’re ready to test (and likely fail):</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="e3b0" class="qd oz fq oo b bg qe qf l qg qh">cargo test --target wasm32-unknown-unknown</span></pre><p id="d9ee" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">On this sample, the compiler complains that WASM in the Browser doesn’t like to return tuple types, here, <code class="cx ol om on oo b">(u32, u32)</code>. It also complains that it doesn’t like to return a <code class="cx ol om on oo b">Result</code> with <code class="cx ol om on oo b">io::Error</code>. To fix these problems, we’ll need to understand which types WASM in the Browser supports. That’s the topic of Rule 4.</p><p id="2472" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">What will happen after we fix the type problems and can run the test? The test will still fail, but now with a runtime error. WASM in the Browser doesn’t support reading from files. The sample test, however, tries to read from a file. In Rule 5, we’ll discuss workarounds for both type limitations and file-access restrictions.</p><h1 id="d9d8" class="oy oz fq bf pa pb pc gq pd pe pf gt pg ph pi pj pk pl pm pn po pp pq pr ps pt bk">Rule 4: Learn what types <code class="cx ol om on oo b">wasm-bindgen</code> supports.</h1><p id="b83d" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">Rust functions that JavaScript can see must have input and output types that <code class="cx ol om on oo b">wasm-bindgen</code> supports. Use of unsupported types causes compiler errors. For example, passing in a <code class="cx ol om on oo b">u32</code> is fine. Passing in a tuple of <code class="cx ol om on oo b">(u32, 32)</code> is not.</p><p id="6396" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">More generally, we can sort Rust types into three categories: “Yep!”, “Nope!”, and “Avoid”.</p><h2 id="6390" class="qj oz fq bf pa qk ql qm pd qn qo qp pg nl qq qr qs np qt qu qv nt qw qx qy qz bk">Yep!</h2><p id="4fc6" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">This is the category for Rust types that JavaScript (via <code class="cx ol om on oo b">wasm-bindgen</code>) understands well.</p><p id="5c9c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We’ll start with <strong class="ne fr">Rust’s simple copy types</strong>:</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj ra"><img src="../Images/40a0ca49852a34ff8b965969aac0a284.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6rLEzmrbFj-upbn6mcYwQ.png"/></div></div></figure><p id="47ad" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Two items surprised me here. First, 64-bit integers require extra work on the JavaScript side. Specifically, they require the use of JavaScript’s <code class="cx ol om on oo b"><a class="af nb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="noopener ugc nofollow" target="_blank">BigInt</a></code> class. Second, JavaScript does not support 128-bit integers. The 128-bit integers are “Nopes”.</p><p id="353a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Turning now to <strong class="ne fr">String-related and vector-related types</strong>:</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj ra"><img src="../Images/fe4f7bd53d64b057ccfc9b2d471ca821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vcxo-fSLtpFUkKg-fDy5XA.png"/></div></div></figure><p id="8a2f" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">These super useful types use heap-allocated memory. Because Rust and JavaScript manage memory differently, each language makes its own copy of the data. I thought I might avoid this allocation by passing a <code class="cx ol om on oo b">&amp;mut [u8]</code> (mutable slice of bytes) from JavaScript to Rust. That didn’t work. <a class="af nb" href="https://stackoverflow.com/questions/78634475/does-wasm-bindgen-copy-mut-u8-zero-times-or-twice/78634853#78634853'" rel="noopener ugc nofollow" target="_blank">Instead of zero copies or one, it copied twice</a>.</p><blockquote class="nz oa ob"><p id="7306" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: For <code class="cx ol om on oo b">String</code> and <code class="cx ol om on oo b">&amp;str</code>, <code class="cx ol om on oo b">wasm-bindgen</code> also converts between JavaScript’s UTF-16 Unicode encoding and Rust’s UTF-8 Unicode encoding.</p></blockquote><p id="7443" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Next, in Rust we love our <strong class="ne fr">Option and Result types</strong>. I’m happy to report that they are “Yeps”.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj rb"><img src="../Images/e2d7c5632da35f7e6ed59d259c8d2f13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Rl4O5CL2uGOY1t1tI78Zw.png"/></div></div></figure><p id="6ce8" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A Rust <code class="cx ol om on oo b">Some(3)</code> becomes a JavaScript <code class="cx ol om on oo b">3</code>, and a Rust <code class="cx ol om on oo b">None</code> becomes a JavaScript <code class="cx ol om on oo b">null</code>. In other words, <code class="cx ol om on oo b">wasm-bindgen</code> converts Rust's type-safe null handling to JavaScript's old-fashioned approach. In both cases, <code class="cx ol om on oo b">null</code>/<code class="cx ol om on oo b">None</code> is handled idiomatically within each language.</p><p id="6338" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Rust <code class="cx ol om on oo b">Result</code> behaves similarly to <code class="cx ol om on oo b">Option</code>. A Rust <code class="cx ol om on oo b">Ok(3)</code> becomes a JavaScript <code class="cx ol om on oo b">3</code>, and a Rust <code class="cx ol om on oo b">Err("Some error message")</code> becomes a JavaScript exception that can be caught with <code class="cx ol om on oo b">try</code>/<code class="cx ol om on oo b">catch</code>. Note that the value inside the Rust <code class="cx ol om on oo b">Err</code> is restricted to types that implement the <code class="cx ol om on oo b">Into&lt;JsValue&gt;</code> trait. Using <code class="cx ol om on oo b">String</code> generally works well.</p><p id="4a59" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Finally, let’s look at <strong class="ne fr">struct, enum, and JSValue</strong>, our last set of “Yeps”:</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj rc"><img src="../Images/c1d7ee973c89183ee633c3f549b171f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jnD6ZfHuaAA0OqFccI8yDw.png"/></div></div></figure><p id="ff78" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Excitingly, JavaScript can construct and call methods on your Rust structs. To enable this, you need to mark the struct and any JavaScript-accessible methods with <code class="cx ol om on oo b">#[wasm_bindgen]</code>.</p><p id="9fc4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">For example, suppose you want to avoid passing a giant string from JavaScript to Rust. You could define a Rust struct that processes a series of strings incrementally. JavaScript could construct the struct, feed it chunks from a file, and then ask for the result.</p><p id="8466" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">JavaScript’s handling of Rust enums is less exciting. It can only handle enums without associated data (C-like enums) and treats their values as integers.</p><p id="76d4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In the middle of the excitement spectrum, you can pass opaque JavaScript values to Rust as <code class="cx ol om on oo b">JsValue</code>. Rust can then dynamically inspect the value to determine its subtype or—if applicable—call its methods.</p><p id="6a9b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">That ends the “Yeps”. Time to look at the “Nopes”.</p><h2 id="7857" class="qj oz fq bf pa qk ql qm pd qn qo qp pg nl qq qr qs np qt qu qv nt qw qx qy qz bk">Nope!</h2><p id="a63a" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">This is the category for Rust types that JavaScript (via <code class="cx ol om on oo b">wasm-bindgen</code>) doesn’t handle.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj rd"><img src="../Images/2bdc9fc79862c1d8d09fffe0877940e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1NaiZwmeUdidKfQf78HP6A.png"/></div></div></figure><p id="f3e2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Not being able to pass, for example, <code class="cx ol om on oo b">&amp;u8</code> by reference is fine because you can just use <code class="cx ol om on oo b">u8</code>, which is likely more efficient anyway.</p><p id="f87b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Not being able to return a string slice (<code class="cx ol om on oo b">&amp;str</code>) or a regular slice (<code class="cx ol om on oo b">&amp;[u8]</code>) is somewhat annoying. To avoid lifetime issues, you must instead return an owned type like <code class="cx ol om on oo b">String</code> or <code class="cx ol om on oo b">Vec&lt;u8&gt;</code>.</p><p id="74dd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">You can’t accept a mutable <code class="cx ol om on oo b">String</code> reference (<code class="cx ol om on oo b">&amp;mut String</code>). However, you can accept a <code class="cx ol om on oo b">String</code> by value, mutate it, and then return the modified <code class="cx ol om on oo b">String</code>.</p><p id="5c35" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">How do we workaround the “Nopes”? In place of fixed-length arrays, tuples, and 128-bit integers, use vectors (<code class="cx ol om on oo b">Vec&lt;T&gt;</code>) or structs.</p><p id="1ed6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Rust has sets and maps. JavaScript has sets and maps. The <code class="cx ol om on oo b">wasm-bindgen</code> library, however, will not automatically convert between them. So, how can you pass, for example, a <code class="cx ol om on oo b">HashSet</code> from Rust to JavaScript? Wrap it in your own Rust struct and define needed methods. Then, mark the struct and those methods with <code class="cx ol om on oo b">#[wasm-bindgen]</code>.</p><p id="cf6c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">And now our third category.</p><h2 id="3e79" class="qj oz fq bf pa qk ql qm pd qn qo qp pg nl qq qr qs np qt qu qv nt qw qx qy qz bk">Avoid</h2><p id="715d" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">This is the category for Rust types that JavaScript (via <code class="cx ol om on oo b">wasm-bindgen</code>) allows but that you shouldn’t use.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj re"><img src="../Images/f588e4f19fc187adcd88b822342e1283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JyXlkXGoEeugehm9tvN2UQ.png"/></div></div></figure><p id="07bc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Avoid using <code class="cx ol om on oo b">usize</code> and <code class="cx ol om on oo b">isize</code> because most people will assume they are 64-bit integers, but in WebAssembly (WASM), they are 32-bit integers. Instead, use <code class="cx ol om on oo b">u32</code>, <code class="cx ol om on oo b">i32</code>, <code class="cx ol om on oo b">u64</code>, or <code class="cx ol om on oo b">i64</code>.</p><p id="00eb" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In Rust, <code class="cx ol om on oo b">char</code> is a special <code class="cx ol om on oo b">u32</code> that can contain only valid Unicode scalar values. JavaScript, in contrast, treats a <code class="cx ol om on oo b">char</code> as a string. It checks for Unicode validity but does not enforce that the string has a length of one. If you need to pass a <code class="cx ol om on oo b">char</code> from JavaScript into Rust, it's better to use the <code class="cx ol om on oo b">String</code> type and then check the length on the Rust side.</p><h1 id="5db6" class="oy oz fq bf pa pb pc gq pd pe pf gt pg ph pi pj pk pl pm pn po pp pq pr ps pt bk">Rule 5: Change functions to use supported types. Change files to generic <code class="cx ol om on oo b">BufRead</code>.</h1><p id="ffa3" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">With our knowledge of <code class="cx ol om on oo b">wasm-bindgen</code> supported types, we can fixup the functions we wish to make available to JavaScript. We left Rule 3’s example with a function like this:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="44fc" class="qd oz fq oo b bg qe qf l qg qh">#[wasm_bindgen]<br/>pub fn good_turing(file_name: &amp;str) -&gt; Result&lt;(u32, u32), io::Error&gt; {<br/>    let reader = BufReader::new(File::open(file_name)?);<br/>    // ...<br/>}</span></pre><p id="b6c7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We, now, change the function by removing <code class="cx ol om on oo b">#[wasm_bindgen] pub</code>. We also change the function to read from a generic reader rather than a file name. Using <code class="cx ol om on oo b">BufRead</code> allows for more flexibility, enabling the function to accept different types of input streams, such as in-memory data or files.</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="f84d" class="qd oz fq oo b bg qe qf l qg qh">fn good_turing&lt;R: BufRead&gt;(reader: R) -&gt; Result&lt;(u32, u32), io::Error&gt; {<br/>  // delete: let reader = BufReader::new(File::open(file_name)?);<br/>  // ...<br/>}</span></pre><p id="04f4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">JavaScript can’t see this function, so we create a wrapper function that calls it. For example:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="c5e9" class="qd oz fq oo b bg qe qf l qg qh">#[wasm_bindgen]<br/>pub fn good_turing_byte_slice(data: &amp;[u8]) -&gt; Result&lt;Vec&lt;u32&gt;, String&gt; {<br/>    let reader = BufReader::new(data);<br/>    match good_turing(reader) {<br/>        Ok((prediction, actual)) =&gt; Ok(vec![prediction, actual]),<br/>        Err(e) =&gt; Err(format!("Error processing data: {e}")),<br/>    }<br/>}</span></pre><p id="0d28" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This wrapper function takes as input a byte slice (<code class="cx ol om on oo b">&amp;[u8]</code>), something JavaScript can pass. The function turns the byte slice into a reader and calls the inner <code class="cx ol om on oo b">good_turing</code>. The inner function returns a <code class="cx ol om on oo b">Result&lt;(u32, u32), io::Error&gt;</code>. The wrapper function translates this result into <code class="cx ol om on oo b">Result&lt;Vec&lt;u32&gt;, String&gt;</code>, a type that JavaScript will accept.</p><p id="83ff" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In general, I’m only willing to make minor changes to functions that will run both natively and in WASM in the Browser. For example, here I’m willing to change the function to work on a generic reader rather than a file name. When JavaScript compatibility requires major, non-idiomatic changes, I create a wrapper function.</p><p id="a15a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In the example, after making these changes, the main code now compiles. The original test, however, does not yet compile. Fixing tests is the topic of Rule 6.</p><h1 id="f4f8" class="oy oz fq bf pa pb pc gq pd pe pf gt pg ph pi pj pk pl pm pn po pp pq pr ps pt bk">Rule 6: Adapt tests, skipping those that don’t apply.</h1><p id="5d87" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">Rule 3 advocated marking every regular test (<code class="cx ol om on oo b">#[test]</code>) to also be a WASM-in-the-Browser test (<code class="cx ol om on oo b">#[wasm_bindgen_test]</code>). However, not all tests from native Rust can be run in a WebAssembly environment, due to WASM’s limitations in accessing system resources like files.</p><p id="224e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In our example, Rule 3 gives us test code that does not compile:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="c45d" class="qd oz fq oo b bg qe qf l qg qh">#[cfg(test)]<br/>mod tests {<br/>    use super::*;<br/>    use wasm_bindgen_test::wasm_bindgen_test;<br/>    wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);<br/><br/>    #[test]<br/>    #[wasm_bindgen_test]<br/>    fn test_process_file() {<br/>        let (prediction, actual) = good_turing("./pg100.txt").unwrap();<br/>        assert_eq!(prediction, 10223);<br/>        assert_eq!(actual, 7967);<br/>    }<br/>}</span></pre><p id="c690" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This test code fails because our updated <code class="cx ol om on oo b">good_turing</code> function expects a generic reader rather than a file name. We can fix the test by creating a reader from the sample file:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="44bf" class="qd oz fq oo b bg qe qf l qg qh">    use std::fs::File;<br/><br/>    #[test]<br/>    fn test_process_file() {<br/>        let reader = BufReader::new(File::open("pg100.txt").unwrap());<br/>        let (prediction, actual) = good_turing(reader).unwrap();<br/>        assert_eq!(prediction, 10223);<br/>        assert_eq!(actual, 7967);<br/>    }</span></pre><p id="8054" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This is a fine native test. Unfortunately, we can’t run it as a WASM-in-the-Browser test because it uses a file reader — something WASM doesn’t support.</p><p id="6820" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The solution is to create an additional test:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="f67b" class="qd oz fq oo b bg qe qf l qg qh">    #[test]<br/>    #[wasm_bindgen_test]<br/>    fn test_good_turing_byte_slice() {<br/>        let data = include_bytes!("../pg100.txt");<br/>        let result = good_turing_byte_slice(data).unwrap();<br/>        assert_eq!(result, vec![10223, 7967]);<br/>    }</span></pre><p id="e987" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">At compile time, this test uses the macro <code class="cx ol om on oo b">include_bytes!</code> to turn a file into a WASM-compatible byte slice. The <code class="cx ol om on oo b">good_turing_byte_slice</code> function turns the byte slice into a reader and calls <code class="cx ol om on oo b">good_turing</code>. (The <code class="cx ol om on oo b">include_bytes</code> macro is <a class="af nb" href="https://doc.rust-lang.org/std/macro.include_bytes.html" rel="noopener ugc nofollow" target="_blank">part of the Rust standard library</a> and, therefore, available to tests.)</p><p id="ee9e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Note that the additional test is both a regular test and a WASM-in-the-Browser test. As much as possible, we want our tests to be both.</p><p id="0100" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In my <code class="cx ol om on oo b">range-set-blaze</code> project, I was able to mark almost all tests as both regular and WASM in the Browser. One exception: a test used a Criterion benchmarking function. Criterion doesn’t run in WASM in the Browser, so I marked that test regular only (<code class="cx ol om on oo b">#[test]</code>).</p><p id="e414" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With both our main code (Rule 5) and our test code (Rule 6) fixed, can we actually run our tests? Not necessarily, we may need to find JavaScript friendly dependences.</p><blockquote class="nz oa ob"><p id="7c0b" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: If you are on Windows and run WASM-in-the-Browser tests, you may see “<code class="cx ol om on oo b">ERROR tiny_http] Error accepting new client: A blocking operation was interrupted by a call to WSACancelBlockingCall. (os error 10004)</code>” This is not related to your tests. You may ignore it.</p></blockquote><h1 id="bf17" class="oy oz fq bf pa pb pc gq pd pe pf gt pg ph pi pj pk pl pm pn po pp pq pr ps pt bk">Rule 7: Change to JavaScript-friendly dependencies, if necessary. Run tests.</h1><h2 id="46fe" class="qj oz fq bf pa qk ql qm pd qn qo qp pg nl qq qr qs np qt qu qv nt qw qx qy qz bk">Dependencies</h2><p id="7a47" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">The sample project will now compile. With my <code class="cx ol om on oo b">range-set-blaze</code> project, however, fixing my code and tests was not enough. I also needed to fix several dependencies. Specifically, I needed to add this to my <code class="cx ol om on oo b">Cargo.toml</code>:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="d426" class="qd oz fq oo b bg qe qf l qg qh">[target.'cfg(all(target_arch = "wasm32", target_os = "unknown"))'.dev-dependencies]<br/>getrandom = { version = "0.2", features = ["js"] }<br/>web-time = "1.1.0"</span></pre><p id="7ea6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">These two dependences enable random numbers and provide an alternative time library. By default, WASM in the Browser has no access to random numbers or time. Both the dependences wrap JavaScript functions making them accessible to and idiomatic for Rust.</p><p id="1b35" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><em class="oc">Aside: For more information on using </em><code class="cx ol om on oo b"><em class="oc">cfg</em></code><em class="oc"> expressions in </em><code class="cx ol om on oo b"><em class="oc">Cargo.toml</em></code><em class="oc">, see my article: </em><a class="af nb" href="https://medium.com/towards-data-science/nine-rust-cargo-toml-wats-and-wat-nots-1e5e02e41648" rel="noopener"><em class="oc">Nine Rust Cargo.toml Wats and Wat Nots</em></a><em class="oc">: Master Cargo.toml formatting rules and avoid frustration | </em>Towards Data Science (medium.com)<em class="oc">.</em></p><p id="63c2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Look for other such JavaScript-wrapping libraries in <a class="af nb" href="https://crates.io/categories/wasm" rel="noopener ugc nofollow" target="_blank">WebAssembly — Categories — crates.io</a>. Popular crates that I haven’t tried but look interesting include:</p><ul class=""><li id="e24b" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk"><a class="af nb" href="https://crates.io/crates/reqwest" rel="noopener ugc nofollow" target="_blank">reqwest</a>— <code class="cx ol om on oo b">features=["wasm"]</code>— HTTP network access</li><li id="b853" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk"><a class="af nb" href="https://crates.io/crates/plotters" rel="noopener ugc nofollow" target="_blank">plotters</a> — Plotting — includes a <a class="af nb" href="https://github.com/plotters-rs/plotters-wasm-demo" rel="noopener ugc nofollow" target="_blank">demo</a> that controls the HTML canvas object from Rust</li><li id="8a21" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk"><a class="af nb" href="https://crates.io/crates/gloo" rel="noopener ugc nofollow" target="_blank">gloo</a> — Toolkit of JavaScript wrappers</li></ul><p id="f770" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Also see Rule 7 in <a class="af nb" rel="noopener" target="_blank" href="/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a">the previous article</a> — about WASM WASI — for more about fixing dependency issues. In the <a class="af nb" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e" rel="noopener">next article</a> in this series — about <code class="cx ol om on oo b">no_std</code> and embedded — we’ll go deeper into more strategies for fixing dependencies.</p><h2 id="f5de" class="qj oz fq bf pa qk ql qm pd qn qo qp pg nl qq qr qs np qt qu qv nt qw qx qy qz bk">Run Tests</h2><p id="1ba9" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">With our dependencies fixed, we can finally run our tests, both regular and WASM in the Browser:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="7250" class="qd oz fq oo b bg qe qf l qg qh">cargo test<br/>cargo test --target wasm32-unknown-unknown</span></pre><p id="310d" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Recall that behind the scenes, our call to <code class="cx ol om on oo b">cargo test --target wasm32-unknown-unknown:</code></p><ul class=""><li id="4623" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Looks in <code class="cx ol om on oo b">.cargo/config.toml</code> and sees <code class="cx ol om on oo b">wasm-bindgen-test-runner</code> (Rule 3).</li><li id="2303" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk">Calls <code class="cx ol om on oo b">wasm-bindgen-test-runner</code>.</li><li id="9e32" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk">Uses Chromedriver to run our tests in Chrome for Testing. (Rule 2, be sure Chrome for Testing and Chromedriver are on your path).</li></ul><p id="a0d7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With our tests working, we’re now ready to call our Rust code from a web page.</p><h1 id="6fe7" class="oy oz fq bf pa pb pc gq pd pe pf gt pg ph pi pj pk pl pm pn po pp pq pr ps pt bk">Rule 8: Connect your web page to your functions.</h1><p id="eec0" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">To call your Rust functions from a web page you must first package your Rust library for the web. We installed <code class="cx ol om on oo b">wasm-pack</code> in Rule 2. Now, we run it:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="e12b" class="qd oz fq oo b bg qe qf l qg qh">wasm-pack build --target web</span></pre><p id="d9be" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This compiles your project and creates a <code class="cx ol om on oo b">pkg</code> output directory that JavaScript understands.</p><h2 id="29e2" class="qj oz fq bf pa qk ql qm pd qn qo qp pg nl qq qr qs np qt qu qv nt qw qx qy qz bk">Example</h2><p id="5341" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">In Rule 1, we created an <code class="cx ol om on oo b">index.html</code> file that didn’t call Rust. Let’s change it now so that it does call Rust. Here is an example of such an <code class="cx ol om on oo b">index.html</code> followed by a description of the changes of interest.</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="1d72" class="qd oz fq oo b bg qe qf l qg qh">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>    &lt;title&gt;Good-Turing Estimation&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;h1&gt;Good-Turing Estimation&lt;/h1&gt;<br/>    &lt;input type="file" id="fileInput" /&gt;<br/>    &lt;p id="lineCount"&gt;&lt;/p&gt;<br/><br/>    &lt;script type="module"&gt;<br/>        import init, { good_turing_byte_slice } from './pkg/good_turing.js'; // These files are generated by `wasm-pack build --target web`<br/>        const output = document.getElementById('lineCount');<br/>        document.getElementById('fileInput').addEventListener('change', (event) =&gt; {<br/>            const file = event.target.files[0];<br/>            if (!file) { output.innerHTML = ''; return } // No file selected<br/>            const reader = new FileReader();<br/>            // When the file is fully read<br/>            reader.onload = async (e) =&gt; {<br/>                await init(); // Ensure 'good_turing_byte_slice' is ready<br/>                // View the memory buffer as a Uint8Array<br/>                const u8array = new Uint8Array(e.target.result);<br/>                try { // Actually run the WASM<br/>                    const [prediction, actual] = good_turing_byte_slice(u8array);<br/>                    output.innerHTML =<br/>                        `Prediction (words that appear exactly once on even lines): ${prediction.toLocaleString()}&lt;br&gt;` +<br/>                        `Actual distinct words that appear only on odd lines: ${actual.toLocaleString()}`;<br/>                } catch (err) { // Or output an error<br/>                    output.innerHTML = `Error: ${err}`;<br/>                }<br/>            };<br/>            // Now start to read the file as memory buffer<br/>            reader.readAsArrayBuffer(file);<br/>        });<br/>    &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="d4c2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let’s go through the changes of interest.</p><ul class=""><li id="5f99" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">The line below imports two functions into JavaScript from the module file <code class="cx ol om on oo b">pkg/good_turing.js</code>, which we created using <code class="cx ol om on oo b">wasm-pack</code>. The default function, <code class="cx ol om on oo b">init</code>, initializes our Rust-generated WebAssembly (WASM) module. The second function, <code class="cx ol om on oo b">good_turing_byte_slice</code>, is explicitly imported by including its name in curly brackets.</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="a32a" class="qd oz fq oo b bg qe qf l qg qh">import init, { good_turing_byte_slice } from './pkg/good_turing.js';</span></pre><ul class=""><li id="20d9" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Create a new <code class="cx ol om on oo b">FileReader</code> object, do some setup, and then read the file as an array of bytes.</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="ed15" class="qd oz fq oo b bg qe qf l qg qh">const reader = new FileReader();<br/>// ... some setup code ...<br/>// Now start to read the file as bytes.<br/>reader.readAsArrayBuffer(file);</span></pre><ul class=""><li id="0da3" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Here is how we setup code that will run after the file is fully read:</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="ec1d" class="qd oz fq oo b bg qe qf l qg qh">reader.onload = async (e) =&gt; {<br/>//...<br/>};</span></pre><ul class=""><li id="19dd" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">This line ensures the WASM module is initialized. The first time it’s called, the module is initialized. On subsequent calls, it does nothing because the module is already ready.</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="6053" class="qd oz fq oo b bg qe qf l qg qh">await init(); // Ensure 'good_turing_byte_slice' is ready</span></pre><ul class=""><li id="a941" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Extract the byte array from the read file.</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="1a24" class="qd oz fq oo b bg qe qf l qg qh">// View the memory buffer as a Uint8Array<br/>const u8array = new Uint8Array(e.target.result);</span></pre><ul class=""><li id="b1fa" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Call the Rust-generated WASM function.</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="4c53" class="qd oz fq oo b bg qe qf l qg qh">const [prediction, actual] = good_turing_byte_slice(u8array);</span></pre><blockquote class="nz oa ob"><p id="cd43" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: Here <code class="cx ol om on oo b">good_turing_byte_slice</code> is a regular (synchronous) function. If you want, however, you can mark it <code class="cx ol om on oo b">async</code> on the Rust side and then call it with <code class="cx ol om on oo b">await</code> on the JavaScript side. If your Rust processing is slow, this can keep your web page more lively.</p></blockquote><ul class=""><li id="308b" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">Display the result.</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="5be9" class="qd oz fq oo b bg qe qf l qg qh">output.innerHTML =<br/>    `Prediction (words that appear exactly once on even lines): ${prediction.toLocaleString()}&lt;br&gt;` +<br/>    `Actual distinct words that appear only on odd lines: ${actual.toLocaleString()}`;</span></pre><ul class=""><li id="0b18" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">If there is an error, display the error message.</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="b47f" class="qd oz fq oo b bg qe qf l qg qh">try { // Actually run the WASM<br/>    // ...<br/>} catch (err) { // Or output an error<br/>    output.innerHTML = `Error: ${err}`;<br/>}</span></pre><p id="8488" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The <a class="af nb" href="https://github.com/CarlKCarlK/rustconf24-good-turing" rel="noopener ugc nofollow" target="_blank">final code</a> of the sample project is on GitHub, including a <a class="af nb" href="https://github.com/CarlKCarlK/rustconf24-good-turing/blob/main/README.md" rel="noopener ugc nofollow" target="_blank">README.md</a> that explains what it is doing. Click <a class="af nb" href="https://carlkcarlk.github.io/rustconf24-good-turing/" rel="noopener ugc nofollow" target="_blank">this link</a> for a live demo.</p><h2 id="c489" class="qj oz fq bf pa qk ql qm pd qn qo qp pg nl qq qr qs np qt qu qv nt qw qx qy qz bk"><code class="cx ol om on oo b">range-set-blaze</code></h2><p id="1e8e" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">I ported <code class="cx ol om on oo b">range-set-blaze</code> to WASM at a user’s request so that they could use it inside their own project. The <code class="cx ol om on oo b"><a class="af nb" href="https://github.com/CarlKCarlK/range-set-blaze" rel="noopener ugc nofollow" target="_blank">range-set-blaze</a></code> project is typically used as a library in other projects. In other words, you normally wouldn’t expect <code class="cx ol om on oo b">range-set-blaze</code> to be the centerpiece of a web page. Nevertheless, I did make a small demo page. You can <a class="af nb" href="https://carlkcarlk.github.io/range-set-blaze/wasm-demo" rel="noopener ugc nofollow" target="_blank">browse it</a> or <a class="af nb" href="https://github.com/CarlKCarlK/range-set-blaze/blob/gh-pages/docs/wasm-demo/index.html" rel="noopener ugc nofollow" target="_blank">inspect its index.html</a>. The page shows how <code class="cx ol om on oo b">range-set-blaze</code> can turn a list of integers into a sorted list of disjoint ranges.</p><blockquote class="nz oa ob"><p id="4705" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Aside: <strong class="ne fr">Host Your WASM-in-the-Browser Project on GitHub for Free</strong><br/>1. In your project, create a <code class="cx ol om on oo b">docs</code> folder.<br/>2. Do <code class="cx ol om on oo b">wasm-pack build --target web</code>.<br/>3. Copy (don’t just move) <code class="cx ol om on oo b">index.html</code> and <code class="cx ol om on oo b">pkg</code> into <code class="cx ol om on oo b">docs</code>.<br/>4. Delete the <code class="cx ol om on oo b">.gitignore</code> file in <code class="cx ol om on oo b">docs/pkg</code>.<br/>5. Check the project into GitHub.<br/>6. Go to the project on GitHub. Then go to “Settings”, “Pages”.<br/>7. Set the branch (in my case <code class="cx ol om on oo b">main</code>) and the folder to <code class="cx ol om on oo b">docs</code>. Save.<br/>8. The URL will be based on your account and project names, for example, <a class="af nb" href="https://carlkcarlk.github.io/rustconf24-good-turing/" rel="noopener ugc nofollow" target="_blank">https://carlkcarlk.github.io/rustconf24-good-turing/</a><br/>9. To update, repeat steps 2 through 5 (inclusive).</p></blockquote><h1 id="5917" class="oy oz fq bf pa pb pc gq pd pe pf gt pg ph pi pj pk pl pm pn po pp pq pr ps pt bk">Rule 9: Add <code class="cx ol om on oo b">wasm-pack</code> to your CI (continuous integration) tests.</h1><p id="838f" class="pw-post-body-paragraph nc nd fq ne b go pu ng nh gr pv nj nk nl pw nn no np px nr ns nt py nv nw nx fj bk">Your project is now compiling to WASM in the Browser, passing tests, and showcased on a web page. Are you done? Not quite. Because, as I said in the first article:</p><blockquote class="rf"><p id="37a9" class="rg rh fq bf ri rj rk rl rm rn ro nx dx"><em class="rp">If it’s not in CI, it doesn’t exist.</em></p></blockquote><p id="32a4" class="pw-post-body-paragraph nc nd fq ne b go rq ng nh gr rr nj nk nl rs nn no np rt nr ns nt ru nv nw nx fj bk">Recall that continuous integration (CI) is a system that can automatically run your tests every time you update your code, ensuring that your code continues to work as expected. In my case, GitHub hosts my project. Here’s the configuration I added to <code class="cx ol om on oo b">.github/workflows/ci.yml</code> to test my project on WASM in the browser:</p><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="f47d" class="qd oz fq oo b bg qe qf l qg qh">  test_wasm_unknown_unknown:<br/>    name: Test WASM unknown unknown<br/>    runs-on: ubuntu-latest<br/>    steps:<br/>      - name: Checkout<br/>        uses: actions/checkout@v4<br/>      - name: Set up Rust<br/>        uses: dtolnay/rust-toolchain@master<br/>        with:<br/>          toolchain: stable<br/>          target: wasm32-unknown-unknown<br/>      - name: Install wasm-pack<br/>        run: |<br/>          curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh<br/>      - name: Run WASM tests with Chrome<br/>        run: |<br/>          rustup target add wasm32-unknown-unknown<br/>          wasm-pack test --chrome --headless</span></pre><p id="2821" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">By integrating WASM in the Browser into CI, I can confidently add new code to my project. CI will automatically test that all my code continues to support WASM in the browser in the future.</p></div></div></div><div class="ab cb oq or os ot" role="separator"><span class="ou by bm ov ow ox"/><span class="ou by bm ov ow ox"/><span class="ou by bm ov ow"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="0957" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">So, there you have it — nine rules for porting your Rust code to WASM in the Browser. Here is what surprised me:</p><p id="9fcd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><strong class="ne fr">The Bad:</strong></p><ul class=""><li id="4af3" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">It’s hard to set up testing for WASM in the Browser. Specifically, Chrome for Testing and Chromedriver are hard to install and manage.</li><li id="f86a" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk">WASM in the Browser violates Rust’s saying “If it compiles, it works”. If you use an unsupported feature — for example, direct file access — the compiler won’t catch the error. Instead, you will fail at runtime.</li><li id="3ab6" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk">Passing strings and byte vectors creates two copies of your data, one on the JavaScript side and one on the Rust side.</li></ul><p id="1ca6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk"><strong class="ne fr">The Good:</strong></p><ul class=""><li id="598b" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">WASM in the Browser is useful and fun.</li><li id="9f8e" class="nc nd fq ne b go og ng nh gr oh nj nk nl oi nn no np oj nr ns nt ok nv nw nx op oe of bk">You can mark your regular tests to also run in WASM in the Browser. Just mark your tests with both attributes:</li></ul><pre class="ml mm mn mo mp qa oo qb bp qc bb bk"><span id="dfc8" class="qd oz fq oo b bg qe qf l qg qh">#[test]<br/>#[wasm_bindgen_test]</span></pre><ul class=""><li id="e6fe" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx op oe of bk">You can run on WASM in the Browser without needing to port to <code class="cx ol om on oo b">no_std</code>. Nevertheless, WASM in the Browser is useful as a steppingstone toward running on embedded/<code class="cx ol om on oo b">no_std</code>.</li></ul><p id="16f0" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Stay tuned! In the <a class="af nb" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e" rel="noopener">next article</a>, we’ll see how to port your Rust code to run in an embedded environment via <code class="cx ol om on oo b">no_std</code>. This allows your code to run in small devices which I find very cool.</p></div></div></div><div class="ab cb oq or os ot" role="separator"><span class="ou by bm ov ow ox"/><span class="ou by bm ov ow ox"/><span class="ou by bm ov ow"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><blockquote class="nz oa ob"><p id="1435" class="nc nd oc ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Interested in future articles? Please <a class="af nb" href="https://medium.com/@carlmkadie" rel="noopener">follow me on Medium</a>. I write about Rust and Python, scientific programming, machine learning, and statistics. I tend to write about one article per month.</p></blockquote></div></div></div></div>    
</body>
</html>
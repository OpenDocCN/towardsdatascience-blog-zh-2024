- en: Why Sets Are So Useful in Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/why-sets-are-so-useful-in-programming-b1157532f7e5?source=collection_archive---------6-----------------------#2024-12-19](https://towardsdatascience.com/why-sets-are-so-useful-in-programming-b1157532f7e5?source=collection_archive---------6-----------------------#2024-12-19)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And how you can use them to boost your code performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@afjal.nc?source=post_page---byline--b1157532f7e5--------------------------------)[![Afjal
    Chowdhury](../Images/92814d13296326ea8dc7d5a64a443092.png)](https://medium.com/@afjal.nc?source=post_page---byline--b1157532f7e5--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--b1157532f7e5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--b1157532f7e5--------------------------------)
    [Afjal Chowdhury](https://medium.com/@afjal.nc?source=post_page---byline--b1157532f7e5--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--b1157532f7e5--------------------------------)
    ·8 min read·Dec 19, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: A *set* is a simple structure defined as a *collection of distinct elements*.
    Sets are most commonly seen in fields like mathematics or logic, but they’re also
    useful in programming for writing efficient code. In this article, I detail cases
    where sets outperform alternative data types like *lists*, and the underlying
    implementation of sets which makes them so useful to programmers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/aa841073ef120a63e6fbafcfd823d962.png)'
  prefs: []
  type: TYPE_IMG
- en: Bolts that form a Set by [Robert Ruggiero](https://unsplash.com/@robert2301?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: A set is an example of a container; these are used to store several elements
    under one variable. When looking for a container datatype, lists (typically defined
    with square brackets [ ]) are the go-to choice, being used extensively in almost
    all programming languages. Sets bare a lot of similarity to lists, most notably
    as they are both **dynamic**, allowing their size to grow or shrink as needed.
    The only differences lie in that lists preserve order of elements and allow duplicates,
    whereas sets do neither, offering a unique advantage in certain scenarios. By
    knowing when to choose sets over lists, you can greatly enhance the performance
    of your programs and improve code readability.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, sets can be declared using curly braces, or by using the set constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Sets do not contain duplicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A defining property of a set is that each element is distinct, or unique, so
    there are no repeated entries. A simple application of this could be to **remove
    all duplicate entries** in a list by converting the list into a set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Because a set is used here, the order of the list is not preserved. Use an implementation
    like the first one if order matters.
  prefs: []
  type: TYPE_NORMAL
- en: The next function **identifies if a list contains any duplicates;** the order
    of elements is not here important, only the *occurrence* of duplicates. The set
    implementation is much more desirable as operations on sets are typically much
    faster than on lists (this is explained in more detail later).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Note: In cases where a duplicate element appears early, the first implementation
    can outperform the second as it catches the duplicate early and returns False
    without checking every entry, whereas the second implementation always iterates
    through every element. A more optimal solution would involve a similar method
    to the first implementation but using a* ***set*** *as the unique_elements container.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Even if these applications seem quite crude or simplistic, there are countless
    uses built upon the principle of “removing duplicates” that take some creativity
    to see. For example, [Leetcode 1832](https://leetcode.com/problems/check-if-the-sentence-is-pangram/)
    ‘*Check if the Sentence is a Pangram*’- where you need to detects if all 26 letters
    have been used in an input sentence- can be elegantly solved using a set comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Without sets, this problem would need to utilise nested looping which is both
    harder to write, and less efficient with a complexity of O(n^2).
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to identifying cases where sets are useful is by considering:'
  prefs: []
  type: TYPE_NORMAL
- en: If we **only care about an occurrence**, like in this problem if the sentence
    contained the word ‘eel’, we only care that the letter ‘e’ occurred, not that
    it occurred twice so we can discard the second and any future ‘e’s.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building on this principal, in cases where a list is **very large**, it may
    be desirable to remove duplicate elements to continue processing on a much smaller
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If **we don’t care about the order** of elements. In cases where maintaining
    order is important, like in a priority queue, lists should instead be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash maps and lack of order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking a step back, it might seem that easy duplicate removal is the only benefit
    of using sets. We previously discussed how sets have no order; arrays have indexed
    element which could simply ignored and treated like a set. It appears that arrays
    can do the same job as a set, if not more.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this simplification enforced by sets opens way to **different underlying
    implementations**. In lists, elements are assigned indices to give each element
    a place in the order. Sets have no need to assign indices, so they instead implement
    a different approach of referencing: hash mapping. These operate by (pseudo)randomly
    allocating addresses to elements, as opposed to storing them in a row. The allocation
    is governed by hashing functions, which use the element as an input to output
    an address.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/48360d958818c5df76f7a6097855dfa1.png)'
  prefs: []
  type: TYPE_IMG
- en: Hashing does not preserve order
  prefs: []
  type: TYPE_NORMAL
- en: '*H(x) is deterministic, so the same input always gives the same output, ie.
    there is no RNG within the function H, so H(4) = 6 always in this case.*'
  prefs: []
  type: TYPE_NORMAL
- en: Running this function takes the same amount of time regardless of the size of
    the set, ie. hashing has O(1) time complexity. This means that the time taken
    to hash is independent of the size of the list, and remains at a constant, quick
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: Set operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because hashing is generally quick, a whole host of operations that are typically
    slow on large arrays can be executed very efficiently on a set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Search or Membership Testing**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Searching for elements in an array utilises an algorithm called *Linear Search*,
    bychecking each item in the list one by one. In the worst case, where the item
    being searched for does not exist in the list, the algorithm traverses every element
    of the list (*O(n)*). In a very large list, this process takes a long time.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/57ec2db048f934d327520f813422a9b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Linear search on average needs n/2 operations, img by author
  prefs: []
  type: TYPE_NORMAL
- en: However, as hashing is O(1), Python hashes the item to be found, and either
    returns where it is in memory, or that it doesn’t exist- in a very small amount
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ee09a8ba99f1baca735980c4270738d5.png)'
  prefs: []
  type: TYPE_IMG
- en: Comparison of search times in lists vs sets
  prefs: []
  type: TYPE_NORMAL
- en: '*Note: Searching using a hashmap has an* ***amortized*** *time complexity of
    O(1). This means that in the average case, it runs at constant time but technically,
    in the worst case, searching is O(n). However, this is extremely unlikely and
    comes down to the hashing implementation having a chance of collisions, which
    is when multiple elements in a hashmap/set are hashed to the same address.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7afe24366b2ac3a3495f2dedd5b2bdb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Collisions are rare
  prefs: []
  type: TYPE_NORMAL
- en: Deletion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting an element from a list first involves a search to locate the element,
    and then removing reference to the element by clearing the address. In an array,
    after the O(n) time search, the index of every element following the deleted element
    needs to be shifted down one. This itself is another O(n) process.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/96a22105c0fd32bd07e8390552b1013c.png)'
  prefs: []
  type: TYPE_IMG
- en: Deletion in a list requires roughly n operations
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an element from a set involves the O(1) lookup, and then erasure of
    the memory address which is an O(1) process so deletion also operates in constant
    time. Sets also have more ways to delete elements, such that errors are not raised,
    or such that multiple elements can be removed concisely.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Insertion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both appending to a list and adding elements to a set are constant operations;
    adding to a specified index in a list (.insert) however comes with the added time
    to shift elements around.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Advanced Set Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Additionally, all the mathematical operations that can be performed on sets
    have implementation in python also. These operations are once again time consuming
    to manually perform on a list, and are once again optimised using hashing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/02016ae2904e6d68483df2cfe84bde21.png)'
  prefs: []
  type: TYPE_IMG
- en: Set Operations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This also includes comparison operators, namely proper and relaxed subsets and
    supersets. These operations once again run much faster than their list counterparts,
    operating in O(n) time, where n is the larger of the 2 sets.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3f8510d9a0ffb98f79661f84c025e805.png)'
  prefs: []
  type: TYPE_IMG
- en: Subset
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Frozen Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A final small, but underrated feature in python is the *frozen set*, which is
    essentially a read-only or **immutable** set. These offer greater memory efficiency
    and could be useful in cases where you frequently test membership in a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The essence of using sets to boost performance is encapsulated by the principle
    of **optimisation by reduction**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/48008eb14526a7d051fad8eafbbecf75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Data structures like lists have the most functionality- being indexed and dynamic-
    but come at the cost of comparatively lower efficiency: speed and memory-wise.
    Identifying which features are essential vs unused to inform what data type to
    use will result in code that runs faster and reads better.'
  prefs: []
  type: TYPE_NORMAL
- en: '*All technical diagrams by author.*'
  prefs: []
  type: TYPE_NORMAL

["```py\nfrom concrete import fhe\n\n#1\\. define the circuit\ndef add(x, y):\n    return x + y\n\n# 2\\. Compile the circuit\ncompiler = fhe.Compiler(add, {\"x\": \"encrypted\", \"y\": \"clear\"})\n\n# examples to determine how many bits to use for integers\ninputset = [(2, 3), (0, 0), (1, 6), (7, 7), (7, 1)]\ncircuit = compiler.compile(inputset)\n\n# 3\\. testing\nx = 4\ny = 4\n\n# clear evaluation (not encrypted)\nclear_evaluation = add(x, y)\n\n# encrypt data, run encrypted circuit, decrypt result\nhomomorphic_evaluation = circuit.encrypt_run_decrypt(x, y)\n\nprint(x, \"+\", y, \"=\", clear_evaluation, \"=\", homomorphic_evaluation)\n```", "```py\nmodule {\n  func.func @main(%arg0: !FHE.eint<4>, %arg1: i5) -> !FHE.eint<4> {\n    %0 = \"FHE.add_eint_int\"(%arg0, %arg1) : (!FHE.eint<4>, i5) -> !FHE.eint<4>\n    return %0 : !FHE.eint<4>\n  }\n}\n```", "```py\ntable = fhe.LookupTable([2, -1, 3, 0])\n\n@fhe.compiler({\"x\": \"encrypted\"})\ndef f(x):\n    return table[x]\n```", "```py\nif a > 0:\n    c = 4\n else:\n    c = 5\n```", "```py\nflag = a > 0 # yields 1 or 0\nc = 4 * flag + 5 * (1 - flag)\n```", "```py\ntable = fhe.LookupTable([0, 1, 1, 1])\n\n@fhe.compiler({\"a\": \"encrypted\"})\ndef f(a):\n    flag = table[a] # a > 0, for 2bit a\n    return 4 * flag + 5 * (1 - flag)\n```", "```py\nfrom concrete import fhe\n\n@fhe.compiler({\"x\": \"encrypted\"})\ndef less_then_21(x):\n    return x < 21\n\ninputset = [1, 31]\n\ncircuit = less_then_21.compile(inputset)\n\n# result in 5bit integer\nx = 19\nhomomorphic_evaluation = circuit.simulate(x)\nprint(f\"homomorphic_evaluation = {homomorphic_evaluation}\")\n```", "```py\nmodule {\n  func.func @main(%arg0: !FHE.eint<5>) -> !FHE.eint<1> {\n    %c21_i6 = arith.constant 21 : i6\n    %cst = arith.constant dense<[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]> : tensor<32xi64>\n    %0 = \"FHE.apply_lookup_table\"(%arg0, %cst) : (!FHE.eint<5>, tensor<32xi64>) -> !FHE.eint<1>\n    return %0 : !FHE.eint<1>\n  }\n}\n```", "```py\n# two numbers are need to presented as  bit arrays\n# ---------------------------\n# 0 0000 -> 1 less (1+0-1), set the curry bit\n# 1 0001 -> 0, equal (1+1-1) or (1+0-0)\n# 2 0010 -> 0, greater (1+1-0)\n# 3 0100 -> 0 (does not exists)\n# carry bit set\n# 5 1000 -> 1\n# 6 1100 -> 1\n# 7 1010 -> 1\n# 8 1010 -> 1\n\nfrom concrete import fhe\n\ntable = fhe.LookupTable([1,0,0,0,1,1,1,1])\n\n# result is 1 if less, 0 otherwise\n@fhe.compiler({\"x\": \"encrypted\", \"y\": \"encrypted\"})\ndef fast_comparision(x, y):\n    carry = 0\n\n    # for all the bits\n    for i in range(4):\n        s = 1 + x[i] - y[i]\n        # left shift by 2 (carry << 4)\n        carry4 = carry*4 + s\n        carry = table[carry4]\n\n    return curry\n\ninputset = [([0,1, 1, 1], [1,0, 1,1])]\n\ncircuit = fast_comparision.compile(inputset)\n\nhomomorphic_evaluation = circuit.simulate([1,0,1, 0], [1,0,0,0])\nprint(\"homomorphic_evaluation =\", homomorphic_evaluation)\n```", "```py\nfrom concrete import fhe\nimport numpy as np\n\n@fhe.compiler({\"in_array\": \"encrypted\"})\ndef bubble_sort(in_array):\n    for i in range(len(in_array)):\n        for j in range(len(in_array)-1):        \n            a = in_array[j]\n            b = in_array[j+1]\n            flag = a > b\n            # if a > b then swap the values\n            in_array[j] = flag * b + (1-flag) * a\n            in_array[j+1] = flag * a + (1-flag) * b\n\n    return in_array\n\ninputset = [[3,0,0,0]]\ncircuit = bubble_sort.compile(inputset)\n\ntest = [3,2,0,1]\ntest_clear = test.copy()\ntest_fhe = test.copy()\n\nclear_evaluation = bubble_sort(test_clear)\n\n#homomorphic_evaluation = circuit.encrypt_run_decrypt(test_fhe)\nhomomorphic_evaluation = circuit.simulate(test_fhe)\n\nprint(test, \"=> \", clear_evaluation, \"=>\", homomorphic_evaluation)\n```"]
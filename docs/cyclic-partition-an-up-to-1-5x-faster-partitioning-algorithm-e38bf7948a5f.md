# 循环划分：一种最多提高1.5倍速度的划分算法

> 原文：[https://towardsdatascience.com/cyclic-partition-an-up-to-1-5x-faster-partitioning-algorithm-e38bf7948a5f?source=collection_archive---------4-----------------------#2024-10-10](https://towardsdatascience.com/cyclic-partition-an-up-to-1-5x-faster-partitioning-algorithm-e38bf7948a5f?source=collection_archive---------4-----------------------#2024-10-10)

## 一种最小化重新排列值的序列划分算法

[](https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------)[![Tigran Hayrapetyan](../Images/36efd337fef6ddc01a4261e301b9ac78.png)](https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------) [Tigran Hayrapetyan](https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------)

·发布于[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------) ·19分钟阅读·2024年10月10日

--

![](../Images/aaca4bc60dbe61ce5228172e0852c4cc.png)

1\. 引言

序列划分是计算机编程中一种基础且常用的算法。给定一个数字序列“*A*”以及一个名为“*p*”的值（称为枢轴值），划分算法的目的是按照某种方式重新排列“*A*”中的数字，使得所有小于‘*p*’的数字排在前面，其余的数字排在后面。

![](../Images/6dd838ac6618329d70677b31f28cab20.png)

*一个示例，展示了在枢轴值“p=20”划分前后的序列。*

在算法执行后，所有小于20的值（浅绿色）

出现于其他值之前（黄色）。*

划分有不同的应用，但最常见的应用包括：

+   快速排序——它通常只不过是一个划分算法，通过递归多次调用在给定数组的不同子数组上，直到数组被排序。

+   查找给定序列的中位数值——利用划分方法有效地缩小搜索范围，最终在线性时间内找到中位数。

排序一个序列是加速大规模数据导航的关键步骤。在两种常见的搜索算法中——线性搜索和二分搜索——只有当数组中的数据已经排序时，二分搜索才能使用。查找中位数或第k阶统计量对于理解给定无序数据的分布非常关键。

目前有不同的划分算法（也称为划分方案），但比较著名的有“Lomuto方案”和“Hoare方案”。Lomuto方案通常更容易直观理解，而Hoare方案在给定数组内部的重新排列较少，因此在实际应用中更为常见。

我在这个故事中将要建议的是一种新的划分方案，叫做“循环划分”，它类似于Hoare方案，但在数组内部进行的重新排列（赋值）减少了1.5倍。因此，正如后续所展示的，赋值的数量几乎等于最初“未在其位置”的值的数量，而这些值应该以某种方式被移动。这一事实让我认为这个新的划分方案几乎是最优的。

接下来的章节将按照以下方式组织：

+   在第2章中，我们将回顾什么是原地划分（一个使得划分任务并非易事的特性），

+   在第3章中，我们将回顾广泛使用的Hoare划分方案，

+   在第4章中，我将介绍“赋值周期”，并展示为什么某些序列的重新排列可能需要比其他重新排列更多的赋值，

+   第5章将使用“赋值周期”的一些性质，推导出新的“循环划分”方案，作为Hoare方案的优化变体，

+   最后，第6章将展示Hoare方案和循环划分在小型和大型数据类型数组上的实验比较。

“循环划分”在C++语言中的实现，以及与当前标准Hoare方案的基准比较，已经在GitHub上展示，并在本故事的最后引用[1]。

# 2\. 回顾原地序列划分

如果输入和输出序列位于计算机内存中的两个不同数组中，划分序列将不再是一个困难的任务。如果是这种情况，可能的方法之一是：

1.  计算在“A”中有多少个值小于‘p’（这将给出输出序列左部分的最终长度），

1.  从左到右扫描输入数组“A”，并根据当前值“A[*i*]”是否小于‘p’，将其分别追加到左部分或右部分。

这里展示了一些运行该算法的状态：

![](../Images/bd9f17358955113e3434fc0f0d8b6782.png)

*在第一阶段，我们计算出有7个值小于“p=20”（这些是浅绿色的），因此我们准备从索引7开始将较大的值写入输出序列。*

![](../Images/f9e1b2e33ffe1606a940fc89c9fef97a.png)

*在第二阶段，在扫描了输入序列中的5个值后，

我们将其中的3个值追加到输出序列的左部分，

其余的2个追加到右部分。*

![](../Images/c82de73a14465cf291d01b03bf0b71ec.png)

*继续第二阶段，我们现在已经从输入序列中扫描了9个值，

将其中5个放在输出序列的左侧部分，另4个放在右侧部分。*

![](../Images/4d3eb3d4846edf6d520b0800ab1312d9.png)

*算法完成。输出序列的两个部分现在已正确填充到最后。

注意，左侧或右侧部分的值的相对顺序被保留，

基于它们在输入数组中的原始写法。

也存在其他较短的解决方案，诸如代码中只有一个循环的那些。

现在，问题在于我们希望不使用额外的内存，因此输入序列将通过仅在唯一数组内移动值来转换为划分后的输出序列。顺便说一下，这种不使用额外内存的算法被称为原地算法。

![](../Images/68571922f3140f447f263db1e119e387.png)

*将相同的输入序列“A”原地划分，使用相同的枢轴值“p=20”。

所呈现的值的顺序对应于序列的输入状态，每个值的箭头显示

如果要将该值移动到哪里，以便整个序列变得划分。*

在介绍我的划分方案之前，让我们回顾一下现有的、常用的原地划分解决方案。

# 3\. 当前使用的划分方案

在观察了几种编程语言标准库中的排序实现后，似乎最广泛使用的划分算法是霍尔方案。我发现它例如在以下实现中被使用：

+   在C++的STL中，使用了“std::sort()”实现，

+   在Java的JDK中，对于原始数据类型，使用了“Arrays.sort()”实现。

在基于霍尔方案的划分中，我们同时从序列的两端向中间扫描，在左侧部分寻找一个值 *A*[*i*]，它大于或等于‘*p*’，在右侧部分寻找一个值 *A*[*j*]，它小于‘*p*’。一旦找到，我们知道这两个值 *A*[*i*] 和 *A*[*j*] 是“没有放在正确的位置”（记住，划分后的序列应当先放置小于‘*p*’的值，然后是大于或等于‘*p*’的值），因此我们交换 *A*[*i*] 和 *A*[*j*]。交换后，我们继续以相同的方式，继续同时扫描数组“A”，使用索引 *i* 和 *j*，直到它们相等。一旦它们相等，划分完成。

让我们在另一个示例中观察霍尔方案：

![](../Images/7dcd2b1d0e8f69d3f0dedf521d6dbb2a.png)

*输入序列“A”长度为’N’，应根据枢轴值“p=20”进行划分。

索引i从0开始向上扫描，索引j从“N-1”开始向下扫描。*

![](../Images/66f4da72a6c895b44fd267f4334a48dd.png)

当索引i增大时，我们遇到值“A[2]=31”，它大于‘p’。然后，在索引j减小时，

我们遇到另一个值“A[10]=16”，它小于‘p’。这两个值将被交换。

![](../Images/79f91856628c0ee07c14e66ec980cf0a.png)

*在交换“A[2]”与“A[10]”之后，我们继续从2开始增加i，从10开始减少j。索引i将在值“A[4]=28”大于‘p’时停止，索引j将在值“A[9]=5”小于‘p’时停止。这两个值也将被交换。*

![](../Images/524bca2c95f5430921fe6c0da6951fa9.png)

*算法按相同的方式继续进行，数字“A[5]=48”和“A[7]=3”也将被交换。*

![](../Images/3c4f00b7e95a7a7d27ff9ce5b00458a8.png)

*之后，索引‘i’和‘j’将变得相等。划分完成。*

如果编写霍尔方案的划分伪代码，我们将得到如下内容：

```py
// Partitions sequence A[0..N) with pivot value 'p' 
// upon Hoare scheme, and returns index of the first value 
// of the resulting right part.
function partition_hoare( A[0..N) : Array of Integers, p: Integer ) : Integer
    i := 0
    j := N-1
    while true
        // Move left index 'i', as much as needed
        while i < j and A[i] < p
            i := i+1
        // Move right index 'j', as much as needed
        while i < j and A[j] >= p
            j := j-1
        // Check for completion
        if i >= j
            if i == j and A[i] < p
                return i+1  // "A[i]" also refers to left part
            else
                return i  // "A[i]" refers to right part
        // Swap "A[i]" and "A[j]"
        tmp := A[i]
        A[i] := A[j]
        A[j] := tmp
        // Advance by one both 'i' and 'j'
        i := i+1
        j := j-1
```

> 在第5和第6行，我们设置了两个扫描的起始索引。
> 
> 第8到10行从左侧查找应该属于右部分的值，划分之后它应该属于右部分。
> 
> 类似地，第11到13行从右侧查找应该属于左部分的值。
> 
> 第15到19行检查扫描是否完成。一旦索引‘i’和‘j’相遇，就有两种情况：要么“A[i]”属于左部分，要么属于右部分。根据情况，我们返回‘i’或‘i+1’，因为函数的返回值应该是右部分的起始索引。
> 
> 接下来，如果扫描尚未完成，第20到23行将交换那些未放置到正确位置的值。
> 
> 最后，第24到26行推进两个索引，以避免重新检查已交换的值。

算法的时间复杂度是*O*(*N*)，无论两个扫描何时相遇，因为它们总共扫描*N*个值。

这里有一个重要的备注，如果数组“*A*”有‘*L*’个“未放置到正确位置”的值，且需要交换，那么按照霍尔方案操作时，我们将进行“3**L*/2”次赋值，因为交换两个值需要进行3次赋值：

![](../Images/7a689b04e744421351a03d3c693d8e7c.png)

*交换两个变量‘a’和‘b’的值需要通过‘tmp’变量进行3次赋值。*

这些赋值是：

```py
tmp := a
a := b
b := tmp
```

我还在这里强调，‘*L*’始终是一个偶数。这是因为，对于每个原本位于左侧区域、满足“A[*i*]>=*p*”的值，都有另一个原本位于右侧区域、满足“A[*j*]<*p*”的值，它们正被交换。所以，每次交换都会重新排列两个这样的值，霍尔方案中的所有重新排列都仅通过交换进行。这就是为什么‘*L*’——需要重新排列的总值数量，始终是一个偶数。

# 4\. 赋值循环

本章看起来可能偏离了故事的议程，但实际上并非如此，因为在下一章优化霍尔划分方案时，我们将需要了解赋值的循环。

假设我们想以某种方式重新排列给定序列“*A*”中的值。这不一定是划分操作，但可以是任何形式的重新排列。让我展示一下，某些重新排列比其他重新排列需要更多的赋值。

## 情况#1：序列的循环左移

如果我们想将序列 “*A*” 循环左移 1 位，应该进行多少次赋值？

![](../Images/e553b939bc7c0ef82e6fe3a43c0d6926.png)

*长度为 N=12 的序列 “A” 循环左移的示例\。

我们看到，所需的赋值次数是 N+1=13，因为我们需要：

1) 将 “A[0]” 存储到临时变量 “tmp” 中，然后

2) 将右侧相邻值赋给当前值，共 “N-1” 次，最后

3) 将 “tmp” 赋值给序列 “A[N-1]” 的最后一个值。*

所需的操作是：

```py
tmp := A[0]
A[0] := A[1]
A[1] := A[2]
...
A[9] := A[10]
A[10] := A[11]
A[11] := tmp
```

… 结果是 13 次赋值。

## 案例 #2: 循环左移 3 位

在下一个示例中，我们仍然希望对相同的序列进行循环左移，但这次是左移 3 位：

![](../Images/f689ead42e953ba64e25a9fbba4927eb.png)

*循环左移 3 位的 “A” 序列示例，长度 N=12。

我们看到，值 A[0]、A[3]、A[6] 和 A[9] 正在彼此之间交换（蓝色箭头），

同时，值 A[1]、A[4]、A[7] 和 A[10] 也会这样做（粉色箭头），

而且值 A[2]、A[5]、A[8] 和 A[11] 仅在彼此之间交换（黄色箭头）。

“tmp” 变量被赋值并读取了 3 次。*

在这里，我们有 3 个独立的链/循环赋值，每个长度为 4。

为了正确地交换 *A*[0]、*A*[3]、*A*[6] 和 *A*[9] 之间的值，需要进行以下操作：

```py
tmp := A[0]
A[0] := A[3]
A[3] := A[6]
A[6] := A[9]
A[9] := tmp
```

… 这会导致 5 次赋值。类似地，交换组内的值（*A*[1]、*A*[4]、*A*[7]、*A*[10]）和（*A*[2]、*A*[5]、*A*[8]、*A*[11]）也需要各 5 次赋值。将这些加在一起，总共需要 5*3=15 次赋值来对长度为 *N*=12 的序列 “*A*” 进行 3 位的循环左移。

## *案例 #3: 反转一个序列*

当反转长度为 ’*N*’ 的序列 “*A*” 时，执行的操作是：

+   将其第一个值与最后一个值交换，然后

+   将第二个值与从右边数来的第二个值交换，

+   将第三个值与从右边数来的第三个值交换，

+   … 依此类推。

![](../Images/3421a95524897208559180641f413088.png)

*反转数组 “A” 的示例，长度 N=12。

我们看到，值对（A[0]、A[11]）、（A[1]、A[10]）、（A[2]、A[9]）等正在彼此交换，互不影响。变量 “tmp” 被赋值并读取了 6 次。*

由于每次交换需要 3 次赋值，而且对于反转整个序列 “*A*” 我们需要做 ⌊*N*/2⌋ 次交换，总的赋值次数为：

> 3*⌊N/2⌋ = 3*⌊12/2⌋ = 3*6 = 18

反转 “*A*” 所需的具体赋值顺序如下：

```py
tmp := A[0]    // Cycle 1
A[0] := A[11]
A[11] := tmp
tmp := A[1]    // Cycle 2
A[1] := A[10]
A[10] := tmp

...

tmp := A[5]    // Cycle 6
A[5] := A[6]
A[6] := tmp
```

## 总结

我们已经看到，对同一序列 “*A*” 进行重新排列可能需要不同数量的赋值，具体取决于值是如何重新排列的。

在这 3 个示例中，序列的长度始终为 *N*=12，但所需的赋值次数是不同的：

![](../Images/6ae43094e570ff03c8f9ab450f725761.png)

更精确地说，赋值次数等于 *N*+*C*，其中“*C*”是重排过程中产生的循环次数。在这里，所谓的“循环”是指“*A*”中的一组变量，其值在彼此之间进行旋转。

在情况 1（左移 1）中，我们只有 *C*=1 次赋值循环，且所有“*A*”中的变量都参与了这个循环。这就是为什么总体赋值次数为：

> N+C = 12+1 = 13。

在情况 2（左移 3）中，我们有 *C*=3 次赋值循环，其中：

— 第一轮应用于变量（*A*[0]，*A*[3]，*A*[6]，*A*[9]），

— 第二轮应用于变量（*A*[1]，*A*[4]，*A*[7]，*A*[10]）并且

— 第三轮应用于变量（*A*[2]，*A*[5]，*A*[8]，*A*[11]）。

这就是为什么总体赋值次数为：

> N+C = 12+3 = 15。

而在我们的情况 3（反转）中，我们有 ⌊*N*/2⌋ = 12/2 = 6 次循环。所有这些都是最短的循环，并且应用于对（*A*[0]，*A*[11]），（*A*[1]，*A*[10]），…… 等等。这就是为什么总体赋值次数为：

> N+C = 12+6 = 18。

当然，在所展示的示例中，赋值数量的绝对差异非常小，在编写高性能代码时不会产生任何影响。但那是因为我们考虑的是一个非常短的数组，长度为“*N*=12”。对于更长的数组，这些赋值数量的差异将与 *N* 成比例增长。

总结本章内容时，让我们记住，重新排列一个序列所需的赋值次数与由这种重新排列引入的循环次数是成正比的。如果我们想要更快速的重新排列，我们应该尝试通过一个赋值循环最少的方案来实现。

# **5\. 优化 Hoare 分区方案**

现在让我们再次观察 Hoare 分区方案，这次关注它引入了多少赋值循环。

假设我们有一个相同长度为 *N* 的数组“*A*”，并且有一个分区值‘*p*’，根据该值必须进行分区。同时假设数组中有‘*L*’个值需要以某种方式重新排列，以将“*A*”带入分区状态。事实证明，Hoare 分区方案以最慢的方式重新排列这些‘*L*’个值，因为它引入了最大数量的赋值循环，每个循环仅涉及 2 个值。

![](../Images/daecf43ab4e32d31447e30733c658d05.png)

*给定分区值“p=20”，需要重新排列的“L=8”个值是那些需要被重新安排的值，

箭头正在出现（或从中移动）。

Hoare 分区方案引入了“L/2=4”个赋值循环，每个循环作用于 2 个值。*

在一个长度为 2 的循环中交换 2 个值，本质上是交换它们，需要 3 次赋值。因此，Hoare 分区方案的总体赋值次数是“3**L*/2”。

我即将描述的优化背后的思想来源于这样一个事实：在划分序列后，我们通常不关心“*A*[*i*]<*p*”的值的相对顺序，它们应该位于划分序列的左侧部分；同样我们也不关心应位于右侧部分的那些值的相对顺序。我们唯一关心的，是所有小于‘*p*’的值应该出现在其他值之前。这个事实使我们能够改变霍尔方案中的赋值循环，并得出一个只包含所有需要重新排列的‘*L*’值的赋值循环。

让我先通过以下插图描述这个改进后的划分方案：

![](../Images/477f288a1d4e8beb24d2e2973a816044.png)

*改进后的划分方案，应用于相同的序列“A”。

由于枢轴“p=20”没有改变，应该重新排列的“L=8”个值也保持不变。

所有箭头表示新方案中唯一的赋值循环。

在将所有‘L’值移动到其上之后，我们将得到一个替代的划分序列。*

那么我们在这里做了什么？

+   与原始的霍尔方案一样，首先我们从左侧扫描，找到这样的值“*A*[*i*]>=*p*”，它应该移到右侧部分。但是我们并不与其他值交换，而是记住它：“*tmp* := *A*[*i*]”。

+   接下来我们从右侧扫描，找到这样的值“*A*[*j*]<*p*”，它应该移到左侧部分。然后我们执行赋值操作“*A*[*i*] := *A*[*j*]”，不会丢失“*A*[*i*]”的值，因为它已经存储在“*tmp*”中。

+   接下来我们从左侧继续扫描，找到这样的值“*A*[*i*]>=*p*”，它也应该移到右侧部分。因此我们执行赋值操作“*A*[*j*] := *A*[*i*]”，不会丢失“*A*[*j*]”的值，因为它已经被赋值到‘*i*’的前一个位置。

+   这个模式会继续下去，当索引 *i* 和 *j* 相遇时，只需将大于‘*p*’的某个值放到“*A*[*j*]”，我们只需执行“*A*[*j*] := *tmp*”，因为最初变量“*tmp*”存储的是第一个大于‘*p*’的值。划分完成。

如我们所见，这里只有1次赋值循环，遍历所有的‘*L*’值，为了正确地重新排列它们，只需要“*L*+1”次赋值，相比之下，霍尔方案需要“3**L*/2”次赋值。

我更喜欢称这个新的划分方案为“循环划分”，因为所有应该重新排列的‘*L*’值现在都位于一个赋值循环中。

这是循环划分算法的伪代码。与霍尔方案的伪代码相比，变化微小，但**现在我们始终执行1.5倍更少的赋值**。

```py
// Partitions sequence A[0..N) with pivot value 'p' 
// by "cyclic partition" scheme, and returns index of 
// the first value of the resulting right part.
function partition_cyclic( A[0..N) : Array of Integers, p: Integer ) : Integer
    i := 0
    j := N-1
    // Find the first value from left, which is not on its place
    while i < N and A[i] < p
        i := i+1
    if i == N
        return N  // All N values go to the left part
    // The cycle of assignments starts here
    tmp := A[i]  // The only write to 'tmp' variable
    while true
        // Move right index 'j', as much as needed
        while i < j and A[j] >= p
            j := j-1
        if i == j  // Check for completion of scans
            break
        // The next assignment in the cycle
        A[i] := A[j]
        i := i+1
        // Move left index 'i', as much as needed
        while i < j and A[i] < p
            i := i+1
        if i == j  // Check for completion of scans
            break
        // The next assignment in the cycle
        A[j] := A[i]
        j := j-1
    // The scans have completed
    A[j] := tmp  // The only read from 'tmp' variable
    return j
```

> 这里第5行和第6行设置了两个扫描的起始索引（‘i’ — 从左到右，‘j’ — 从右到左）。
> 
> 第7至9行从左侧查找应当移到右侧部分的值“A[i]”。如果没有找到这样的值，且所有N个项都属于左侧部分，则第10和11行报告这一点并结束算法。
> 
> 否则，如果找到了该值，第13行我们将其记住在‘tmp’变量中，从而为索引‘i’的槽开启了一个位置，以便放入另一个值。
> 
> 第15至19行从右侧查找应当移动到左侧部分的值“A[j]”。一旦找到，第20至22行将其放入索引‘i’的空槽中，之后索引‘j’的槽变为空，并等待另一个值。
> 
> 同样，第23至27行从左侧查找应当移动到右侧部分的值“A[i]”。一旦找到，第28至30行将其放入索引‘j’的空槽中，之后索引‘i’的槽变为空，并等待另一个值。
> 
> 这种模式在算法的主循环中得以延续，位于第14至30行。
> 
> 一旦索引‘i’和‘j’相遇，我们就在该位置有一个空槽，第31和32行将最初记住的‘tmp’变量中的值放入该槽中，之后索引‘j’成为持有该值的第一个位置，这个值属于右侧部分。
> 
> 最后一行返回那个索引。

这样，我们可以将循环体中的两个赋值操作合并在一起，因为正如第3章所证明的那样，‘*L*’总是一个偶数。

这个算法的时间复杂度也是*O*(*N*)，因为我们仍然是从两端扫描序列。它只是做了1.5倍更少的值赋值操作，因此加速仅反映在常数因子上。

在GitHub上有一个用C++语言实现的循环分区，可以在故事的最后找到引用[1]。

我还想表明，在Hoare方案中出现的值‘*L*’无论我们使用什么分区方案，都无法降低。假设分区后，左侧部分的长度为“*left_n*”，右侧部分的长度为“*right_n*”。现在，如果查看原始未分区数组的左对齐“*left_n*”长区域，我们会发现其中有一些‘t1’值，它们还没有放到最终的位置。所以，这些是大于或等于‘*p*’的值，应该无论如何都要移动到右侧部分。

![](../Images/d395148fb74f9a7086da0d3df7bba2ad.png)

*分区前后序列的示意图。*

左侧部分的长度是“left_n=7”，右侧部分的长度是“right_n=5”。

在未分区序列的前7个值中，有“t1=3”个值。

这些值大于“p=20”（黄色的值），应该以某种方式移动到右侧部分。

而在未分区序列的最后5个值中，有“t2=3”个值。

这些值小于‘p’（浅绿色的值），应该以某种方式移动到左侧部分。*

类似地，如果观察原始未划分数组的右对齐的“*right_n*”长区域，我们将找到一些‘*t2*’值，它们也没有处于最终位置。这些值小于‘*p*’，应该移动到左边部分。我们不能把小于‘*t1*’的值从左移到右，也不能把小于‘*t2*’的值从右移到左。

在霍尔划分方案中，‘*t1*’和‘*t2*’值是相互交换的。所以这里我们有：

> t1 = t2 = L/2，

或者

> t1 + t2 = L。

这意味着‘*L*’实际上是应该以某种方式重新排列的最小值数量，以使得序列能够被划分。而循环划分算法通过执行“*L*+1”次赋值来完成重新排列。这就是为什么我允许自己称这种新的划分方案为“几乎最优”的原因。

# 6. 实验结果

已经证明新的划分方案进行的赋值操作更少，因此我们可以期望它运行得更快。然而，在发布算法之前，我希望以实验的方式收集结果。

我已经比较了使用霍尔（Hoare）方案和循环划分（Cyclic partition）方案时的运行时间。所有实验都是在随机打乱的数组上进行的。

实验之间的不同参数是：

+   *N* — 数组的长度，

+   “left_part_percent” — 划分后左边部分的长度百分比（相对于*N*），

+   在原始数据类型变量数组（32位整数）*vs.* 大对象数组（256长静态数组，包含16位整数）上的运行。

我想澄清一下为什么我认为有必要对原始数据类型的数组和大对象的数组进行划分。在这里，所谓的“大对象”是指占用的内存比原始数据类型要多得多的值。当划分原始数据类型时，将一个变量赋值给另一个变量的速度与算法中几乎所有其他指令（如递增索引或检查循环条件）一样快。与此同时，当划分大对象时，将一个此类对象赋值给另一个将比其他使用的指令需要更多的时间，而这正是我们希望减少赋值总次数的原因。

我稍后会解释为什么我决定在本章稍后进行不同的实验，使用不同的“left_part_percent”值。

实验是在以下系统上使用 Google Benchmark 执行的：

> CPU: Intel Core i7–11800H @ 2.30GHz
> 
> 内存: 16.0 GB
> 
> 操作系统: Windows 11 Home, 64位
> 
> 编译器: MSVC 2022 ( /O2 /Ob2 /MD /GR /Gd )

## *原始数据类型数组的划分*

以下是对原始数据类型数组（32位整数）运行划分算法的结果：

![](../Images/5dc5942fff1891d9586462a471299fdf.png)![](../Images/3635c3e77ec7d8b6b9fdbfefe66f71ed.png)

*在包含32位整数的数组上的分区算法运行时间，数组长度为N=10'000。*

蓝色柱状图对应于霍尔分区算法，

而红色柱状图则对应于循环分区算法。

分区算法在5种不同的情况下运行，基于“left_part_percent”——分区后数组左部分所占百分比（基于N）。时间以纳秒为单位表示。*

我们可以看到，“left_part_percent”的值与两个算法运行时间的相对差异之间没有明显的关联。这种行为是预期中的。

## *分区“large objects”数组*

下面是运行两个分区算法的结果，针对所谓的“large objects”数组——每个数组是一个包含256个16位随机整数的静态数组。

![](../Images/c96678e7fda50c54f2b241541c080557.png)![](../Images/f53f40b7b62dab8d72b720966896c573.png)

*在“large objects”数组上的分区算法运行时间*

（256长的静态数组，包含随机的16位整数），长度为N=10'000。

蓝色柱状图对应于霍尔分区算法，

而红色柱状图则对应于循环分区算法。

分区算法在5种不同的情况下运行，基于“left_part_percent”——分区后数组左部分所占百分比（基于N）。时间以纳秒为单位表示。*

现在我们看到一个明显的关联：当“left_part_percent”接近50%时，循环分区算法的性能优于霍尔分区算法。换句话说，当分区后数组的左右部分长度接近时，循环分区算法的运行速度相对较快。这也是预期的行为。

## 结果解释

*— 为什么当“left_part_percent”接近50%时，分区通常需要更长时间？*

让我们暂时设想一个极端情况——当分区后几乎所有值出现在左边（或右边）部分时。这意味着几乎所有的数组值都小于（或大于）枢轴值。这还意味着在扫描过程中，所有这些值被认为已经位于最终位置，只有很少的值进行了赋值操作。如果设想另一种情况——当分区后，左右部分的长度几乎相等时，这将意味着进行了大量的值赋值操作（因为最初数组中的所有值都是随机打乱的）。

*— 为什么在分区“large objects”时，当“left_part_percent”接近50%时，两个算法的运行时间差异会更大？*

之前的解释表明，当“left_part_percent”接近 50% 时，就需要在数组中进行更多的值赋值。在前面的章节中，我们也展示过，相较于 Hoare 算法，循环分区总是会减少 1.5 倍的值赋值次数。因此，这 1.5 倍的差异在整体运行时间上会带来更大的影响，尤其是在我们通常需要做更多值重新排列的时候。

*— 为什么在分区“大型对象”时，绝对时间（以纳秒为单位）比分区 32 位整数时更长？*

这个问题很简单——因为将一个“大型对象”赋值给另一个对象，所花费的时间要比将一个原始数据类型赋值给另一个原始数据类型要长得多。

我也在不同长度的数组上进行了所有实验，但整体结果并没有改变。

# 7\. 结论

在本故事中，我介绍了一种修改过的分区方案，称为“循环分区”。与当前使用的 Hoare 分区方案相比，它总是能减少 1.5 倍的值赋值次数。

当然，在对序列进行分区时，值赋值并不是唯一的操作类型。除了赋值之外，分区算法还需要检查输入序列“*A*”中的值是否小于或大于枢轴值‘*p*’，并且还会对“*A*”中的索引进行增减操作。比较次数、增减操作的次数与引入“循环分区”没有关系，因此我们不能仅仅期待它能跑得 1.5 倍更快。然而，当分区一个包含复杂数据类型的数组时，值赋值操作比简单的索引增减操作要耗时得多，因此整体算法的执行时间可能会加快最多 1.5 倍。

分区过程是快速排序算法的主要步骤，同时也是查找无序数组中中位数或查找其 *k* 次序统计量的算法步骤。所以我们也可以预期，当处理复杂数据类型时，这些算法的性能提升可以达到 1.5 倍。

> 我感谢：
> 
> — Roza Galstyan，感谢她审阅故事草稿并提出有益的改进建议，
> 
> — David Ayrapetyan，感谢他进行拼写检查（ [https://www.linkedin.com/in/davidayrapetyan/](https://www.linkedin.com/in/davidayrapetyan/) ），
> 
> — Asya Papyan，感谢她精心设计了所有使用的插图（ [https://www.behance.net/asyapapyan](https://www.behance.net/asyapapyan) ）。
> 
> 如果你喜欢这个故事，可以在 LinkedIn 上找到我并联系我（ [https://www.linkedin.com/in/tigran-hayrapetyan-cs/](https://www.linkedin.com/in/tigran-hayrapetyan-cs/) ）。
> 
> 所有使用的图片，除非另有说明，都是根据作者的要求设计的。

# 参考文献：

[1] — C++ 中循环分区的实现： [https://github.com/tigranh/cyclic_partition](https://github.com/tigranh/cyclic_partition)

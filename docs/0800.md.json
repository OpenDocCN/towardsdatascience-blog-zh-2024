["```py\nmvn archetype:generate \\\n-DarchetypeGroupId=org.apache.flink \\\n-DarchetypeArtifactId=flink-quickstart-java \\\n-DarchetypeVersion=1.17.2 \\\n-DgroupId=de.vojay \\\n-DartifactId=flitch \\\n-Dpackage=de.vojay.flitch \\\n-Dversion=0.1.0 \\\n-q\n```", "```py\nConfirm properties configuration:\ngroupId: de.vojay\nartifactId: flitch\nversion: 0.1.0\npackage: de.vojay.flitch\n Y: :\n```", "```py\npackage de.vojay.flitch;\n\nimport org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n\npublic class App {\n\n public static void main(String[] args) throws Exception {\n  StreamExecutionEnvironment env = StreamExecutionEnvironment\n   .getExecutionEnvironment();\n\n  env.fromElements(\"Hello\", \"World\").print();\n  env.execute(\"Flitch\");\n }\n\n}\n```", "```py\n<target.java.version>11</target.java.version>\n```", "```py\n<name>Flitch - Flink Twitch Demo Project</name>\n```", "```py\n<mainClass>de.vojay.flitch.App</mainClass>\n```", "```py\n<dependency>\n <groupId>org.apache.flink</groupId>\n <artifactId>flink-streaming-java</artifactId>\n <version>${flink.version}</version>\n <scope>provided</scope>\n</dependency>\n<dependency>\n <groupId>org.apache.flink</groupId>\n <artifactId>flink-clients</artifactId>\n <version>${flink.version}</version>\n <scope>provided</scope>\n</dependency>\n```", "```py\n<dependency>\n <groupId>org.apache.flink</groupId>\n <artifactId>flink-runtime-web</artifactId>\n <version>${flink.version}</version>\n</dependency>\n```", "```py\npackage de.vojay.flitch;\n\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n\npublic class App {\n\n public static void main(String[] args) throws Exception {\n  StreamExecutionEnvironment env = StreamExecutionEnvironment\n   .createLocalEnvironmentWithWebUI(new Configuration());\n\n  env.fromSequence(1, Long.MAX_VALUE).print();\n  env.execute(\"Flitch\");\n  env.close();\n }\n\n}\n```", "```py\n<dependency>\n <groupId>com.github.twitch4j</groupId>\n <artifactId>twitch4j</artifactId>\n <version>1.19.0</version>\n</dependency>\n```", "```py\npackage de.vojay.flitch;\n\npublic class TwitchMessage {\n\n private final String channel;\n private final String user;\n private final String message;\n\n public TwitchMessage(String channel, String user, String message) {\n  this.channel = channel;\n  this.user = user;\n  this.message = message;\n }\n\n public String getChannel() {\n  return channel;\n }\n\n public String getUser() {\n  return user;\n }\n\n public String getMessage() {\n  return message;\n }\n\n @Override\n public String toString() {\n  StringBuffer sb = new StringBuffer(\"TwitchMessage{\");\n  sb.append(\"channel='\").append(channel).append('\\'');\n  sb.append(\", user='\").append(user).append('\\'');\n  sb.append(\", message='\").append(message).append('\\'');\n  sb.append('}');\n  return sb.toString();\n }\n\n}\n```", "```py\nTwitchClientBuilder clientBuilder = TwitchClientBuilder.builder();\nclient = clientBuilder\n .withEnableChat(true)\n .build();\n\nclient.getChat().joinChannel(\"vojay\");\n```", "```py\npublic class TwitchSource extends RichSourceFunction<TwitchMessage> {\n @Override\n public void open(Configuration configuration) {\n  // ...\n }\n\n // ...\n}\n```", "```py\npublic class TwitchSource extends RichSourceFunction<TwitchMessage> {\n\n private final String[] twitchChannels;\n\n private TwitchClient client;\n private SimpleEventHandler eventHandler;\n private boolean running = true;\n\n public TwitchSource(String[] twitchChannels) {\n  this.twitchChannels = twitchChannels;\n }\n\n @Override\n public void open(Configuration configuration) {\n  client = TwitchClientBuilder\n   .builder()\n   .withEnableChat(true)\n   .build();\n\n  for(String channel : twitchChannels) {\n   client.getChat().joinChannel(channel);\n  }\n\n  eventHandler = client\n   .getEventManager()\n   .getEventHandler(SimpleEventHandler.class);\n\n  running = true;\n }\n\n // ...\n```", "```py\n @Override\n public void run(SourceContext<TwitchMessage> ctx) throws InterruptedException {\n  eventHandler.onEvent(IRCMessageEvent.class, event -> {\n   String channel = event.getChannel().getName();\n   EventUser eventUser = event.getUser();\n   String user = eventUser == null ? \"\" : eventUser.getName();\n   String message = event.getMessage().orElseGet(String::new);\n\n   ctx.collect(new TwitchMessage(channel, user, message));\n  });\n\n  while(running) {\n   Thread.sleep(100);\n  }\n }\n\n @Override\n public void cancel() {\n  client.close();\n  running = false;\n }\n```", "```py\npackage de.vojay.flitch;\n\nimport com.github.philippheuer.events4j.simple.SimpleEventHandler;\nimport com.github.twitch4j.TwitchClient;\nimport com.github.twitch4j.TwitchClientBuilder;\nimport com.github.twitch4j.chat.events.channel.IRCMessageEvent;\nimport com.github.twitch4j.common.events.domain.EventUser;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.streaming.api.functions.source.RichSourceFunction;\n\npublic class TwitchSource extends RichSourceFunction<TwitchMessage> {\n\n private final String[] twitchChannels;\n\n private TwitchClient client;\n private SimpleEventHandler eventHandler;\n private boolean running = true;\n\n public TwitchSource(String[] twitchChannels) {\n  this.twitchChannels = twitchChannels;\n }\n\n @Override\n public void open(Configuration configuration) {\n  client = TwitchClientBuilder\n   .builder()\n   .withEnableChat(true)\n   .build();\n\n  for(String channel : twitchChannels) {\n   client.getChat().joinChannel(channel);\n  }\n\n  eventHandler = client\n   .getEventManager()\n   .getEventHandler(SimpleEventHandler.class);\n\n  running = true;\n }\n\n @Override\n public void run(SourceContext<TwitchMessage> ctx) throws InterruptedException {\n  eventHandler.onEvent(IRCMessageEvent.class, event -> {\n   String channel = event.getChannel().getName();\n   EventUser eventUser = event.getUser();\n   String user = eventUser == null ? \"\" : eventUser.getName();\n   String message = event.getMessage().orElseGet(String::new);\n\n   ctx.collect(new TwitchMessage(channel, user, message));\n  });\n\n  while(running) {\n   Thread.sleep(100);\n  }\n }\n\n @Override\n public void cancel() {\n  client.close();\n  running = false;\n }\n\n}\n```", "```py\npackage de.vojay.flitch;\n\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n\npublic class App {\n\n public static void main(String[] args) throws Exception {\n  StreamExecutionEnvironment env = StreamExecutionEnvironment\n   .createLocalEnvironmentWithWebUI(new Configuration());\n\n  TwitchSource twitchSource = new TwitchSource(new String[]{\"vojay\"});\n  env.addSource(twitchSource)\n   .print();\n\n  env.execute(\"Flitch\");\n  env.close();\n }\n\n}\n```", "```py\nTuple2<TwitchMessage, Tuple2<List<Integer>, List<String>>>\n```", "```py\n<dependency>\n <groupId>edu.stanford.nlp</groupId>\n <artifactId>stanford-corenlp</artifactId>\n <version>4.5.6</version>\n</dependency>\n<dependency>\n <groupId>edu.stanford.nlp</groupId>\n <artifactId>stanford-corenlp</artifactId>\n <version>4.5.6</version>\n <classifier>models</classifier>\n</dependency>\n```", "```py\npublic class AnalyzeSentiment extends RichMapFunction<\n TwitchMessage,\n Tuple2<TwitchMessage, Tuple2<List<Integer>, List<String>>>\n> {\n // ...\n}\n```", "```py\n @Override\n public void open(Configuration configuration) {\n  Properties properties = new Properties();\n  properties.setProperty(\n   \"annotators\",\n   \"tokenize, ssplit, parse, sentiment\"\n  );\n\n  pipeline = new StanfordCoreNLP(properties);\n }\n```", "```py\nAnnotation annotation = pipeline.process(message);\n```", "```py\nannotation.get(SentencesAnnotation.class).forEach(sentence -> {\n```", "```py\n// sentiment score\nTree tree = sentence.get(SentimentAnnotatedTree.class);\nscores.add(getPredictedClass(tree));\n```", "```py\n// sentiment class\nclasses.add(sentence.get(SentimentClass.class));\n```", "```py\nprivate Tuple2<List<Integer>, List<String>> getSentiment(String message) {\n List<Integer> scores = new ArrayList<>();\n List<String> classes = new ArrayList<>();\n\n if (message != null && !message.isEmpty()) {\n  Annotation annotation = pipeline.process(message);\n\n  annotation.get(SentencesAnnotation.class).forEach(sentence -> {\n   // sentiment score\n   Tree tree = sentence.get(SentimentAnnotatedTree.class);\n   scores.add(getPredictedClass(tree));\n\n   // sentiment class\n   classes.add(sentence.get(SentimentClass.class));\n  });\n }\n\n return new Tuple2<>(scores, classes);\n}\n```", "```py\npackage de.vojay.flitch;\n\nimport edu.stanford.nlp.ling.CoreAnnotations.SentencesAnnotation;\nimport edu.stanford.nlp.pipeline.Annotation;\nimport edu.stanford.nlp.pipeline.StanfordCoreNLP;\nimport edu.stanford.nlp.sentiment.SentimentCoreAnnotations.SentimentAnnotatedTree;\nimport edu.stanford.nlp.sentiment.SentimentCoreAnnotations.SentimentClass;\nimport edu.stanford.nlp.trees.Tree;\nimport org.apache.flink.api.common.functions.RichMapFunction;\nimport org.apache.flink.api.java.tuple.Tuple2;\nimport org.apache.flink.configuration.Configuration;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\nimport static edu.stanford.nlp.neural.rnn.RNNCoreAnnotations.getPredictedClass;\n\npublic class AnalyzeSentiment extends RichMapFunction<\n TwitchMessage,\n Tuple2<TwitchMessage, Tuple2<List<Integer>, List<String>>>\n> {\n\n private StanfordCoreNLP pipeline;\n\n @Override\n public void open(Configuration configuration) {\n  Properties properties = new Properties();\n  properties.setProperty(\n   \"annotators\",\n   \"tokenize, ssplit, parse, sentiment\"\n  );\n\n  pipeline = new StanfordCoreNLP(properties);\n }\n\n @Override\n public Tuple2<\n  TwitchMessage,\n  Tuple2<List<Integer>, List<String>>\n > map(TwitchMessage twitchMessage) {\n  return new Tuple2<>(\n   twitchMessage,\n   getSentiment(twitchMessage.getMessage())\n  );\n }\n\n private Tuple2<List<Integer>, List<String>> getSentiment(String message) {\n  List<Integer> scores = new ArrayList<>();\n  List<String> classes = new ArrayList<>();\n\n  if (message != null && !message.isEmpty()) {\n   Annotation annotation = pipeline.process(message);\n\n   annotation.get(SentencesAnnotation.class).forEach(sentence -> {\n    // sentiment score\n    Tree tree = sentence\n     .get(SentimentAnnotatedTree.class);\n    scores.add(getPredictedClass(tree));\n\n    // sentiment class\n    classes.add(sentence.get(SentimentClass.class));\n   });\n  }\n\n  return new Tuple2<>(scores, classes);\n }\n\n}\n```", "```py\nParameterTool parameters = ParameterTool.fromArgs(args);\nString[] twitchChannels = parameters\n .getRequired(\"twitchChannels\")\n .trim()\n .split(\",\");\n```", "```py\n.map(new AnalyzeSentiment())\n```", "```py\npackage de.vojay.flitch;\n\nimport org.apache.flink.api.java.utils.ParameterTool;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\n\npublic class App {\n\n public static void main(String[] args) throws Exception {\n  StreamExecutionEnvironment env = StreamExecutionEnvironment\n   .createLocalEnvironmentWithWebUI(new Configuration());\n\n  ParameterTool parameters = ParameterTool.fromArgs(args);\n  String[] twitchChannels = parameters\n   .getRequired(\"twitchChannels\")\n   .trim()\n   .split(\",\");\n\n  env\n   .addSource(new TwitchSource(twitchChannels))\n   .map(new AnalyzeSentiment())\n   .print();\n\n  env.execute(\"Flitch\");\n  env.close();\n }\n\n}\n```"]
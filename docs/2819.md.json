["```py\nfrom google.oauth2 import service_account\nfrom abc import ABC, abstractmethod\nfrom googleapiclient.discovery import build\n# path to your .json credentials file\nfrom research_assist.gsuite.base.config import CREDENTIALS\nfrom typing import Any\n\nclass GSuiteService(ABC):\n    \"\"\"\n    An abstract base class for G Suite services.\n\n    This class defines the structure for any G Suite service implementation,\n    requiring subclasses to specify the scopes and service creation logic.\n\n    Attributes:\n        credential_path (str): The path to the credentials file.\n        SCOPES (list): The scopes required for the service.\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Initializes the GSuiteService with the credential path and scopes.\n        \"\"\"\n        # The name of the file containing your credentials\n        self.credential_path = CREDENTIALS\n        self.SCOPES = self.get_scopes()\n\n    @abstractmethod\n    def get_scopes(self) -> list[str]:\n        \"\"\"\n        Retrieves the scopes required for the G Suite service.\n\n        Returns:\n            list[str]: A list of scopes required for the service.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    @abstractmethod\n    def get_service(self, credentials: Any) -> Any:\n        \"\"\"\n        Creates and returns the service object for the G Suite service.\n\n        Args:\n            credentials (Any): The credentials to use for the service.\n\n        Returns:\n            Any: The service object for the G Suite service.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement this method.\")\n\n    def build(self) -> Any:\n        \"\"\"\n        Builds the G Suite service using the provided credentials.\n\n        Returns:\n            Any: The constructed service object.\n        \"\"\"\n        # Get credentials into the desired format\n        creds = service_account.Credentials.from_service_account_file(\n            self.credential_path, scopes=self.SCOPES\n        )\n\n        service = self.get_service(creds)\n        return service\n\nclass GoogleDriveService(GSuiteService):\n    \"\"\"\n    A service class for interacting with Google Drive API.\n\n    Inherits from GSuiteService and implements the methods to retrieve\n    the required scopes and create the Google Drive service.\n\n    Methods:\n        get_scopes: Returns the scopes required for Google Drive API.\n        get_service: Creates and returns the Google Drive service object.\n    \"\"\"\n\n    def get_scopes(self) -> list[str]:\n        \"\"\"\n        Retrieves the scopes required for the Google Drive service.\n\n        Returns:\n            list[str]: A list containing the required scopes for Google Drive API.\n        \"\"\"\n        SCOPES = [\"https://www.googleapis.com/auth/drive\"]\n        return SCOPES\n\n    def get_service(self, creds: Any) -> Any:\n        \"\"\"\n        Creates and returns the Google Drive service object.\n\n        Args:\n            creds (Any): The credentials to use for the Google Drive service.\n\n        Returns:\n            Any: The Google Drive service object.\n        \"\"\"\n        return build(\"drive\", \"v3\", credentials=creds, cache_discovery=False)\n```", "```py\nfrom research_assist.gsuite.drive.GoogleDriveHelper import GoogleDriveHelper\n\nmaster_folder_name = ai_assistant_research_projects\ndrive_helper = GoogleDriveHelper(f\"{master_folder_name}\")\n```", "```py\nproject_folder_id = drive_helper.create_new_folder(\"voyager\")\n```", "```py\nversion_folder_id = drive_helper.create_new_folder(\n  \"v1\", \n  parent_folder_id=project_folder_id\n)\n```", "```py\nfinal_report_id = drive_helper.create_basic_document(\n    \"final report\", parent_folder_id=version_folder_id\n)\n```", "```py\ndocument_metadata = {\n            \"name\": document_name,\n            \"mimeType\": \"application/vnd.google-apps.document\",\n            \"parents\": [parent_folder_id],\n}\n# make the document\ndoc = (\n  self.drive_service.files()\n  .create(body=document_metadata, fields=\"id\")\n  execute()\n)\ndoc_id = doc.get(\"id\")\n```", "```py\nfrom research_assist.researcher.Agent import ResearchAgent, load_secrets\nfrom langchain_openai import ChatOpenAI\nfrom tavily import TavilyClient\n\nsecrets = load_secrets()\nmodel = ChatOpenAI(\n    model=\"gpt-4o-mini\", temperature=0, api_key=secrets[\"OPENAI_API_KEY\"]\n)\ntavily = TavilyClient(api_key=secrets[\"TAVILY_API_KEY\"])\n\nagent = ResearchAgent(llm, tavily)\nagent.run_task(\n    task_description=\"The Voyager missions: What did we learn?\", \n    max_revisions=3\n\n)\n```", "```py\nmemories = agent.in_memory_store.search((\"1\", \"memories\"))\n```", "```py\nfinal_essay = agent.in_memory_store.search((\"1\", \"memories\"))[-3].dict()[\"value\"][\n    \"memory\"\n][\"write\"][\"draft\"]\n```", "```py\ndef create_doc_template_header(self, document_title: str, doc_id: str) -> int:\n     \"\"\"\n     Creates a header template for the document, \n     including the title and the current date.\n\n     Args:\n         document_title (str): The title of the document.\n         doc_id (str): The ID of the document to update.\n\n     Returns:\n         int: The index after the inserted header.\n     \"\"\"\n     # add template header\n     title = f\"\"\"\n     {document_title}\n     \"\"\"\n     template = f\"\"\"\n     Written on {datetime.date.today()} at {datetime.datetime.now().strftime(\"%H:%M:%S\")}\n     \"\"\"\n     requests: List[Dict[str, Any]] = [\n            {\n                \"insertText\": {\n                    \"location\": {\n                        \"index\": 1,\n                    },\n                    \"text\": template,\n                }\n            },\n            {\n                \"insertText\": {\n                    \"location\": {\n                        \"index\": 1,\n                    },\n                    \"text\": title,\n                }\n            },\n            {\n                \"updateParagraphStyle\": {\n                    \"range\": {\n                        \"startIndex\": 1,\n                        \"endIndex\": len(title),\n                    },\n                    \"paragraphStyle\": {\n                        \"namedStyleType\": \"TITLE\",\n                        \"spaceAbove\": {\"magnitude\": 1.0, \"unit\": \"PT\"},\n                        \"spaceBelow\": {\"magnitude\": 1.0, \"unit\": \"PT\"},\n                    },\n                    \"fields\": \"namedStyleType,spaceAbove,spaceBelow\",\n                }\n            },\n            {\n                \"updateParagraphStyle\": {\n                    \"range\": {\n                        \"startIndex\": len(title) + 1,\n                        \"endIndex\": len(title) + len(template),\n                    },\n                    \"paragraphStyle\": {\n                        \"namedStyleType\": \"SUBTITLE\",\n                        \"spaceAbove\": {\"magnitude\": 1.0, \"unit\": \"PT\"},\n                        \"spaceBelow\": {\"magnitude\": 1.0, \"unit\": \"PT\"},\n                    },\n                    \"fields\": \"namedStyleType,spaceAbove,spaceBelow\",\n                }\n            },\n        ]\n     result = (\n            self.docs_service.documents()\n            .batchUpdate(documentId=doc_id, body={\"requests\": requests})\n            .execute()\n     )\n     end_index = len(title) + len(template) + 1\n     return end_index\n\ndef write_text_to_doc(self, start_index: int, text: str, doc_id: str) -> int:\n     \"\"\"\n     Writes text to the document at the specified index.\n\n     Args:\n         start_index (int): The index at which to insert the text.\n         text (str): The text to insert.\n         doc_id (str): The ID of the document to update.\n\n     Returns:\n         int: The index after the inserted text.\n     \"\"\"\n     end_index = start_index + len(text) + 1\n\n     requests: List[Dict[str, Any]] = [\n            {\n                \"insertText\": {\n                    \"location\": {\n                        \"index\": start_index,\n                    },\n                    \"text\": text,\n                }\n            },\n            {\n                \"updateParagraphStyle\": {\n                    \"range\": {\n                        \"startIndex\": start_index,\n                        \"endIndex\": start_index + len(text),\n                    },\n                    \"paragraphStyle\": {\n                        \"namedStyleType\": \"NORMAL_TEXT\",\n                        \"spaceAbove\": {\"magnitude\": 1.0, \"unit\": \"PT\"},\n                        \"spaceBelow\": {\"magnitude\": 1.0, \"unit\": \"PT\"},\n                    },\n                    \"fields\": \"namedStyleType,spaceAbove,spaceBelow\",\n                }\n            },\n        ]\n\n     result = (\n            self.docs_service.documents()\n            .batchUpdate(documentId=doc_id, body={\"requests\": requests})\n            .execute()\n        )\n\n     return end_index\n```", "```py\nfrom research_assist.gsuite.docs.GoogleDocsHelper import GoogleDocsHelper\n\ndocs_helper = GoogleDocsHelper()\n\n# add the document title \ntitle_end_index = docs_helper.create_doc_template_header(\n    \"voyager final report\", doc_id\n)\n\n# add the text\ndoc_end_index = docs_helper.write_text_to_doc(\n    start_index=title_end_index, text=final_essay, doc_id=doc_id\n)\n```", "```py\nmemories = agent.in_memory_store.search((\"1\", \"memories\"))\n\n# this is needed because we may call some nodes several times \n# and we want to keep track of this so that we can make new documents\n# for each call\nseen_keys = set()\niterations = defaultdict(int)\n\n# folder id where we want to write the documents\nfolder_id = f\"{folder_id}\"\n\nfor m in memories:\n    data = m.dict()[\"value\"][\"memory\"]\n    available_keys = data.keys()\n    node_key = list(available_keys)[0]\n    unique_node_key = node_key + \"_00\"\n    if unique_node_key in seen_keys:\n        iterations[node_key] += 1\n        unique_node_key = unique_node_key.replace(\"_00\", \"\") + \"_{:02d}\".format(\n            iterations[node_key]\n        )\n\n    print(\"-\" * 20)\n    print(\"Creating doc {}\".format(unique_node_key))\n\n    # get the text\n    text = data[node_key][list(data[node_key].keys())[0]]\n\n    # the tavily research output is a list, so convert it to a string\n    if isinstance(text, List):\n        text = \"\\n\\n\".join(text)\n\n    # if anything else is not a string (e.g. the output of the accept node)\n    # convert it to a string\n    if not isinstance(text, str):\n        text = str(text)\n\n    # create document\n    report_id = drive_service.create_basic_document(\n        unique_node_key, parent_folder_id=folder_id\n    )\n\n    # create header\n    end_index = docs_helper.create_doc_template_header(unique_node_key, report_id)\n\n    # fill document\n    end_index = docs_helper.write_text_to_doc(\n        start_index=end_index, text=text, doc_id=report_id\n    )\n\n    seen_keys.add(unique_node_key)\n```"]
["```py\ndef power(self, effect_size, nobs1, alpha, ratio=1, df=None,\n          alternative='two-sided'):\n    nobs2 = nobs1*ratio\n    if df is None:\n        df = (nobs1 + nobs2 - 2)\n\n    # Get non-centrality parameter\n    nobs = nobs1 * nobs2 / (nobs1 + nobs2)\n    d = effect_size\n    nc_param = d * np.sqrt(nobs)\n\n    # Get effective level of signifiance, alpha_\n    if alternative in ['two-sided']:\n        alpha_ = alpha / 2.\n    elif alternative in ['smaller', 'larger']:\n        alpha_ = alpha\n    else:\n        raise ValueError(\"alternative has to be 'two-sided', 'larger' \" +\n                        \"or 'smaller'\")\n\n    # Compute power of a t-test\n    power = 0\n    if alternative in ['two-sided', 'larger']:\n        crit_upp = stats.t.isf(alpha_, df) # isf = inverse survival function = value where Pr(t > value) = alpha\n        power += 1 - special.nctdtr(df, nc_param, crit_upp)  # 1 - Pr(t < crit_upp) = Pr(t > crit_upp) for non-central t distribution\n    if alternative in ['two-sided', 'smaller']:\n        crit_low = stats.t.ppf(alpha_, df) # ppf = percent point function = value where Pr(t < value) = alpha\n        power += special.nctdtr(df, nc_param, crit_low) # \n    return power\n```", "```py\ndef solve_power(self, effect_size=None, nobs1=None, alpha=None, power=None,\n                ratio=1., alternative='two-sided'):\n    print('--- Arguments: ---')\n    print('effect_size:', effect_size, 'nobs1:', nobs1, 'alpha:', alpha, 'power:', power, 'ratio:', ratio, 'alternative:', alternative, '\\n')\n\n    # Check that only nobs1 is None\n    kwds = dict(effect_size=effect_size, nobs1=nobs1, alpha=alpha,\n                power=power, ratio=ratio, alternative=alternative)\n    key = [k for k,v in kwds.items() if v is None]\n    assert(key == ['nobs1'])\n\n    # Check that the effect_size is not 0\n    if kwds['effect_size'] == 0:\n        raise ValueError('Cannot detect an effect-size of 0\\. Try changing your effect-size.')\n\n    # Initialize the counter\n    self._counter = 0\n\n    # Define the function that we want to find the root of\n    # We want to find nobs1 s.t. current power = target power, i.e. current power - target power = 0\n    # So func = current power - target power\n    def func(x):\n        kwds['nobs1'] = x\n        target_power = kwds.pop('power') # always the same target power specified in keywords, e.g. 0.8\n        current_power = self.power(**kwds) # current power given the current nobs1, note that self.power does not have power as an argument\n        kwds['power'] = target_power # add back power to kwds\n\n        fval = current_power - target_power\n        print(f'Iteration {self._counter}: nobs1 = {x}, current power - target power = {fval}')\n        self._counter += 1\n        return fval\n\n    # Get the starting values for nobs1, given the brentq_expanding algorithm\n    # In the original code, this is the self.start_bqexp dictionary set up in the __init__ method\n    bqexp_fit_kwds = {'low': 2., 'start_upp': 50.}\n\n    # Solve for nobs1 using brentq_expanding\n    print('--- Solving for optimal nobs1: ---')\n    val, _ = brentq_expanding(func, full_output=True, **bqexp_fit_kwds)\n\n    return val\n```"]
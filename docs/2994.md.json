["```py\nimport cv2\n\ncap = cv2.VideoCapture(<video_path>)\nret = True\nwhile ret:\n  ret, frame = cap.read()\n  algo_output = some_video_analsys_algorithm(frame)\n  frame_to_display = visualizer(frame, algo_output)\n  cv2.imshow(frame_to_display)\n  cv2.waitKey()\n```", "```py\nfrom cvvideoplayer import create_video_player\n\nVIDEO_OR_FRAME_FOLDER_PATH = \"<add local path here>\"\n\nvideo_player = create_video_player(video_source=VIDEO_OR_FRAME_FOLDER_PATH)\nvideo_player.run()\n```", "```py\nfrom cvvideoplayer import VideoPlayer\n\nVIDEO_OR_FRAME_FOLDER_PATH = \"<add local path here>\"\n\nvideo_player = create_video_player(\n  video_source=VIDEO_OR_FRAME_FOLDER_PATH,\n  frame_edit_callbacks=[\n            FitFrameToScreen(),\n            FrameInfoOverlay(),\n            KeyMapOverlay(),\n        ]\n)\nvideo_player.run()\n```", "```py\nclass MyCallback(BaseFrameEditCallback):\n    def __init__(\n        self,\n        enable_by_default: bool = True,\n        enable_disable_key: Optional[str] = None,\n        additional_keyboard_shortcuts: Optional[List[KeyFunction]] = None\n        **any_other_needed_params\n    ):\n        super().__init__(\n            enable_by_default,\n            enable_disable_key,\n            additional_keyboard_shortcuts\n         )\n\n    def edit_frame(\n        self,\n        video_player: \"VideoPlayer\",\n        frame: np.ndarray,\n        frame_num: int,\n        original_frame: np.ndarray,\n    ) -> np.ndarray:\n        \"\"\"\n        This function receives the displayed frame and should return it\n        after it has been altered in any way desirable by the user\n\n        Args:\n            video_player: an instance fo VideoPlayer\n            frame (): the frame to be edited and displayed\n            frame_num ():\n            original_frame () the frame before any alterations\n\n        Returns: the edited frame\n        \"\"\"\n        frame = add_any_visalizations(frame)\n        return frame\n```", "```py\nclass MyCallback(BaseFrameEditCallback):\n    ... \n    def setup(self, video_player: \"VideoPlayer\", frame) -> None:\n        \"\"\"\n        Optionally configure more parameters according to the\n        first incoming frame\n        \"\"\"\n\n    def teardown(self) -> None:\n        \"\"\"\n        Optionally define how the callback should close when the\n        video player is closed\n        \"\"\"\n```", "```py\nmy_callback = MyCallback(\n    enable_disable_key=\"ctrl+a\"\n)\n```", "```py\nfrom cvvideoplayer import KeyFunction\n\nclass MyCallback(BaseFrameEditCallback):\n    ...\n    @property\n    def additional_keyboard_shortcuts(self) -> List[KeyFunction]:\n      [\n          KeyFunction(\n              key=\"alt+r\",\n              function=self.a_function_to_modify_the_visualiztion,\n              description=\"what this does\"\n          )\n      ]\n```", "```py\nfrom cvvideoplayer import KeyFunction\n\nclass MyCallback(BaseFrameEditCallback):\n...\n    @property\n    def additional_keyboard_shortcuts(self) -> List[KeyFunction]:\n      [\n          KeyFunction(\n              key=\"alt+r\",\n              function=self.a_function_to_modify_the_visualiztion,\n              description=\"what this does\"\n          )\n      ]\n    def a_function_to_modify_the_visualiztion():\n        self._draw_something = bool(1 - self._draw_somthing)\n```", "```py\nvideo_player = create_video_player(\n  ...\n  double_frame_mode=True\n)\n```", "```py\nvideo_player = create_video_player(\n    ...\n    double_frame_mode=True\n    right_frame_callbacks = [callback1, callback2, ...]\n)\n```"]
["```py\nimport weaviate\nfrom weaviate.util import generate_uuid5\nfrom weaviate.classes.init import Auth\nimport os\nimport json\nimport pandas as pd\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=\"XXX\",  # Replace with your Weaviate Cloud URL\n    auth_credentials=Auth.api_key(\"XXX\"),  # Replace with your Weaviate Cloud key\n    headers={'X-OpenAI-Api-key': \"XXX\"}  # Replace with your OpenAI API key\n)\n```", "```py\ndf = spark.sql(\"SELECT * FROM workspace.default.pub_med_multi_label_text_classification_dataset_processed\").toPandas()\n```", "```py\ndf = pd.read_csv(\"PubMed Multi Label Text Classification Dataset Processed.csv\")\n```", "```py\nimport numpy as np\n# Replace infinity values with NaN and then fill NaN values\ndf.replace([np.inf, -np.inf], np.nan, inplace=True)\ndf.fillna('', inplace=True)\n\n# Convert columns to string type\ndf['Title'] = df['Title'].astype(str)\ndf['abstractText'] = df['abstractText'].astype(str)\ndf['meshMajor'] = df['meshMajor'].astype(str)\n```", "```py\nimport urllib.parse\nfrom rdflib import Graph, RDF, RDFS, Namespace, URIRef, Literal\n\n# Function to create a valid URI\ndef create_valid_uri(base_uri, text):\n    if pd.isna(text):\n        return None\n    # Encode text to be used in URI\n    sanitized_text = urllib.parse.quote(text.strip().replace(' ', '_').replace('\"', '').replace('<', '').replace('>', '').replace(\"'\", \"_\"))\n    return URIRef(f\"{base_uri}/{sanitized_text}\")\n\n# Function to create a valid URI for Articles\ndef create_article_uri(title, base_namespace=\"http://example.org/article/\"):\n    \"\"\"\n    Creates a URI for an article by replacing non-word characters with underscores and URL-encoding.\n\n    Args:\n        title (str): The title of the article.\n        base_namespace (str): The base namespace for the article URI.\n\n    Returns:\n        URIRef: The formatted article URI.\n    \"\"\"\n    if pd.isna(title):\n        return None\n    # Replace non-word characters with underscores\n    sanitized_title = re.sub(r'\\W+', '_', title.strip())\n    # Condense multiple underscores into a single underscore\n    sanitized_title = re.sub(r'_+', '_', sanitized_title)\n    # URL-encode the term\n    encoded_title = quote(sanitized_title)\n    # Concatenate with base_namespace without adding underscores\n    uri = f\"{base_namespace}{encoded_title}\"\n    return URIRef(uri)\n\n# Add a new column to the DataFrame for the article URIs\ndf['Article_URI'] = df['Title'].apply(lambda title: create_valid_uri(\"http://example.org/article\", title))\n```", "```py\n# Function to clean and parse MeSH terms\ndef parse_mesh_terms(mesh_list):\n    if pd.isna(mesh_list):\n        return []\n    return [\n        term.strip().replace(' ', '_')\n        for term in mesh_list.strip(\"[]'\").split(',')\n    ]\n\n# Function to create a valid URI for MeSH terms\ndef create_valid_uri(base_uri, text):\n    if pd.isna(text):\n        return None\n    sanitized_text = urllib.parse.quote(\n        text.strip()\n        .replace(' ', '_')\n        .replace('\"', '')\n        .replace('<', '')\n        .replace('>', '')\n        .replace(\"'\", \"_\")\n    )\n    return f\"{base_uri}/{sanitized_text}\"\n\n# Extract and process all MeSH terms\nall_mesh_terms = []\nfor mesh_list in df[\"meshMajor\"]:\n    all_mesh_terms.extend(parse_mesh_terms(mesh_list))\n\n# Deduplicate terms\nunique_mesh_terms = list(set(all_mesh_terms))\n\n# Create a DataFrame of MeSH terms and their URIs\nmesh_df = pd.DataFrame({\n    \"meshTerm\": unique_mesh_terms,\n    \"URI\": [create_valid_uri(\"http://example.org/mesh\", term) for term in unique_mesh_terms]\n})\n\n# Display the DataFrame\nprint(mesh_df)\n```", "```py\nfrom weaviate.classes.config import Configure\n\n#define the collection\narticles = client.collections.create(\n    name = \"Article\",\n    vectorizer_config=Configure.Vectorizer.text2vec_openai(),  # If set to \"none\" you must always provide vectors yourself. Could be any other \"text2vec-*\" also.\n    generative_config=Configure.Generative.openai(),  # Ensure the `generative-openai` module is used for generative queries\n)\n\n#add ojects\narticles = client.collections.get(\"Article\")\n\nwith articles.batch.dynamic() as batch:\n    for index, row in df.iterrows():\n        batch.add_object({\n            \"title\": row[\"Title\"],\n            \"abstractText\": row[\"abstractText\"],\n            \"Article_URI\": row[\"Article_URI\"],\n            \"meshMajor\": row[\"meshMajor\"],\n        })\n```", "```py\n#define the collection\nterms = client.collections.create(\n    name = \"term\",\n    vectorizer_config=Configure.Vectorizer.text2vec_openai(),  # If set to \"none\" you must always provide vectors yourself. Could be any other \"text2vec-*\" also.\n    generative_config=Configure.Generative.openai(),  # Ensure the `generative-openai` module is used for generative queries\n)\n\n#add ojects\nterms = client.collections.get(\"term\")\n\nwith terms.batch.dynamic() as batch:\n    for index, row in mesh_df.iterrows():\n        batch.add_object({\n            \"meshTerm\": row[\"meshTerm\"],\n            \"URI\": row[\"URI\"],\n        })\n```", "```py\nfrom rdflib import Graph, RDF, RDFS, Namespace, URIRef, Literal\nfrom rdflib.namespace import SKOS, XSD\nimport pandas as pd\nimport urllib.parse\nimport random\nfrom datetime import datetime, timedelta\nimport re\nfrom urllib.parse import quote\n\n# --- Initialization ---\ng = Graph()\n\n# Define namespaces\nschema = Namespace('http://schema.org/')\nex = Namespace('http://example.org/')\nprefixes = {\n    'schema': schema,\n    'ex': ex,\n    'skos': SKOS,\n    'xsd': XSD\n}\nfor p, ns in prefixes.items():\n    g.bind(p, ns)\n\n# Define classes and properties\nArticle = URIRef(ex.Article)\nMeSHTerm = URIRef(ex.MeSHTerm)\ng.add((Article, RDF.type, RDFS.Class))\ng.add((MeSHTerm, RDF.type, RDFS.Class))\n\ntitle = URIRef(schema.name)\nabstract = URIRef(schema.description)\ndate_published = URIRef(schema.datePublished)\naccess = URIRef(ex.access)\n\ng.add((title, RDF.type, RDF.Property))\ng.add((abstract, RDF.type, RDF.Property))\ng.add((date_published, RDF.type, RDF.Property))\ng.add((access, RDF.type, RDF.Property))\n\n# Function to clean and parse MeSH terms\ndef parse_mesh_terms(mesh_list):\n    if pd.isna(mesh_list):\n        return []\n    return [term.strip() for term in mesh_list.strip(\"[]'\").split(',')]\n\n# Enhanced convert_to_uri function\ndef convert_to_uri(term, base_namespace=\"http://example.org/mesh/\"):\n    \"\"\"\n    Converts a MeSH term into a standardized URI by replacing spaces and special characters with underscores,\n    ensuring it starts and ends with a single underscore, and URL-encoding the term.\n\n    Args:\n        term (str): The MeSH term to convert.\n        base_namespace (str): The base namespace for the URI.\n\n    Returns:\n        URIRef: The formatted URI.\n    \"\"\"\n    if pd.isna(term):\n        return None  # Handle NaN or None terms gracefully\n\n    # Step 1: Strip existing leading and trailing non-word characters (including underscores)\n    stripped_term = re.sub(r'^\\W+|\\W+$', '', term)\n\n    # Step 2: Replace non-word characters with underscores (one or more)\n    formatted_term = re.sub(r'\\W+', '_', stripped_term)\n\n    # Step 3: Replace multiple consecutive underscores with a single underscore\n    formatted_term = re.sub(r'_+', '_', formatted_term)\n\n    # Step 4: URL-encode the term to handle any remaining special characters\n    encoded_term = quote(formatted_term)\n\n    # Step 5: Add single leading and trailing underscores\n    term_with_underscores = f\"_{encoded_term}_\"\n\n    # Step 6: Concatenate with base_namespace without adding an extra underscore\n    uri = f\"{base_namespace}{term_with_underscores}\"\n\n    return URIRef(uri)\n\n# Function to generate a random date within the last 5 years\ndef generate_random_date():\n    start_date = datetime.now() - timedelta(days=5*365)\n    random_days = random.randint(0, 5*365)\n    return start_date + timedelta(days=random_days)\n\n# Function to generate a random access value between 1 and 10\ndef generate_random_access():\n    return random.randint(1, 10)\n\n# Function to create a valid URI for Articles\ndef create_article_uri(title, base_namespace=\"http://example.org/article\"):\n    \"\"\"\n    Creates a URI for an article by replacing non-word characters with underscores and URL-encoding.\n\n    Args:\n        title (str): The title of the article.\n        base_namespace (str): The base namespace for the article URI.\n\n    Returns:\n        URIRef: The formatted article URI.\n    \"\"\"\n    if pd.isna(title):\n        return None\n    # Encode text to be used in URI\n    sanitized_text = urllib.parse.quote(title.strip().replace(' ', '_').replace('\"', '').replace('<', '').replace('>', '').replace(\"'\", \"_\"))\n    return URIRef(f\"{base_namespace}/{sanitized_text}\")\n\n# Loop through each row in the DataFrame and create RDF triples\nfor index, row in df.iterrows():\n    article_uri = create_article_uri(row['Title'])\n    if article_uri is None:\n        continue\n\n    # Add Article instance\n    g.add((article_uri, RDF.type, Article))\n    g.add((article_uri, title, Literal(row['Title'], datatype=XSD.string)))\n    g.add((article_uri, abstract, Literal(row['abstractText'], datatype=XSD.string)))\n\n    # Add random datePublished and access\n    random_date = generate_random_date()\n    random_access = generate_random_access()\n    g.add((article_uri, date_published, Literal(random_date.date(), datatype=XSD.date)))\n    g.add((article_uri, access, Literal(random_access, datatype=XSD.integer)))\n\n    # Add MeSH Terms\n    mesh_terms = parse_mesh_terms(row['meshMajor'])\n    for term in mesh_terms:\n        term_uri = convert_to_uri(term, base_namespace=\"http://example.org/mesh/\")\n        if term_uri is None:\n            continue\n\n        # Add MeSH Term instance\n        g.add((term_uri, RDF.type, MeSHTerm))\n        g.add((term_uri, RDFS.label, Literal(term.replace('_', ' '), datatype=XSD.string)))\n\n        # Link Article to MeSH Term\n        g.add((article_uri, schema.about, term_uri))\n\n# Path to save the file\nfile_path = \"/Workspace/PubMedGraph.ttl\"\n\n# Save the file\ng.serialize(destination=file_path, format='turtle')\n\nprint(f\"File saved at {file_path}\")\n```", "```py\n-- app.py (a python file that drives the app and calls other functions as needed)\n-- query_functions (a folder containing python files with queries)\n  -- rdf_queries.py (python file with RDF queries)\n  -- weaviate_queries.py (python file containing weaviate queries)\n-- PubMedGraph.ttl (the pubmed data in RDF format, stored as a ttl file)\n```", "```py\n# --- TAB 1: Search Articles ---\nwith tab_search:\n    st.header(\"Search Articles (Vector Query)\")\n    query_text = st.text_input(\"Enter your vector search term (e.g., Mouth Neoplasms):\", key=\"vector_search\")\n\n    if st.button(\"Search Articles\", key=\"search_articles_btn\"):\n        try:\n            client = initialize_weaviate_client()\n            article_results = query_weaviate_articles(client, query_text)\n\n            # Extract URIs here\n            article_uris = [\n                result[\"properties\"].get(\"article_URI\")\n                for result in article_results\n                if result[\"properties\"].get(\"article_URI\")\n            ]\n\n            # Store article_uris in the session state\n            st.session_state.article_uris = article_uris\n\n            st.session_state.article_results = [\n                {\n                    \"Title\": result[\"properties\"].get(\"title\", \"N/A\"),\n                    \"Abstract\": (result[\"properties\"].get(\"abstractText\", \"N/A\")[:100] + \"...\"),\n                    \"Distance\": result[\"distance\"],\n                    \"MeSH Terms\": \", \".join(\n                        ast.literal_eval(result[\"properties\"].get(\"meshMajor\", \"[]\"))\n                        if result[\"properties\"].get(\"meshMajor\") else []\n                    ),\n\n                }\n                for result in article_results\n            ]\n            client.close()\n        except Exception as e:\n            st.error(f\"Error during article search: {e}\")\n\n    if st.session_state.article_results:\n        st.write(\"**Search Results for Articles:**\")\n        st.table(st.session_state.article_results)\n    else:\n        st.write(\"No articles found yet.\")\n```", "```py\n# Function to query Weaviate for Articles\ndef query_weaviate_articles(client, query_text, limit=10):\n    # Perform vector search on Article collection\n    response = client.collections.get(\"Article\").query.near_text(\n        query=query_text,\n        limit=limit,\n        return_metadata=MetadataQuery(distance=True)\n    )\n\n    # Parse response\n    results = []\n    for obj in response.objects:\n        results.append({\n            \"uuid\": obj.uuid,\n            \"properties\": obj.properties,\n            \"distance\": obj.metadata.distance,\n        })\n    return results\n```", "```py\n# Function to query Weaviate for MeSH Terms\ndef query_weaviate_terms(client, query_text, limit=10):\n    # Perform vector search on MeshTerm collection\n    response = client.collections.get(\"term\").query.near_text(\n        query=query_text,\n        limit=limit,\n        return_metadata=MetadataQuery(distance=True)\n    )\n\n    # Parse response\n    results = []\n    for obj in response.objects:\n        results.append({\n            \"uuid\": obj.uuid,\n            \"properties\": obj.properties,\n            \"distance\": obj.metadata.distance,\n        })\n    return results\n```", "```py\n# Fetch alternative names and triples for a MeSH term\ndef get_concept_triples_for_term(term):\n    term = sanitize_term(term)  # Sanitize input term\n    sparql = SPARQLWrapper(\"https://id.nlm.nih.gov/mesh/sparql\")\n    query = f\"\"\"\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n    PREFIX meshv: <http://id.nlm.nih.gov/mesh/vocab#>\n    PREFIX mesh: <http://id.nlm.nih.gov/mesh/>\n\n    SELECT ?subject ?p ?pLabel ?o ?oLabel\n    FROM <http://id.nlm.nih.gov/mesh>\n    WHERE {{\n        ?subject rdfs:label \"{term}\"@en .\n        ?subject ?p ?o .\n        FILTER(CONTAINS(STR(?p), \"concept\"))\n        OPTIONAL {{ ?p rdfs:label ?pLabel . }}\n        OPTIONAL {{ ?o rdfs:label ?oLabel . }}\n    }}\n    \"\"\"\n    try:\n        sparql.setQuery(query)\n        sparql.setReturnFormat(JSON)\n        results = sparql.query().convert()\n\n        triples = set()\n        for result in results[\"results\"][\"bindings\"]:\n            obj_label = result.get(\"oLabel\", {}).get(\"value\", \"No label\")\n            triples.add(sanitize_term(obj_label))  # Sanitize term before adding\n\n        # Add the sanitized term itself to ensure it's included\n        triples.add(sanitize_term(term))\n        return list(triples)\n\n    except Exception as e:\n        print(f\"Error fetching concept triples for term '{term}': {e}\")\n        return []\n```", "```py\n# Fetch narrower concepts for a MeSH term\ndef get_narrower_concepts_for_term(term):\n    term = sanitize_term(term)  # Sanitize input term\n    sparql = SPARQLWrapper(\"https://id.nlm.nih.gov/mesh/sparql\")\n    query = f\"\"\"\n    PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n    PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n    PREFIX meshv: <http://id.nlm.nih.gov/mesh/vocab#>\n    PREFIX mesh: <http://id.nlm.nih.gov/mesh/>\n\n    SELECT ?narrowerConcept ?narrowerConceptLabel\n    WHERE {{\n        ?broaderConcept rdfs:label \"{term}\"@en .\n        ?narrowerConcept meshv:broaderDescriptor ?broaderConcept .\n        ?narrowerConcept rdfs:label ?narrowerConceptLabel .\n    }}\n    \"\"\"\n    try:\n        sparql.setQuery(query)\n        sparql.setReturnFormat(JSON)\n        results = sparql.query().convert()\n\n        concepts = set()\n        for result in results[\"results\"][\"bindings\"]:\n            subject_label = result.get(\"narrowerConceptLabel\", {}).get(\"value\", \"No label\")\n            concepts.add(sanitize_term(subject_label))  # Sanitize term before adding\n\n        return list(concepts)\n\n    except Exception as e:\n        print(f\"Error fetching narrower concepts for term '{term}': {e}\")\n        return []\n\n# Recursive function to fetch narrower concepts to a given depth\ndef get_all_narrower_concepts(term, depth=2, current_depth=1):\n    term = sanitize_term(term)  # Sanitize input term\n    all_concepts = {}\n    try:\n        narrower_concepts = get_narrower_concepts_for_term(term)\n        all_concepts[sanitize_term(term)] = narrower_concepts\n\n        if current_depth < depth:\n            for concept in narrower_concepts:\n                child_concepts = get_all_narrower_concepts(concept, depth, current_depth + 1)\n                all_concepts.update(child_concepts)\n\n    except Exception as e:\n        print(f\"Error fetching all narrower concepts for term '{term}': {e}\")\n\n    return all_concepts\n```", "```py\n if st.button(\"Filter Articles\"):\n            try:\n                # Check if we have URIs from tab 1\n                if \"article_uris\" in st.session_state and st.session_state.article_uris:\n                    article_uris = st.session_state.article_uris\n\n                    # Convert list of URIs into a string for the VALUES clause or FILTER\n                    article_uris_string = \", \".join([f\"<{str(uri)}>\" for uri in article_uris])\n\n                    SPARQL_QUERY = \"\"\"\n                    PREFIX schema: <http://schema.org/>\n                    PREFIX ex: <http://example.org/>\n\n                    SELECT ?article ?title ?abstract ?datePublished ?access ?meshTerm\n                    WHERE {{\n                      ?article a ex:Article ;\n                               schema:name ?title ;\n                               schema:description ?abstract ;\n                               schema:datePublished ?datePublished ;\n                               ex:access ?access ;\n                               schema:about ?meshTerm .\n\n                      ?meshTerm a ex:MeSHTerm .\n\n                      FILTER (?article IN ({article_uris}))\n                    }}\n                    \"\"\"\n                    # Insert the article URIs into the query\n                    query = SPARQL_QUERY.format(article_uris=article_uris_string)\n                else:\n                    st.write(\"No articles selected from Tab 1.\")\n                    st.stop()\n\n                # Query the RDF and save results in session state\n                top_articles = query_rdf(LOCAL_FILE_PATH, query, final_terms)\n                st.session_state.filtered_articles = top_articles\n\n                if top_articles:\n\n                    # Combine abstracts from top articles and save in session state\n                    def combine_abstracts(ranked_articles):\n                        combined_text = \" \".join(\n                            [f\"Title: {data['title']} Abstract: {data['abstract']}\" for article_uri, data in\n                             ranked_articles]\n                        )\n                        return combined_text\n\n                    st.session_state.combined_text = combine_abstracts(top_articles)\n\n                else:\n                    st.write(\"No articles found for the selected terms.\")\n            except Exception as e:\n                st.error(f\"Error filtering articles: {e}\")\n```", "```py\n# Function to query RDF using SPARQL\ndef query_rdf(local_file_path, query, mesh_terms, base_namespace=\"http://example.org/mesh/\"):\n    if not mesh_terms:\n        raise ValueError(\"The list of MeSH terms is empty or invalid.\")\n\n    print(\"SPARQL Query:\", query)\n\n    # Create and parse the RDF graph\n    g = Graph()\n    g.parse(local_file_path, format=\"ttl\")\n\n    article_data = {}\n\n    for term in mesh_terms:\n        # Convert the term to a valid URI\n        mesh_term_uri = convert_to_uri(term, base_namespace)\n        #print(\"Term:\", term, \"URI:\", mesh_term_uri)\n\n        # Perform SPARQL query with initBindings\n        results = g.query(query, initBindings={'meshTerm': mesh_term_uri})\n\n        for row in results:\n            article_uri = row['article']\n            if article_uri not in article_data:\n                article_data[article_uri] = {\n                    'title': row['title'],\n                    'abstract': row['abstract'],\n                    'datePublished': row['datePublished'],\n                    'access': row['access'],\n                    'meshTerms': set()\n                }\n            article_data[article_uri]['meshTerms'].add(str(row['meshTerm']))\n        #print(\"DEBUG article_data:\", article_data)\n\n    # Rank articles by the number of matching MeSH terms\n    ranked_articles = sorted(\n        article_data.items(),\n        key=lambda item: len(item[1]['meshTerms']),\n        reverse=True\n    )\n    return ranked_articles[:10]\n```"]
["```py\ndef get_data(API_key, Movie_ID, max_retries=5):\n    \"\"\"\n    Function to pull details of your film of interest in JSON format.\n\n    parameters:\n    API_key (str): Your API key for TMBD\n    Movie_ID (str): TMDB id for film of interest\n\n    returns:\n    dict: JSON formatted dictionary containing all details of your film of\n    interest\n    \"\"\"\n\n    query = 'https://api.themoviedb.org/3/movie/' + Movie_ID + \\\n        '?api_key='+API_key + '&append_to_response=keywords,' + \\\n            'watch/providers,credits'\n    for i in range(max_retries):\n        response = requests.get(query)\n        if response.status_code == 429:\n            # If the response was a 429, wait and then try again\n            print(\n                f\"Request limit reached. Waiting and retrying ({i+1}/{\n                    max_retries})\")\n            time.sleep(2 ** i)  # Exponential backoff\n        else:\n            dict = response.json()\n            return dict\n```", "```py\ncredits = dict[‘credits’]\nactor_list, director_list = [], []\n\n# Parsing cast\ncast = credits['cast']\nNUM_ACTORS = 5\nfor member in cast[:NUM_ACTORS]:\n    actor_list.append(member[\"name\"])\n\n# Parsing crew\ncrew = credits['crew']\nfor member in crew:\n    if member['job'] == 'Director':\n        director_list.append(member[\"name\"])\n\nactor_str = ', '.join(list(set(actor_list)))\ndirector_str = ', '.join(list(set(director_list)))\n```", "```py\n# Loading in data from all csv files\nloader = DirectoryLoader(\n    path=\"./data\",\n    glob=\"*.csv\",\n    loader_cls=CSVLoader,\n    show_progress=True)\n\ndocs = loader.load()\n\nmetadata_field_info = [\n    AttributeInfo(\n        name=\"Title\", description=\"The title of the movie\", type=\"string\"),\n    AttributeInfo(name=\"Runtime (minutes)\",\n                  description=\"The runtime of the movie in minutes\", type=\"integer\"),\n    AttributeInfo(name=\"Language\",\n                  description=\"The language of the movie\", type=\"string\"),\n    ...\n]\n\nfor doc in docs:\n    # Parse the page_content string into a dictionary\n    page_content_dict = dict(line.split(\": \", 1)\n                             for line in doc.page_content.split(\"\\n\") if \": \" in line)\n\n    doc.page_content = 'Overview: ' + page_content_dict.get(\n        'Overview') + '. Keywords: ' + page_content_dict.get('Keywords')\n    doc.metadata = {field.name: page_content_dict.get(\n        field.name) for field in metadata_field_info}\n\n    # Convert fields from string to list of strings\n    for field in fields_to_convert_list:\n        convert_to_list(doc, field)      \n\n    # Convert fields from string to integers\n    for field in fields_to_convert_int:\n        convert_to_int(doc, field)\n```", "```py\n# Create empty index\nPINECONE_KEY, PINECONE_INDEX_NAME = os.getenv(\n    'PINECONE_API_KEY'), os.getenv('PINECONE_INDEX_NAME')\n\npc = Pinecone(api_key=PINECONE_KEY)\n\n# Uncomment if index is not created already\npc.create_index(\n    name=PINECONE_INDEX_NAME,\n    dimension=1536,\n    metric=\"cosine\",\n    spec=PodSpec(\n        environment=\"gcp-starter\"\n    )\n)\n\n# Target index and check status\npc_index = pc.Index(PINECONE_INDEX_NAME)\nprint(pc_index.describe_index_stats())\n\nembeddings = OpenAIEmbeddings(model='text-embedding-ada-002')\n\nvectorstore = PineconeVectorStore(\n    pc_index, embeddings\n)\n\n# Create record manager\nnamespace = f\"pinecone/{PINECONE_INDEX_NAME}\"\nrecord_manager = SQLRecordManager(\n    namespace, db_url=\"sqlite:///record_manager_cache.sql\"\n)\n\nrecord_manager.create_schema()\n\n# Upload documents to pinecome\nindex(docs, record_manager, vectorstore,\n      cleanup=\"full\", source_id_key=\"Website\")\n```", "```py\ndocument_content_description = \"Brief overview of a movie, along with keywords\"\n\n        # Define allowed comparators list\n        allowed_comparators = [\n            \"$eq\",  # Equal to (number, string, boolean)\n            \"$ne\",  # Not equal to (number, string, boolean)\n            \"$gt\",  # Greater than (number)\n            \"$gte\",  # Greater than or equal to (number)\n            \"$lt\",  # Less than (number)\n            \"$lte\",  # Less than or equal to (number)\n            \"$in\",  # In array (string or number)\n            \"$nin\",  # Not in array (string or number)\n            \"$exists\", # Has the specified metadata field (boolean)\n        ]\n\n        examples = [\n            (\n                \"Recommend some films by Yorgos Lanthimos.\",\n                {\n                    \"query\": \"Yorgos Lanthimos\",\n                    \"filter\": 'in(\"Directors\", [\"Yorgos Lanthimos]\")',\n                },\n            ),\n            (\n                \"Films similar to Yorgos Lanthmios movies.\",\n                {\n                    \"query\": \"Dark comedy, absurd, Greek Weird Wave\",\n                    \"filter\": 'NO_FILTER',\n                },\n            ),\n            ...\n        ]\n\n        metadata_field_info = [\n            AttributeInfo(\n                name=\"Title\", description=\"The title of the movie\", type=\"string\"),\n            AttributeInfo(name=\"Runtime (minutes)\",\n                          description=\"The runtime of the movie in minutes\", type=\"integer\"),\n            AttributeInfo(name=\"Language\",\n                          description=\"The language of the movie\", type=\"string\"),\n            ...\n        ]\n\n        constructor_prompt = get_query_constructor_prompt(\n            document_content_description,\n            metadata_field_info,\n            allowed_comparators=allowed_comparators,\n            examples=examples,\n        )\n\n        output_parser = StructuredQueryOutputParser.from_components()\n        query_constructor = constructor_prompt | query_model | output_parser\n\n        retriever = SelfQueryRetriever(\n            query_constructor=query_constructor,\n            vectorstore=vectorstore,\n            structured_query_translator=PineconeTranslator(),\n            search_kwargs={'k': 10}\n        )\n```", "```py\nchat_model = ChatOpenAI(\n    model=SUMMARY_MODEL_NAME,\n    temperature=0,\n    streaming=True,\n)\n\nprompt = ChatPromptTemplate.from_messages(\n    [\n        (\n            'system',\n            \"\"\"\n            Your goal is to recommend films to users based on their \n            query and the retrieved context. If a retrieved film doesn't seem \n            relevant, omit it from your response. If your context is empty\n            or none of the retrieved films are relevant, do not recommend films\n            , but instead tell the user you couldn't find any films \n            that match their query. Aim for three to five film recommendations,\n            as long as the films are relevant. You cannot recommend more than \n            five films. Your recommendation should be relevant, original, and \n            at least two to three sentences long.\n\n            YOU CANNOT RECOMMEND A FILM IF IT DOES NOT APPEAR IN YOUR \n            CONTEXT.\n\n            # TEMPLATE FOR OUTPUT\n            - **Title of Film**:\n                - Runtime:\n                - Release Year:\n                - Streaming:\n                - (Your reasoning for recommending this film)\n\n            Question: {question} \n            Context: {context} \n            \"\"\"\n        ),\n    ]\n)\n\ndef format_docs(docs):\n    return \"\\n\\n\".join(f\"{doc.page_content}\\n\\nMetadata: {doc.metadata}\" for doc in docs)\n\n# Create a chatbot Question & Answer chain from the retriever\nrag_chain_from_docs = (\n    RunnablePassthrough.assign(\n        context=(lambda x: format_docs(x[\"context\"])))\n    | prompt\n    | chat_model\n    | StrOutputParser()\n)\n\nrag_chain_with_source = RunnableParallel(\n    {\"context\": retriever, \"question\": RunnablePassthrough()}\n).assign(answer=rag_chain_from_docs)\n```", "```py\nfor chunk in rag_chain_with_source.stream(query):\n    for key in chunk:\n        if key == 'answer':\n            yield chunk[key]\n```"]
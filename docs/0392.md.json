["```py\nasync def get_transcript(audio_file_path: str, \n                         text_to_draw_while_waiting: str) -> Optional[str]:\n    openai.api_key = os.environ.get(\"OPENAI_API_KEY\")\n    audio_file = open(audio_file_path, \"rb\")\n    transcript = None\n\n    async def transcribe_audio() -> None:\n        nonlocal transcript\n        try:\n            response = openai.Audio.transcribe(\n                model=\"whisper-1\", file=audio_file, language=\"en\")\n            transcript = response.get(\"text\")\n        except Exception as e:\n            print(e)\n\n    draw_thread = Thread(target=print_text_while_waiting_for_transcription(\n        text_to_draw_while_waiting))\n    draw_thread.start()\n\n    transcription_task = asyncio.create_task(transcribe_audio())\n    await transcription_task\n\n    if transcript is None:\n        print(\"Transcription not available within the specified timeout.\")\n\n    return transcript\n```", "```py\ndef detect_chosen_option_from_transcript(\n        transcript: str, options: List[str]) -> str:\n    best_match_score = 0\n    best_match = \"\"\n\n    for option in options:\n        score = fuzz.token_set_ratio(transcript.lower(), option.lower())\n        if score > best_match_score:\n            best_match_score = score\n            best_match = option\n\n    if best_match_score >= 70:\n        return best_match\n    else:\n        return \"\"\n```", "```py\ndef get_gpt_response(transcript: str, chosen_figure: str) -> str:\n    system_instructions = get_system_instructions(chosen_figure)\n    try:\n        return make_openai_request(\n            system_instructions=system_instructions, \n            user_question=transcript).choices[0].message[\"content\"]\n    except Exception as e:\n        logging.error(f\"could not get ChatGPT response. error: {str(e)}\")\n        raise e\n```", "```py\ndef get_system_instructions(figure: str) -> str:\n    return f\"You provide funny and short answers. You are: {figure}\"\n```", "```py\ndef text_to_speech(text: str, gender: str = Gender.FEMALE.value) -> None:\n    engine = pyttsx3.init()\n\n    engine.setProperty(\"rate\", WORDS_PER_MINUTE_RATE)\n    voices = engine.getProperty(\"voices\")\n    voice_id = voices[0].id if gender == \"male\" else voices[1].id\n    engine.setProperty(\"voice\", voice_id)\n\n    engine.say(text)\n    engine.runAndWait()\n```", "```py\nimport asyncio\n\nfrom src.handle_transcript import text_to_speech\nfrom src.main_flow_helpers import choose_figure, start, play_round, \\\n    is_another_round\n\ndef farewell() -> None:\n    farewell_message = \"It was great having you here, \" \\\n                       \"hope to see you again soon!\"\n    print(f\"\\n{farewell_message}\")\n    text_to_speech(farewell_message)\n\nasync def get_round_settings(figure: str) -> dict:\n    new_round_choice = await is_another_round()\n    if new_round_choice == \"new figure\":\n        return {\"figure\": \"\", \"another_round\": True}\n    elif new_round_choice == \"no\":\n        return {\"figure\": \"\", \"another_round\": False}\n    elif new_round_choice == \"yes\":\n        return {\"figure\": figure, \"another_round\": True}\n\nasync def main():\n    start()\n    another_round = True\n    figure = \"\"\n\n    while True:\n        if not figure:\n            figure = await choose_figure()\n\n        while another_round:\n            await play_round(chosen_figure=figure)\n            user_choices = await get_round_settings(figure)\n            figure, another_round = \\\n                user_choices.get(\"figure\"), user_choices.get(\"another_round\")\n            if not figure:\n                break\n\n        if another_round is False:\n            farewell()\n            break\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```"]
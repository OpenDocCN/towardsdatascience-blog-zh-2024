- en: Nine Rules for Accessing Cloud Files from Your Rust Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»ä½ çš„ Rust ä»£ç è®¿é—®äº‘æ–‡ä»¶çš„ä¹ä¸ªè§„åˆ™
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/nine-rules-for-accessing-cloud-files-from-your-rust-code-d456c1e2ceb4?source=collection_archive---------7-----------------------#2024-02-07](https://towardsdatascience.com/nine-rules-for-accessing-cloud-files-from-your-rust-code-d456c1e2ceb4?source=collection_archive---------7-----------------------#2024-02-07)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/nine-rules-for-accessing-cloud-files-from-your-rust-code-d456c1e2ceb4?source=collection_archive---------7-----------------------#2024-02-07](https://towardsdatascience.com/nine-rules-for-accessing-cloud-files-from-your-rust-code-d456c1e2ceb4?source=collection_archive---------7-----------------------#2024-02-07)
- en: Practical Lessons from Upgrading Bed-Reader, a Bioinformatics Library
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å‡çº§ Bed-Readerï¼šæ¥è‡ªç”Ÿç‰©ä¿¡æ¯å­¦åº“çš„å®è·µç»éªŒ
- en: '[](https://medium.com/@carlmkadie?source=post_page---byline--d456c1e2ceb4--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page---byline--d456c1e2ceb4--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--d456c1e2ceb4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--d456c1e2ceb4--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page---byline--d456c1e2ceb4--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlmkadie?source=post_page---byline--d456c1e2ceb4--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page---byline--d456c1e2ceb4--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--d456c1e2ceb4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--d456c1e2ceb4--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page---byline--d456c1e2ceb4--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--d456c1e2ceb4--------------------------------)
    Â·21 min readÂ·Feb 7, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘è¡¨äº [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--d456c1e2ceb4--------------------------------)
    Â·é˜…è¯»æ—¶é•¿ 21 åˆ†é’ŸÂ·2024å¹´2æœˆ7æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/1e411080a4ed67bba652ec6626318f0e.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1e411080a4ed67bba652ec6626318f0e.png)'
- en: 'Rust and Python reading DNA data directly from the cloud â€” Source: [https://openai.com/dall-e-2/](https://openai.com/dall-e-2/).
    All other figures from the author.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Rust å’Œ Python ç›´æ¥ä»äº‘ç«¯è¯»å– DNA æ•°æ® â€” æ¥æºï¼š[https://openai.com/dall-e-2/](https://openai.com/dall-e-2/)ã€‚æ‰€æœ‰å…¶ä»–å›¾ç‰‡æ¥è‡ªä½œè€…ã€‚
- en: Would you like your Rust program to seamlessly access data from files in the
    cloud? When I refer to â€œfiles in the cloud,â€ I mean data housed on web servers
    or within cloud storage solutions like AWS S3, Azure Blob Storage, or Google Cloud
    Storage. The term â€œreadâ€, here, encompasses both the sequential retrieval of file
    contents â€” be they text or binary, from beginning to end â€”and the capability to
    pinpoint and extract specific sections of the file as needed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¸Œæœ›ä½ çš„ Rust ç¨‹åºèƒ½å¤Ÿæ— ç¼åœ°è®¿é—®äº‘ç«¯çš„æ–‡ä»¶æ•°æ®å—ï¼Ÿå½“æˆ‘æåˆ°â€œäº‘ç«¯æ–‡ä»¶â€æ—¶ï¼Œæˆ‘æŒ‡çš„æ˜¯å­˜å‚¨åœ¨ Web æœåŠ¡å™¨æˆ–äº‘å­˜å‚¨è§£å†³æ–¹æ¡ˆï¼ˆå¦‚ AWS S3ã€Azure
    Blob Storage æˆ– Google Cloud Storageï¼‰ä¸­çš„æ•°æ®ã€‚è¿™é‡Œæ‰€è¯´çš„â€œè¯»å–â€åŒ…å«äº†å¯¹æ–‡ä»¶å†…å®¹çš„é¡ºåºæ£€ç´¢â€”â€”æ— è®ºæ˜¯æ–‡æœ¬è¿˜æ˜¯äºŒè¿›åˆ¶æ•°æ®ï¼Œä»å¤´åˆ°å°¾â€”â€”å¹¶ä¸”å…·æœ‰æ ¹æ®éœ€è¦å®šä½å¹¶æå–æ–‡ä»¶ä¸­ç‰¹å®šéƒ¨åˆ†çš„èƒ½åŠ›ã€‚
- en: 'Upgrading your program to access cloud files can reduce annoyance and complication:
    the annoyance of downloading to local storage and the complication of periodically
    checking that a local copy is up to date.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å°†ç¨‹åºå‡çº§ä»¥è®¿é—®äº‘æ–‡ä»¶ï¼Œå¯ä»¥å‡å°‘çƒ¦æ¼å’Œå¤æ‚æ€§ï¼šä¸å†éœ€è¦å°†æ–‡ä»¶ä¸‹è½½åˆ°æœ¬åœ°å­˜å‚¨ï¼Œä¹Ÿä¸å†éœ€è¦å®šæœŸæ£€æŸ¥æœ¬åœ°å‰¯æœ¬æ˜¯å¦ä¸ºæœ€æ–°ã€‚
- en: 'Sadly, upgrading your program to access cloud files can also *increase* annoyance
    and complication: the annoyance of URLs and credential information, and the complication
    of asynchronous programming.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸å¹¸çš„æ˜¯ï¼Œå°†ä½ çš„ç¨‹åºå‡çº§ä»¥è®¿é—®äº‘æ–‡ä»¶ä¹Ÿå¯èƒ½ä¼š*å¢åŠ *çƒ¦æ¼å’Œå¤æ‚æ€§ï¼šURLs å’Œå‡­è¯ä¿¡æ¯å¸¦æ¥çš„çƒ¦æ¼ï¼Œä»¥åŠå¼‚æ­¥ç¼–ç¨‹çš„å¤æ‚æ€§ã€‚
- en: '[Bed-Reader](https://github.com/fastlmm/bed-reader) is a Python package and
    Rust crate for reading PLINK Bed Files, a binary format used in bioinformatics
    to store genotype (DNA) data. At a userâ€™s request, I recently updated Bed-Reader
    to optionally read data directly from cloud storage. Along the way, I learned
    nine rules that can help you add cloud-file support to your programs. The rules
    are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[Bed-Reader](https://github.com/fastlmm/bed-reader) æ˜¯ä¸€ä¸ªç”¨äºè¯»å– PLINK Bed æ–‡ä»¶çš„ Python
    åŒ…å’Œ Rust crateï¼Œè¿™æ˜¯ä¸€ç§åœ¨ç”Ÿç‰©ä¿¡æ¯å­¦ä¸­ç”¨äºå­˜å‚¨åŸºå› å‹ï¼ˆDNAï¼‰æ•°æ®çš„äºŒè¿›åˆ¶æ ¼å¼ã€‚åº”ç”¨æˆ·çš„è¦æ±‚ï¼Œæˆ‘æœ€è¿‘æ›´æ–°äº† Bed-Readerï¼Œä½¿å…¶èƒ½å¤Ÿé€‰æ‹©æ€§åœ°ç›´æ¥ä»äº‘å­˜å‚¨è¯»å–æ•°æ®ã€‚åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œæˆ‘æ€»ç»“äº†ä¹æ¡è§„åˆ™ï¼Œå¯ä»¥å¸®åŠ©ä½ ä¸ºç¨‹åºæ·»åŠ äº‘æ–‡ä»¶æ”¯æŒã€‚è¿™äº›è§„åˆ™æ˜¯ï¼š'
- en: Use crate `[object_store](https://crates.io/crates/object_store)` (and, perhaps,
    `[cloud-file](https://crates.io/crates/cloud-file)`) to sequentially read the
    bytes of a cloud file.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ crate `[object_store](https://crates.io/crates/object_store)`ï¼ˆä»¥åŠå¯èƒ½çš„ `[cloud-file](https://crates.io/crates/cloud-file)`ï¼‰æŒ‰é¡ºåºè¯»å–äº‘æ–‡ä»¶çš„å­—èŠ‚ã€‚
- en: Sequentially read text lines from cloud files via two nested loops.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é€šè¿‡ä¸¤ä¸ªåµŒå¥—çš„å¾ªç¯é¡ºåºè¯»å–äº‘æ–‡ä»¶ä¸­çš„æ–‡æœ¬è¡Œã€‚
- en: Randomly access cloud files, even giant ones, with â€œrangeâ€ methods, while respecting
    server-imposed limits.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: éšæœºè®¿é—®äº‘æ–‡ä»¶ï¼Œå³ä½¿æ˜¯éå¸¸å¤§çš„æ–‡ä»¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨â€œèŒƒå›´â€æ–¹æ³•ï¼ŒåŒæ—¶éµå®ˆæœåŠ¡å™¨æ–½åŠ çš„é™åˆ¶ã€‚
- en: Use URL strings and option strings to access HTTP, Local Files, AWS S3, Azure,
    and Google Cloud.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ URL å­—ç¬¦ä¸²å’Œé€‰é¡¹å­—ç¬¦ä¸²è®¿é—® HTTPã€æœ¬åœ°æ–‡ä»¶ã€AWS S3ã€Azure å’Œ Google Cloudã€‚
- en: Test via `[tokio](https://crates.io/crates/tokio)::test` on http and local files.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: é€šè¿‡ `[tokio](https://crates.io/crates/tokio)::test` æµ‹è¯• HTTP å’Œæœ¬åœ°æ–‡ä»¶ã€‚
- en: '*If other programs call your program â€” in other words, if your program offers
    an API (application program interface) â€” four additional rules apply:*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*å¦‚æœå…¶ä»–ç¨‹åºè°ƒç”¨ä½ çš„ç¨‹åºâ€”â€”æ¢å¥è¯è¯´ï¼Œå¦‚æœä½ çš„ç¨‹åºæä¾›äº†ä¸€ä¸ª APIï¼ˆåº”ç”¨ç¨‹åºæ¥å£ï¼‰â€”â€”åˆ™æœ‰å››æ¡é¢å¤–çš„è§„åˆ™é€‚ç”¨ï¼š*'
- en: 6\. For maximum performance, add cloud-file support to your Rust library via
    an async API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. ä¸ºäº†è·å¾—æœ€ä½³æ€§èƒ½ï¼Œå¯ä»¥é€šè¿‡å¼‚æ­¥ API å°†äº‘æ–‡ä»¶æ”¯æŒæ·»åŠ åˆ°ä½ çš„ Rust åº“ä¸­ã€‚
- en: 7\. Alternatively, for maximum convenience, add cloud-file support to your Rust
    library via a traditional (â€œsynchronousâ€) API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. æˆ–è€…ï¼Œä¸ºäº†æœ€å¤§ç¨‹åº¦çš„æ–¹ä¾¿ï¼Œå¯ä»¥é€šè¿‡ä¼ ç»Ÿçš„ï¼ˆâ€œåŒæ­¥â€ï¼‰API å°†äº‘æ–‡ä»¶æ”¯æŒæ·»åŠ åˆ°ä½ çš„ Rust åº“ä¸­ã€‚
- en: 8\. Follow the rules of good API design in part by using hidden lines in your
    doc tests.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. é€šè¿‡ä½¿ç”¨æ–‡æ¡£æµ‹è¯•ä¸­çš„éšè—è¡Œï¼Œéµå¾ªè‰¯å¥½çš„ API è®¾è®¡è§„åˆ™ã€‚
- en: 9\. Include a runtime, but optionally.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. åŒ…æ‹¬ä¸€ä¸ªè¿è¡Œæ—¶ï¼Œä½†å¯ä»¥é€‰æ‹©æ€§åœ°ä½¿ç”¨ã€‚
- en: 'Aside: To avoid wishy-washiness, I call these â€œrulesâ€, but they are, of course,
    just suggestions.'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é¡ºä¾¿æä¸€ä¸‹ï¼šä¸ºäº†é¿å…æ¨¡ç³Šä¸æ¸…ï¼Œæˆ‘ç§°è¿™äº›ä¸ºâ€œè§„åˆ™â€ï¼Œä½†å®ƒä»¬å½“ç„¶åªæ˜¯å»ºè®®ã€‚
- en: 'Rule 1: Use crate `object_store` (and, perhaps, `cloud-file`) to sequentially
    read the bytes of a cloud file.'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§„åˆ™ 1ï¼šä½¿ç”¨ crate `object_store`ï¼ˆä»¥åŠå¯èƒ½çš„ `cloud-file`ï¼‰é¡ºåºè¯»å–äº‘æ–‡ä»¶çš„å­—èŠ‚ã€‚
- en: The powerful `[object_store](https://crates.io/crates/object_store)` crate provides
    full content access to files stored on http, AWS S3, Azure, Google Cloud, and
    local files. It is part of the [Apache Arrow](https://arrow.apache.org/) project
    and has over 2.4 million downloads.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: å¼ºå¤§çš„`[object_store](https://crates.io/crates/object_store)` crate æä¾›å¯¹å­˜å‚¨åœ¨ HTTPã€AWS
    S3ã€Azureã€Google Cloud å’Œæœ¬åœ°æ–‡ä»¶ä¸­çš„æ–‡ä»¶çš„å®Œæ•´å†…å®¹è®¿é—®ã€‚å®ƒæ˜¯ [Apache Arrow](https://arrow.apache.org/)
    é¡¹ç›®çš„ä¸€éƒ¨åˆ†ï¼Œå·²ä¸‹è½½è¶…è¿‡ 240 ä¸‡æ¬¡ã€‚
- en: For this article, I also created a new crate called `[cloud-file](https://crates.io/crates/cloud-file)`.
    It simplifies the use of the `object_store` crate. It wraps and focuses on a useful
    subset of `object_store`â€™s features. You can either use it directly, or pull-out
    its code for your own use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºæœ¬æ–‡ï¼Œæˆ‘è¿˜åˆ›å»ºäº†ä¸€ä¸ªåä¸º `[cloud-file](https://crates.io/crates/cloud-file)` çš„æ–° crateã€‚å®ƒç®€åŒ–äº†
    `object_store` crate çš„ä½¿ç”¨ã€‚å®ƒåŒ…è£…å¹¶ä¸“æ³¨äº `object_store` çš„ä¸€ä¸ªæœ‰ç”¨å­é›†ã€‚ä½ å¯ä»¥ç›´æ¥ä½¿ç”¨å®ƒï¼Œæˆ–è€…å°†å…¶ä»£ç æå–å‡ºæ¥ä¾›ä½ è‡ªå·±ä½¿ç”¨ã€‚
- en: Letâ€™s look at an example. Weâ€™ll count the lines of a cloud file by counting
    the number of newline characters it contains.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªä¾‹å­ã€‚æˆ‘ä»¬é€šè¿‡è®¡ç®—äº‘æ–‡ä»¶ä¸­åŒ…å«çš„æ¢è¡Œç¬¦æ•°é‡æ¥ç»Ÿè®¡æ–‡ä»¶çš„è¡Œæ•°ã€‚
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we run this code, it returns:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘ä»¬è¿è¡Œè¿™æ®µä»£ç æ—¶ï¼Œå®ƒè¿”å›ï¼š
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Some points of interest:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€äº›è¦ç‚¹ï¼š
- en: We use `async` (and, here, `[tokio](https://docs.rs/tokio/latest/tokio/)`).
    Weâ€™ll discuss this choice more in Rules 6 and 7.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨ `async`ï¼ˆåœ¨è¿™é‡Œä½¿ç”¨çš„æ˜¯`[tokio](https://docs.rs/tokio/latest/tokio/)`ï¼‰ã€‚æˆ‘ä»¬å°†åœ¨è§„åˆ™ 6
    å’Œ 7 ä¸­è¿›ä¸€æ­¥è®¨è®ºè¿™ä¸€é€‰æ‹©ã€‚
- en: We turn a URL string and string options into a `CloudFile` instance with `CloudFile::new_with_options(url,
    options)?`. We use `?` to catch malformed URLs).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šè¿‡ `CloudFile::new_with_options(url, options)?` å°† URL å­—ç¬¦ä¸²å’Œé€‰é¡¹å­—ç¬¦ä¸²è½¬æ¢ä¸º `CloudFile`
    å®ä¾‹ã€‚æˆ‘ä»¬ä½¿ç”¨ `?` æ¥æ•è·æ ¼å¼é”™è¯¯çš„ URLï¼‰ã€‚
- en: We create a stream of binary chunks with `cloud_file.stream_chunks().await?`.
    This is the first place that the code tries to access the cloud file. If the file
    doesnâ€™t exist or we canâ€™t open it, the `?` will return an error.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šè¿‡ `cloud_file.stream_chunks().await?` åˆ›å»ºä¸€ä¸ªäºŒè¿›åˆ¶å—æµã€‚è¿™æ˜¯ä»£ç é¦–æ¬¡å°è¯•è®¿é—®äº‘æ–‡ä»¶çš„åœ°æ–¹ã€‚å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨æˆ–æ— æ³•æ‰“å¼€ï¼Œ`?`
    ä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ã€‚
- en: We use `chunks.next().await` to retrieve the fileâ€™s next binary chunk. (Note
    the `use futures_util::StreamExt;`.) The `next` method returns `None` after all
    chunks have been retrieved.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä½¿ç”¨ `chunks.next().await` æ¥è·å–æ–‡ä»¶çš„ä¸‹ä¸€ä¸ªäºŒè¿›åˆ¶å—ã€‚ï¼ˆè¯·æ³¨æ„ `use futures_util::StreamExt;`ã€‚ï¼‰`next`
    æ–¹æ³•åœ¨æ‰€æœ‰å—è¢«æ£€ç´¢å®Œåè¿”å› `None`ã€‚
- en: What if there *is* a next chunk but also a problem retrieving it? Weâ€™ll catch
    any problem with `let chunk = chunk?;`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœç¡®å®æœ‰ä¸‹ä¸€ä¸ªå—ï¼Œä½†åœ¨æ£€ç´¢æ—¶å‡ºç°é—®é¢˜å‘¢ï¼Ÿæˆ‘ä»¬å°†é€šè¿‡ `let chunk = chunk?;` æ•è·ä»»ä½•é—®é¢˜ã€‚
- en: Finally, we use the fast `[bytecount](https://docs.rs/bytecount/latest/bytecount/)`
    crate to count newline characters.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨å¿«é€Ÿçš„ `[bytecount](https://docs.rs/bytecount/latest/bytecount/)` crate
    æ¥è®¡ç®—æ¢è¡Œç¬¦çš„æ•°é‡ã€‚
- en: 'In contrast with this cloud solution, think about how you would write a simple
    line counter for a local file. You might write this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸è¿™ç§äº‘è§£å†³æ–¹æ¡ˆç›¸å¯¹æ¯”ï¼Œæƒ³æƒ³ä½ ä¼šå¦‚ä½•ä¸ºæœ¬åœ°æ–‡ä»¶ç¼–å†™ä¸€ä¸ªç®€å•çš„è¡Œè®¡æ•°å™¨ã€‚ä½ å¯èƒ½ä¼šå†™æˆè¿™æ ·ï¼š
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Between the cloud-file version and the local-file version, three differences
    stand out. First, we can easily read local files as text. By default, we read
    cloud files as binary (but see Rule 2). Second, by default, we read local files
    synchronously, blocking program execution until completion. On the other hand,
    we usually access cloud files asynchronously, allowing other parts of the program
    to continue running while waiting for the relatively slow network access to complete.
    Third, iterators such as `lines()` support `for`. However, streams such as `stream_chunks()`
    do not, so we use `while let`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨`cloud-file`ç‰ˆæœ¬å’Œæœ¬åœ°æ–‡ä»¶ç‰ˆæœ¬ä¹‹é—´ï¼Œæœ‰ä¸‰ä¸ªçªå‡ºå·®å¼‚ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°å°†æœ¬åœ°æ–‡ä»¶ä½œä¸ºæ–‡æœ¬è¯»å–ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†äº‘æ–‡ä»¶ä½œä¸ºäºŒè¿›åˆ¶æ–‡ä»¶è¯»å–ï¼ˆä½†è¯·å‚è§è§„åˆ™2ï¼‰ã€‚å…¶æ¬¡ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬åŒæ­¥è¯»å–æœ¬åœ°æ–‡ä»¶ï¼Œç›´åˆ°å®Œæˆæ‰ä¼šé˜»å¡ç¨‹åºæ‰§è¡Œã€‚å¦ä¸€æ–¹é¢ï¼Œæˆ‘ä»¬é€šå¸¸å¼‚æ­¥è®¿é—®äº‘æ–‡ä»¶ï¼Œè¿™æ ·åœ¨ç­‰å¾…ç›¸å¯¹è¾ƒæ…¢çš„ç½‘ç»œè®¿é—®å®Œæˆæ—¶ï¼Œç¨‹åºçš„å…¶ä»–éƒ¨åˆ†ä»ç„¶å¯ä»¥ç»§ç»­è¿è¡Œã€‚ç¬¬ä¸‰ï¼Œåƒ`lines()`è¿™æ ·çš„è¿­ä»£å™¨æ”¯æŒ`for`å¾ªç¯ã€‚ç„¶è€Œï¼Œåƒ`stream_chunks()`è¿™æ ·çš„æµåˆ™ä¸æ”¯æŒï¼Œæ‰€ä»¥æˆ‘ä»¬ä½¿ç”¨`while
    let`ã€‚
- en: 'I mentioned earlier that you didnâ€™t need to use the `cloud-file` wrapper and
    that you could use the `object_store` crate directly. Letâ€™s see what it looks
    like when we count the newlines in a cloud file using only `object_store` methods:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¹‹å‰æåˆ°è¿‡ï¼Œä½ ä¸éœ€è¦ä½¿ç”¨`cloud-file`åŒ…è£…å™¨ï¼Œè€Œå¯ä»¥ç›´æ¥ä½¿ç”¨`object_store` crateã€‚æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹åªä½¿ç”¨`object_store`æ–¹æ³•æ—¶ï¼Œå¦‚ä½•è®¡ç®—äº‘æ–‡ä»¶ä¸­çš„æ¢è¡Œç¬¦ï¼š
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Youâ€™ll see the code is very similar to the `cloud-file` code. The differences
    are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ä¼šå‘ç°ä»£ç ä¸`cloud-file`ä»£ç éå¸¸ç›¸ä¼¼ã€‚ä¸åŒä¹‹å¤„åœ¨äºï¼š
- en: 'Instead of one `CloudFile` input, most methods take two inputs: an `ObjectStore`
    and a `StorePath`. Because `ObjectStore` is a non-cloneable trait, here the `count_lines`
    function specifically uses `&Arc<Box<dyn ObjectStore>>`. Alternatively, we could
    make the function generic and use `&Arc<impl ObjectStore>`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸å•ä¸ª`CloudFile`è¾“å…¥ä¸åŒï¼Œå¤§å¤šæ•°æ–¹æ³•éœ€è¦ä¸¤ä¸ªè¾“å…¥ï¼š`ObjectStore`å’Œ`StorePath`ã€‚å› ä¸º`ObjectStore`æ˜¯ä¸€ä¸ªä¸å¯å…‹éš†çš„ç‰¹æ€§ï¼Œè¿™é‡Œ`count_lines`å‡½æ•°ä¸“é—¨ä½¿ç”¨äº†`&Arc<Box<dyn
    ObjectStore>>`ã€‚æˆ–è€…ï¼Œæˆ‘ä»¬å¯ä»¥å°†å‡½æ•°è®¾ä¸ºæ³›å‹ï¼Œå¹¶ä½¿ç”¨`&Arc<impl ObjectStore>`ã€‚
- en: Creating the `ObjectStore` instance, the `StorePath` instance, and the stream
    requires a few extra steps compared to creating a `CloudFile` instance and a stream.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åˆ›å»º`ObjectStore`å®ä¾‹ã€`StorePath`å®ä¾‹å’Œæµéœ€è¦æ¯”åˆ›å»º`CloudFile`å®ä¾‹å’Œæµå¤šä¸€äº›æ­¥éª¤ã€‚
- en: Instead of dealing with one error type (namely, `CloudFileError`), multiple
    error types are possible, so we fall back to using the `[anyhow](https://crates.io/crates/anyhow)`
    crate.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¸å†åªå¤„ç†ä¸€ç§é”™è¯¯ç±»å‹ï¼ˆå³`CloudFileError`ï¼‰ï¼Œè€Œæ˜¯å¯èƒ½å‡ºç°å¤šç§é”™è¯¯ç±»å‹ï¼Œå› æ­¤æˆ‘ä»¬é€€å›ä½¿ç”¨äº†`[anyhow](https://crates.io/crates/anyhow)`
    crateã€‚
- en: Whether you use `object_store` (with 2.4 million downloads) directly or indirectly
    via `cloud-file` (currently, with 124 downloads ğŸ˜€), is up to you.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºä½ æ˜¯ç›´æ¥ä½¿ç”¨`object_store`ï¼ˆç›®å‰ä¸‹è½½é‡ä¸º240ä¸‡æ¬¡ï¼‰ï¼Œè¿˜æ˜¯é€šè¿‡`cloud-file`é—´æ¥ä½¿ç”¨ï¼ˆç›®å‰ä¸‹è½½é‡ä¸º124æ¬¡ ğŸ˜€ï¼‰ï¼Œéƒ½ç”±ä½ å†³å®šã€‚
- en: For the rest of this article, Iâ€™ll focus on `cloud-file`. If you want to translate
    a `cloud-file` method into pure `object_store` code, look up the cloud-file [methodâ€™s
    documentation](https://docs.rs/cloud-file) and follow the "source" link. The source
    is usually only a line or two.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬æ–‡çš„å…¶ä½™éƒ¨åˆ†ï¼Œæˆ‘å°†é‡ç‚¹è®¨è®º`cloud-file`ã€‚å¦‚æœä½ æƒ³å°†`cloud-file`æ–¹æ³•è½¬æ¢ä¸ºçº¯`object_store`ä»£ç ï¼Œå¯ä»¥æŸ¥é˜…[è¯¥æ–¹æ³•çš„æ–‡æ¡£](https://docs.rs/cloud-file)ï¼Œå¹¶ç‚¹å‡»â€œsourceâ€é“¾æ¥ã€‚æºä»£ç é€šå¸¸åªæœ‰ä¸€ä¸¤è¡Œã€‚
- en: Weâ€™ve seen how to sequentially read the bytes of a cloud file. Letâ€™s look next
    at sequentially reading its lines.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å·²ç»äº†è§£äº†å¦‚ä½•é¡ºåºè¯»å–äº‘æ–‡ä»¶çš„å­—èŠ‚ã€‚æ¥ä¸‹æ¥ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•é¡ºåºè¯»å–å®ƒçš„è¡Œã€‚
- en: 'Rule 2: Sequentially read text lines from cloud files via two nested loops.'
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§„åˆ™2ï¼šé€šè¿‡ä¸¤ä¸ªåµŒå¥—å¾ªç¯é¡ºåºè¯»å–äº‘æ–‡ä»¶çš„æ–‡æœ¬è¡Œã€‚
- en: We often want to sequentially read the lines of a cloud file. To do that with
    `cloud-file` (or `object_store`) requires two nested loops.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ç»å¸¸éœ€è¦é¡ºåºè¯»å–äº‘æ–‡ä»¶çš„è¡Œã€‚ä½¿ç”¨`cloud-file`ï¼ˆæˆ–`object_store`ï¼‰æ¥å®ç°è¿™ä¸€ç‚¹éœ€è¦ä¸¤ä¸ªåµŒå¥—å¾ªç¯ã€‚
- en: 'The outer loop yields binary chunks, as before, but with a key modification:
    we now ensure that each chunk only contains complete lines, starting from the
    first character of a line and ending with a newline character. In other words,
    chunks may consist of one or more complete lines but no partial lines. The inner
    loop turns the chunk into text and iterates over the resultant one or more lines.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: å¤–éƒ¨å¾ªç¯åƒä»¥å‰ä¸€æ ·è¿”å›äºŒè¿›åˆ¶å—ï¼Œä½†æœ‰ä¸€ä¸ªå…³é”®çš„ä¿®æ”¹ï¼šæˆ‘ä»¬ç°åœ¨ç¡®ä¿æ¯ä¸ªå—åªåŒ…å«å®Œæ•´çš„è¡Œï¼Œä»è¡Œçš„ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹ï¼Œåˆ°æ¢è¡Œç¬¦ç»“æŸã€‚æ¢å¥è¯è¯´ï¼Œå—å¯èƒ½åŒ…å«ä¸€è¡Œæˆ–å¤šè¡Œå®Œæ•´çš„å†…å®¹ï¼Œä½†æ²¡æœ‰éƒ¨åˆ†è¡Œã€‚å†…éƒ¨å¾ªç¯å°†å—è½¬æ¢ä¸ºæ–‡æœ¬ï¼Œå¹¶è¿­ä»£ç”Ÿæˆçš„ä¸€è¡Œæˆ–å¤šè¡Œã€‚
- en: 'In this example, given a cloud file and a number *n*, we find the line at index
    position *n*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œç»™å®šä¸€ä¸ªäº‘æ–‡ä»¶å’Œä¸€ä¸ªæ•°å­—*n*ï¼Œæˆ‘ä»¬æ‰¾å‡ºç´¢å¼•ä½ç½®*n*çš„é‚£ä¸€è¡Œï¼š
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code prints:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ®µä»£ç æ‰“å°ï¼š
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Some points of interest:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€äº›å€¼å¾—æ³¨æ„çš„è¦ç‚¹ï¼š
- en: The key method is `.stream_line_chunks()`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å…³é”®æ–¹æ³•æ˜¯`.stream_line_chunks()`ã€‚
- en: We must also call `std::str::from_utf8` to create text. (Possibly returning
    a `[Utf8Error](https://doc.rust-lang.org/std/str/struct.Utf8Error.html)`.) Also,
    we call the `.lines()` method to create an iterator of lines.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜å¿…é¡»è°ƒç”¨`std::str::from_utf8`æ¥åˆ›å»ºæ–‡æœ¬ã€‚ï¼ˆå¯èƒ½ä¼šè¿”å›ä¸€ä¸ª`[Utf8Error](https://doc.rust-lang.org/std/str/struct.Utf8Error.html)`ã€‚ï¼‰æ­¤å¤–ï¼Œæˆ‘ä»¬è°ƒç”¨`.lines()`æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªè¡Œè¿­ä»£å™¨ã€‚
- en: 'If we want a line index, we must make it ourselves. Here we use:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬æƒ³è¦è¡Œç´¢å¼•ï¼Œå¿…é¡»è‡ªå·±åˆ›å»ºã€‚è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ï¼š
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Aside: Why two loops? Why doesnâ€™t `cloud-file` define a new stream that returns
    one line at a time? Because I donâ€™t know how. If anyone can figure it out, please
    send me a pull request with the solution!'
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ—ç™½ï¼šä¸ºä»€ä¹ˆè¦ç”¨ä¸¤ä¸ªå¾ªç¯ï¼Ÿä¸ºä»€ä¹ˆ`cloud-file`ä¸å®šä¹‰ä¸€ä¸ªè¿”å›æ¯æ¬¡ä¸€è¡Œçš„æµï¼Ÿå› ä¸ºæˆ‘ä¸çŸ¥é“æ€ä¹ˆåšã€‚å¦‚æœæœ‰äººèƒ½ææ˜ç™½ï¼Œè¯·å‘é€ä¸€ä¸ªåŒ…å«è§£å†³æ–¹æ¡ˆçš„pullè¯·æ±‚ç»™æˆ‘ï¼
- en: I wish this was simpler. Iâ€™m happy it is efficient. Letâ€™s return to simplicity
    by next look at randomly accessing cloud files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å¸Œæœ›è¿™èƒ½æ›´ç®€å•äº›ã€‚æˆ‘å¾ˆé«˜å…´å®ƒæ˜¯é«˜æ•ˆçš„ã€‚è®©æˆ‘ä»¬é€šè¿‡ä¸‹ä¸€æ­¥æ¥å›å½’ç®€æ´ï¼Œçœ‹çœ‹å¦‚ä½•éšæœºè®¿é—®äº‘æ–‡ä»¶ã€‚
- en: 'Rule 3: Randomly access cloud files, even giant ones, with range methods, while
    respecting server-imposed limits.'
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§„åˆ™3ï¼šä½¿ç”¨èŒƒå›´æ–¹æ³•éšæœºè®¿é—®äº‘æ–‡ä»¶ï¼Œå³ä½¿æ˜¯å·¨å¤§çš„æ–‡ä»¶ï¼ŒåŒæ—¶å°Šé‡æœåŠ¡å™¨è®¾ç½®çš„é™åˆ¶ã€‚
- en: I work with a genomics file format called PLINK Bed 1.9\. Files can be as large
    as 1 TB. Too big for web access? Not necessarily. We sometimes only need a fraction
    of the file. Moreover, modern cloud services (including most web servers) can
    efficiently retrieve regions of interest from a cloud file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘åœ¨å¤„ç†ä¸€ç§å«åšPLINK Bed 1.9çš„åŸºå› ç»„å­¦æ–‡ä»¶æ ¼å¼ã€‚æ–‡ä»¶æœ€å¤§å¯è¾¾1 TBã€‚æ˜¯ä¸æ˜¯å¤ªå¤§ï¼Œæ— æ³•é€šè¿‡ç½‘ç»œè®¿é—®ï¼Ÿä¸ä¸€å®šã€‚æœ‰æ—¶å€™æˆ‘ä»¬åªéœ€è¦æ–‡ä»¶çš„ä¸€å°éƒ¨åˆ†ã€‚æ­¤å¤–ï¼Œç°ä»£äº‘æœåŠ¡ï¼ˆåŒ…æ‹¬å¤§å¤šæ•°ç½‘ç»œæœåŠ¡å™¨ï¼‰å¯ä»¥é«˜æ•ˆåœ°ä»äº‘æ–‡ä»¶ä¸­æå–æ„Ÿå…´è¶£çš„åŒºåŸŸã€‚
- en: Letâ€™s look at an example. This test code uses a `CloudFile` method called `read_range_and_file_size`
    It reads a *.bed fileâ€™s first 3 bytes, checks that the file starts with the expected
    bytes, and then checks for the expected length.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä¾‹å­ã€‚è¿™ä¸ªæµ‹è¯•ä»£ç ä½¿ç”¨äº†ä¸€ä¸ªåä¸º`read_range_and_file_size`çš„`CloudFile`æ–¹æ³•ã€‚å®ƒè¯»å–ä¸€ä¸ª*.bedæ–‡ä»¶çš„å‰3ä¸ªå­—èŠ‚ï¼Œæ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä»¥é¢„æœŸçš„å­—èŠ‚å¼€å¤´ï¼Œç„¶åæ£€æŸ¥æ–‡ä»¶çš„é¢„æœŸé•¿åº¦ã€‚
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that in one web call, this method returns not just the bytes requested,
    but also the size of the whole file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œåœ¨ä¸€æ¬¡ç½‘ç»œè°ƒç”¨ä¸­ï¼Œè¿™ä¸ªæ–¹æ³•ä¸ä»…è¿”å›è¯·æ±‚çš„å­—èŠ‚ï¼Œè¿˜è¿”å›äº†æ•´ä¸ªæ–‡ä»¶çš„å¤§å°ã€‚
- en: 'Here is a list of high-level `CloudFile` methods and what they can retrieve
    in one web call:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä¸€äº›é«˜å±‚æ¬¡çš„`CloudFile`æ–¹æ³•åŠå®ƒä»¬åœ¨ä¸€æ¬¡ç½‘ç»œè°ƒç”¨ä¸­å¯ä»¥æ£€ç´¢çš„å†…å®¹ï¼š
- en: '`[read_all](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_all)`
    â€” Whole file contents as an in-memory `[Bytes](https://docs.rs/bytes/latest/bytes/struct.Bytes.html)`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[read_all](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_all)`
    â€” ä½œä¸ºå†…å­˜ä¸­çš„`[Bytes](https://docs.rs/bytes/latest/bytes/struct.Bytes.html)`è¿”å›çš„æ•´ä¸ªæ–‡ä»¶å†…å®¹'
- en: '`[read_range](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_range)`
    â€” `[Bytes](https://docs.rs/bytes/latest/bytes/struct.Bytes.html)` from a specified
    range'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[read_range](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_range)`
    â€” ä»æŒ‡å®šèŒƒå›´è¯»å–çš„`[Bytes](https://docs.rs/bytes/latest/bytes/struct.Bytes.html)`'
- en: '`[read_ranges](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_ranges)`
    â€” `Vec` of `[Bytes](https://docs.rs/bytes/latest/bytes/struct.Bytes.html)` from
    specified ranges'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[read_ranges](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_ranges)`
    â€” ä»æŒ‡å®šèŒƒå›´è¯»å–çš„`Vec`ç±»å‹çš„`[Bytes](https://docs.rs/bytes/latest/bytes/struct.Bytes.html)`'
- en: '`[read_range_and_file_size](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_range_and_file_size)`
    â€” `[Bytes](https://docs.rs/bytes/latest/bytes/struct.Bytes.html)` from a specified
    range & the fileâ€™s size'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[read_range_and_file_size](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_range_and_file_size)`
    â€” ä»æŒ‡å®šèŒƒå›´è¯»å–çš„`[Bytes](https://docs.rs/bytes/latest/bytes/struct.Bytes.html)`å’Œæ–‡ä»¶çš„å¤§å°'
- en: '`[read_file_size](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_file_size)`
    â€” Size of the file'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[read_file_size](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_file_size)`
    â€” æ–‡ä»¶çš„å¤§å°'
- en: These methods can run into two problems if we ask for too much data at a time.
    First, our cloud service may limit the number of bytes we can retrieve in one
    call. Second, we may get faster results by making multiple simultaneous requests
    rather than just one at a time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ä¸€æ¬¡è¯·æ±‚å¤ªå¤šæ•°æ®ï¼Œè¿™äº›æ–¹æ³•å¯èƒ½ä¼šé‡åˆ°ä¸¤ä¸ªé—®é¢˜ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬çš„äº‘æœåŠ¡å¯èƒ½ä¼šé™åˆ¶æ¯æ¬¡è°ƒç”¨èƒ½æ£€ç´¢çš„å­—èŠ‚æ•°ã€‚å…¶æ¬¡ï¼Œé€šè¿‡åŒæ—¶å‘å‡ºå¤šä¸ªè¯·æ±‚è€Œä¸æ˜¯ä¸€æ¬¡å‘ä¸€ä¸ªè¯·æ±‚ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¾—åˆ°æ›´å¿«çš„ç»“æœã€‚
- en: 'Consider this example: We want to gather statistics on the frequency of adjacent
    ASCII characters in a file of any size. For example, in a random sample of 10,000
    adjacent characters, perhaps â€œthâ€ appears 171 times.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘è¿™ä¸ªä¾‹å­ï¼šæˆ‘ä»¬æƒ³è¦æ”¶é›†ä¸€ä¸ªä»»æ„å¤§å°çš„æ–‡ä»¶ä¸­ç›¸é‚»ASCIIå­—ç¬¦çš„é¢‘ç‡ç»Ÿè®¡ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªåŒ…å«10,000ä¸ªç›¸é‚»å­—ç¬¦çš„éšæœºæ ·æœ¬ä¸­ï¼Œæˆ–è®¸â€œthâ€å‡ºç°äº†171æ¬¡ã€‚
- en: Suppose our web server is happy with 10 concurrent requests but only wants us
    to retrieve 750 bytes per call. (8 MB would be a more normal limit).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬çš„WebæœåŠ¡å™¨æ”¯æŒ10ä¸ªå¹¶å‘è¯·æ±‚ï¼Œä½†æ¯ä¸ªè¯·æ±‚åªå…è®¸æˆ‘ä»¬è·å–750å­—èŠ‚ã€‚ï¼ˆ8 MBä¼šæ˜¯ä¸€ä¸ªæ›´å¸¸è§çš„é™åˆ¶ï¼‰ã€‚
- en: Thanks to Ben Lichtman (B3NNY) at the Seattle Rust Meetup for pointing me in
    the right direction on adding limits to async streams.
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ„Ÿè°¢Seattle Rust Meetupçš„Ben Lichtmanï¼ˆB3NNYï¼‰æŒ‡å¼•æˆ‘æ­£ç¡®çš„æ–¹å‘ï¼Œå¸®åŠ©æˆ‘å‘å¼‚æ­¥æµæ·»åŠ äº†é™åˆ¶ã€‚
- en: 'Our main function could look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ä¸»å‡½æ•°å¯èƒ½é•¿è¿™æ ·ï¼š
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `count_bigrams` function can start by creating a random number generator
    and making a call to find the size of the cloud file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`count_bigrams`å‡½æ•°å¯ä»¥é¦–å…ˆåˆ›å»ºä¸€ä¸ªéšæœºæ•°ç”Ÿæˆå™¨ï¼Œå¹¶è°ƒç”¨æ¥æŸ¥æ‰¾äº‘æ–‡ä»¶çš„å¤§å°ï¼š'
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, based on the file size, the function can create a vector of 10,000 random
    two-byte ranges.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæ ¹æ®æ–‡ä»¶å¤§å°ï¼Œå‡½æ•°å¯ä»¥åˆ›å»ºä¸€ä¸ªåŒ…å«10,000ä¸ªéšæœºä¸¤å­—èŠ‚èŒƒå›´çš„å‘é‡ã€‚
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, it might produce the vector `[4122418..4122420, 4361192..4361194,
    145726..145728,` â€¦ `]`. But retrieving 20,000 bytes at once (we are pretending)
    is too much. So, we divide the vector into 27 chunks of no more than 750 bytes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå®ƒå¯èƒ½ç”Ÿæˆä»¥ä¸‹å‘é‡`[4122418..4122420, 4361192..4361194, 145726..145728,` â€¦ `]`ã€‚ä½†ä¸€æ¬¡æ€§è·å–20,000å­—èŠ‚ï¼ˆæˆ‘ä»¬å‡è®¾è¿™æ ·ï¼‰å¤ªå¤šäº†ã€‚æ‰€ä»¥ï¼Œæˆ‘ä»¬å°†å‘é‡åˆ†æˆ27ä¸ªå—ï¼Œæ¯ä¸ªå—ä¸è¶…è¿‡750å­—èŠ‚ï¼š
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using a little async magic, we create an iterator of future work for each of
    the 27 chunks and then we turn that iterator into a stream. We tell the stream
    to do up to 10 simultaneous calls. Also, we say that out-of-order results are
    fine.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ä¸€äº›å¼‚æ­¥é­”æ³•ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ª27ä¸ªå—åˆ›å»ºä¸€ä¸ªæœªæ¥å·¥ä½œçš„è¿­ä»£å™¨ï¼Œç„¶åå°†è¯¥è¿­ä»£å™¨è½¬æ¢ä¸ºæµã€‚æˆ‘ä»¬å‘Šè¯‰æµæœ€å¤šåŒæ—¶è°ƒç”¨10ä¸ªè¯·æ±‚ã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜è¡¨ç¤ºå¯ä»¥æ¥å—ä¹±åºçš„ç»“æœã€‚
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the last section of code, we first do the work in the stream and â€” as we
    get results â€” tabulate. Finally, we sort and print the top results.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ€åä¸€æ®µä»£ç ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆåœ¨æµä¸­è¿›è¡Œå·¥ä½œï¼Œå¹¶ä¸”â€”éšç€ç»“æœçš„åˆ°æ¥â€”è¿›è¡Œæ±‡æ€»ã€‚æœ€åï¼Œæˆ‘ä»¬å¯¹ç»“æœè¿›è¡Œæ’åºå¹¶æ‰“å°å‡ºæœ€å¥½çš„ç»“æœã€‚
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: è¾“å‡ºæ˜¯ï¼š
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code for the Bed-Reader genomics crate uses the same technique to retrieve
    information from scattered DNA regions of interest. As the DNA information comes
    in, perhaps out of order, the code fills in the correct columns of an output array.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Bed-ReaderåŸºå› ç»„å­¦crateçš„ä»£ç ä½¿ç”¨ç›¸åŒçš„æŠ€æœ¯æ¥ä»åˆ†æ•£çš„DNAåŒºåŸŸè·å–ä¿¡æ¯ã€‚å½“DNAä¿¡æ¯åˆ°è¾¾æ—¶ï¼Œå¯èƒ½æ˜¯ä¹±åºçš„ï¼Œä»£ç ä¼šå¡«å……è¾“å‡ºæ•°ç»„çš„æ­£ç¡®åˆ—ã€‚
- en: 'Aside: This method uses an iterator, a stream, and a loop. I wish it were simpler.
    If you can figure out a simpler way to retrieve a vector of regions while limiting
    the maximum chunk size and the maximum number of concurrent requests, please send
    me a pull request.'
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é¡ºä¾¿æä¸€ä¸‹ï¼šæ­¤æ–¹æ³•ä½¿ç”¨äº†è¿­ä»£å™¨ã€æµå’Œå¾ªç¯ã€‚æˆ‘å¸Œæœ›å®ƒèƒ½æ›´ç®€å•ã€‚å¦‚æœä½ èƒ½æ‰¾åˆ°ä¸€ç§æ›´ç®€å•çš„æ–¹æ³•æ¥è·å–åŒºåŸŸçš„å‘é‡ï¼ŒåŒæ—¶é™åˆ¶æœ€å¤§å—å¤§å°å’Œå¹¶å‘è¯·æ±‚æ•°ï¼Œè¯·å‘ç»™æˆ‘ä¸€ä¸ªpull
    requestã€‚
- en: That covers access to files stored on an HTTP server, but what about AWS S3
    and other cloud services? What about local files?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ¶µç›–äº†è®¿é—®å­˜å‚¨åœ¨HTTPæœåŠ¡å™¨ä¸Šçš„æ–‡ä»¶ï¼Œä½†AWS S3å’Œå…¶ä»–äº‘æœåŠ¡å‘¢ï¼Ÿæœ¬åœ°æ–‡ä»¶æ€ä¹ˆåŠï¼Ÿ
- en: 'Rule 4: Use URL strings and option strings to access HTTP, Local Files, AWS
    S3, Azure, and Google Cloud.'
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§„åˆ™4ï¼šä½¿ç”¨URLå­—ç¬¦ä¸²å’Œé€‰é¡¹å­—ç¬¦ä¸²æ¥è®¿é—®HTTPã€æœ¬åœ°æ–‡ä»¶ã€AWS S3ã€Azureå’ŒGoogle Cloudã€‚
- en: The `object_store` crate (and the `cloud-file` wrapper crate) supports specifying
    files either via a URL string or via structs. I recommend sticking with URL strings,
    but the choice is yours.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`object_store` crateï¼ˆä»¥åŠ`cloud-file`åŒ…è£…crateï¼‰æ”¯æŒé€šè¿‡URLå­—ç¬¦ä¸²æˆ–ç»“æ„ä½“æŒ‡å®šæ–‡ä»¶ã€‚æˆ‘å»ºè®®ä½¿ç”¨URLå­—ç¬¦ä¸²ï¼Œä½†é€‰æ‹©æƒåœ¨ä½ ã€‚'
- en: Letâ€™s consider an AWS S3 example. As you can see, AWS access requires credential
    information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è€ƒè™‘ä¸€ä¸ªAWS S3çš„ç¤ºä¾‹ã€‚å¦‚ä½ æ‰€è§ï¼ŒAWSè®¿é—®éœ€è¦å‡­è¯ä¿¡æ¯ã€‚
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The key part is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: å…³é”®éƒ¨åˆ†æ˜¯ï¼š
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we wish to use structs instead of URL strings, this becomes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬å¸Œæœ›ä½¿ç”¨ç»“æ„ä½“è€Œä¸æ˜¯URLå­—ç¬¦ä¸²ï¼Œåˆ™å˜ä¸ºï¼š
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I prefer the URL approach over structs. I find URLs slightly simpler, much more
    uniform across cloud services, and vastly easier for interop (with, for example,
    Python).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æ›´å–œæ¬¢URLæ–¹æ³•è€Œä¸æ˜¯ç»“æ„ä½“ã€‚æˆ‘å‘ç°URLç¨å¾®ç®€å•ä¸€äº›ï¼Œæ›´åŠ ç»Ÿä¸€ï¼Œè·¨äº‘æœåŠ¡æ—¶ä¹Ÿæ›´å®¹æ˜“äº’æ“ä½œï¼ˆä¾‹å¦‚ä¸Pythonï¼‰ã€‚
- en: 'Here are example URLs for the three web services I have used:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯æˆ‘ä½¿ç”¨çš„ä¸‰ä¸ªWebæœåŠ¡çš„ç¤ºä¾‹URLï¼š
- en: HTTP â€” `[https://www.gutenberg.org/cache/epub/100/pg100.txt](https://www.gutenberg.org/cache/epub/100/pg100.txt)`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP â€” `[https://www.gutenberg.org/cache/epub/100/pg100.txt](https://www.gutenberg.org/cache/epub/100/pg100.txt)`
- en: local file â€” `file:///M:/data%20files/small.bed` â€” use the `[cloud_file::abs_path_to_url_string](/fn.abs_path_to_url_string.html)`
    function to properly encode a full file path into a URL
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ¬åœ°æ–‡ä»¶ â€” `file:///M:/data%20files/small.bed` â€” ä½¿ç”¨`[cloud_file::abs_path_to_url_string](/fn.abs_path_to_url_string.html)`å‡½æ•°å°†å®Œæ•´çš„æ–‡ä»¶è·¯å¾„æ­£ç¡®ç¼–ç ä¸ºURLã€‚
- en: AWS S3 â€” `s3://bedreader/v1/toydata.5chrom.bed`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS S3 â€” `s3://bedreader/v1/toydata.5chrom.bed`
- en: 'Local files donâ€™t need options. For the other services, here are links to their
    supported options and selected examples:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬åœ°æ–‡ä»¶ä¸éœ€è¦é€‰é¡¹ã€‚å¯¹äºå…¶ä»–æœåŠ¡ï¼Œè¿™é‡Œæ˜¯å®ƒä»¬æ”¯æŒçš„é€‰é¡¹å’Œä¸€äº›ç¤ºä¾‹é“¾æ¥ï¼š
- en: HTTP â€” `[ClientConfigKey](https://docs.rs/object_store/latest/object_store/enum.ClientConfigKey.html#variant.Timeout)`
    â€” `[("timeout", "30s")]`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP â€” `[ClientConfigKey](https://docs.rs/object_store/latest/object_store/enum.ClientConfigKey.html#variant.Timeout)`
    â€” `[("timeout", "30s")]`
- en: AWS S3 â€” `[AmazonS3ConfigKey](https://docs.rs/object_store/latest/object_store/aws/enum.AmazonS3ConfigKey.html)`
    â€” `[("aws_region", "us-west-2"), ("aws_access_key_id",` â€¦`), ("aws_secret_access_key",`
    â€¦`)]`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS S3 â€” `[AmazonS3ConfigKey](https://docs.rs/object_store/latest/object_store/aws/enum.AmazonS3ConfigKey.html)`
    â€” `[("aws_region", "us-west-2"), ("aws_access_key_id",` â€¦`), ("aws_secret_access_key",`
    â€¦`)]`
- en: Azure â€” `[AzureConfigKey](https://docs.rs/object_store/latest/object_store/azure/enum.AzureConfigKey.html)`
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure â€” `[AzureConfigKey](https://docs.rs/object_store/latest/object_store/azure/enum.AzureConfigKey.html)`
- en: Google â€” `[GoogleConfigKey](https://docs.rs/object_store/latest/object_store/gcp/enum.GoogleConfigKey.html)`
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google â€” `[GoogleConfigKey](https://docs.rs/object_store/latest/object_store/gcp/enum.GoogleConfigKey.html)`
- en: Now that we can specify and read cloud files, we should create tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å¯ä»¥æŒ‡å®šå’Œè¯»å–äº‘æ–‡ä»¶ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬åº”è¯¥åˆ›å»ºæµ‹è¯•ã€‚
- en: 'Rule 5: Test via `tokio::test` on http and local files.'
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§„åˆ™ 5ï¼šé€šè¿‡ `tokio::test` å¯¹ HTTP æ–‡ä»¶å’Œæœ¬åœ°æ–‡ä»¶è¿›è¡Œæµ‹è¯•ã€‚
- en: 'The `object_store` crate (and `cloud-file`) supports any async runtime. For
    testing, the [Tokio runtime](https://docs.rs/tokio/latest/tokio/index.html) makes
    it easy to test your code on cloud files. Here is a test on an http file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`object_store` crateï¼ˆä»¥åŠ `cloud-file`ï¼‰æ”¯æŒä»»ä½•å¼‚æ­¥è¿è¡Œæ—¶ã€‚ä¸ºäº†æµ‹è¯•ï¼Œ[Tokio è¿è¡Œæ—¶](https://docs.rs/tokio/latest/tokio/index.html)ä½¿å¾—åœ¨äº‘æ–‡ä»¶ä¸Šæµ‹è¯•ä»£ç å˜å¾—ç®€å•ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªé’ˆå¯¹
    HTTP æ–‡ä»¶çš„æµ‹è¯•ï¼š'
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run this test with:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: è¿è¡Œæ­¤æµ‹è¯•å‘½ä»¤ï¼š
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you donâ€™t want to hit an outside web server with your tests, you can instead
    test against local files as though they were in the cloud.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨ä¸æƒ³é€šè¿‡æµ‹è¯•è®¿é—®å¤–éƒ¨ Web æœåŠ¡å™¨ï¼Œæ‚¨å¯ä»¥æ”¹ä¸ºå°†æœ¬åœ°æ–‡ä»¶å½“ä½œäº‘æ–‡ä»¶è¿›è¡Œæµ‹è¯•ã€‚
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This uses the standard Rust environment variable `[CARGO_MANIFEST_DIR](https://doc.rust-lang.org/cargo/reference/environment-variables.html)`
    to find the full path to a text file. It then uses `cloud_file::abs_path_to_url_string`
    to correctly encode that full path into a URL.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä½¿ç”¨æ ‡å‡†çš„ Rust ç¯å¢ƒå˜é‡ `[CARGO_MANIFEST_DIR](https://doc.rust-lang.org/cargo/reference/environment-variables.html)`
    æ¥æŸ¥æ‰¾æ–‡æœ¬æ–‡ä»¶çš„å®Œæ•´è·¯å¾„ã€‚ç„¶åï¼Œå®ƒä½¿ç”¨ `cloud_file::abs_path_to_url_string` å°†è¯¥å®Œæ•´è·¯å¾„æ­£ç¡®ç¼–ç ä¸º URLã€‚
- en: Whether you test on http files or local files, the power of `object_store` means
    that your code should work on any cloud service, including AWS S3, Azure, and
    Google Cloud.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: æ— è®ºæ˜¯åœ¨ HTTP æ–‡ä»¶è¿˜æ˜¯æœ¬åœ°æ–‡ä»¶ä¸Šè¿›è¡Œæµ‹è¯•ï¼Œ`object_store` çš„å¼ºå¤§åŠŸèƒ½æ„å‘³ç€æ‚¨çš„ä»£ç åº”è¯¥èƒ½åœ¨ä»»ä½•äº‘æœåŠ¡ä¸Šè¿è¡Œï¼ŒåŒ…æ‹¬ AWS S3ã€Azure
    å’Œ Google Cloudã€‚
- en: If you only need to access cloud files for your own use, you can stop reading
    the rules here and skip to the conclusion. If you are adding cloud access to a
    library (Rust crate) for others, keep reading.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨åªéœ€è¦è®¿é—®äº‘æ–‡ä»¶ä¾›è‡ªå·±ä½¿ç”¨ï¼Œæ‚¨å¯ä»¥åœ¨è¿™é‡Œåœæ­¢é˜…è¯»è§„åˆ™å¹¶è·³åˆ°ç»“è®ºéƒ¨åˆ†ã€‚å¦‚æœæ‚¨æ˜¯ä¸ºä»–äººæ·»åŠ äº‘è®¿é—®åˆ°ä¸€ä¸ªåº“ï¼ˆRust crateï¼‰ï¼Œè¯·ç»§ç»­é˜…è¯»ã€‚
- en: 'Rule 6: For maximum performance, add cloud-file support to your Rust library
    via an async API.'
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§„åˆ™ 6ï¼šä¸ºäº†è·å¾—æœ€ä½³æ€§èƒ½ï¼Œé€šè¿‡å¼‚æ­¥ API å°†äº‘æ–‡ä»¶æ”¯æŒæ·»åŠ åˆ°æ‚¨çš„ Rust åº“ä¸­ã€‚
- en: If you offer a Rust crate to others, supporting cloud files offers great convenience
    to your users, but not without a cost. Letâ€™s look at [Bed-Reader](https://pypi.org/project/bed-reader/),
    the genomics crate to which I added cloud support.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‚¨æä¾› Rust crate ç»™ä»–äººä½¿ç”¨ï¼Œæ”¯æŒäº‘æ–‡ä»¶ä¸ºæ‚¨çš„ç”¨æˆ·æä¾›äº†æå¤§çš„ä¾¿åˆ©ï¼Œä½†ä¹Ÿæœ‰ä¸€å®šæˆæœ¬ã€‚è®©æˆ‘ä»¬æ¥çœ‹çœ‹æˆ‘ä¸º [Bed-Reader](https://pypi.org/project/bed-reader/)
    æ·»åŠ äº†äº‘æ”¯æŒçš„åŸºå› ç»„å­¦ crateã€‚
- en: As previously mentioned, Bed-Reader is a library for reading and writing PLINK
    Bed Files, a binary format used in bioinformatics to store genotype (DNA) data.
    Files in Bed format can be as large as a terabyte. Bed-Reader gives users fast,
    random access to large subsets of the data. It returns a 2-D array in the userâ€™s
    choice of int8, float32, or float64\. Bed-Reader also gives users access to 12
    pieces of metadata, six associated with individuals and six associated with SNPs
    (roughly speaking, DNA locations). The genotype data is often 100,000 times larger
    than the metadata.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚å‰æ‰€è¿°ï¼ŒBed-Reader æ˜¯ä¸€ä¸ªç”¨äºè¯»å–å’Œå†™å…¥ PLINK Bed æ–‡ä»¶çš„åº“ï¼ŒPLINK Bed æ–‡ä»¶æ˜¯ä¸€ç§åœ¨ç”Ÿç‰©ä¿¡æ¯å­¦ä¸­ç”¨äºå­˜å‚¨åŸºå› å‹ï¼ˆDNAï¼‰æ•°æ®çš„äºŒè¿›åˆ¶æ ¼å¼ã€‚Bed
    æ ¼å¼çš„æ–‡ä»¶å¯ä»¥å¤§åˆ°ä¸€ä¸ª TBã€‚Bed-Reader ä¸ºç”¨æˆ·æä¾›å¯¹å¤§é‡æ•°æ®å­é›†çš„å¿«é€Ÿéšæœºè®¿é—®ã€‚å®ƒè¿”å›ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œç”¨æˆ·å¯ä»¥é€‰æ‹© int8ã€float32 æˆ–
    float64 æ ¼å¼ã€‚Bed-Reader è¿˜ä¸ºç”¨æˆ·æä¾›äº† 12 ä¸ªå…ƒæ•°æ®å­—æ®µï¼Œå…¶ä¸­å…­ä¸ªä¸ä¸ªä½“ç›¸å…³ï¼Œå…­ä¸ªä¸ SNPï¼ˆå¤§è‡´æ¥è¯´ï¼Œæ˜¯ DNA ä½ç½®ï¼‰ç›¸å…³ã€‚åŸºå› å‹æ•°æ®é€šå¸¸æ¯”å…ƒæ•°æ®å¤§
    100,000 å€ã€‚
- en: '![](../Images/210196974c88a9518883ab78d09b7c00.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/210196974c88a9518883ab78d09b7c00.png)'
- en: PLINK stores genotype data and metadata. (Figure by author.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: PLINK å­˜å‚¨åŸºå› å‹æ•°æ®å’Œå…ƒæ•°æ®ã€‚ï¼ˆå›¾ç”±ä½œè€…æä¾›ã€‚ï¼‰
- en: 'Aside: In this context, an â€œ[API](https://en.wikipedia.org/wiki/API)â€ refers
    to an Application Programming Interface. It is the public structs, methods, etc.,
    provided by library code such as Bed-Reader for another program to call.'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ—æ³¨ï¼šåœ¨æ­¤ä¸Šä¸‹æ–‡ä¸­ï¼Œâ€œ[API](https://en.wikipedia.org/wiki/API)â€æŒ‡çš„æ˜¯åº”ç”¨ç¨‹åºç¼–ç¨‹æ¥å£ã€‚å®ƒæ˜¯ç”±è¯¸å¦‚ Bed-Reader
    ä¹‹ç±»çš„åº“ä»£ç æä¾›çš„å…¬å…±ç»“æ„ã€æ–¹æ³•ç­‰ï¼Œä¾›å…¶ä»–ç¨‹åºè°ƒç”¨ã€‚
- en: 'Here is some sample code using Bed-Readerâ€™s original â€œlocal fileâ€ API. This
    code lists the first five individual ids, the first five SNP ids, and every unique
    chromosome number. It then reads every genomic value in chromosome 5:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ä½¿ç”¨ Bed-Reader åŸå§‹â€œæœ¬åœ°æ–‡ä»¶â€API çš„ç¤ºä¾‹ä»£ç ã€‚è¯¥ä»£ç åˆ—å‡ºäº†å‰äº”ä¸ªä¸ªä½“ IDï¼Œå‰äº”ä¸ª SNP IDï¼Œä»¥åŠæ¯ä¸ªç‹¬ç‰¹çš„æŸ“è‰²ä½“ç¼–å·ã€‚ç„¶åï¼Œå®ƒè¯»å–æŸ“è‰²ä½“
    5 ä¸­çš„æ¯ä¸ªåŸºå› ç»„å€¼ï¼š
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And here is the same code using the new cloud file API:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä½¿ç”¨æ–°äº‘æ–‡ä»¶ API çš„ç›¸åŒä»£ç ï¼š
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When switching to cloud data, a Bed-Reader user must make these changes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: å½“åˆ‡æ¢åˆ°äº‘æ•°æ®æ—¶ï¼ŒBed-Reader ç”¨æˆ·å¿…é¡»åšå‡ºä»¥ä¸‹æ›´æ”¹ï¼š
- en: They must run in an async environment, here `#[tokio::test]`.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»–ä»¬å¿…é¡»åœ¨ä¸€ä¸ªå¼‚æ­¥ç¯å¢ƒä¸­è¿è¡Œï¼Œè¿™é‡Œæ˜¯ `#[tokio::test]`ã€‚
- en: They must use a new struct, `BedCloud` instead of `Bed`. (Also, not shown, `BedCloudBuilder`
    rather than `BedBuilder`.)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»–ä»¬å¿…é¡»ä½¿ç”¨ä¸€ä¸ªæ–°çš„ç»“æ„ä½“ `BedCloud`ï¼Œè€Œä¸æ˜¯ `Bed`ã€‚ï¼ˆå¦å¤–ï¼Œæœªå±•ç¤ºçš„æ˜¯ï¼Œä½¿ç”¨ `BedCloudBuilder` è€Œä¸æ˜¯ `BedBuilder`ã€‚ï¼‰
- en: They give a URL string and optional string options rather than a local file
    path.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒä»¬æä¾›äº†ä¸€ä¸ª URL å­—ç¬¦ä¸²å’Œå¯é€‰çš„å­—ç¬¦ä¸²é€‰é¡¹ï¼Œè€Œä¸æ˜¯æœ¬åœ°æ–‡ä»¶è·¯å¾„ã€‚
- en: They must use `.await` in many, rather unpredictable, places. (Happily, the
    compiler gives a good error message if they miss a place.)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»–ä»¬å¿…é¡»åœ¨è®¸å¤šåœ°æ–¹ä½¿ç”¨ `.await`ï¼Œè¿™äº›åœ°æ–¹å¾€å¾€æ˜¯ä¸å¯é¢„æµ‹çš„ã€‚ï¼ˆå¹¸è¿çš„æ˜¯ï¼Œå¦‚æœä»–ä»¬æ¼æ‰äº†æŸä¸ªåœ°æ–¹ï¼Œç¼–è¯‘å™¨ä¼šç»™å‡ºå¾ˆå¥½çš„é”™è¯¯æç¤ºã€‚ï¼‰
- en: The `ReadOptionsBuilder` gets a new method, `read_cloud`, to go along with its
    previous `read` method.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadOptionsBuilder` å¢åŠ äº†ä¸€ä¸ªæ–°æ–¹æ³• `read_cloud`ï¼Œç”¨äºé…åˆä¹‹å‰çš„ `read` æ–¹æ³•ã€‚'
- en: From the library developerâ€™s point of view, adding the new `BedCloud` and `BedCloudBuilder`
    structs costs many lines of main and test code. In my case, 2,200 lines of new
    main code and 2,400 lines of new test code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ä»åº“å¼€å‘è€…çš„è§’åº¦æ¥çœ‹ï¼Œæ·»åŠ æ–°çš„ `BedCloud` å’Œ `BedCloudBuilder` ç»“æ„ä½“éœ€è¦å¢åŠ å¤§é‡çš„ä¸»ä»£ç å’Œæµ‹è¯•ä»£ç ã€‚åœ¨æˆ‘çš„æƒ…å†µä¸‹ï¼Œæ˜¯ 2200
    è¡Œæ–°çš„ä¸»ä»£ç å’Œ 2400 è¡Œæ–°çš„æµ‹è¯•ä»£ç ã€‚
- en: 'Aside: Also, see Mario Ortiz Maneroâ€™s article â€œ[The bane of my existence: Supporting
    both async and sync code in Rust](https://nullderef.com/blog/rust-async-sync/)â€.'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ—æ³¨ï¼šæ­¤å¤–ï¼Œè¿˜å¯ä»¥å‚è€ƒ Mario Ortiz Manero çš„æ–‡ç«  â€œ[æˆ‘ç”Ÿå‘½ä¸­çš„ç—›è‹¦ï¼šåœ¨ Rust ä¸­æ”¯æŒå¼‚æ­¥å’ŒåŒæ­¥ä»£ç ](https://nullderef.com/blog/rust-async-sync/)â€ã€‚
- en: The benefit users get from these changes is the ability to read data from cloud
    files with asyncâ€™s high efficiency.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ç”¨æˆ·ä»è¿™äº›æ”¹åŠ¨ä¸­è·å¾—çš„å¥½å¤„æ˜¯å¯ä»¥åˆ©ç”¨å¼‚æ­¥çš„é«˜æ•ˆæ€§ä»äº‘æ–‡ä»¶ä¸­è¯»å–æ•°æ®ã€‚
- en: Is this benefit worth it? If not, there is an alternative that weâ€™ll look at
    next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§å¥½å¤„å€¼å¾—å—ï¼Ÿå¦‚æœä¸å€¼å¾—ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°†çœ‹ä¸€ä¸‹æ›¿ä»£æ–¹æ¡ˆã€‚
- en: 'Rule 7: Alternatively, for maximum convenience, add cloud-file support to your
    Rust library via a traditional (â€œsynchronousâ€) API.'
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§„åˆ™ 7ï¼šæˆ–è€…ï¼Œä¸ºäº†æœ€å¤§ç¨‹åº¦çš„ä¾¿åˆ©ï¼Œé€šè¿‡ä¼ ç»Ÿçš„ï¼ˆâ€œåŒæ­¥â€ï¼‰API å‘ä½ çš„ Rust åº“æ·»åŠ äº‘æ–‡ä»¶æ”¯æŒã€‚
- en: If adding an efficient async API seems like too much work for you or seems too
    confusing for your users, there is an alternative. Namely, you can offer a traditional
    (â€œsynchronousâ€) API. I do this for the Python version of Bed-Reader and for the
    Rust code that supports the Python version.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä¸ºä½ æ·»åŠ ä¸€ä¸ªé«˜æ•ˆçš„å¼‚æ­¥ API çœ‹èµ·æ¥å¤ªéº»çƒ¦ï¼Œæˆ–è€…å¯¹ä½ çš„ç”¨æˆ·æ¥è¯´å¤ªæ··ä¹±ï¼Œé‚£ä¹Ÿæœ‰æ›¿ä»£æ–¹æ¡ˆã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä½ å¯ä»¥æä¾›ä¸€ä¸ªä¼ ç»Ÿçš„ï¼ˆâ€œåŒæ­¥â€ï¼‰APIã€‚æˆ‘åœ¨ Bed-Reader
    çš„ Python ç‰ˆæœ¬å’Œæ”¯æŒè¯¥ Python ç‰ˆæœ¬çš„ Rust ä»£ç ä¸­å°±æ˜¯è¿™ä¹ˆåšçš„ã€‚
- en: 'Aside: See: [Nine Rules for Writing Python Extensions in Rust: Practical Lessons
    from Upgrading Bed-Reader, a Python Bioinformatics Package](https://medium.com/towards-data-science/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29)
    in *Towards Data Science*.'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: æ—æ³¨ï¼šè§ï¼š[ç”¨ Rust ç¼–å†™ Python æ‰©å±•çš„ä¹æ¡è§„åˆ™ï¼šä»å‡çº§ Python ç”Ÿç‰©ä¿¡æ¯å­¦åŒ… Bed-Reader ä¸­è·å¾—çš„å®é™…ç»éªŒæ•™è®­](https://medium.com/towards-data-science/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29)ï¼Œã€Š*Towards
    Data Science*ã€‹ã€‚
- en: Here is the Rust function that Python calls to check if a *.bed file starts
    with the correct file signature.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™é‡Œæ˜¯ Python è°ƒç”¨çš„ Rust å‡½æ•°ï¼Œç”¨äºæ£€æŸ¥ä¸€ä¸ª *.bed æ–‡ä»¶æ˜¯å¦ä»¥æ­£ç¡®çš„æ–‡ä»¶ç­¾åå¼€å§‹ã€‚
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Notice that this is *not* an async function. It is a normal â€œsynchronousâ€ function.
    Inside this synchronous function, Rust makes an async call:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªå¼‚æ­¥å‡½æ•°ã€‚å®ƒæ˜¯ä¸€ä¸ªæ™®é€šçš„â€œåŒæ­¥â€å‡½æ•°ã€‚åœ¨è¿™ä¸ªåŒæ­¥å‡½æ•°å†…éƒ¨ï¼ŒRust è¿›è¡Œäº†ä¸€ä¸ªå¼‚æ­¥è°ƒç”¨ï¼š
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We make the async call synchronous by wrapping it in a Tokio runtime:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é€šè¿‡å°†å¼‚æ­¥è°ƒç”¨åŒ…è£…åœ¨ Tokio è¿è¡Œæ—¶ä¸­æ¥ä½¿å…¶å˜ä¸ºåŒæ­¥ï¼š
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Bed-Readerâ€™s Python users could previously open a local file for reading with
    the command `open_bed(file_name_string)`. Now, they can also open a cloud file
    for reading with the same command `open_bed(url_string)`. The only difference
    is the format of the string they pass in.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Bed-Reader çš„ Python ç”¨æˆ·ä¹‹å‰å¯ä»¥ä½¿ç”¨å‘½ä»¤ `open_bed(file_name_string)` æ‰“å¼€ä¸€ä¸ªæœ¬åœ°æ–‡ä»¶è¿›è¡Œè¯»å–ã€‚ç°åœ¨ï¼Œä»–ä»¬ä¹Ÿå¯ä»¥ç”¨ç›¸åŒçš„å‘½ä»¤
    `open_bed(url_string)` æ‰“å¼€ä¸€ä¸ªäº‘æ–‡ä»¶è¿›è¡Œè¯»å–ã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯ä»–ä»¬ä¼ å…¥çš„å­—ç¬¦ä¸²æ ¼å¼ã€‚
- en: 'Here is the example from Rule 6, in Python, using the updated Python API:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯è§„åˆ™ 6 ä¸­çš„ç¤ºä¾‹ï¼Œä½¿ç”¨æ›´æ–°åçš„ Python API çš„ Python ä»£ç ï¼š
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice the Python API also offers a new optional parameter called `cloud_options`.
    Also, behind the scenes, a tiny bit of new code distinguishes between strings
    representing local files and strings representing URLs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼ŒPython API è¿˜æä¾›äº†ä¸€ä¸ªåä¸º `cloud_options` çš„æ–°å¯é€‰å‚æ•°ã€‚æ­¤å¤–ï¼Œå¹•åæœ‰ä¸€å°æ®µæ–°ä»£ç ï¼ŒåŒºåˆ†äº†è¡¨ç¤ºæœ¬åœ°æ–‡ä»¶å’Œè¡¨ç¤º URL
    çš„å­—ç¬¦ä¸²ã€‚
- en: In Rust, you can use the same trick to make calls to `object_cloud` synchronous.
    Specifically, you can wrap async calls in a runtime. The benefit is a simpler
    interface and less library code. The cost is less efficiency compared to offering
    an async API.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Rust ä¸­ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ç›¸åŒçš„æŠ€å·§ä½¿ `object_cloud` çš„è°ƒç”¨å˜ä¸ºåŒæ­¥ã€‚å…·ä½“è€Œè¨€ï¼Œä½ å¯ä»¥å°†å¼‚æ­¥è°ƒç”¨åŒ…è£…åœ¨è¿è¡Œæ—¶ä¸­ã€‚å¥½å¤„æ˜¯æ¥å£æ›´ç®€å•ï¼Œåº“ä»£ç æ›´å°‘ã€‚ä»£ä»·æ˜¯æ•ˆç‡æ¯”æä¾›å¼‚æ­¥
    API è¦ä½ã€‚
- en: 'If you decide against the â€œsynchronousâ€ alternative and choose to offer an
    async API, youâ€™ll discover a new problem: providing async examples in your documentation.
    We will look at that issue next.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ å†³å®šæ”¾å¼ƒâ€œåŒæ­¥â€æ›¿ä»£æ–¹æ¡ˆï¼Œé€‰æ‹©æä¾›å¼‚æ­¥ APIï¼Œä½ ä¼šå‘ç°ä¸€ä¸ªæ–°é—®é¢˜ï¼šå¦‚ä½•åœ¨æ–‡æ¡£ä¸­æä¾›å¼‚æ­¥ç¤ºä¾‹ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬å°†è®¨è®ºè¿™ä¸ªé—®é¢˜ã€‚
- en: 'Rule 8: Follow the rules of good API design in part by using hidden lines in
    your doc tests.'
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: è§„åˆ™ 8ï¼šé€šè¿‡åœ¨æ–‡æ¡£æµ‹è¯•ä¸­ä½¿ç”¨éšè—è¡Œï¼Œéµå¾ªè‰¯å¥½çš„ API è®¾è®¡è§„åˆ™ã€‚
- en: 'All the rules from the article [Nine Rules for Elegant Rust Library APIs: Practical
    Lessons from Porting Bed-Reader, a Bioinformatics Library, from Python to Rust](https://medium.com/towards-data-science/nine-rules-for-elegant-rust-library-apis-9b986a465247)
    in *Towards Data Science* apply. Of particular importance are these two:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: æ–‡ç« ä¸­çš„æ‰€æœ‰è§„åˆ™ [ä¼˜é›… Rust åº“ API çš„ä¹æ¡è§„åˆ™ï¼šä»å°† Bed-Readerï¼ˆä¸€ç§ç”Ÿç‰©ä¿¡æ¯å­¦åº“ï¼‰ä» Python ç§»æ¤åˆ° Rust ä¸­å¾—åˆ°çš„å®è·µç»éªŒ](https://medium.com/towards-data-science/nine-rules-for-elegant-rust-library-apis-9b986a465247)
    é€‚ç”¨ï¼Œç‰¹åˆ«æ˜¯ä»¥ä¸‹ä¸¤æ¡ï¼š
- en: '*Write good documentation to keep your design honest.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*ç¼–å†™è‰¯å¥½çš„æ–‡æ¡£ï¼Œä¿æŒè®¾è®¡çš„è¯šå®ã€‚'
- en: Create examples that donâ€™t embarrass you.*
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ›å»ºä¸ä¼šè®©ä½ å°´å°¬çš„ç¤ºä¾‹ã€‚*
- en: 'These suggest that we should give examples in our documentation, but how can
    we do that with async methods and awaits? The trick is â€œhidden linesâ€ in our [doc
    tests](https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html).
    For example, here is the documentation for `[CloudFile::read_ranges](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_ranges)`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™è¡¨æ˜æˆ‘ä»¬åº”è¯¥åœ¨æ–‡æ¡£ä¸­ç»™å‡ºç¤ºä¾‹ï¼Œä½†å¦‚ä½•åœ¨å¼‚æ­¥æ–¹æ³•å’Œ await ä¸­å®ç°è¿™ä¸€ç‚¹å‘¢ï¼Ÿçªé—¨åœ¨äºåœ¨æˆ‘ä»¬çš„[æ–‡æ¡£æµ‹è¯•](https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html)ä¸­ä½¿ç”¨â€œéšè—è¡Œâ€ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹æ˜¯
    `[CloudFile::read_ranges](https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_ranges)`
    çš„æ–‡æ¡£ï¼š
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: /// use cloud_file::CloudFile;
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// ä½¿ç”¨ cloud_file::CloudFile;
- en: ///
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ///
- en: '/// # Runtime::new().unwrap().block_on(async {'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '/// # Runtime::new().unwrap().block_on(async {'
- en: /// let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/plink_sim_10s_100v_10pmiss.bim";
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/plink_sim_10s_100v_10pmiss.bim";
- en: /// let cloud_file = CloudFile::new(url)?;
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// let cloud_file = CloudFile::new(url)?;
- en: /// let bytes_vec = cloud_file.read_ranges(&[0..10, 1000..1010]).await?;
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// let bytes_vec = cloud_file.read_ranges(&[0..10, 1000..1010]).await?;
- en: /// assert_eq!(bytes_vec.len(), 2);
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// assert_eq!(bytes_vec.len(), 2);
- en: /// assert_eq!(bytes_vec[0].as_ref(), b"1\t1:1:A:C\t");
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// assert_eq!(bytes_vec[0].as_ref(), b"1\t1:1:A:C\t");
- en: /// assert_eq!(bytes_vec[1].as_ref(), b":A:C\t0.0\t4");
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// assert_eq!(bytes_vec[1].as_ref(), b":A:C\t0.0\t4");
- en: '/// # Ok::<(), CloudFileError>(())}).unwrap();'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '/// # Ok::<(), CloudFileError>(())}).unwrap();'
- en: '/// # use {tokio::runtime::Runtime, cloud_file::CloudFileError};'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '/// # ä½¿ç”¨ {tokio::runtime::Runtime, cloud_file::CloudFileError};'
- en: /// [PRE28]
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: /// [PRE28]
- en: The doc test starts with [PRE29] [PRE30]
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: æ–‡æ¡£æµ‹è¯•ä» [PRE29] [PRE30] å¼€å§‹
- en: '[features]'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[åŠŸèƒ½]'
- en: extension-module = ["pyo3/extension-module", "tokio/full"]
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: extension-module = ["pyo3/extension-module", "tokio/full"]
- en: default = []
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: é»˜è®¤ = []
- en: '[dependencies]'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[ä¾èµ–]'
- en: '#...'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '#...'
- en: pyo3 = { version = "0.20.0", features = ["extension-module"], optional = true
    }
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: pyo3 = { version = "0.20.0", features = ["extension-module"], optional = true
    }
- en: tokio = { version = "1.35.0", features = ["full"], optional = true }
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: tokio = { version = "1.35.0", features = ["full"], optional = true }
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[tool.maturin]'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[tool.maturin]'
- en: features = ["extension-module"]
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: features = ["extension-module"]
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '#![cfg(feature = "extension-module")] // ignore file if feature not ''on'''
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#![cfg(feature = "extension-module")] // å¦‚æœç‰¹æ€§æœªå¼€å¯åˆ™å¿½ç•¥æ–‡ä»¶'
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#![cfg(feature = "tokio")]'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#![cfg(feature = "tokio")]'
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: /// Chromosome of each SNP (variant)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: /// æ¯ä¸ª SNPï¼ˆå˜å¼‚ï¼‰çš„æŸ“è‰²ä½“
- en: /// [...]
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: /// [...]
- en: ///
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ///
- en: '/// # Example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '/// # ç¤ºä¾‹ï¼š'
- en: /// [PRE35]
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: /// [PRE35]
- en: '```'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In this doc test, when the `tokio` feature is â€˜onâ€™, the example, uses `tokio`
    and runs four lines of code inside a Tokio runtime. When the `tokio` feature is
    â€˜offâ€™, the code within the `#[cfg(feature = "tokio")]` block disappears, effectively
    skipping the asynchronous operations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªæ–‡æ¡£æµ‹è¯•ä¸­ï¼Œå½“ `tokio` åŠŸèƒ½â€œå¼€å¯â€æ—¶ï¼Œç¤ºä¾‹ä½¿ç”¨ `tokio` å¹¶åœ¨ Tokio è¿è¡Œæ—¶ä¸­è¿è¡Œå››è¡Œä»£ç ã€‚å½“ `tokio` åŠŸèƒ½â€œå…³é—­â€æ—¶ï¼Œ`#[cfg(feature
    = "tokio")]` å—ä¸­çš„ä»£ç æ¶ˆå¤±ï¼Œä»è€Œæœ‰æ•ˆåœ°è·³è¿‡å¼‚æ­¥æ“ä½œã€‚
- en: 'When formatting the documentation, Rust includes documentation for all features
    by default, so we see the four lines of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ ¼å¼åŒ–æ–‡æ¡£æ—¶ï¼ŒRust é»˜è®¤åŒ…å«æ‰€æœ‰åŠŸèƒ½çš„æ–‡æ¡£ï¼Œå› æ­¤æˆ‘ä»¬çœ‹åˆ°äº†è¿™å››è¡Œä»£ç ï¼š
- en: '![](../Images/4544233478a0a6911c16e85bb4a9ab4e.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4544233478a0a6911c16e85bb4a9ab4e.png)'
- en: 'To summarize Rule 9: By using Cargo features and conditional compilation we
    can ensure that users only pay for the features that they use.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ç»“è§„åˆ™9ï¼šé€šè¿‡ä½¿ç”¨CargoåŠŸèƒ½å’Œæ¡ä»¶ç¼–è¯‘ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®ä¿ç”¨æˆ·åªä¸ºä»–ä»¬ä½¿ç”¨çš„åŠŸèƒ½ä»˜è´¹ã€‚
- en: Conclusion
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: 'So, there you have it: nine rules for reading cloud files in your Rust program.
    Thanks to the power of the `[object_store](https://docs.rs/object_store/latest/object_store/)`
    crate, your programs can move beyond your local drive and load data from the web,
    AWS S3, Azure, and Google Cloud. To make this a little simpler, you can also use
    the new `[cloud-file](https://crates.io/crates/cloud-file)` wrapping crate that
    I wrote for this article.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œå°±è¿™æ ·ï¼šä¹æ¡è§„åˆ™å¸®åŠ©ä½ åœ¨Rustç¨‹åºä¸­è¯»å–äº‘æ–‡ä»¶ã€‚å€ŸåŠ©[`object_store`](https://docs.rs/object_store/latest/object_store/)
    crateçš„å¼ºå¤§åŠŸèƒ½ï¼Œä½ çš„ç¨‹åºå¯ä»¥çªç ´æœ¬åœ°é©±åŠ¨å™¨çš„é™åˆ¶ï¼Œä»Webã€AWS S3ã€Azureå’ŒGoogle CloudåŠ è½½æ•°æ®ã€‚ä¸ºäº†è®©è¿™ä¸€è¿‡ç¨‹æ›´ç®€å•ï¼Œä½ è¿˜å¯ä»¥ä½¿ç”¨æˆ‘ä¸ºæœ¬æ–‡ç¼–å†™çš„å…¨æ–°[`cloud-file`](https://crates.io/crates/cloud-file)åŒ…è£…crateã€‚
- en: I should also mention that this article explored only a subset of `object_store`â€™s
    features. In addition to what weâ€™ve seen, the `object_store` crate also handles
    writing files and working with folders and subfolders. The `[cloud-file](https://crates.io/crates/cloud-file)`
    crate, on the other hand, only handles reading files. (But, hey, Iâ€™m open to pull
    requests).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘è¿˜åº”è¯¥æåˆ°ï¼Œè¿™ç¯‡æ–‡ç« ä»…æ¢è®¨äº†`object_store`çš„ä¸€ä¸ªå­é›†åŠŸèƒ½ã€‚é™¤äº†æˆ‘ä»¬çœ‹åˆ°çš„ï¼Œ`object_store` crate è¿˜å¤„ç†å†™å…¥æ–‡ä»¶å’Œæ“ä½œæ–‡ä»¶å¤¹åŠå­æ–‡ä»¶å¤¹ã€‚å¦ä¸€æ–¹é¢ï¼Œ[`cloud-file`](https://crates.io/crates/cloud-file)
    crate åªå¤„ç†è¯»å–æ–‡ä»¶ã€‚ï¼ˆä½†å˜¿ï¼Œæˆ‘å¾ˆæ¬¢è¿æäº¤Pull Requestï¼‰ã€‚
- en: Should you add cloud file support to your program? It, of course, depends. Supporting
    cloud files offers a huge convenience to your programâ€™s users. The cost is the
    extra complexity of using/providing an async interface. The cost also includes
    the increased file size of runtimes like Tokio. On the other hand, I think the
    tools for adding such support are good and trying them is easy, so give it a try!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æ˜¯å¦åº”è¯¥åœ¨ç¨‹åºä¸­æ·»åŠ äº‘æ–‡ä»¶æ”¯æŒï¼Ÿå½“ç„¶ï¼Œè¿™å–å†³äºã€‚æ”¯æŒäº‘æ–‡ä»¶ä¸ºä½ çš„ç¨‹åºç”¨æˆ·æä¾›äº†å·¨å¤§çš„ä¾¿åˆ©ã€‚ä»£ä»·æ˜¯ä½¿ç”¨/æä¾›å¼‚æ­¥æ¥å£çš„é¢å¤–å¤æ‚æ€§ã€‚ä»£ä»·è¿˜åŒ…æ‹¬åƒTokioè¿™æ ·çš„è¿è¡Œæ—¶æ–‡ä»¶å¤§å°çš„å¢åŠ ã€‚å¦ä¸€æ–¹é¢ï¼Œæˆ‘è®¤ä¸ºæ·»åŠ æ­¤ç±»æ”¯æŒçš„å·¥å…·å·²ç»éå¸¸å¥½ï¼Œè€Œä¸”å°è¯•å®ƒä»¬ä¹Ÿå¾ˆç®€å•ï¼Œæ‰€ä»¥ä¸å¦¨è¯•è¯•çœ‹ï¼
- en: Thank you for joining me on this journey into the cloud. I hope that if you
    choose to support cloud files, these steps will help you do it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: æ„Ÿè°¢ä½ ä¸æˆ‘ä¸€åŒè¸ä¸Šäº‘ç«¯ä¹‹æ—…ã€‚å¦‚æœä½ é€‰æ‹©æ”¯æŒäº‘æ–‡ä»¶ï¼Œæˆ‘å¸Œæœ›è¿™äº›æ­¥éª¤èƒ½å¸®åŠ©ä½ å®ç°ã€‚
- en: '*Please* [*follow Carl on Medium*](https://medium.com/@carlmkadie)*. I write
    on scientific programming in Rust and Python, machine learning, and statistics.
    I tend to write about one article per month.*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*è¯·* [*å…³æ³¨Carlçš„Mediumè´¦å·*](https://medium.com/@carlmkadie)*ã€‚æˆ‘åœ¨Rustå’ŒPythonçš„ç§‘å­¦ç¼–ç¨‹ã€æœºå™¨å­¦ä¹ å’Œç»Ÿè®¡å­¦æ–¹é¢å†™ä½œã€‚æˆ‘é€šå¸¸æ¯ä¸ªæœˆå†™ä¸€ç¯‡æ–‡ç« ã€‚*'

- en: Explore Solvable and Unsolvable Equations with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/explore-solvable-and-unsolvable-equations-with-python-661ac11f4f20?source=collection_archive---------2-----------------------#2024-10-29](https://towardsdatascience.com/explore-solvable-and-unsolvable-equations-with-python-661ac11f4f20?source=collection_archive---------2-----------------------#2024-10-29)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Find closed-form solutions when possible — use numerical methods when necessary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@carlmkadie?source=post_page---byline--661ac11f4f20--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page---byline--661ac11f4f20--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--661ac11f4f20--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--661ac11f4f20--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page---byline--661ac11f4f20--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--661ac11f4f20--------------------------------)
    ·15 min read·Oct 29, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7c1f799be7465f76240afc9db30d3020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A Python Refereeing an Italian Renaissance Mathematics Duel — Source: [https://openai.com/dall-e-2/](https://openai.com/dall-e-2/).
    All other figures from the author.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Why can we solve some equations easily, while others seem impossible? And
    another thing: why is this knowledge hidden from us?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As data scientists, applied scientists, and engineers, we often create mathematical
    models. For example, consider the model: *y = x²*. Given a value for *x, w*e can
    apply it forward to compute *y*. For instance, if *x = 3*, then *y = 9*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also apply this model backward. Starting with *y = x²*, we rearrange
    to solve for *x*: *x = ±√y*. If *y = 9*, then *x = ±3*. The expression *x = ±√y*
    is an example of a **closed-form solution** — an expression that uses a finite
    combination of standard operations and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: However, not all models are so straightforward. Sometimes, we encounter equations
    where we can’t simply “solve for *x*” and get a closed-form expression. In such
    cases, we might hear, “That’s not solvable — you need numerical methods.” Numerical
    methods are powerful. They can provide precise approximations. Still, it frustrates
    me (and perhaps you) that no one ever seems to explain when closed-form solutions
    are possible and when they aren’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'The great Johannes Kepler shared our frustration. When studying planetary motion,
    he created this model:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *x* −c sin(*x*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This equation converts a body’s position along its orbit (*x)* into its time
    along the orbit (*y)*. Kepler sought a closed-form solution for *x* to turn time
    into a position. However, even 400 years later, the best we have are numerical
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this article, we’ll build intuition about when to expect a closed-form solution.
    The only way to determine this rigorously is by using advanced mathematics — such
    as Galois theory, transcendental number theory, and algebraic geometry. These
    topics go far beyond what we, as applied scientists and engineers, typically learn
    in our training.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of diving into these advanced fields, we’ll cheat. Using **SymPy**,
    a Python-based computer algebra system, we’ll explore different classes of equations
    to see which it can solve with a closed-form expression. For completeness, we’ll
    also apply numerical methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore equations that combine polynomials, exponentials, logarithms,
    and trigonometric functions. Along the way, we’ll discover specific combinations
    that often resist closed-form solutions. We’ll see that if you want to create
    an equation **with** (or **without**) a closed-form solution, you should **avoid**
    (or **try**) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Fifth degree and higher polynomials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing *x* with exp(*x*) or log(*x*) — if Lambert’s *W* function is off-limits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining exp(*x*) and log(*x*) within the same equation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some pairs of trigonometric functions with commensurate frequencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many pairs of trigonometric functions with non-commensurate frequencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing trigonometric functions with *x*, exp(x), or log(x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aside 1: I’m not a mathematician, and my SymPy scripts are not higher mathematics.
    If you find any mistakes or overlooked resources, forgive my oversight. Please
    share them with me, and I’ll gladly add a note.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Aside 2: Welch Lab’s recent video, [Kepler’s Impossible Equation](https://www.youtube.com/watch?v=hBkmyJ3TE0g),
    reminded me of my frustration about not knowing when an equation can be solved
    in a closed form. The video sparked the investigation that follows and provides
    our first example.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kepler’s Equation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you are Johannes Kepler’s research programmer. He has created the following
    model of orbital motion:'
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = *x* −*c* sin(*x*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'where:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* is the body’s position along its orbit. We measure this position as an
    angle (in radians). The angle starts at 0 radians when the body is closest to
    the Sun. When the body has covered ¼ of its orbit’s distance, the angle is π/2
    radians (90°). When it has covered half of its orbit’s distance, the angle is
    π (180°), and so on. Recall that radians measure angles from 0 to 2π rather than
    from 0 to 360°.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*c* is the orbit’s eccentricity, ranging from 0 (a perfect circle) to just
    under 1 (a highly elongated ellipse). Suppose Kepler has observed a comet with
    c = 0.967.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*y* is the body’s time along its orbit. We measure this time as an angle (in
    radians). For instance, if the comet has an orbital period of 76 Earth years,
    then π/2 (90°) corresponds to ¼ of 76 years, or 19 years. A time of π (180°) corresponds
    to ½ of 76 years, or 38 years. A time of 2π (360°) is the full 76-year orbital
    period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This diagram shows the comet’s position at π/2 radians (90°), which is ¼ of
    the way along its orbit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9d4348de333abf529adc5317f2f0455f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Kepler asks for the time when the comet reaches position π/2 radians (90°).
    You create and run this Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You report back to Kepler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Aside: The comet covers 25% of its orbit distance in under 10% of its orbital
    period because it speeds up when closer to the Sun.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'No good deed goes unpunished. Kepler, fascinated by the result, assigns you
    a new task: “Can you tell me how far along its orbit the comet is after 20 Earth
    years? I want to know the position in radians.”'
  prefs: []
  type: TYPE_NORMAL
- en: “No problem,” you think. “I’ll just use a bit of high school algebra.”
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you convert 20 Earth years into radians:'
  prefs: []
  type: TYPE_NORMAL
- en: time_radians = (20 / 76) × 2π = (10 / 19)π
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you rearrange Kepler’s equation, setting it equal to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '*x* − 0.967 sin(*x*) − (10 / 19)π = 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now you want to find the value of *x* that makes this equation true. You decide
    to graph the equation to see where it crosses zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/cb926a0e01695cc42dae35835f1951cb.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, so good. The graph shows that a solution for *x* exists. But when you
    try to rearrange the equation to solve for *x* using algebra, you hit a wall.
    How do you isolate *x* when you have a combination of *x* and sin(*x*)?
  prefs: []
  type: TYPE_NORMAL
- en: “That’s okay,” you think. “We’ve got Python, and Python has the [SymPy package](https://www.sympy.org/),”
    a powerful and free computer algebra system.
  prefs: []
  type: TYPE_NORMAL
- en: 'You pose the problem to SymPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, it replies with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: SymPy is quite good at solving equations, but not all equations can be solved
    in what’s called **closed form** — a solution expressed in a finite number of
    **elementary functions** such as addition, multiplication, roots, exponentials,
    logarithms, and trigonometric functions. When we combine a term such as *x* with
    a trigonometric term like sin⁡(*x*), isolating *x* can become fundamentally impossible.
    In other words, these types of mixed equations often lack a closed-form solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s okay. From the graph, we know a solution exists. SymPy can get us arbitrarily
    close to that solution using numerical methods. We use SymPy’s `nsolve()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Which reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can summarize the results in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e3ef29a79ea4e43bbefffc9df2e89bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: Are we sure there is not a closed-form solution? We add a question mark to our
    “No” answer. This reminds us that SymPy’s failure is not a mathematical proof
    that no closed-form solution exists. We label the last column “**A** Numeric”
    to remind ourselves that it represents one numerical solution. There could be
    more.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored Kepler’s equation and discovered the challenge
    of solving it in closed form. Python’s SymPy package confirmed our struggle, and
    in the end, we had to rely on a numerical solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us one example of an equation with no apparent closed-form solution.
    But is this typical? Are there classes of equations where we can always — or never
    — find a closed-form solution? Let’s dig deeper by exploring another kind of equation:
    polynomials.'
  prefs: []
  type: TYPE_NORMAL
- en: Polynomials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Polynomial](https://en.wikipedia.org/wiki/Polynomial) equations such as *x*²
    − *x* − 1 = 0 are the reliable hammer of mathematical modeling — straightforward
    but powerful. We all learn how to solve degree-two polynomials (those with *x*²,
    “quadratic”) in school.'
  prefs: []
  type: TYPE_NORMAL
- en: 500 years ago, during the Renaissance in Italy, solving polynomials of higher
    degrees became a form of public entertainment. Mathematicians like Tartaglia and
    Cardano competed for glory and recognition in [public math duels](https://old.maa.org/press/maa-reviews/the-secret-formula-how-a-mathematical-duel-inflamed-renaissance-italy-and-uncovered-the-cubic).
    These contests led to solutions for degree-three (cubic) and degree-four (quartic)
    polynomials. But what about degree five?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use SymPy to investigate a sample of polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0f3e71215f730a7a7cffd72d197facf6.png)'
  prefs: []
  type: TYPE_IMG
- en: For polynomials up to degree four, we can always find closed-form elementary
    solutions. Specifically, these solutions require only a finite expression of basic
    arithmetic operations and roots (such as square roots or cube roots).
  prefs: []
  type: TYPE_NORMAL
- en: The number of solutions will never exceed the degree of the polynomial. However,
    some solutions may involve *i*, the square root of −1, which represents complex
    numbers. More on that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: And what about degree-five polynomials and beyond? Can we always find closed-form
    solutions? The answer is mixed. Sometimes, we can. When a closed-form solution
    exists — for example, for *x*⁵+1=0 above — SymPy typically finds it.
  prefs: []
  type: TYPE_NORMAL
- en: However, in other cases, such as with *x*⁵-*x*-1=0, SymPy cannot find a closed-form,
    elementary solution. Évariste Galois famously demonstrated the impossibility of
    closed-form solutions for general higher-degree polynomial. However, SymPy’s failure
    on a specific equation is not a proof that no closed-form solution exists. So,
    for this example, we add a question mark and answer “No?”.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore further, let’s see exactly what SymPy does when given *x*⁵-*x*-1=0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Yikes! SymPy is clearly cheating here. It’s saying, “Oh, you want a closed form?
    No problem! I’ll just define a new, one-off function called `CRootOf(x**5 - x
    - 1, 0)` and call that the answer.”
  prefs: []
  type: TYPE_NORMAL
- en: This is cheating because it doesn’t answer the question of interest. SymPy is
    essentially giving a new name to an unsolved problem and claiming success.
  prefs: []
  type: TYPE_NORMAL
- en: 'SymPy, of course, has good reasons for producing its answer this way. For one
    thing, we can now easily find a numerical solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Prints `1.16730397826142`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solutions Even When No Real Solutions Exist:** One surprising thing about
    polynomial equations is that you can always find solutions — at least numerically
    — even when no real solutions exist!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this simple equation of degree two:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*² + 1 = 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we plot this equation, it never crosses the *x*-axis, indicating no real
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/58fc36a03afc02e8aa37b6758d984eb1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, using SymPy, we can find numerical solutions for any polynomial. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Which prints: `[-1.0*I, 1.0*I]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the solutions use *i* (the imaginary unit), meaning they are complex
    numbers. This is an illustration of the [Fundamental Theorem of Algebra](https://en.wikipedia.org/wiki/Fundamental_theorem_of_algebra),
    which states that every (non-constant) polynomial equation has at least one complex
    solution, even when no real solutions exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The takeaway: unless complex numbers are meaningful in your domain, you should
    ignore complex solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Degree four and below**: There is always a closed-form solution involving
    basic arithmetic operations and roots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Degree five and above**: Generally, no closed-form solution exists using
    elementary operations, though SymPy occasionally finds one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solutions**: Polynomials will always have solutions — at least numerically
    — but these solutions may not be real (both mathematically and practically). You
    should typically ignore them unless complex numbers are meaningful in your domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we’ll add exponentials and logarithms to our equations. In the solutions,
    we discover the Lambert *W* function. Is it a CRootOf-like cheat?
  prefs: []
  type: TYPE_NORMAL
- en: Exp, Log and x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we model data mathematically, we often use exponentials and logarithms.
    Below is a sample of what happens when we try to reverse such models by solving
    their equations with SymPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6335c6c8cc5569c6cfff858a6b6b4634.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sometimes you get lucky**: The first equation *x*e*ˣ*=0 has an elementary
    solution *x*=0\. While this isn’t always the case, simple closed-form solutions
    can sometimes be found, even in equations involving exponentials or logarithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Every equation in this “family” appears to be solvable, with two caveats:**
    First, I can’t precisely define this family and am unsure if a clear definition
    is possible. Second, solving these equations requires the Lambert *W* function,
    such as *W(1)* and *W₋₁(1/10)*. This function arises when *x* appears both inside
    and outside of an exponential (or logarithmic) expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**If you don’t accept *W*, you can’t solve these functions in closed form**:
    Equations in this “family” generally have no closed-form elementary solutions
    without the Lambert *W* function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We should accept *W*:** The Lambert *W* function is a well-defined, easily
    computable function with applications across math and science. Its late adoption
    relative to *exp*, *log*, *sin*, and *cos* is simply historical.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A single *W* can generate multiple solutions**: Similar to how the square
    root function can produce two solutions, a *W* expression can yield zero, one,
    or two real solutions. When two real solutions exist, SymPy lists them separately,
    representing one as *W* (the principal branch) and the other as *W₋₁* (the secondary
    branch). Beyond the real solutions, any *W* expression also generates an infinite
    number of complex solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex solutions will arise**: Some equations, such as *x* log(*x*)+1=0,
    lead to only complex solutions. As with polynomials, you should ignore complex
    numbers unless they are meaningful in your domain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Degree-five and higher polynomials mixed with exp (or log) remain unsolvable**:
    Even with special functions like the Lambert *W* function, degree-five and higher
    polynomials cannot be solved in closed form using elementary functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What happens if we use both an exponential and a logarithm in the same equation?
    Generally, we won’t find a closed-form solution — not even with the Lambert *W*
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5829be0bc9a1cd84c0b62c9c3ce9049f.png)'
  prefs: []
  type: TYPE_IMG
- en: To summarize, combining exponentials or logarithms with polynomials typically
    makes the equation unsolvable by traditional closed-form methods. However, if
    we allow the Lambert *W* function, equations with exponentials or logarithms (but
    not both) become solvable. We should embrace *W* as a valid tool for handling
    such cases.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s generalize Kepler’s problem and see what happens when we introduce
    trigonometric functions into our equations.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometric Equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Simple Trigonometric Equations:** Here is our first batch of trigonometric
    samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4cd22357d32d194a39711f98d4d3e16e.png)'
  prefs: []
  type: TYPE_IMG
- en: SymPy successfully finds closed-form elementary solutions for each equation.
    The solutions involve trigonometric functions, and in some cases, complex numbers
    appear. (Again, we typically ignore the complex solutions unless they are meaningful
    for the problem at hand.)
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that sine and cosine are periodic, which leads to infinitely many
    solutions. The closed-form solutions that SymPy provides typically represent a
    single cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '**Commensurate Frequency Equations:** In the preceding equations, we limited
    the trigonometric function’s input to *x*+*b*, where *b* is a constant. What happens
    if we allow inputs like *a*₁*x*+*b*₁ and *a*₂*x*+*b*₂ where *a*₁ is rational and
    *a*₂ is rational? This means the two periodic functions may have different frequencies
    but those frequences can synchronize. (The *a*’s are the frequencies.) We say
    our trigonometric functions have “commensurate frequencies.”'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b94534cad076b5a3afdff21207d78ded.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Observations:'
  prefs: []
  type: TYPE_NORMAL
- en: We occasionally get a closed-form elementary solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On sin(*x*) + sin(3*x*)+1=0, SymPy returns zero solutions. Plots and numerical
    methods, however, suggest solutions exist. Moreover, when I input [sin(x) + sin(3x)+1=0
    into WolframAlpha](https://www.wolframalpha.com/input?i=sin%28x%29+%2B+sin%283x%29+%2B+1+%3D+0%2C+solve+for+x),
    an on-line computer algebra system, it produces hybrid solutions. (The WolframAlpha
    solutions combine elementary functions with **CRootOf** expressions of degree
    six. As we discussed in the polynomial section, such expressions generally lack
    a closed-form solution.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SymPy sometimes times out looking for a closed-form solution when numerical
    methods can still provide solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other cases, it times out, and both numerical methods and plots confirm there
    are no solutions. Before, instead of no numerical solution, we’d get a complex
    number solution. [WolframAlpha does give [a complex numerical solution](https://www.wolframalpha.com/input?i=sin%283x%29+*+sin%28x+%2B+1%29+%2B1+%3D+0%2C+solve+for+x).]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s plot the equation that returned zero closed-formed solutions. Let’s also
    plot the one that numerically returned `ValueError:`
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8d65d0f9096833b9596b900a53b9acf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Additional Observations:'
  prefs: []
  type: TYPE_NORMAL
- en: From the blue plot, SymPy’s response of “no solutions” appears to be a bug.
    There are clearly solutions in the plot, and SymPy should either have found them
    or thrown an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, in the red plot, the numerical result of `ValueError` is
    accurate. There are no solutions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all the trigonometric equations we’ve encountered so far, SymPy seems to
    find real-valued closed-form solutions when they exist. When they don’t exist,
    it times out or gives unpredictable errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-Commensurate Frequency Equations:** In the preceding equations, we allowed
    trigonometric functions with inputs of the form *ax*+*b*​, where *a*​ is a rational
    constant. What happens if we allow inputs like *a*₁*x*+*b*₁ and *a*₂*x*+*b*₂ where
    *a*₁ is rational and *a*₂ is irrational? This means the two periodic functions
    will never synchronize. We say they have “non-commensurate frequencies.”'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8040ccb39120f11492d4509551c293aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Observations:'
  prefs: []
  type: TYPE_NORMAL
- en: Equations with two trigonometric functions having non-commensurate frequencies
    generally seem unsolvable in closed form. When no elementary solution is available,
    SymPy returns `NotImplementedError.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can still get lucky and occasionally find an equation with an elementary
    solution. In the case above, in which SymPy returned `PolynomialDivisionFailed`,
    [WolframAlpha found a closed-form solution](https://www.wolframalpha.com/input?i=sin%28sqrt%283%29*x%29+%2B+sin%28x%2B1%29%3D+0%2C+solve+for+x).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an equation has no solutions, SymPy produces a `ValueError`, which we can
    confirm through plots (see below). We did not see complex-number results in these
    cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/f8314a07ca7e67d95fc55e8deb6699b6.png)'
  prefs: []
  type: TYPE_IMG
- en: The equations do not quite touch zero, so no solutions
  prefs: []
  type: TYPE_NORMAL
- en: Our conclusion regarding trigonometric equations is that we can often find elementary
    closed-form solutions. The main exception seems to be when the frequencies are
    non-commensurate — for example, in an equation containing sin(*x*) and sin⁡(√3
    *x*).
  prefs: []
  type: TYPE_NORMAL
- en: The final question we’ll explore is what happens when we mix trigonometric functions
    with exponentials and logarithms.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometric and x, Exp, Log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our final set of samples will require only a short discussion. What if we run
    a sample of equations through SymPy, each equation containing one trigonometric
    function combined with either *x*, exp(*x*), or log(*x*)?
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/80176233339aefc1eed8143e46e7479b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The results are unanimous: SymPy is unable to produce closed-form solutions
    for any of these combinations. However, it seems that SymPy should have produced
    *x*=0 as the closed-form solution for the first equation, as indeed [WolframAlpha
    does](https://www.wolframalpha.com/input?i=x%2Bsin%28x%29%3D0%2C+solve).'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, there you have it — an exploration of which equations tend to lack closed-form
    solutions. If you’re interested in experimenting with the examples in this article,
    you can find my [Python code on GitHub](https://github.com/CarlKCarlK/unsolvable).
  prefs: []
  type: TYPE_NORMAL
- en: 'As I worked through these sample equations, here is what surprised me:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kepler’s Equation is wonderfully simple.** I didn’t know one could model
    anellipse — a geometric shape I find complicated — with such elegance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lambert’s *W* function** proved to be invaluable for handling equations that
    mix terms like *x* and exp⁡(*x*). We should consider it an elementary function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SymPy** is an excellent, free tool that handles symbolic algebra and trigonometric
    equations far better than many of us could handle manually. While it may not match
    WolframAlpha in some cases, it’s incredibly versatile and accessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixing trigonometric functions** with other terms frequently prevents closed-form
    solutions, especially when frequencies are non-commensurate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When closed-form solutions remain out of reach, **plotting and numerical methods**
    step in, delivering practical results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thank you for joining me on this journey. I hope you now have a clearer understanding
    of when you can use equation-solving techniques to reverse models and how much
    SymPy can assist. Also, when an equation resists a closed-form solution, you can
    now understand why and when to rely on numerical methods.
  prefs: []
  type: TYPE_NORMAL
- en: If you enjoyed exploring **mathematics** with Python and SymPy, you may also
    enjoy using them to explore **Newtonian physics**. Please see this[Towards Data
    Science article](https://medium.com/towards-data-science/perfect-infinite-precision-game-physics-in-python-part-1-698211c08d95)
    and the related, popular [PyData conference talk](https://www.youtube.com/watch?v=52n2qKgwW_Q).
  prefs: []
  type: TYPE_NORMAL
- en: '*Interested in future articles? Please* [*follow me on Medium*](https://medium.com/@carlmkadie)*.
    I write about Rust and Python, scientific programming, machine learning, and statistics.
    I tend to write about one article per month.*'
  prefs: []
  type: TYPE_NORMAL

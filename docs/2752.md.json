["```py\ndo i, n\n  a(i) = b(i) + c(i)\n  d(i) = e(i) + f(i)\nend do\n```", "```py\nb:  | b(i) | b(i+1) | b(i+2) | b(i+3) | ... |\nc:  | c(i) | c(i+1) | c(i+2) | c(i+3) | ... |\n------------------------------------------------\n           Vectorized Addition (SIMD)\n\nVector Register 1 (loaded with b values):\n      | b(i)   | b(i+1) | b(i+2) | b(i+3) | ... |\n\nVector Register 2 (loaded with c values):\n      | c(i)   | c(i+1) | c(i+2) | c(i+3) | ... |\n\n------------------------------------------------\nResult in Vector Register 3:\n      | a(i)   | a(i+1) | a(i+2) | a(i+3) | ... |\n```", "```py\ndo i, n\n  a(i) = a(i-1) +b(i)\n```", "```py\ndo i, n\n  a(i) = a(i+1) +b(i)\n```", "```py\ndo i, n\n  a(i%2) = a(i+1) +b(i)\n```", "```py\ndo i, n\n  a(i) = b(i%2) + c(i)\n```", "```py\nfor (element=0; element<n; ++element){\n  total = 0;\n  for(qp = 0; qp < numQPs; ++qp){\n    total += dot(left[element][qp], right[element][qp]);\n  } \n  elementValues[element] = total;\n}\n```", "```py\n // ENABLE_CUDA is a compile time argument with default value true\n    #define ENABLE_CUDA true\n\n    // If CUDA is enabled, run the kernel on the CUDA (GPU) architecture\n    #if defined(ENABLE_CUDA) && ENABLE_CUDA\n        #define MemSpace Kokkos::CudaSpace\n        #define Layout Kokkos::LayoutLeft\n    #else\n    // Define default values or behavior when ENABLE_CUDA is not set or is false\n        #define MemSpace Kokkos::HostSpace\n        #define Layout Kokkos::LayoutRight\n    #endif\n```", "```py\n // View for a 2d array of data type double\n    Kokkos::View<double**> myView(\"myView\", numRows, numCols);\n    // Access Views\n    myView(i, j) = 42.0; \n    double value = myView(i, j);\n```", "```py\n // Intended Computation -\n    // <y, A*x> = y^T * A * x\n    // Here:\n    // y and x are vectors.\n    // A is a matrix.\n\n    // Allocate y, x vectors and Matrix A on device\n    typedef Kokkos::View<double*, Layout, MemSpace>   ViewVectorType;\n    typedef Kokkos::View<double**, Layout, MemSpace>  ViewMatrixType;\n\n    // N and M are number of rows and columns\n    ViewVectorType y( \"y\", N );\n    ViewVectorType x( \"x\", M );\n    ViewMatrixType A( \"A\", N, M );\n\n    // Create host mirrors of device views\n    ViewVectorType::HostMirror h_y = Kokkos::create_mirror_view( y );\n    ViewVectorType::HostMirror h_x = Kokkos::create_mirror_view( x );\n    ViewMatrixType::HostMirror h_A = Kokkos::create_mirror_view( A );\n\n    // Initialize y vector on host.\n    for ( int i = 0; i < N; ++i ) {\n        h_y( i ) = 1;\n    }\n\n    // Initialize x vector on host.\n    for ( int i = 0; i < M; ++i ) {\n        h_x( i ) = 1;\n    }\n\n    // Initialize A matrix on host.\n    for ( int j = 0; j < N; ++j ) {\n        for ( int i = 0; i < M; ++i ) {\n            h_A( j, i ) = 1;\n        }\n    }\n\n    // Deep copy host views to device views.\n    Kokkos::deep_copy( y, h_y );\n    Kokkos::deep_copy( x, h_x );\n    Kokkos::deep_copy( A, h_A );\n```", "```py\n // Execution space determined based on MemorySpace\nusing ExecSpace = MemSpace::execution_space;\n```", "```py\n<y, A*x> = y^T * (A * x)\n\nHere:\n\ny and x are vectors.\n\nA is a matrix.\n\n<y, A*x> represents the inner product or dot product of vectors y \nand the result of the matrix-vector multiplication A*x.\n\ny^T denotes the transpose of vector y.\n\n* denotes matrix-vector multiplication.\n```", "```py\n // Use a RangePolicy.\n    typedef Kokkos::RangePolicy<ExecSpace>  range_policy;\n\n    // The below code is run for multiple iterations across different \n    // architectures for time comparison\n    Kokkos::parallel_reduce( \"yAx\", range_policy( 0, N ),\n                KOKKOS_LAMBDA ( int j, double &update ) {\n                    double temp2 = 0;\n\n                    for ( int i = 0; i < M; ++i ) {\n                        temp2 += A( j, i ) * x( i );\n                    }\n                    update += y( j ) * temp2;\n            }, result );\n```"]
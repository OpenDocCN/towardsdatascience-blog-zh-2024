["```py\nclass Model:\n    def __call__(self, input):\n        \"\"\"The forward call of the model.\n\n        Args:\n          input: A tensor. The input to the model.\n        \"\"\"\n        pass\n```", "```py\ninput = keras.Input(shape=(10,))\nx = layers.Dense(32, activation='relu')(input)\noutput = layers.Dense(10, activation='softmax')(x)\nmodel = keras.models.Model(inputs=input, outputs=output)\nmodel.compile(\n    optimizer='adam', loss='categorical_crossentropy'\n)\n```", "```py\nclass RandomSearch:\n    def __init__(self, ..., metrics, objective=\"val_loss\", ...):\n        \"\"\"The initializer.\n\n        Args:\n            metrics: A list of Keras metrics.\n            objective: String or a custom metric function. The\n                name of the metirc we want to minimize.\n        \"\"\"\n        pass\n```", "```py\ntuner = RandomSearch(\n    ...,\n    metrics=[custom_metric],\n    objective=\"val_???\",\n)\n```", "```py\ndef custom_metric(y_true, y_pred):\n    squared_diff = ops.square(y_true - y_pred)\n    return ops.mean(squared_diff, axis=-1)\n```", "```py\nclass MyHyperModel(HyperModel):\n    def fit(self, trial, model, validation_data):\n        x_val, y_true = validation_data\n        y_pred = model(x_val)\n        return custom_metric(y_true, y_pred)\n\ntuner = RandomSearch(MyHyperModel(), max_trials=20)\n```", "```py\nmodel = keras.Sequential([\n    layers.Dense(10, activation=\"relu\"),\n    layers.Dense(num_classes, activation=\"softmax\"),\n])\nmodel.compile(loss='categorical_crossentropy')\nmodel.fit(...)\nmodel.predict(...)\n```", "```py\nclass MyModel(nn.Module):\n    def forward(self, x):\n        if x.sum() > 0:\n            return self.path_a(x)\n        return self.path_b(x)\n```", "```py\nclass MyModel(keras.Model):\n    def call(self, inputs):\n        return ops.cond(\n            ops.sum(inputs) > 0,\n            lambda : self.path_a(inputs),\n            lambda : self.path_b(inputs),\n        )\n```", "```py\ntorch.relu(x, inplace=True)\nx = torch._foreach_add(x, y)\ntorch._foreach_add_(x, y)\nx = x.cuda()\n```", "```py\nimport torch.nn.functional as F\n# pad the 32x32 images to (1+32+1)x(2+32+2)\n# (100, 3, 32, 32) to (100, 3, 34, 36)\nout = F.pad(\n    torch.empty(100, 3, 32, 32),\n    pad=???,\n)\n```", "```py\nvalue = True\n\n@tf.function\ndef get_value():\n    return value\n\nvalue = False\nprint(get_value())\n```", "```py\nx = x.add(y)\nx.add_(y)\nx = x.mul(y)\nx.mul_(y)\n```", "```py\nfrom keras import layers\n\nlayers.MaxPooling2D()\nlayers.GlobalMaxPooling1D()\nlayers.GlobalAveragePooling3D()\n```", "```py\n# Bad example:\nraise ValueError(\"Tensor shape mismatch.\")\n\n# Good example:\nraise ValueError(\n    \"Tensor shape mismatch. \"\n    \"Expected: (batch, num_features). \"\n    f\"Received: {x.shape}\"\n)\n```", "```py\nimport math\n\nmath.sqr(4)\n\"AttributeError: module 'math' has no attribute 'sqr'. Did you mean: 'sqrt'?\"\n```"]
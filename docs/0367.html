<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Nine Rules for Accessing Cloud Files from Your Rust Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Nine Rules for Accessing Cloud Files from Your Rust Code</h1>
<blockquote>ÂéüÊñáÔºö<a href="https://towardsdatascience.com/nine-rules-for-accessing-cloud-files-from-your-rust-code-d456c1e2ceb4?source=collection_archive---------7-----------------------#2024-02-07">https://towardsdatascience.com/nine-rules-for-accessing-cloud-files-from-your-rust-code-d456c1e2ceb4?source=collection_archive---------7-----------------------#2024-02-07</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="0a0c" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Practical Lessons from Upgrading Bed-Reader, a Bioinformatics Library</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@carlmkadie?source=post_page---byline--d456c1e2ceb4--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Carl M. Kadie" class="l ep by dd de cx" src="../Images/9dbe27c76e9567136e5a7dc587f1fb15.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*RGViuuvF-_GQ-LXuVDQN7w.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--d456c1e2ceb4--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@carlmkadie?source=post_page---byline--d456c1e2ceb4--------------------------------" rel="noopener follow">Carl M. Kadie</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">¬∑</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--d456c1e2ceb4--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">¬∑</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">21 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">¬∑</span></span></div><span data-testid="storyPublishDate">Feb 7, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj la lb ab q ee lc ld" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="le"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lf k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lg an ao ap id lh li lj" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lk cn"><div class="l ae"><div class="ab cb"><div class="ll lm ln lo lp lq ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mi mj mk ml mm mn mo mp paragraph-image"><div class="ab cn cb mq"><img src="../Images/1e411080a4ed67bba652ec6626318f0e.png" data-original-src="https://miro.medium.com/v2/format:webp/1*iUGjk-QBLCHh_cakb5Z1bw.png"/></div><figcaption class="ms mt mu mo mp mv mw bf b bg z dx">Rust and Python reading DNA data directly from the cloud ‚Äî Source: <a class="af mx" href="https://openai.com/dall-e-2/" rel="noopener ugc nofollow" target="_blank">https://openai.com/dall-e-2/</a>. All other figures from the author.</figcaption></figure><p id="7fed" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Would you like your Rust program to seamlessly access data from files in the cloud? When I refer to ‚Äúfiles in the cloud,‚Äù I mean data housed on web servers or within cloud storage solutions like AWS S3, Azure Blob Storage, or Google Cloud Storage. The term ‚Äúread‚Äù, here, encompasses both the sequential retrieval of file contents ‚Äî be they text or binary, from beginning to end ‚Äîand the capability to pinpoint and extract specific sections of the file as needed.</p><p id="be37" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Upgrading your program to access cloud files can reduce annoyance and complication: the annoyance of downloading to local storage and the complication of periodically checking that a local copy is up to date.</p><p id="0908" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Sadly, upgrading your program to access cloud files can also <em class="nu">increase </em>annoyance and complication: the annoyance of URLs and credential information, and the complication of asynchronous programming.</p><p id="c31d" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk"><a class="af mx" href="https://github.com/fastlmm/bed-reader" rel="noopener ugc nofollow" target="_blank">Bed-Reader</a> is a Python package and Rust crate for reading PLINK Bed Files, a binary format used in bioinformatics to store genotype (DNA) data. At a user‚Äôs request, I recently updated Bed-Reader to optionally read data directly from cloud storage. Along the way, I learned nine rules that can help you add cloud-file support to your programs. The rules are:</p><ol class=""><li id="ae90" class="my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt nv nw nx bk">Use crate <code class="cx ny nz oa ob b"><a class="af mx" href="https://crates.io/crates/object_store" rel="noopener ugc nofollow" target="_blank">object_store</a></code> (and, perhaps, <code class="cx ny nz oa ob b"><a class="af mx" href="https://crates.io/crates/cloud-file" rel="noopener ugc nofollow" target="_blank">cloud-file</a></code>) to sequentially read the bytes of a cloud file.</li><li id="d62e" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt nv nw nx bk">Sequentially read text lines from cloud files via two nested loops.</li><li id="14e2" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt nv nw nx bk">Randomly access cloud files, even giant ones, with ‚Äúrange‚Äù methods, while respecting server-imposed limits.</li><li id="5d0d" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt nv nw nx bk">Use URL strings and option strings to access HTTP, Local Files, AWS S3, Azure, and Google Cloud.</li><li id="9378" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt nv nw nx bk">Test via <code class="cx ny nz oa ob b"><a class="af mx" href="https://crates.io/crates/tokio" rel="noopener ugc nofollow" target="_blank">tokio</a>::test</code> on http and local files.</li></ol><p id="e588" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk"><em class="nu">If other programs call your program ‚Äî in other words, if your program offers an API (application program interface) ‚Äî four additional rules apply:</em></p><p id="a033" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">6. For maximum performance, add cloud-file support to your Rust library via an async API.</p><p id="4fe0" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">7. Alternatively, for maximum convenience, add cloud-file support to your Rust library via a traditional (‚Äúsynchronous‚Äù) API.</p><p id="3b59" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">8. Follow the rules of good API design in part by using hidden lines in your doc tests.</p><p id="22a5" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">9. Include a runtime, but optionally.</p><blockquote class="oh oi oj"><p id="22a6" class="my mz nu na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Aside: To avoid wishy-washiness, I call these ‚Äúrules‚Äù, but they are, of course, just suggestions.</p></blockquote><h1 id="e801" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Rule 1: Use crate <code class="cx ny nz oa ob b">object_store</code> (and, perhaps, <code class="cx ny nz oa ob b">cloud-file</code>) to sequentially read the bytes of a cloud file.</h1><p id="1db0" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">The powerful <code class="cx ny nz oa ob b"><a class="af mx" href="https://crates.io/crates/object_store" rel="noopener ugc nofollow" target="_blank">object_store</a></code> crate provides full content access to files stored on http, AWS S3, Azure, Google Cloud, and local files. It is part of the <a class="af mx" href="https://arrow.apache.org/" rel="noopener ugc nofollow" target="_blank">Apache Arrow</a> project and has over 2.4 million downloads.</p><p id="12d1" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">For this article, I also created a new crate called <code class="cx ny nz oa ob b"><a class="af mx" href="https://crates.io/crates/cloud-file" rel="noopener ugc nofollow" target="_blank">cloud-file</a></code>. It simplifies the use of the <code class="cx ny nz oa ob b">object_store</code> crate. It wraps and focuses on a useful subset of <code class="cx ny nz oa ob b">object_store</code>‚Äôs features. You can either use it directly, or pull-out its code for your own use.</p><p id="b64e" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Let‚Äôs look at an example. We‚Äôll count the lines of a cloud file by counting the number of newline characters it contains.</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="3686" class="po ol fq ob b bg pp pq l pr ps">use cloud_file::{CloudFile, CloudFileError};<br/>use futures_util::StreamExt; // Enables `.next()` on streams.<br/><br/>async fn count_lines(cloud_file: &amp;CloudFile) -&gt; Result&lt;usize, CloudFileError&gt; {<br/>    let mut chunks = cloud_file.stream_chunks().await?;<br/>    let mut newline_count: usize = 0;<br/>    while let Some(chunk) = chunks.next().await {<br/>        let chunk = chunk?;<br/>        newline_count += bytecount::count(&amp;chunk, b'\n');<br/>    }<br/>    Ok(newline_count)<br/>}<br/><br/>#[tokio::main]<br/>async fn main() -&gt; Result&lt;(), CloudFileError&gt; {<br/>    let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/toydata.5chrom.fam";<br/>    let options = [("timeout", "10s")];<br/>    let cloud_file = CloudFile::new_with_options(url, options)?;<br/>    let line_count = count_lines(&amp;cloud_file).await?;<br/>    println!("line_count: {line_count}");<br/>    Ok(())<br/>}</span></pre><p id="5a6f" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">When we run this code, it returns:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="df1d" class="po ol fq ob b bg pp pq l pr ps">line_count: 500</span></pre><p id="6edf" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Some points of interest:</p><ul class=""><li id="2b4b" class="my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt pt nw nx bk">We use <code class="cx ny nz oa ob b">async</code> (and, here, <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/tokio/latest/tokio/" rel="noopener ugc nofollow" target="_blank">tokio</a></code>). We‚Äôll discuss this choice more in Rules 6 and 7.</li><li id="f34b" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">We turn a URL string and string options into a <code class="cx ny nz oa ob b">CloudFile</code> instance with <code class="cx ny nz oa ob b">CloudFile::new_with_options(url, options)?</code>. We use <code class="cx ny nz oa ob b">?</code> to catch malformed URLs).</li><li id="46de" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">We create a stream of binary chunks with <code class="cx ny nz oa ob b">cloud_file.stream_chunks().await?</code>. This is the first place that the code tries to access the cloud file. If the file doesn‚Äôt exist or we can‚Äôt open it, the <code class="cx ny nz oa ob b">?</code> will return an error.</li><li id="0812" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">We use <code class="cx ny nz oa ob b">chunks.next().await</code> to retrieve the file‚Äôs next binary chunk. (Note the <code class="cx ny nz oa ob b">use futures_util::StreamExt;</code>.) The <code class="cx ny nz oa ob b">next</code> method returns <code class="cx ny nz oa ob b">None</code> after all chunks have been retrieved.</li><li id="716b" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">What if there <em class="nu">is</em> a next chunk but also a problem retrieving it? We‚Äôll catch any problem with <code class="cx ny nz oa ob b">let chunk = chunk?;</code>.</li><li id="b54c" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">Finally, we use the fast <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/bytecount/latest/bytecount/" rel="noopener ugc nofollow" target="_blank">bytecount</a></code> crate to count newline characters.</li></ul><p id="032d" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">In contrast with this cloud solution, think about how you would write a simple line counter for a local file. You might write this:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="3980" class="po ol fq ob b bg pp pq l pr ps">use std::fs::File;<br/>use std::io::{self, BufRead, BufReader};<br/><br/>fn main() -&gt; io::Result&lt;()&gt; {<br/>    let path = "examples/line_counts_local.rs";<br/>    let reader = BufReader::new(File::open(path)?);<br/>    let mut line_count = 0;<br/>    for line in reader.lines() {<br/>        let _line = line?;<br/>        line_count += 1;<br/>    }<br/>    println!("line_count: {line_count}");<br/>    Ok(())<br/>}</span></pre><p id="048a" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Between the cloud-file version and the local-file version, three differences stand out. First, we can easily read local files as text. By default, we read cloud files as binary (but see Rule 2). Second, by default, we read local files synchronously, blocking program execution until completion. On the other hand, we usually access cloud files asynchronously, allowing other parts of the program to continue running while waiting for the relatively slow network access to complete. Third, iterators such as <code class="cx ny nz oa ob b">lines()</code> support <code class="cx ny nz oa ob b">for</code>. However, streams such as <code class="cx ny nz oa ob b">stream_chunks()</code> do not, so we use <code class="cx ny nz oa ob b">while let</code>.</p><p id="48c0" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">I mentioned earlier that you didn‚Äôt need to use the <code class="cx ny nz oa ob b">cloud-file</code> wrapper and that you could use the <code class="cx ny nz oa ob b">object_store</code> crate directly. Let‚Äôs see what it looks like when we count the newlines in a cloud file using only <code class="cx ny nz oa ob b">object_store</code> methods:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="f13f" class="po ol fq ob b bg pp pq l pr ps">use futures_util::StreamExt;  // Enables `.next()` on streams.<br/>pub use object_store::path::Path as StorePath;<br/>use object_store::{parse_url_opts, ObjectStore};<br/>use std::sync::Arc;<br/>use url::Url;<br/><br/>async fn count_lines(<br/>    object_store: &amp;Arc&lt;Box&lt;dyn ObjectStore&gt;&gt;,<br/>    store_path: StorePath,<br/>) -&gt; Result&lt;usize, anyhow::Error&gt; {<br/>    let mut chunks = object_store.get(&amp;store_path).await?.into_stream();<br/>    let mut newline_count: usize = 0;<br/>    while let Some(chunk) = chunks.next().await {<br/>        let chunk = chunk?;<br/>        newline_count += bytecount::count(&amp;chunk, b'\n');<br/>    }<br/>    Ok(newline_count)<br/>}<br/><br/>#[tokio::main]<br/>async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {<br/>    let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/toydata.5chrom.fam";<br/>    let options = [("timeout", "10s")];<br/><br/>    let url = Url::parse(url)?;<br/>    let (object_store, store_path) = parse_url_opts(&amp;url, options)?;<br/>    let object_store = Arc::new(object_store); // enables cloning and borrowing<br/>    let line_count = count_lines(&amp;object_store, store_path).await?;<br/>    println!("line_count: {line_count}");<br/>    Ok(())<br/>}</span></pre><p id="30e6" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">You‚Äôll see the code is very similar to the <code class="cx ny nz oa ob b">cloud-file</code> code. The differences are:</p><ul class=""><li id="9894" class="my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt pt nw nx bk">Instead of one <code class="cx ny nz oa ob b">CloudFile</code> input, most methods take two inputs: an <code class="cx ny nz oa ob b">ObjectStore</code> and a <code class="cx ny nz oa ob b">StorePath</code>. Because <code class="cx ny nz oa ob b">ObjectStore</code> is a non-cloneable trait, here the <code class="cx ny nz oa ob b">count_lines</code> function specifically uses <code class="cx ny nz oa ob b">&amp;Arc&lt;Box&lt;dyn ObjectStore&gt;&gt;</code>. Alternatively, we could make the function generic and use<code class="cx ny nz oa ob b"> &amp;Arc&lt;impl ObjectStore&gt;</code>.</li><li id="2d01" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">Creating the <code class="cx ny nz oa ob b">ObjectStore</code> instance, the <code class="cx ny nz oa ob b">StorePath</code> instance, and the stream requires a few extra steps compared to creating a <code class="cx ny nz oa ob b">CloudFile</code> instance and a stream.</li><li id="32e8" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">Instead of dealing with one error type (namely, <code class="cx ny nz oa ob b">CloudFileError</code>), multiple error types are possible, so we fall back to using the <code class="cx ny nz oa ob b"><a class="af mx" href="https://crates.io/crates/anyhow" rel="noopener ugc nofollow" target="_blank">anyhow</a></code> crate.</li></ul><p id="139f" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Whether you use <code class="cx ny nz oa ob b">object_store</code> (with 2.4 million downloads) directly or indirectly via <code class="cx ny nz oa ob b">cloud-file</code> (currently, with 124 downloads üòÄ), is up to you.</p><p id="854f" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">For the rest of this article, I‚Äôll focus on <code class="cx ny nz oa ob b">cloud-file</code>. If you want to translate a <code class="cx ny nz oa ob b">cloud-file</code> method into pure <code class="cx ny nz oa ob b">object_store</code> code, look up the cloud-file<a class="af mx" href="https://docs.rs/cloud-file" rel="noopener ugc nofollow" target="_blank"> method‚Äôs documentation</a> and follow the "source" link. The source is usually only a line or two.</p><p id="4836" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">We‚Äôve seen how to sequentially read the bytes of a cloud file. Let‚Äôs look next at sequentially reading its lines.</p><h1 id="9506" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Rule 2: Sequentially read text lines from cloud files via two nested loops.</h1><p id="d544" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">We often want to sequentially read the lines of a cloud file. To do that with <code class="cx ny nz oa ob b">cloud-file</code> (or <code class="cx ny nz oa ob b">object_store</code>) requires two nested loops.</p><p id="0149" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">The outer loop yields binary chunks, as before, but with a key modification: we now ensure that each chunk only contains complete lines, starting from the first character of a line and ending with a newline character. In other words, chunks may consist of one or more complete lines but no partial lines. The inner loop turns the chunk into text and iterates over the resultant one or more lines.</p><p id="b60c" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">In this example, given a cloud file and a number <em class="nu">n</em>, we find the line at index position <em class="nu">n</em>:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="f091" class="po ol fq ob b bg pp pq l pr ps">use cloud_file::CloudFile;<br/>use futures::StreamExt;  // Enables `.next()` on streams.<br/>use std::str::from_utf8;<br/><br/>async fn nth_line(cloud_file: &amp;CloudFile, n: usize) -&gt; Result&lt;String, anyhow::Error&gt; {<br/>    // Each binary line_chunk contains one or more lines, that is, each chunk ends with a newline.<br/>    let mut line_chunks = cloud_file.stream_line_chunks().await?;<br/>    let mut index_iter = 0usize..;<br/>    while let Some(line_chunk) = line_chunks.next().await {<br/>        let line_chunk = line_chunk?;<br/>        let lines = from_utf8(&amp;line_chunk)?.lines();<br/>        for line in lines {<br/>            let index = index_iter.next().unwrap(); // safe because we know the iterator is infinite<br/>            if index == n {<br/>                return Ok(line.to_string());<br/>            }<br/>        }<br/>    }<br/>    Err(anyhow::anyhow!("Not enough lines in the file"))<br/>}<br/><br/>#[tokio::main]<br/>async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {<br/>    let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/toydata.5chrom.fam";<br/>    let n = 4;<br/><br/>    let cloud_file = CloudFile::new(url)?;<br/>    let line = nth_line(&amp;cloud_file, n).await?;<br/>    println!("line at index {n}: {line}");<br/>    Ok(())<br/>}</span></pre><p id="3f06" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">The code prints:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="a226" class="po ol fq ob b bg pp pq l pr ps">line at index 4: per4 per4 0 0 2 0.452591</span></pre><p id="7044" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Some points of interest:</p><ul class=""><li id="0f48" class="my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt pt nw nx bk">The key method is <code class="cx ny nz oa ob b">.stream_line_chunks()</code>.</li><li id="caa9" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">We must also call <code class="cx ny nz oa ob b">std::str::from_utf8</code> to create text. (Possibly returning a <code class="cx ny nz oa ob b"><a class="af mx" href="https://doc.rust-lang.org/std/str/struct.Utf8Error.html" rel="noopener ugc nofollow" target="_blank">Utf8Error</a></code>.) Also, we call the <code class="cx ny nz oa ob b">.lines()</code> method to create an iterator of lines.</li><li id="bf94" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">If we want a line index, we must make it ourselves. Here we use:</li></ul><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="b589" class="po ol fq ob b bg pp pq l pr ps">let mut index_iter = 0usize..;<br/>...<br/>let index = index_iter.next().unwrap(); // safe because we know the iterator is infinite</span></pre><blockquote class="oh oi oj"><p id="fa0b" class="my mz nu na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Aside: Why two loops? Why doesn‚Äôt <code class="cx ny nz oa ob b">cloud-file</code> define a new stream that returns one line at a time? Because I don‚Äôt know how. If anyone can figure it out, please send me a pull request with the solution!</p></blockquote><p id="0bfb" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">I wish this was simpler. I‚Äôm happy it is efficient. Let‚Äôs return to simplicity by next look at randomly accessing cloud files.</p><h1 id="6aca" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Rule 3: Randomly access cloud files, even giant ones, with range methods, while respecting server-imposed limits.</h1><p id="0865" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">I work with a genomics file format called PLINK Bed 1.9. Files can be as large as 1 TB. Too big for web access? Not necessarily. We sometimes only need a fraction of the file. Moreover, modern cloud services (including most web servers) can efficiently retrieve regions of interest from a cloud file.</p><p id="51d8" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Let‚Äôs look at an example. This test code uses a <code class="cx ny nz oa ob b">CloudFile</code> method called <code class="cx ny nz oa ob b">read_range_and_file_size</code> It reads a *.bed file‚Äôs first 3 bytes, checks that the file starts with the expected bytes, and then checks for the expected length.</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="f3b9" class="po ol fq ob b bg pp pq l pr ps">#[tokio::test]<br/>async fn check_file_signature() -&gt; Result&lt;(), CloudFileError&gt; {<br/>    let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/plink_sim_10s_100v_10pmiss.bed";<br/>    let cloud_file = CloudFile::new(url)?;<br/>    let (bytes, size) = cloud_file.read_range_and_file_size(0..3).await?;<br/><br/>    assert_eq!(bytes.len(), 3);<br/>    assert_eq!(bytes[0], 0x6c);<br/>    assert_eq!(bytes[1], 0x1b);<br/>    assert_eq!(bytes[2], 0x01);<br/>    assert_eq!(size, 303);<br/>    Ok(())<br/>}</span></pre><p id="48bd" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Notice that in one web call, this method returns not just the bytes requested, but also the size of the whole file.</p><p id="1d06" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Here is a list of high-level <code class="cx ny nz oa ob b">CloudFile</code> methods and what they can retrieve in one web call:</p><ul class=""><li id="baf4" class="my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt pt nw nx bk"><code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_all" rel="noopener ugc nofollow" target="_blank">read_all</a></code> ‚Äî Whole file contents as an in-memory <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/bytes/latest/bytes/struct.Bytes.html" rel="noopener ugc nofollow" target="_blank">Bytes</a></code></li><li id="809c" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk"><code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_range" rel="noopener ugc nofollow" target="_blank">read_range</a></code> ‚Äî <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/bytes/latest/bytes/struct.Bytes.html" rel="noopener ugc nofollow" target="_blank">Bytes</a></code> from a specified range</li><li id="0715" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk"><code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_ranges" rel="noopener ugc nofollow" target="_blank">read_ranges</a></code> ‚Äî <code class="cx ny nz oa ob b">Vec</code> of <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/bytes/latest/bytes/struct.Bytes.html" rel="noopener ugc nofollow" target="_blank">Bytes</a></code> from specified ranges</li><li id="0e47" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk"><code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_range_and_file_size" rel="noopener ugc nofollow" target="_blank">read_range_and_file_size</a></code> ‚Äî <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/bytes/latest/bytes/struct.Bytes.html" rel="noopener ugc nofollow" target="_blank">Bytes</a></code> from a specified range &amp; the file‚Äôs size</li><li id="17e9" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk"><code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_file_size" rel="noopener ugc nofollow" target="_blank">read_file_size</a></code> ‚Äî Size of the file</li></ul><p id="3170" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">These methods can run into two problems if we ask for too much data at a time. First, our cloud service may limit the number of bytes we can retrieve in one call. Second, we may get faster results by making multiple simultaneous requests rather than just one at a time.</p><p id="d32d" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Consider this example: We want to gather statistics on the frequency of adjacent ASCII characters in a file of any size. For example, in a random sample of 10,000 adjacent characters, perhaps ‚Äúth‚Äù appears 171 times.</p><p id="b13b" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Suppose our web server is happy with 10 concurrent requests but only wants us to retrieve 750 bytes per call. (8 MB would be a more normal limit).</p><blockquote class="oh oi oj"><p id="feef" class="my mz nu na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Thanks to Ben Lichtman (B3NNY) at the Seattle Rust Meetup for pointing me in the right direction on adding limits to async streams.</p></blockquote><p id="41f8" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Our main function could look like this:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="3c99" class="po ol fq ob b bg pp pq l pr ps">#[tokio::main]<br/>async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {<br/>    let url = "https://www.gutenberg.org/cache/epub/100/pg100.txt";<br/>    let options = [("timeout", "30s")];<br/>    let cloud_file = CloudFile::new_with_options(url, options)?;<br/><br/>    let seed = Some(0u64);<br/>    let sample_count = 10_000;<br/>    let max_chunk_bytes = 750; // 8_000_000 is a good default when chunks are bigger.<br/>    let max_concurrent_requests = 10; // 10 is a good default<br/><br/>    count_bigrams(<br/>        cloud_file,<br/>        sample_count,<br/>        seed,<br/>        max_concurrent_requests,<br/>        max_chunk_bytes,<br/>    )<br/>    .await?;<br/><br/>    Ok(())<br/>}</span></pre><p id="febc" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">The <code class="cx ny nz oa ob b">count_bigrams</code> function can start by creating a random number generator and making a call to find the size of the cloud file:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="1c1e" class="po ol fq ob b bg pp pq l pr ps">#[cfg(not(target_pointer_width = "64"))]<br/>compile_error!("This code requires a 64-bit target architecture.");<br/><br/>use cloud_file::CloudFile;<br/>use futures::pin_mut;<br/>use futures_util::StreamExt; // Enables `.next()` on streams.<br/>use rand::{rngs::StdRng, Rng, SeedableRng};<br/>use std::{cmp::max, collections::HashMap, ops::Range};<br/><br/>async fn count_bigrams(<br/>    cloud_file: CloudFile,<br/>    sample_count: usize,<br/>    seed: Option&lt;u64&gt;,<br/>    max_concurrent_requests: usize,<br/>    max_chunk_bytes: usize,<br/>) -&gt; Result&lt;(), anyhow::Error&gt; {<br/>    // Create a random number generator<br/>    let mut rng = if let Some(s) = seed {<br/>        StdRng::seed_from_u64(s)<br/>    } else {<br/>        StdRng::from_entropy()<br/>    };<br/><br/>    // Find the document size<br/>    let file_size = cloud_file.read_file_size().await?;<br/>//...</span></pre><p id="c0d3" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Next, based on the file size, the function can create a vector of 10,000 random two-byte ranges.</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="5758" class="po ol fq ob b bg pp pq l pr ps">   // Randomly choose the two-byte ranges to sample<br/>    let range_samples: Vec&lt;Range&lt;usize&gt;&gt; = (0..sample_count)<br/>        .map(|_| rng.gen_range(0..file_size - 1))<br/>        .map(|start| start..start + 2)<br/>        .collect();</span></pre><p id="1cad" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">For example, it might produce the vector <code class="cx ny nz oa ob b">[4122418..4122420, 4361192..4361194, 145726..145728,</code> ‚Ä¶ <code class="cx ny nz oa ob b">]</code>. But retrieving 20,000 bytes at once (we are pretending) is too much. So, we divide the vector into 27 chunks of no more than 750 bytes:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="a81e" class="po ol fq ob b bg pp pq l pr ps">   // Divide the ranges into chunks respecting the max_chunk_bytes limit<br/>    const BYTES_PER_BIGRAM: usize = 2;<br/>    let chunk_count = max(1, max_chunk_bytes / BYTES_PER_BIGRAM);<br/>    let range_chunks = range_samples.chunks(chunk_count);</span></pre><p id="aef3" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Using a little async magic, we create an iterator of future work for each of the 27 chunks and then we turn that iterator into a stream. We tell the stream to do up to 10 simultaneous calls. Also, we say that out-of-order results are fine.</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="7650" class="po ol fq ob b bg pp pq l pr ps">   // Create an iterator of future work<br/>    let work_chunks_iterator = range_chunks.map(|chunk| {<br/>        let cloud_file = cloud_file.clone(); // by design, clone is cheap<br/>        async move { cloud_file.read_ranges(chunk).await }<br/>    });<br/><br/>    // Create a stream of futures to run out-of-order and with constrained concurrency.<br/>    let work_chunks_stream =<br/>        futures_util::stream::iter(work_chunks_iterator).buffer_unordered(max_concurrent_requests);<br/>    pin_mut!(work_chunks_stream); // The compiler says we need this</span></pre><p id="50ff" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">In the last section of code, we first do the work in the stream and ‚Äî as we get results ‚Äî tabulate. Finally, we sort and print the top results.</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="f9ed" class="po ol fq ob b bg pp pq l pr ps">    // Run the futures and, as result bytes come in, tabulate.<br/>    let mut bigram_counts = HashMap::new();<br/>    while let Some(result) = work_chunks_stream.next().await {<br/>        let bytes_vec = result?;<br/>        for bytes in bytes_vec.iter() {<br/>            let bigram = (bytes[0], bytes[1]);<br/>            let count = bigram_counts.entry(bigram).or_insert(0);<br/>            *count += 1;<br/>        }<br/>    }<br/><br/>    // Sort the bigrams by count and print the top 10<br/>    let mut bigram_count_vec: Vec&lt;(_, usize)&gt; = bigram_counts.into_iter().collect();<br/>    bigram_count_vec.sort_by(|a, b| b.1.cmp(&amp;a.1));<br/>    for (bigram, count) in bigram_count_vec.into_iter().take(10) {<br/>        let char0 = (bigram.0 as char).escape_default();<br/>        let char1 = (bigram.1 as char).escape_default();<br/>        println!("Bigram ('{}{}') occurs {} times", char0, char1, count);<br/>    }<br/>    Ok(())<br/>}</span></pre><p id="a47a" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">The output is:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="82fc" class="po ol fq ob b bg pp pq l pr ps">Bigram ('\r\n') occurs 367 times<br/>Bigram ('e ') occurs 221 times<br/>Bigram (' t') occurs 184 times<br/>Bigram ('th') occurs 171 times<br/>Bigram ('he') occurs 158 times<br/>Bigram ('s ') occurs 143 times<br/>Bigram ('.\r') occurs 136 times<br/>Bigram ('d ') occurs 133 times<br/>Bigram (', ') occurs 127 times<br/>Bigram (' a') occurs 121 times</span></pre><p id="f0a5" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">The code for the Bed-Reader genomics crate uses the same technique to retrieve information from scattered DNA regions of interest. As the DNA information comes in, perhaps out of order, the code fills in the correct columns of an output array.</p><blockquote class="oh oi oj"><p id="3ad0" class="my mz nu na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Aside: This method uses an iterator, a stream, and a loop. I wish it were simpler. If you can figure out a simpler way to retrieve a vector of regions while limiting the maximum chunk size and the maximum number of concurrent requests, please send me a pull request.</p></blockquote><p id="01d8" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">That covers access to files stored on an HTTP server, but what about AWS S3 and other cloud services? What about local files?</p><h1 id="9bd2" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Rule 4: Use URL strings and option strings to access HTTP, Local Files, AWS S3, Azure, and Google Cloud.</h1><p id="8ea4" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">The <code class="cx ny nz oa ob b">object_store</code> crate (and the <code class="cx ny nz oa ob b">cloud-file</code> wrapper crate) supports specifying files either via a URL string or via structs. I recommend sticking with URL strings, but the choice is yours.</p><p id="a4c4" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Let‚Äôs consider an AWS S3 example. As you can see, AWS access requires credential information.</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="a5fb" class="po ol fq ob b bg pp pq l pr ps">use cloud_file::CloudFile;<br/>use rusoto_credential::{CredentialsError, ProfileProvider, ProvideAwsCredentials};<br/><br/>#[tokio::main]<br/>async fn main() -&gt; Result&lt;(), anyhow::Error&gt; {<br/>    // get credentials from ~/.aws/credentials<br/>    let credentials = if let Ok(provider) = ProfileProvider::new() {<br/>        provider.credentials().await<br/>    } else {<br/>        Err(CredentialsError::new("No credentials found"))<br/>    };<br/><br/>    let Ok(credentials) = credentials else {<br/>        eprintln!("Skipping example because no AWS credentials found");<br/>        return Ok(());<br/>    };<br/><br/>    let url = "s3://bedreader/v1/toydata.5chrom.bed";<br/>    let options = [<br/>        ("aws_region", "us-west-2"),<br/>        ("aws_access_key_id", credentials.aws_access_key_id()),<br/>        ("aws_secret_access_key", credentials.aws_secret_access_key()),<br/>    ];<br/>    let cloud_file = CloudFile::new_with_options(url, options)?;<br/><br/>    assert_eq!(cloud_file.read_file_size().await?, 1_250_003);<br/>    Ok(())<br/>}</span></pre><p id="7c60" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">The key part is:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="f57b" class="po ol fq ob b bg pp pq l pr ps">    let url = "s3://bedreader/v1/toydata.5chrom.bed";<br/>    let options = [<br/>        ("aws_region", "us-west-2"),<br/>        ("aws_access_key_id", credentials.aws_access_key_id()),<br/>        ("aws_secret_access_key", credentials.aws_secret_access_key()),<br/>    ];<br/>    let cloud_file = CloudFile::new_with_options(url, options)?;</span></pre><p id="4553" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">If we wish to use structs instead of URL strings, this becomes:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="1319" class="po ol fq ob b bg pp pq l pr ps">    use object_store::{aws::AmazonS3Builder, path::Path as StorePath};<br/><br/>    let s3 = AmazonS3Builder::new()<br/>        .with_region("us-west-2")<br/>        .with_bucket_name("bedreader")<br/>        .with_access_key_id(credentials.aws_access_key_id())<br/>        .with_secret_access_key(credentials.aws_secret_access_key())<br/>        .build()?;<br/>    let store_path = StorePath::parse("v1/toydata.5chrom.bed")?;<br/>    let cloud_file = CloudFile::from_structs(s3, store_path);</span></pre><p id="548e" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">I prefer the URL approach over structs. I find URLs slightly simpler, much more uniform across cloud services, and vastly easier for interop (with, for example, Python).</p><p id="3332" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Here are example URLs for the three web services I have used:</p><ul class=""><li id="6f7b" class="my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt pt nw nx bk">HTTP ‚Äî <code class="cx ny nz oa ob b"><a class="af mx" href="https://www.gutenberg.org/cache/epub/100/pg100.txt" rel="noopener ugc nofollow" target="_blank">https://www.gutenberg.org/cache/epub/100/pg100.txt</a></code></li><li id="573e" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">local file ‚Äî <code class="cx ny nz oa ob b">file:///M:/data%20files/small.bed</code> ‚Äî use the <code class="cx ny nz oa ob b"><a class="af mx" rel="noopener ugc nofollow" target="_blank" href="/fn.abs_path_to_url_string.html">cloud_file::abs_path_to_url_string</a></code> function to properly encode a full file path into a URL</li><li id="8cb3" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">AWS S3 ‚Äî <code class="cx ny nz oa ob b">s3://bedreader/v1/toydata.5chrom.bed</code></li></ul><p id="a1f2" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Local files don‚Äôt need options. For the other services, here are links to their supported options and selected examples:</p><ul class=""><li id="d2c5" class="my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt pt nw nx bk">HTTP ‚Äî <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/object_store/latest/object_store/enum.ClientConfigKey.html#variant.Timeout" rel="noopener ugc nofollow" target="_blank">ClientConfigKey</a></code> ‚Äî <code class="cx ny nz oa ob b">[("timeout", "30s")]</code></li><li id="8d24" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">AWS S3 ‚Äî <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/object_store/latest/object_store/aws/enum.AmazonS3ConfigKey.html" rel="noopener ugc nofollow" target="_blank">AmazonS3ConfigKey</a></code> ‚Äî <code class="cx ny nz oa ob b">[("aws_region", "us-west-2"), ("aws_access_key_id",</code> ‚Ä¶<code class="cx ny nz oa ob b">), ("aws_secret_access_key",</code> ‚Ä¶<code class="cx ny nz oa ob b">)]</code></li><li id="0ace" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">Azure ‚Äî <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/object_store/latest/object_store/azure/enum.AzureConfigKey.html" rel="noopener ugc nofollow" target="_blank">AzureConfigKey</a></code></li><li id="d299" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">Google ‚Äî <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/object_store/latest/object_store/gcp/enum.GoogleConfigKey.html" rel="noopener ugc nofollow" target="_blank">GoogleConfigKey</a></code></li></ul><p id="62a4" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Now that we can specify and read cloud files, we should create tests.</p><h1 id="b083" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Rule 5: Test via <code class="cx ny nz oa ob b">tokio::test</code> on http and local files.</h1><p id="bd32" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">The <code class="cx ny nz oa ob b">object_store</code> crate (and <code class="cx ny nz oa ob b">cloud-file</code>) supports any async runtime. For testing, the <a class="af mx" href="https://docs.rs/tokio/latest/tokio/index.html" rel="noopener ugc nofollow" target="_blank">Tokio runtime</a> makes it easy to test your code on cloud files. Here is a test on an http file:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="460c" class="po ol fq ob b bg pp pq l pr ps">[tokio::test]<br/>async fn cloud_file_extension() -&gt; Result&lt;(), CloudFileError&gt; {<br/>    let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/plink_sim_10s_100v_10pmiss.bed";<br/>    let mut cloud_file = CloudFile::new(url)?;<br/>    assert_eq!(cloud_file.read_file_size().await?, 303);<br/>    cloud_file.set_extension("fam")?;<br/>    assert_eq!(cloud_file.read_file_size().await?, 130);<br/>    Ok(())<br/>}</span></pre><p id="29fb" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Run this test with:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="b3d3" class="po ol fq ob b bg pp pq l pr ps">cargo test</span></pre><p id="90f8" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">If you don‚Äôt want to hit an outside web server with your tests, you can instead test against local files as though they were in the cloud.</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="89e6" class="po ol fq ob b bg pp pq l pr ps">#[tokio::test]<br/>async fn local_file() -&gt; Result&lt;(), CloudFileError&gt; {<br/>    use std::env;<br/>    <br/>    let apache_url = abs_path_to_url_string(env::var("CARGO_MANIFEST_DIR").unwrap()<br/>             + "/LICENSE-APACHE")?;<br/>    let cloud_file = CloudFile::new(&amp;apache_url)?;<br/>    assert_eq!(cloud_file.read_file_size().await?, 9898);<br/>    Ok(())<br/>}</span></pre><p id="7b6a" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">This uses the standard Rust environment variable <code class="cx ny nz oa ob b"><a class="af mx" href="https://doc.rust-lang.org/cargo/reference/environment-variables.html" rel="noopener ugc nofollow" target="_blank">CARGO_MANIFEST_DIR</a></code> to find the full path to a text file. It then uses <code class="cx ny nz oa ob b">cloud_file::abs_path_to_url_string</code> to correctly encode that full path into a URL.</p><p id="9343" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Whether you test on http files or local files, the power of <code class="cx ny nz oa ob b">object_store</code> means that your code should work on any cloud service, including AWS S3, Azure, and Google Cloud.</p><p id="da0e" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">If you only need to access cloud files for your own use, you can stop reading the rules here and skip to the conclusion. If you are adding cloud access to a library (Rust crate) for others, keep reading.</p><h1 id="03fd" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Rule 6: For maximum performance, add cloud-file support to your Rust library via an async API.</h1><p id="6ba7" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">If you offer a Rust crate to others, supporting cloud files offers great convenience to your users, but not without a cost. Let‚Äôs look at <a class="af mx" href="https://pypi.org/project/bed-reader/" rel="noopener ugc nofollow" target="_blank">Bed-Reader</a>, the genomics crate to which I added cloud support.</p><p id="f0f9" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">As previously mentioned, Bed-Reader is a library for reading and writing PLINK Bed Files, a binary format used in bioinformatics to store genotype (DNA) data. Files in Bed format can be as large as a terabyte. Bed-Reader gives users fast, random access to large subsets of the data. It returns a 2-D array in the user‚Äôs choice of int8, float32, or float64. Bed-Reader also gives users access to 12 pieces of metadata, six associated with individuals and six associated with SNPs (roughly speaking, DNA locations). The genotype data is often 100,000 times larger than the metadata.</p><figure class="mi mj mk ml mm mn mo mp paragraph-image"><div class="mo mp pu"><img src="../Images/210196974c88a9518883ab78d09b7c00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xE5owkOA5pqmFzCs.png"/></div><figcaption class="ms mt mu mo mp mv mw bf b bg z dx">PLINK stores genotype data and metadata. (Figure by author.)</figcaption></figure><blockquote class="oh oi oj"><p id="ed90" class="my mz nu na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Aside: In this context, an ‚Äú<a class="af mx" href="https://en.wikipedia.org/wiki/API" rel="noopener ugc nofollow" target="_blank">API</a>‚Äù refers to an Application Programming Interface. It is the public structs, methods, etc., provided by library code such as Bed-Reader for another program to call.</p></blockquote><p id="e1e0" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Here is some sample code using Bed-Reader‚Äôs original ‚Äúlocal file‚Äù API. This code lists the first five individual ids, the first five SNP ids, and every unique chromosome number. It then reads every genomic value in chromosome 5:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="dd0b" class="po ol fq ob b bg pp pq l pr ps">#[test]<br/>fn lib_intro() -&gt; Result&lt;(), Box&lt;BedErrorPlus&gt;&gt; {<br/>    let file_name = sample_bed_file("some_missing.bed")?;<br/><br/>    let mut bed = Bed::new(file_name)?;<br/>    println!("{:?}", bed.iid()?.slice(s![..5])); // Outputs ndarray: ["iid_0", "iid_1", "iid_2", "iid_3", "iid_4"]<br/>    println!("{:?}", bed.sid()?.slice(s![..5])); // Outputs ndarray: ["sid_0", "sid_1", "sid_2", "sid_3", "sid_4"]<br/>    println!("{:?}", bed.chromosome()?.iter().collect::&lt;HashSet&lt;_&gt;&gt;());<br/>    // Outputs: {"12", "10", "4", "8", "19", "21", "9", "15", "6", "16", "13", "7", "17", "18", "1", "22", "11", "2", "20", "3", "5", "14"}<br/>    let _ = ReadOptions::builder()<br/>        .sid_index(bed.chromosome()?.map(|elem| elem == "5"))<br/>        .f64()<br/>        .read(&amp;mut bed)?;<br/><br/>    Ok(())<br/>}</span></pre><p id="b2d2" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">And here is the same code using the new cloud file API:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="16f6" class="po ol fq ob b bg pp pq l pr ps">#[tokio::test]<br/>async fn cloud_lib_intro() -&gt; Result&lt;(), Box&lt;BedErrorPlus&gt;&gt; {<br/>    let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/some_missing.bed";<br/>    let cloud_options = [("timeout", "10s")];<br/><br/>    let mut bed_cloud = BedCloud::new_with_options(url, cloud_options).await?;<br/>    println!("{:?}", bed_cloud.iid().await?.slice(s![..5])); // Outputs ndarray: ["iid_0", "iid_1", "iid_2", "iid_3", "iid_4"]<br/>    println!("{:?}", bed_cloud.sid().await?.slice(s![..5])); // Outputs ndarray: ["sid_0", "sid_1", "sid_2", "sid_3", "sid_4"]<br/>    println!(<br/>        "{:?}",<br/>        bed_cloud.chromosome().await?.iter().collect::&lt;HashSet&lt;_&gt;&gt;()<br/>    );<br/>    // Outputs: {"12", "10", "4", "8", "19", "21", "9", "15", "6", "16", "13", "7", "17", "18", "1", "22", "11", "2", "20", "3", "5", "14"}<br/>    let _ = ReadOptions::builder()<br/>        .sid_index(bed_cloud.chromosome().await?.map(|elem| elem == "5"))<br/>        .f64()<br/>        .read_cloud(&amp;mut bed_cloud)<br/>        .await?;<br/><br/>    Ok(())<br/>}</span></pre><p id="80a4" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">When switching to cloud data, a Bed-Reader user must make these changes:</p><ul class=""><li id="7d59" class="my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt pt nw nx bk">They must run in an async environment, here <code class="cx ny nz oa ob b">#[tokio::test]</code>.</li><li id="4fad" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">They must use a new struct, <code class="cx ny nz oa ob b">BedCloud</code> instead of <code class="cx ny nz oa ob b">Bed</code>. (Also, not shown, <code class="cx ny nz oa ob b">BedCloudBuilder</code> rather than <code class="cx ny nz oa ob b">BedBuilder</code>.)</li><li id="20ab" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">They give a URL string and optional string options rather than a local file path.</li><li id="f1bf" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">They must use <code class="cx ny nz oa ob b">.await</code> in many, rather unpredictable, places. (Happily, the compiler gives a good error message if they miss a place.)</li><li id="f7c1" class="my mz fq na b go oc nc nd gr od nf ng nh oe nj nk nl of nn no np og nr ns nt pt nw nx bk">The <code class="cx ny nz oa ob b">ReadOptionsBuilder</code> gets a new method, <code class="cx ny nz oa ob b">read_cloud</code>, to go along with its previous <code class="cx ny nz oa ob b">read</code> method.</li></ul><p id="cc4f" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">From the library developer‚Äôs point of view, adding the new <code class="cx ny nz oa ob b">BedCloud</code> and <code class="cx ny nz oa ob b">BedCloudBuilder</code> structs costs many lines of main and test code. In my case, 2,200 lines of new main code and 2,400 lines of new test code.</p><blockquote class="oh oi oj"><p id="c8e9" class="my mz nu na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Aside: Also, see Mario Ortiz Manero‚Äôs article ‚Äú<a class="af mx" href="https://nullderef.com/blog/rust-async-sync/" rel="noopener ugc nofollow" target="_blank">The bane of my existence: Supporting both async and sync code in Rust</a>‚Äù.</p></blockquote><p id="50ea" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">The benefit users get from these changes is the ability to read data from cloud files with async‚Äôs high efficiency.</p><p id="dba9" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Is this benefit worth it? If not, there is an alternative that we‚Äôll look at next.</p><h1 id="7b45" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Rule 7: Alternatively, for maximum convenience, add cloud-file support to your Rust library via a traditional (‚Äúsynchronous‚Äù) API.</h1><p id="5cb1" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">If adding an efficient async API seems like too much work for you or seems too confusing for your users, there is an alternative. Namely, you can offer a traditional (‚Äúsynchronous‚Äù) API. I do this for the Python version of Bed-Reader and for the Rust code that supports the Python version.</p><blockquote class="oh oi oj"><p id="dc41" class="my mz nu na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Aside: See: <a class="af mx" href="https://medium.com/towards-data-science/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29" rel="noopener">Nine Rules for Writing Python Extensions in Rust: Practical Lessons from Upgrading Bed-Reader, a Python Bioinformatics Package</a> in <em class="fq">Towards Data Science</em>.</p></blockquote><p id="9654" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Here is the Rust function that Python calls to check if a *.bed file starts with the correct file signature.</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="142b" class="po ol fq ob b bg pp pq l pr ps">use tokio::runtime;<br/>// ...<br/>    #[pyfn(m)]<br/>    fn check_file_cloud(location: &amp;str, options: HashMap&lt;&amp;str, String&gt;) -&gt; Result&lt;(), PyErr&gt; {<br/>        runtime::Runtime::new()?.block_on(async {<br/>            BedCloud::new_with_options(location, options).await?;<br/>            Ok(())<br/>        })<br/>    }</span></pre><p id="5aa1" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Notice that this is <em class="nu">not</em> an async function. It is a normal ‚Äúsynchronous‚Äù function. Inside this synchronous function, Rust makes an async call:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="cb6a" class="po ol fq ob b bg pp pq l pr ps">BedCloud::new_with_options(location, options).await?;</span></pre><p id="4d67" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">We make the async call synchronous by wrapping it in a Tokio runtime:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="de0d" class="po ol fq ob b bg pp pq l pr ps">use tokio::runtime;<br/>// ...<br/><br/>runtime::Runtime::new()?.block_on(async {<br/>    BedCloud::new_with_options(location, options).await?;<br/>    Ok(())<br/>})</span></pre><p id="0957" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Bed-Reader‚Äôs Python users could previously open a local file for reading with the command <code class="cx ny nz oa ob b">open_bed(file_name_string)</code>. Now, they can also open a cloud file for reading with the same command <code class="cx ny nz oa ob b">open_bed(url_string)</code>. The only difference is the format of the string they pass in.</p><p id="c762" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Here is the example from Rule 6, in Python, using the updated Python API:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="7370" class="po ol fq ob b bg pp pq l pr ps">  with open_bed(<br/>      "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/some_missing.bed",<br/>      cloud_options={"timeout": "30s"},<br/>  ) as bed:<br/>      print(bed.iid[:5])<br/>      print(bed.sid[:5])<br/>      print(np.unique(bed.chromosome))<br/>      val = bed.read(index=np.s_[:, bed.chromosome == "5"])<br/>      print(val.shape)</span></pre><p id="7478" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Notice the Python API also offers a new optional parameter called <code class="cx ny nz oa ob b">cloud_options</code>. Also, behind the scenes, a tiny bit of new code distinguishes between strings representing local files and strings representing URLs.</p><p id="a37a" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">In Rust, you can use the same trick to make calls to <code class="cx ny nz oa ob b">object_cloud</code> synchronous. Specifically, you can wrap async calls in a runtime. The benefit is a simpler interface and less library code. The cost is less efficiency compared to offering an async API.</p><p id="962c" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">If you decide against the ‚Äúsynchronous‚Äù alternative and choose to offer an async API, you‚Äôll discover a new problem: providing async examples in your documentation. We will look at that issue next.</p><h1 id="de82" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Rule 8: Follow the rules of good API design in part by using hidden lines in your doc tests.</h1><p id="6977" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">All the rules from the article <a class="af mx" href="https://medium.com/towards-data-science/nine-rules-for-elegant-rust-library-apis-9b986a465247" rel="noopener">Nine Rules for Elegant Rust Library APIs: Practical Lessons from Porting Bed-Reader, a Bioinformatics Library, from Python to Rust</a> in <em class="nu">Towards Data Science</em> apply. Of particular importance are these two:</p><p id="2823" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk"><em class="nu">Write good documentation to keep your design honest.<br/>Create examples that don‚Äôt embarrass you.</em></p><p id="04e3" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">These suggest that we should give examples in our documentation, but how can we do that with async methods and awaits? The trick is ‚Äúhidden lines‚Äù in our <a class="af mx" href="https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html" rel="noopener ugc nofollow" target="_blank">doc tests</a>. For example, here is the documentation for <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/cloud-file/0.1.0-beta.2/cloud_file/struct.CloudFile.html#method.read_ranges" rel="noopener ugc nofollow" target="_blank">CloudFile::read_ranges</a></code>:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="34ab" class="po ol fq ob b bg pp pq l pr ps">    /// Return the `Vec` of [`Bytes`](https://docs.rs/bytes/latest/bytes/struct.Bytes.html) from specified ranges.<br/>    ///<br/>    /// # Example<br/>    /// ```<br/>    /// use cloud_file::CloudFile;<br/>    ///<br/>    /// # Runtime::new().unwrap().block_on(async {<br/>    /// let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/plink_sim_10s_100v_10pmiss.bim";<br/>    /// let cloud_file = CloudFile::new(url)?;<br/>    /// let bytes_vec = cloud_file.read_ranges(&amp;[0..10, 1000..1010]).await?;<br/>    /// assert_eq!(bytes_vec.len(), 2);<br/>    /// assert_eq!(bytes_vec[0].as_ref(), b"1\t1:1:A:C\t");<br/>    /// assert_eq!(bytes_vec[1].as_ref(), b":A:C\t0.0\t4");<br/>    /// # Ok::&lt;(), CloudFileError&gt;(())}).unwrap();<br/>    /// # use {tokio::runtime::Runtime, cloud_file::CloudFileError};<br/>    /// ```</span></pre><p id="3ee8" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">The doc test starts with <code class="cx ny nz oa ob b">```</code>. Within the doc test, lines starting with <code class="cx ny nz oa ob b">/// #</code> disappear from the documentation:</p><figure class="mi mj mk ml mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="pw px ed py bh pz"><div class="mo mp pv"><img src="../Images/3aa4177d13d6e88dd119ca930801c492.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gyAZk_SP22r52UYJ07wo_Q.png"/></div></div></figure><p id="0874" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">The hidden lines, however, will still be run by <code class="cx ny nz oa ob b">cargo test</code>.</p><p id="7501" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">In my library crates, I try to include a working example with every method. If such an example turns out overly complex or otherwise embarrassing, I try to fix the issue by improving the API.</p><p id="2566" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Notice that in this rule and the previous Rule 7, we added a runtime to the code. Unfortunately, including a runtime can easily double the size of your user‚Äôs programs, even if they don‚Äôt read files from the cloud. Making this extra size optional is the topic of Rule 9.</p><h1 id="0679" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Rule 9: Include a runtime, but optionally.</h1><p id="6d9c" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">If you follow Rule 6 and provide async methods, your users gain the freedom to choose their own runtime. Opting for a runtime like Tokio may significantly increase their compiled program‚Äôs size. However, if they use no async methods, selecting a runtime becomes unnecessary, keeping the compiled program lean. This embodies the ‚Äúzero cost principle‚Äù, where one incurs costs only for the features one uses.</p><p id="c705" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">On the other hand, if you follow Rule 7 and wrap async calls inside traditional, ‚Äúsynchronous‚Äù methods, then you must provide a runtime. This will increase the size of the resultant program. To mitigate this cost, you should make the inclusion of any runtime optional.</p><p id="17a2" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Bed-Reader includes a runtime under two conditions. First, when used as a Python extension. Second, when testing the async methods. To handle the first condition, we create a Cargo feature called <code class="cx ny nz oa ob b">extension-module</code> that pulls in optional dependencies <code class="cx ny nz oa ob b">pyo3</code> and <code class="cx ny nz oa ob b">tokio</code>. Here are the relevant sections of <code class="cx ny nz oa ob b">Cargo.toml</code>:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="2102" class="po ol fq ob b bg pp pq l pr ps">[features]<br/>extension-module = ["pyo3/extension-module", "tokio/full"]<br/>default = []<br/><br/>[dependencies]<br/>#...<br/>pyo3 = { version = "0.20.0", features = ["extension-module"], optional = true }<br/>tokio = { version = "1.35.0", features = ["full"], optional = true }<br/></span></pre><p id="9d28" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Also, because I‚Äôm using Maturin to <a class="af mx" rel="noopener" target="_blank" href="/nine-rules-for-writing-python-extensions-in-rust-d35ea3a4ec29">create a Rust extension for Python</a>, I include this text in <code class="cx ny nz oa ob b">pyproject.toml</code>:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="db90" class="po ol fq ob b bg pp pq l pr ps">[tool.maturin]<br/>features = ["extension-module"]</span></pre><p id="41c4" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">I put all the Rust code related to extending Python in a file called <code class="cx ny nz oa ob b">python_modules.rs</code>. It starts with this <a class="af mx" href="https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg-attribute" rel="noopener ugc nofollow" target="_blank">conditional compilation attribute</a>:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="bba7" class="po ol fq ob b bg pp pq l pr ps">#![cfg(feature = "extension-module")] // ignore file if feature not 'on'</span></pre><p id="4efe" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">This starting line ensures that the compiler includes the extension code only when needed.</p><p id="7946" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">With the Python extension code taken care of, we turn next to providing an optional runtime for testing our async methods. I again choose Tokio as the runtime. I put the tests for the async code in their own file called <code class="cx ny nz oa ob b">tests_api_cloud.rs</code>. To ensure that that async tests are run only when the <code class="cx ny nz oa ob b">tokio</code> dependency feature is ‚Äúon‚Äù, I start the file with this line:</p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="935a" class="po ol fq ob b bg pp pq l pr ps">#![cfg(feature = "tokio")]</span></pre><p id="2c83" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">As per Rule 5, we should also include examples in our documentation of the async methods. These examples also serve as ‚Äúdoc tests‚Äù. The doc tests need conditional compilation attributes. Below is the documentation for the method that retrieves chromosome metadata. Notice that the example includes two hidden lines that start <br/><code class="cx ny nz oa ob b">/// # #[cfg(feature = "tokio")]</code></p><pre class="mi mj mk ml mm pl ob pm bp pn bb bk"><span id="c8d3" class="po ol fq ob b bg pp pq l pr ps">/// Chromosome of each SNP (variant)<br/>/// [...]<br/>///<br/>/// # Example:<br/>/// ```<br/>/// use ndarray as nd;<br/>/// use bed_reader::{BedCloud, ReadOptions};<br/>/// use bed_reader::assert_eq_nan;<br/>///<br/>/// # #[cfg(feature = "tokio")] Runtime::new().unwrap().block_on(async {<br/>/// let url = "https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/small.bed";<br/>/// let mut bed_cloud = BedCloud::new(url).await?;<br/>/// let chromosome = bed_cloud.chromosome().await?;<br/>/// println!("{chromosome:?}"); // Outputs ndarray ["1", "1", "5", "Y"]<br/>/// # Ok::&lt;(), Box&lt;BedErrorPlus&gt;&gt;(())}).unwrap();<br/>/// # #[cfg(feature = "tokio")] use {tokio::runtime::Runtime, bed_reader::BedErrorPlus};<br/>/// ```</span></pre><p id="b132" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">In this doc test, when the <code class="cx ny nz oa ob b">tokio</code> feature is ‚Äòon‚Äô, the example, uses <code class="cx ny nz oa ob b">tokio</code> and runs four lines of code inside a Tokio runtime. When the <code class="cx ny nz oa ob b">tokio</code> feature is ‚Äòoff‚Äô, the code within the <code class="cx ny nz oa ob b">#[cfg(feature = "tokio")]</code> block disappears, effectively skipping the asynchronous operations.</p><p id="d964" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">When formatting the documentation, Rust includes documentation for all features by default, so we see the four lines of code:</p><figure class="mi mj mk ml mm mn mo mp paragraph-image"><div role="button" tabindex="0" class="pw px ed py bh pz"><div class="mo mp qa"><img src="../Images/4544233478a0a6911c16e85bb4a9ab4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5D6S24maF-Ib1xfpjEoZw.png"/></div></div></figure><p id="9aff" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">To summarize Rule 9: By using Cargo features and conditional compilation we can ensure that users only pay for the features that they use.</p><h1 id="9f63" class="ok ol fq bf om on oo gq op oq or gt os ot ou ov ow ox oy oz pa pb pc pd pe pf bk">Conclusion</h1><p id="bda4" class="pw-post-body-paragraph my mz fq na b go pg nc nd gr ph nf ng nh pi nj nk nl pj nn no np pk nr ns nt fj bk">So, there you have it: nine rules for reading cloud files in your Rust program. Thanks to the power of the <code class="cx ny nz oa ob b"><a class="af mx" href="https://docs.rs/object_store/latest/object_store/" rel="noopener ugc nofollow" target="_blank">object_store</a></code> crate, your programs can move beyond your local drive and load data from the web, AWS S3, Azure, and Google Cloud. To make this a little simpler, you can also use the new <code class="cx ny nz oa ob b"><a class="af mx" href="https://crates.io/crates/cloud-file" rel="noopener ugc nofollow" target="_blank">cloud-file</a></code> wrapping crate that I wrote for this article.</p><p id="411e" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">I should also mention that this article explored only a subset of <code class="cx ny nz oa ob b">object_store</code>‚Äôs features. In addition to what we‚Äôve seen, the <code class="cx ny nz oa ob b">object_store</code> crate also handles writing files and working with folders and subfolders. The <code class="cx ny nz oa ob b"><a class="af mx" href="https://crates.io/crates/cloud-file" rel="noopener ugc nofollow" target="_blank">cloud-file</a></code> crate, on the other hand, only handles reading files. (But, hey, I‚Äôm open to pull requests).</p><p id="1d32" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Should you add cloud file support to your program? It, of course, depends. Supporting cloud files offers a huge convenience to your program‚Äôs users. The cost is the extra complexity of using/providing an async interface. The cost also includes the increased file size of runtimes like Tokio. On the other hand, I think the tools for adding such support are good and trying them is easy, so give it a try!</p><p id="36b9" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk">Thank you for joining me on this journey into the cloud. I hope that if you choose to support cloud files, these steps will help you do it.</p><p id="3007" class="pw-post-body-paragraph my mz fq na b go nb nc nd gr ne nf ng nh ni nj nk nl nm nn no np nq nr ns nt fj bk"><em class="nu">Please </em><a class="af mx" href="https://medium.com/@carlmkadie" rel="noopener"><em class="nu">follow Carl on Medium</em></a><em class="nu">. I write on scientific programming in Rust and Python, machine learning, and statistics. I tend to write about one article per month.</em></p></div></div></div></div>    
</body>
</html>
["```py\ndef process0(v, q): ... # no type information\n```", "```py\ndef process0(v: int, q: bool) -> list[float]: ...\n```", "```py\nx = process0(v=5, q=20)\n# tp.py: error: Argument \"q\" to \"process0\"\n# has incompatible type \"int\"; expected \"bool\"  [arg-type]\n```", "```py\nimport static_frame as sf\n\n@sf.CallGuard.check\ndef process0(v: int, q: bool) -> list[float]:\n    return [x * (0.5 if q else 0.25) for x in range(v)]\n\nz = process0(v=5, q=20)\n# static_frame.core.type_clinic.ClinicError:\n# In args of (v: int, q: bool) -> list[float]\n# └── Expected bool, provided int invalid\n```", "```py\nfrom typing import Any\nimport numpy as np\n\nTNDArrayInt8 = np.ndarray[Any, np.dtype[np.int8]]\nTNDArrayBool = np.ndarray[Any, np.dtype[np.bool_]]\nTNDArrayFloat64 = np.ndarray[Any, np.dtype[np.float64]]\n\ndef process1(\n        v: TNDArrayInt8,\n        q: TNDArrayBool,\n        ) -> TNDArrayFloat64:\n    s: TNDArrayFloat64 = np.where(q, 0.5, 0.25)\n    return v * s\n```", "```py\nv1: TNDArrayInt8 = np.arange(20, dtype=np.int8)\nx = process1(v1, v1)\n# tp.py: error: Argument 2 to \"process1\" has incompatible type\n# \"ndarray[Any, dtype[floating[_64Bit]]]\"; expected \"ndarray[Any, dtype[bool_]]\"  [arg-type]\n```", "```py\nTNDArrayInt64 = np.ndarray[Any, np.dtype[np.int64]]\nv2: TNDArrayInt64 = np.arange(20, dtype=np.int64)\nq: TNDArrayBool = np.arange(20) % 3 == 0\nx = process1(v2, q)\n# tp.py: error: Argument 1 to \"process1\" has incompatible type\n# \"ndarray[Any, dtype[signedinteger[_64Bit]]]\"; expected \"ndarray[Any, dtype[signedinteger[_8Bit]]]\"  [arg-type]\n```", "```py\nTNDArrayIntAny = np.ndarray[Any, np.dtype[np.signedinteger[Any]]]\ndef process2(\n        v: TNDArrayIntAny, # a more flexible interface\n        q: TNDArrayBool,\n        ) -> TNDArrayFloat64:\n    s: TNDArrayFloat64 = np.where(q, 0.5, 0.25)\n    return v * s\n\nx = process2(v1, q) # no mypy error\nx = process2(v2, q) # no mypy error\n```", "```py\n@sf.CallGuard.check\ndef process3(v: TNDArrayIntAny, q: TNDArrayBool) -> TNDArrayFloat64:\n    s: TNDArrayFloat64 = np.where(q, 0.5, 0.25)\n    return v * s\n\nx = process3(v1, q) # no error, same as mypy\nx = process3(v2, q) # no error, same as mypy\nv3: TNDArrayFloat64 = np.arange(20, dtype=np.float64) * 0.5\nx = process3(v3, q) # error\n# static_frame.core.type_clinic.ClinicError:\n# In args of (v: ndarray[Any, dtype[signedinteger[Any]]],\n# q: ndarray[Any, dtype[bool_]]) -> ndarray[Any, dtype[float64]]\n# └── ndarray[Any, dtype[signedinteger[Any]]]\n#     └── dtype[signedinteger[Any]]\n#         └── Expected signedinteger, provided float64 invalid\n```", "```py\nfrom typing import Annotated\n\n@sf.CallGuard.check\ndef process4(\n        v: Annotated[TNDArrayIntAny, sf.Require.Shape(24)],\n        q: Annotated[TNDArrayBool, sf.Require.Shape(24)],\n        ) -> Annotated[TNDArrayFloat64, sf.Require.Shape(24)]:\n    s: TNDArrayFloat64 = np.where(q, 0.5, 0.25)\n    return v * s\n\nx = process4(v1, q) # types pass, but Require.Shape fails\n# static_frame.core.type_clinic.ClinicError:\n# In args of (v: Annotated[ndarray[Any, dtype[int8]], Shape((24,))], q: Annotated[ndarray[Any, dtype[bool_]], Shape((24,))]) -> Annotated[ndarray[Any, dtype[float64]], Shape((24,))]\n# └── Annotated[ndarray[Any, dtype[int8]], Shape((24,))]\n#     └── Shape((24,))\n#         └── Expected shape ((24,)), provided shape (20,)\n```", "```py\n>>> v4 = sf.Frame.from_fields([range(5), np.arange(3, 8) * 0.5],\ncolumns=('a', 'b'), index=sf.IndexDate.from_date_range('2021-12-30', '2022-01-03'))\n>>> v4\n<Frame>\n<Index>         a       b         <<U1>\n<IndexDate>\n2021-12-30      0       1.5\n2021-12-31      1       2.0\n2022-01-01      2       2.5\n2022-01-02      3       3.0\n2022-01-03      4       3.5\n<datetime64[D]> <int64> <float64>\n\n# get a string representation of the annotation\n>>> v4.via_type_clinic\nFrame[IndexDate, Index[str_], int64, float64]\n```", "```py\nTFrameDateInts = sf.Frame[sf.IndexDate, sf.Index[np.str_], np.int64, np.int64]\nTSeriesYMBool = sf.Series[sf.IndexYearMonth, np.bool_]\nTSeriesDFloat = sf.Series[sf.IndexDate, np.float64]\n\ndef process5(v: TFrameDateInts, q: TSeriesYMBool) -> TSeriesDFloat:\n    t = v.index.iter_label().apply(lambda l: q[l.astype('datetime64[M]')]) # type: ignore\n    s = np.where(t, 0.5, 0.25)\n    return cast(TSeriesDFloat, (v.via_T * s).mean(axis=1))\n```", "```py\nTFrameDateIntFloat = sf.Frame[sf.IndexDate, sf.Index[np.str_], np.int64, np.float64]\nv5: TFrameDateIntFloat = sf.Frame.from_fields([range(5), np.arange(3, 8) * 0.5],\ncolumns=('a', 'b'), index=sf.IndexDate.from_date_range('2021-12-30', '2022-01-03'))\n\nq: TSeriesYMBool = sf.Series([True, False],\nindex=sf.IndexYearMonth.from_date_range('2021-12', '2022-01'))\n\nx = process5(v5, q)\n# tp.py: error: Argument 1 to \"process5\" has incompatible type\n# \"Frame[IndexDate, Index[str_], signedinteger[_64Bit], floating[_64Bit]]\"; expected\n# \"Frame[IndexDate, Index[str_], signedinteger[_64Bit], signedinteger[_64Bit]]\"  [arg-type]\n```", "```py\n# a Frame of three columns of integers\nTFrameDateIntIntInt = sf.Frame[sf.IndexDate, sf.Index[np.str_], np.int64, np.int64, np.int64]\nv6: TFrameDateIntIntInt = sf.Frame.from_fields([range(5), range(3, 8), range(1, 6)],\ncolumns=('a', 'b', 'c'), index=sf.IndexDate.from_date_range('2021-12-30', '2022-01-03'))\n\nx = process5(v6, q)\n# static_frame.core.type_clinic.ClinicError:\n# In args of (v: Frame[IndexDate, Index[str_], signedinteger[_64Bit], signedinteger[_64Bit]],\n# q: Series[IndexYearMonth, bool_]) -> Series[IndexDate, float64]\n# └── Frame[IndexDate, Index[str_], signedinteger[_64Bit], signedinteger[_64Bit]]\n#     └── Expected Frame has 2 dtype, provided Frame has 3 dtype\n```", "```py\nTFrameDateNums = sf.Frame[sf.IndexDate, sf.Index[np.str_], *tuple[np.number[Any], ...]]\n\n@sf.CallGuard.check\ndef process6(v: TFrameDateNums, q: TSeriesYMBool) -> TSeriesDFloat:\n    t = v.index.iter_label().apply(lambda l: q[l.astype('datetime64[M]')]) # type: ignore\n    s = np.where(t, 0.5, 0.25)\n    return tp.cast(TSeriesDFloat, (v.via_T * s).mean(axis=1))\n\nx = process6(v5, q) # a Frame with integer, float columns passes\nx = process6(v6, q) # a Frame with three integer columns passes\n```"]
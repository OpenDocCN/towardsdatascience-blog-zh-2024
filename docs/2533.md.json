["```py\npip install graphmuse\n```", "```py\nimport graphmuse as gm\n\nmidi_url_raw = \"https://github.com/CPJKU/partitura/raw/refs/heads/main/tests/data/midi/bach_midi_score.mid\"\ngraph = gm.load_midi_to_graph(midi_url_raw)\n```", "```py\ngit clone https://github.com/cpjku/asap-dataset.git\n```", "```py\nimport graphmuse as gm\nimport partitura as pt\nimport os\nimport torch\nimport numpy as np\n\n# Directory containing the dataset, change this to the location of your dataset\ndataset_dir = \"/your/path/to/the/asap-dataset\"\n\n# Find all the score files in the dataset (they are all named 'xml_score.musicxml')\nscore_files = [os.path.join(dp, f) for dp, dn, filenames in os.walk(dataset_dir) for f in filenames if f == 'xml_score.musicxml']\n\n# Use the first 30 scores, change this number to use more or less scores\nscore_files = score_files[:30]\n\n# probe the first score file\nscore = pt.load_score(score_files[0])\n# Extract features and note array\nfeatures, f_names = gm.utils.get_score_features(score)\nna = score.note_array(include_pitch_spelling=True, include_key_signature=True)\n# Create a graph from the score features\ngraph = gm.create_score_graph(features, score.note_array())\n\n# Get input feature size and metadata from the first graph\nin_feats = graph[\"note\"].x.shape[1]\nmetadata = graph.metadata()\n\n# Create a model for pitch spelling prediction\nmodel = gm.nn.models.PitchSpellingGNN(\n    in_feats=in_feats, n_hidden=128, out_feats_enc=64, n_layers=2, metadata=metadata, add_seq=True\n)\n\n# Create encoders for pitch and key signature labels\npe = model.pitch_label_encoder\nke = model.key_label_encoder\n```", "```py\n# Initialize lists to store graphs and encoders\ngraphs = []\n\n# Process each score file\nfor score_file in score_files:\n    # Load the score\n    score = pt.load_score(score_file)\n\n    # Extract features and note array\n    features, f_names = gm.utils.get_score_features(score)\n    na = score.note_array(include_pitch_spelling=True, include_key_signature=True)\n\n    # Encode pitch and key signature labels\n    labels_pitch = pe.encode(na)\n    labels_key = ke.encode(na)\n\n    # Create a graph from the score features\n    graph = gm.create_score_graph(features, score.note_array())\n\n    # Add encoded labels to the graph\n    graph[\"note\"].y_pitch = torch.from_numpy(labels_pitch).long()\n    graph[\"note\"].y_key = torch.from_numpy(labels_key).long()\n\n    # Append the graph to the list\n    graphs.append(graph) \n```", "```py\n# Create a DataLoader to sample subgraphs from the graphs\nloader = gm.loader.MuseNeighborLoader(graphs, subgraph_size=100, batch_size=16, num_neighbors=[3, 3])\n\n# Define loss functions for pitch and key prediction\nloss_pitch = torch.nn.CrossEntropyLoss()\nloss_key = torch.nn.CrossEntropyLoss()\n\n# Define the optimizer\noptimizer = torch.optim.Adam(model.parameters(), lr=0.001)\n```", "```py\n # Train the model for 5 epochs\nfor epoch in range(5):\n    loss = 0\n    i = 0\n    for batch in loader:\n        # Zero the gradients\n        optimizer.zero_grad()\n\n        # Get neighbor masks for nodes and edges for more efficient training\n        neighbor_mask_node = {k: batch[k].neighbor_mask for k in batch.node_types}\n        neighbor_mask_edge = {k: batch[k].neighbor_mask for k in batch.edge_types}\n\n        # Forward pass through the model\n        pred_pitch, pred_key = model(\n            batch.x_dict, batch.edge_index_dict, neighbor_mask_node, neighbor_mask_edge,\n            batch[\"note\"].batch[batch[\"note\"].neighbor_mask == 0]\n        )\n\n        # Compute loss for pitch and key prediction\n        loss_pitch_val = loss_pitch(pred_pitch, batch[\"note\"].y_pitch[batch[\"note\"].neighbor_mask == 0])\n        loss_key_val = loss_key(pred_key, batch[\"note\"].y_key[batch[\"note\"].neighbor_mask == 0])\n\n        # Total loss\n        loss_val = loss_pitch_val + loss_key_val\n\n        # Backward pass and optimization\n        loss_val.backward()\n        optimizer.step()\n\n        # Accumulate loss\n        loss += loss_val.item()\n        i += 1\n\n    # Print average loss for the epoch\n    print(f\"Epoch {epoch} Loss {loss / i}\")\n```"]
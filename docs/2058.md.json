["```py\ndef distances(object, data):\n  euclidean = []\n  for row in data: #iterating through all the objects in the dataset\n    d = 0\n    for i in range(data.shape[1]): #calculating sum of squared residuals for all the coords\n      d+=(row[i]-object[i])**2\n    euclidean.append(d**0.5) #taking a sqaure root\n  return np.array(euclidean)\n```", "```py\ndef DBSCAN(data, epsilon=0.5, N=3):\n  visited, noise = [], [] #lists to collect visited points and outliers\n  clusters = [] #list to collect clusters\n  for i in range(data.shape[0]): #iterating through all the points\n    if i not in visited: #getting in if the point's not visited\n      visited.append(i)\n      d = distances(data[i], data) #getting distances to all the other points\n      neighbors = list(np.where((d<=epsilon)&(d!=0))[0]) #getting the list of neighbors in the epsilon vicinity and removing distance = 0 (it's the point itself)\n      if len(neighbors)<N: #if the number of object is less than N, it's an outlier\n        noise.append(i)\n      else:\n        cluster = [i] #otherwise it forms a new cluster\n        for neighbor in neighbors: #iterating trough all the neighbors of the point i\n          if neighbor not in visited: #if neighbor isn't visited\n            visited.append(neighbor)\n            d = distances(data[neighbor], data) #get the distances to other objects from the neighbor\n            neighbors_idx = list(np.where((d<=epsilon)&(d!=0))[0]) #getting neighbors of the neighbor\n            if len(neighbors_idx)>=N: #if the neighbor has N or more neighbors, than it's a core point\n              neighbors += neighbors_idx #add neighbors of the neighbor to the neighbors of the ith object\n          if not any(neighbor in cluster for cluster in clusters):\n            cluster.append(neighbor) #if neighbor is not in clusters, add it there\n        clusters.append(cluster) #put the cluster into clusters list\n\n  return clusters, noise\n```", "```py\nX1 = [[x,y] for x, y in zip(np.random.normal(6,1, 2000), np.random.normal(0,0.5, 2000))]\nX2 = [[x,y] for x, y in zip(np.random.normal(10,2, 2000), np.random.normal(6,1, 2000))]\nX3 = [[x,y] for x, y in zip(np.random.normal(-2,1, 2000), np.random.normal(4,2.5, 2000))]\n\nfig, ax = plt.subplots()\nax.scatter([x[0] for x in X1], [y[1] for y in X1], s=40, c='#00b8ff', edgecolors='#133e7c', linewidth=0.5, alpha=0.8)\nax.scatter([x[0] for x in X2], [y[1] for y in X2], s=40, c='#00ff9f', edgecolors='#0abdc6', linewidth=0.5, alpha=0.8)\nax.scatter([x[0] for x in X3], [y[1] for y in X3], s=40, c='#d600ff', edgecolors='#ea00d9', linewidth=0.5, alpha=0.8)\nax.spines[['right', 'top', 'bottom', 'left']].set_visible(False)\nax.set_xticks([])\nax.set_yticks([])\nax.set_facecolor('black')\nax.patch.set_alpha(0.7)\n```"]
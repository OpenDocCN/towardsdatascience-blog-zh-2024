["```py\nI'm looking for AI events in Melbourne this month. Please prioritize events that are on weekends.\n```", "```py\nconst messages: ChatCompletionMessageParam[] = [];\n\n// STEP 1: Welcome the user\nconsole.log(staticMessageMap.welcome);\n// STEP 2: provide the context of the conversation - system prompt\nmessages.push(promptMap.context());\n// STEP 3: Ask and apply the user's query as a task - user task prompt\nconst userPrompt = await userPromptInterfaceV2(staticMessageMap.you);\nmessages.push(promptMap.task(userPrompt));\n```", "```py\n/**\n * This service creates a user prompt interface and returns a promise that resolves to the user's input. Allow user to input in the `terminal`.\n * @param query - The message to hint the user on what to input\n * @returns A promise that resolves to the user's input\n */\nexport const userPromptInterfaceV2 = async (query: string) => {\n  // Create an interface to read input from the user\n  const userInterface = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout,\n  });\n\n  // Return a promise that resolves to the user's input\n  // The userInterface.question method takes a query and a callback function\n  // The reason for using a promise is to make the user's input accessible outside of the callback function\n  return new Promise<string>((resolve) => {\n    userInterface.question(query, (input) => {\n      resolve(input);\n      userInterface.close(); // Close the user interface\n    });\n  });\n};\n```", "```py\nexport const promptMap = {\n  context: (\n    role: \"teacher\" | \"student\" | \"AI\"\n  ): ChatCompletionMessageParam => ({\n    role: \"system\",\n    content: `You are a ${role}. You will be given instructions on what to do by browsing. You are connected to a web browser and you will be given the screenshot of the website you are on.`,\n  }),\n};\n```", "```py\nconst taskFlow = async (): Promise<void> => {\n  console.log(`${staticMessageMap.agent}Let me think...`);\n  // Start the conversation with the LLM\n  const response = await openai.chat.completions.create({\n    model: \"gpt-4-vision-preview\",\n    max_tokens: 1024,\n    messages, // The messages array which contains the conversation history is sent to the LLM\n    temperature: 0,\n  });\n\n// For the initial conversation, the agent will respond with the url (google search if not provided by the user)\n  const { message } = response.choices[0];\n  const { content: messageText } = message;\n  if (messageText === null) {\n    throw new Error(\"The response message text is null\");\n  }\n  // Show the response in the terminal\n  console.log(`${staticMessageMap.agent}${messageText}`);\n  // Memorize the answer from agent\n  messages.push({\n    role: \"assistant\",\n    content: messageText,\n  });\n};\nawait taskFlow();\n```", "```py\nimport dotenv from \"dotenv\";\ndotenv.config();\nimport OpenAI from \"openai\";\n\n/**\n * An instance of the OpenAI Class that can invoke the API methods\n * @example `openai.chat.completions.create`\n */\nexport const openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n});\n```", "```py\n// Use typescript to define the 3 types of response\nexport type ResponseMessage =\n  | {\n      type: ResponseMessageCategory.URL;\n      url: string;\n    }\n  | {\n      type: ResponseMessageCategory.CLICK;\n      linkText: string;\n    }\n  // This initial type is simply a placeholder to indicate the start of the conversation in which the LLM has not yet provided a response (not relevant to the path selection logic)\n  | {\n      type: ResponseMessageCategory.INITIAL;\n      text: \"initial\";\n    }\n  | {\n      type: ResponseMessageCategory.REGULAR;\n      text: string;\n    };\n```", "```py\nexport const convertTextToResponseMessage = (text: string): ResponseMessage => {\n  // The `extractActionFromString` function is a helper function that simply checks if a string contains a particular pattern, such as '{\"url\": \"' or '{\"click\": \"' which is directly related to the response format. See the repo for the full implementation.\n  if (extractActionFromString(text, ResponseMessageCategory.URL) !== null) {\n    return {\n      type: ResponseMessageCategory.URL,\n      // Extract the URL from the response and store it in the `url` property, so it can be accessed easily\n      url: extractActionFromString(text, ResponseMessageCategory.URL) as string,\n    };\n  }\n\n  if (extractActionFromString(text, ResponseMessageCategory.CLICK) !== null) {\n    return {\n      type: ResponseMessageCategory.CLICK,\n      // Extract the link text from the response and store it in the `linkText` property, so it can be accessed easily\n      linkText: extractActionFromString(\n        text,\n        ResponseMessageCategory.CLICK\n      ) as string,\n    };\n  }\n\n  if (text === ResponseMessageCategory.INITIAL) {\n    return {\n      type: ResponseMessageCategory.INITIAL,\n      text,\n    };\n  }\n  return {\n    type: ResponseMessageCategory.REGULAR,\n    text,\n  };\n};\n```", "```py\n// messageText is the plain string response from the LLM (see above code)\n// It is then converted to the defined type using the `convertTextToResponseMessage` function\nresponseMessage = convertTextToResponseMessage(messageText);\n\n// if-else statement to determine the path based on the response type\n// URL Response Flow\nif (responseMessage.type === ResponseMessageCategory.URL) {\n  // 1\\. Extract the URL from the response\n  const { url } = responseMessage;\n  // 2\\. Opens a headless browser using Puppeteer and navigates to the URL and take a screenshot of the page\n  const imagePath = await screenshot(url, page);\n  if (imagePath === undefined) {\n    throw new Error(\"The screenshot path is undefined\");\n  }\n  // converts the screenshot to a format that LLM accepts\n  const base64String = await imageToBase64String(imagePath);\n  // 3\\. Send the screenshot with the instruction prompt back to the LLM\n  messages.push(\n    promptMap.instruction({\n      url: base64String,\n      detail: \"auto\",\n    })\n  );\n  return; // end of this path\n}\n// Click Response Flow\nif (responseMessage.type === ResponseMessageCategory.CLICK) {\n  // 1\\. Extract the link text from the response\n  const { linkText } = responseMessage;\n  // 2\\. The agent then uses Puppeteer to find the element with the matching text and clicks on it\n  const imagePath = await clickNavigationAndScreenshot(linkText, page, browser);\n  if (imagePath === undefined) {\n    throw new Error(\"The screenshot path is undefined\");\n  }\n  const base64String = await imageToBase64String(imagePath);\n  // 3\\. Send the screenshot with the instruction prompt back to the LLM\n  messages.push(\n    promptMap.instruction({\n      url: base64String,\n      detail: \"auto\",\n    })\n  );\n  return;\n}\n// Regular Message Flow - return message directly\n```", "```py\nexport const shouldContinueLoop = (responseMessage: ResponseMessage) => {\n\n// If the response is a regular message, the agent has finished the task and the loop should stop\n  if (responseMessage.type === ResponseMessageCategory.REGULAR) {\n    return false;\n  }\n  // Otherwise, the loop should continue\n  return true;\n};\n```", "```py\n// The initial response message before the loop starts. Basically, a placeholder.\nlet responseMessage: ResponseMessage = {\n  type: ResponseMessageCategory.INITIAL,\n  text: \"initial\",\n};\n//==================================LOOP==================================\n// shouldContinueLoop determines when to stop the loop\nwhile (shouldContinueLoop(responseMessage)) {\n\n  // +++++ openai service to generate the response +++++\n  console.log(`${staticMessageMap.agent}Let me think...`);\n  const response = await openai.chat.completions.create({\n    model: \"gpt-4-vision-preview\",\n    max_tokens: 1024,\n    messages,\n    temperature: 0,\n  });\n\n  const { message } = response.choices[0];\n  const { content: messageText } = message;\n  if (messageText === null) {\n    throw new Error(\"The response message text is null\");\n  }\n  console.log(`${staticMessageMap.agent}${messageText}`);\n  // +++++++++++++++++++++++++++++++++++++++++++++++++++\n\n  // Memorize the answer from agent\n  messages.push({\n    role: \"assistant\",\n    content: messageText,\n  });\n\n  // +++++ Path Selection +++++\n  responseMessage = convertTextToResponseMessage(messageText);\n  // URL Response Flow\n  if (responseMessage.type === ResponseMessageCategory.URL) {\n    const { url } = responseMessage;\n    const imagePath = await screenshot(url, page);\n    if (imagePath === undefined) {\n      throw new Error(\"The screenshot path is undefined\");\n    }\n    const base64String = await imageToBase64String(imagePath);\n    messages.push(\n      promptMap.instruction({\n        url: base64String,\n        detail: \"auto\",\n      })\n    );\n    // Instead of stopping here, we need to continue the loop for the next step\n    continue;\n  }\n  // Click Response Flow\n  if (responseMessage.type === ResponseMessageCategory.CLICK) {\n    const { linkText } = responseMessage;\n    try {\n      const imagePath = await clickNavigationAndScreenshot(\n        linkText,\n        page,\n        browser\n      );\n      if (imagePath === undefined) {\n        throw new Error(\"The screenshot path is undefined\");\n      }\n      const base64String = await imageToBase64String(imagePath);\n      messages.push(\n        promptMap.instruction({\n          url: base64String,\n          detail: \"auto\",\n        })\n      );\n      // continue the loop for the next step\n      continue;\n    } catch (err) {\n      // Handle the error and retry if the link is not found; sometimes the LLM just comes up with a link that doesn't exist or with a typo\n      if (\n        err instanceof Error &&\n        err.message.includes(\"Link with text not found\")\n      ) {\n        console.log(`...Error clicking on link: ${err.message}`);\n        messages.push(promptMap.retryIfLinkNotFound(linkText));\n        continue;\n      } else {\n        console.log(`...Unexpected error: ${err}. Please try again.`);\n        break;\n      }\n    }\n  }\n  // ++++++++++++++++++++++++++++\n}\n```", "```py\nconsole.log(`${staticMessageMap.agent}${messageText}`);\n```", "```py\nagent.ts\nservices/\n├── browser-controller.ts\n├── data-transformer.ts\n├── element-annotator.ts\n├── openai.ts\n├── prompt-map.ts\n└── user-prompt-interface.ts\nutils.ts\n```", "```py\nconst browserWindowSize = { width: 900, height: 1600 };\n\n/**\n * This service initializes a new browser session and a new page tab\n * @returns An object containing the browser and the page\n */\nexport const initController = async () => {\n  const pup = puppeteer.default.use(StealthPlugin());\n  // launch the browser\n  const browser = await pup.launch({\n    // detailed configurations\n    headless: false, // Determines whether to run the browser in headless mode (without a GUI). boolean | \"new\" | undefined\n    executablePath: process.env.GOOGLE_CHROME_CANARY_PATH, // path to a browser executable to use instead of the bundled Chromium\n    userDataDir: process.env.GOOGLE_CHROME_CANARY_USER_DATA_DIR, // Path to a user data directory, i.e, the user profile\n    args: [\n      `--profile-directory=${process.env.PROFILE}`, // Select the expected profile\n      \"--disable-setuid-sandbox\",\n      \"--no-sandbox\",\n      \"--no-zygote\",\n      `--window-size=${browserWindowSize.width},${browserWindowSize.height}`,\n    ],\n  });\n  // open a new tab\n  const page = await browser.newPage();\n  // set the viewport\n  await page.setViewport({\n    width: browserWindowSize.width,\n    height: browserWindowSize.height,\n    deviceScaleFactor: 1,\n  });\n  // the initialized browser and page are returned\n  return { browser, page };\n};\n```", "```py\nexport const navToUrlAndScreenshot = async (url: string, page: Page) => {\n  console.log(`...Opening ${url}`);\n  // validate the URL\n  if (!isValidURL(url)) {\n    throw new Error(`Invalid URL: ${url}`);\n  }\n\n  // +++++ go to the URL +++++\n  await page.goto(url, {\n    // a simple logic to determine if the page is loaded: wait 500 ms after the number of active network requests are 2\n    waitUntil: \"networkidle2\",\n    timeout: TIMEOUT,\n  });\n  // +++++++++++++++++++++++++++\n\n  // +++++ take a screenshot of the page +++++\n  // also include waiting for the page to load completely\n  const imagePath = await waitAndScreenshot(page);\n  // +++++++++++++++++++++++++++++++++++++++++\n  return imagePath;\n};\n```", "```py\nconst waitAndScreenshot = async (page: Page) => {\n  // is the page still loading? `document.readyState` === 'loading' or there is a loading indicator on the page\n  const isLoading = await isPageExplicitlyLoading(page);\n\n  // if the page is still loading, wait for the page to load completely\n  isLoading && (await waitTillHTMLRendered(page));\n\n  // apply Set-of-Mark Prompting\n  console.log(`...Highlight all interactive elements`);\n  await highlightInteractiveElements(page);\n\n  // take a screenshot of the page\n  console.log(`...Taking screenshot`);\n  await page.screenshot({\n    //path: \"/agent/web-agent-screenshot.jpg\" is a wrong path\n    path: imagePath,\n    fullPage: true,\n  });\n\n  return imagePath;\n};\n```", "```py\nexport const waitTillHTMLRendered = async (\n  page: Page,\n  timeout: number = 30000,\n  checkOnlyHTMLBody: boolean = false\n) => {\n  const waitTimeBetweenChecks: number = 1000;\n  const maximumChecks: number = timeout / waitTimeBetweenChecks; // assuming check itself does not take time\n  let lastHTMLSize = 0;\n  let stableSizeCount = 0;\n  const COUNT_THRESHOLD = 3;\n\n  const isSizeStable = (currentSize: number, lastSize: number) => {\n    if (currentSize !== lastSize) {\n      return false; // still rendering\n    } else if (currentSize === lastSize && lastSize === 0) {\n      return false; // page remains empty - failed to render\n    } else {\n      return true; // stable\n    }\n  };\n\n  for (let i = 0; i < maximumChecks; i++) {\n    const html = await page.content();\n    const currentHTMLSize = html.length;\n    const currentBodyHTMLSize = await page.evaluate(\n      () => document.body.innerHTML.length\n    );\n\n    const currentSize = checkOnlyHTMLBody\n      ? currentBodyHTMLSize\n      : currentHTMLSize;\n    // logging\n    console.log(\n      \"last: \",\n      lastHTMLSize,\n      \" <> curr: \",\n      currentHTMLSize,\n      \" body html size: \",\n      currentBodyHTMLSize\n    );\n\n    stableSizeCount = isSizeStable(currentSize, lastHTMLSize)\n      ? stableSizeCount + 1\n      : 0;\n    console.log(`Stable size count: ${stableSizeCount}`);\n\n    // if the HTML size remains the same for 3 consecutive seconds, it assumes the page has finished loading\n    if (stableSizeCount >= COUNT_THRESHOLD) {\n      console.log(\"Page rendered fully..\");\n      break;\n    }\n\n    lastHTMLSize = currentSize;\n    await page.waitForTimeout(waitTimeBetweenChecks);\n  }\n};\n```", "```py\nexport const clickNavigationAndScreenshot = async (\n  linkText: string,\n  page: Page,\n  browser: Browser\n) => {\n  let imagePath;\n\n  try {\n    const navigationPromise = page.waitForNavigation();\n    // The Click action\n    const clickResponse = await clickOnLink(linkText, page);\n\n    if (!clickResponse) {\n      // if the link triggers a navigation on the same page, wait for the page to load completely and then take a screenshot\n      await navigationPromise;\n      imagePath = await waitAndScreenshot(page);\n    } else {\n      // if the link opens in a new tab, ignore the navigationPromise as there won't be any navigation\n      navigationPromise.catch(() => undefined);\n      // switch to the new tab and take a screenshot\n      const newPage = await newTabNavigation(clickResponse, page, browser);\n\n      if (newPage === undefined) {\n        throw new Error(\"The new page cannot be opened\");\n      }\n\n      imagePath = await waitAndScreenshot(newPage);\n    }\n\n    return imagePath;\n  } catch (err) {\n    throw err;\n  }\n};\n```", "```py\nconst clickOnLink = async (linkText: string, page: Page) => {\n  try {\n    const clickResponse = await page.evaluate(async (linkText) => {\n\n      const isHTMLElement = (element: Element): element is HTMLElement => {\n        return element instanceof HTMLElement;\n      };\n\n      const elements = document.querySelectorAll(\"[gpt-link-text]\");\n\n      // loop through all elements with `gpt-link-text` attribute\n      for (const element of elements) {\n\n        if (!isHTMLElement(element)) {\n          continue;\n        }\n\n        // find the element that contains the targeted link text\n        if (\n          element\n            .getAttribute(\"gpt-link-text\")\n            ?.includes(linkText.trim().toLowerCase())\n        ) {\n          // This if statement is to handle the case where the link opens in a new tab\n          if (element.getAttribute(\"target\") === \"_blank\") {\n            return element.getAttribute(\"gpt-link-text\");\n          }\n\n          // highlight and perform the click action\n          element.style.backgroundColor = \"rgba(255,255,0,0.25)\";\n          element.click();\n          return;\n        }\n\n      }\n\n      // only if the loop ends without returning\n      throw new Error(`Link with text not found: \"${linkText}\"`);\n    }, linkText);\n\n    return clickResponse;\n  } catch (err) {\n    if (err instanceof Error) {\n      throw err;\n    }\n  }\n};\n```", "```py\n<div style=\"display: none\">\n  <a href=\"https://www.example.com\">\n    <span>Click me</span>\n  </a>\n</div>\n```", "```py\nimport { Page } from \"puppeteer\";\n\nconst INTERACTIVE_ELEMENTS = [\n  \"a\",\n  \"button\",\n  \"input\",\n  \"textarea\",\n  \"[role=button]\",\n  \"[role=treeitem]\",\n  '[onclick]:not([onclick=\"\"])',\n];\n/**\n * Reset the unique identifier attribute and remove previously highlighted elements\n * @param page\n */\nconst resetUniqueIdentifierAttribute = async (page: Page): Promise<void> => {\n  await page.evaluate(() => {\n    const UNIQUE_IDENTIFIER_ATTRIBUTE = \"gpt-link-text\";\n    const elements = document.querySelectorAll(\n      `[${UNIQUE_IDENTIFIER_ATTRIBUTE}]`\n    );\n    for (const element of elements) {\n      element.removeAttribute(UNIQUE_IDENTIFIER_ATTRIBUTE);\n    }\n  });\n};\n/**\n * This function annotates all the interactive elements on the page\n * @param page\n */\nconst annotateAllInteractiveElements = async (page: Page) => {\n  // $$eval method runs Array.from(document.querySelectorAll(selector)) within the `page`and passes the result as the first argument to the pageFunction.\n  // If no elements match the selector, the first argument to the pageFunction is [].\n  await page.$$eval(\n    INTERACTIVE_ELEMENTS.join(\", \"), // the selector can be defined outside the browser context\n    // the argument `elements` can be an empty array if no elements match the selector\n    function (elements) {\n      // any console.log will not be visible in the node terminal\n      // instead, it will be visible in the browser console\n      // handle empty array\n      if (elements.length === 0) {\n        throw new Error(\"No elements found\");\n      }\n      //======================================VALIDATE ELEMENT CAN INTERACT=================================================\n      // This run-time check must be defined inside the pageFunction as it is running in the browser context. If defined outside, it will throw an error: \"ReferenceError: isHTMLElement is not defined\"\n      const isHTMLElement = (element: Element): element is HTMLElement => {\n        // this assertion is to allow Element to be treated as HTMLElement and has `style` property\n        return element instanceof HTMLElement;\n      };\n      const isElementStyleVisible = (element: Element) => {\n        const style = window.getComputedStyle(element);\n        return (\n          style.display !== \"none\" &&\n          style.visibility !== \"hidden\" &&\n          style.opacity !== \"0\" &&\n          style.width !== \"0px\" &&\n          style.height !== \"0px\"\n        );\n      };\n      const isElementVisible = (element: Element | undefined | null) => {\n        if (element === null || element === undefined) {\n          throw new Error(\"isElementVisible: Element is null or undefined\");\n        }\n        let currentElement: Element | null = element;\n        while (currentElement) {\n          if (!isElementStyleVisible(currentElement)) {\n            return false;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        return true;\n      };\n      //========================================PREPARE UNIQUE IDENTIFIER================================================\n      const setUniqueIdentifierBasedOnTextContent = (element: Element) => {\n        const UNIQUE_IDENTIFIER_ATTRIBUTE = \"gpt-link-text\";\n        const { textContent, tagName } = element;\n        // if the node is a document or doctype, textContent will be null\n        if (textContent === null) {\n          return;\n        }\n        element.setAttribute(\n          UNIQUE_IDENTIFIER_ATTRIBUTE,\n          textContent.trim().toLowerCase()\n        );\n      };\n      //========================================HIGHLIGHT INTERACTIVE ELEMENTS================================================\n      for (const element of elements) {\n        if (isHTMLElement(element)) {\n          // highlight all the interactive elements with a red bonding box\n          element.style.outline = \"2px solid red\";\n        }\n        // assign a unique identifier to the element\n        if (isElementVisible(element)) {\n          // set a unique identifier attribute to the element\n          // this attribute will be used to identify the element that puppeteer should interact with\n          setUniqueIdentifierBasedOnTextContent(element);\n        }\n      }\n    }\n  );\n};\n/**\n * This function highlights all the interactive elements on the page\n * @param page\n */\nexport const highlightInteractiveElements = async (page: Page) => {\n  await resetUniqueIdentifierAttribute(page);\n  await annotateAllInteractiveElements(page);\n};\n```"]
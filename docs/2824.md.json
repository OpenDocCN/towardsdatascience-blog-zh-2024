["```py\nimport cv2\n\ncap = cv2.VideoCapture(\"ball.mp4\")\nfps = int(cap.get(cv2.CAP_PROP_FPS))\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        cap.set(cv2.CAP_PROP_POS_FRAMES, 0)\n        continue\n\n    cv2.imshow(\"Frame\", frame)\n\n    sleep_time = 1000 // fps\n    key = cv2.waitKey(sleep_time) & 0xFF\n    if key & 0xFF == ord(\"q\"):\n        break\n\ncap.release()\ncv2.destroyAllWindows()\n```", "```py\n# filter based on color\nhsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\nmask_color = cv2.inRange(hsv, (20, 0, 0), (100, 255, 255))\n```", "```py\n...\n\n# initialize background model\nbg_sub = cv2.createBackgroundSubtractorMOG2(varThreshold=50, detectShadows=False)\nret, frame0 = cap.read()\nif not ret:\n    print(\"Error: cannot read video file\")\n    exit(1)\nbg_sub.apply(frame0, learningRate=1.0)\n\nwhile True:\n  ...\n  # filter based on motion\n  mask_fg = bg_sub.apply(frame, learningRate=0)\n```", "```py\n# combine both masks\nmask = cv2.bitwise_and(mask_color, mask_fg)\nmask = cv2.morphologyEx(\n    mask, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (13, 13))\n)\n```", "```py\n# find largest contour corresponding to the ball we want to track\ncontours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\nif len(contours) > 0:\n    largest_contour = max(contours, key=cv2.contourArea)\n    x, y, w, h = cv2.boundingRect(largest_contour)\n    center = (x + w // 2, y + h // 2)\n```", "```py\ncv2.circle(frame, center, 30, (255, 0, 0), 2)\ncv2.circle(frame, center, 2, (255, 0, 0), 2)\n```", "```py\ntracked_pos = []\n\nwhile True:\n  ...\n\n  if len(contours) > 0:\n    ... \n    tracked_pos.append(center)\n\n  # draw trajectory\n  for i in range(1, len(tracked_pos)):\n      cv2.line(frame, tracked_pos[i - 1], tracked_pos[i], (255, 0, 0), 1)\n```", "```py\nfig, axs = plt.subplots(nrows=1, ncols=3, figsize=(10, 2), dpi=100)\n\naxs[0].set_title(\"Position\")\naxs[0].set_ylim(0, 700)\naxs[1].set_title(\"Velocity\")\naxs[1].set_ylim(-200, 200)\naxs[2].set_title(\"Acceleration\")\naxs[2].set_ylim(-30, 10)\n\nfor ax in axs:\n    ax.set_xlim(0, 20)\n    ax.grid(True)\n```", "```py\npos0 = tracked_pos[0][1]\npos = np.array([pos0 - pos[1] for pos in tracked_pos])\n```", "```py\nvel = np.diff(pos)\nacc = np.diff(vel)\n```", "```py\naxs[0].plot(range(len(pos)), pos, c=\"b\")\naxs[1].plot(range(len(vel)), vel, c=\"b\")\naxs[2].plot(range(len(acc)), acc, c=\"b\")\n\nplt.show()\n```", "```py\nfig.canvas.draw()\n\nbuf = fig.canvas.buffer_rgba()\nplot = np.asarray(buf)\nplot = cv2.cvtColor(plot, cv2.COLOR_RGB2BGR)\n```", "```py\nwhile True:\n  ...\n\n  axs[0].plot(range(len(pos)), pos, c=\"b\")\n  axs[1].plot(range(len(vel)), vel, c=\"b\")\n  axs[2].plot(range(len(acc)), acc, c=\"b\")\n\n  ... \n```", "```py\ncv2.imshow(\"Plot\", plot)\n```", "```py\npl_pos = axs[0].plot([], [], c=\"b\")[0]\npl_vel = axs[1].plot([], [], c=\"b\")[0]\npl_acc = axs[2].plot([], [], c=\"b\")[0]\n```", "```py\nfig.canvas.draw()\nbg_axs = [fig.canvas.copy_from_bbox(ax.bbox) for ax in axs]\n```", "```py\n# Update plot data\npl_pos.set_data(range(len(pos)), pos)\npl_vel.set_data(range(len(vel)), vel)\npl_acc.set_data(range(len(acc)), acc)\n\n# Blit Pos\nfig.canvas.restore_region(bg_axs[0])\naxs[0].draw_artist(pl_pos)\nfig.canvas.blit(axs[0].bbox)\n\n# Blit Vel\nfig.canvas.restore_region(bg_axs[1])\naxs[1].draw_artist(pl_vel)\nfig.canvas.blit(axs[1].bbox)\n\n# Blit Acc\nfig.canvas.restore_region(bg_axs[2])\naxs[2].draw_artist(pl_acc)\nfig.canvas.blit(axs[2].bbox)\n```"]
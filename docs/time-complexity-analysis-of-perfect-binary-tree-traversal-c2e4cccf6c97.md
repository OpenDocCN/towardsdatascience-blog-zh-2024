# 完美二叉树遍历的时间复杂度分析

> 原文：[https://towardsdatascience.com/time-complexity-analysis-of-perfect-binary-tree-traversal-c2e4cccf6c97?source=collection_archive---------9-----------------------#2024-10-03](https://towardsdatascience.com/time-complexity-analysis-of-perfect-binary-tree-traversal-c2e4cccf6c97?source=collection_archive---------9-----------------------#2024-10-03)

## 推导特定树遍历算法的最紧致渐近界

[](https://cardstdani.medium.com/?source=post_page---byline--c2e4cccf6c97--------------------------------)[![Daniel García Solla](../Images/b6e7bc9fdfdfcda7875215b1e0264d9e.png)](https://cardstdani.medium.com/?source=post_page---byline--c2e4cccf6c97--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--c2e4cccf6c97--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--c2e4cccf6c97--------------------------------) [Daniel García Solla](https://cardstdani.medium.com/?source=post_page---byline--c2e4cccf6c97--------------------------------)

·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--c2e4cccf6c97--------------------------------) ·29分钟阅读·2024年10月3日

--

![](../Images/fcd17c04446c6273e6410ec13e4ce97c.png)

图片来源：作者

# 介绍

数据结构和算法是任何软件开发中的关键元素，特别是由于它们对最终产品质量的影响。一方面，通过广泛已知和研究的算法来描述一个过程，有可能提高代码库的可维护性，因为互联网上有大量的开源资源和文档可供使用。但是，当决定使用哪种数据结构来表示信息或选择哪个理想算法来执行给定任务时，主要考虑的因素是效率，包括内存和时间的效率。简而言之，选择一个好的程序或结构通常会带来市场上其他产品所无法比拟的优势，因为它们在响应时间、执行任务所需的计算资源或可扩展性上无法满足要求。

因此，为了在这方面做出适当的决策，有必要[***准确测量***](/big-o-d13a8b1068c8)算法的成本，以便随后进行研究，在其中可以建立足够有效的比较，以淘汰那些不符合产品要求的实现或数据结构，这些要求通常涉及时间和空间的限制。因此，这两个量通过它们的渐近增长来量化，当输入数据的大小趋于无穷大时。这就是说，衡量一个算法效率的标准取决于当输入大小增加时，其执行所需的时间或空间资源的增长情况，如果它们随着相同的输入大小变化而增加得更多，则认为其性能更差，因为它们将需要比必要的更多资源。另一方面，选择一个适合的可以应用高效算法的数据结构，主要取决于需要建模的信息的复杂性，尽管最终目标是使通过[***操作***](https://dev.to/m__mdy__m/data-structures-a-comprehensive-introduction-2o13#:~:text=Common%20operations%20include%20insertion%20(adding,structure%20for%20a%20given%20task.) *(add(), remove(), search(element)…)* 定义的算法具有最小的渐近增长。

## 目标

在本工作中，旨在展示描述算法时间复杂度的方法并允许与其他替代方案进行比较，我们将首先从一个数据结构开始，即一个完美平衡的二叉树，以及在其上执行的算法。随后，我们将形式化其输入的格式，构建可视化图表以理解其组成以及过程跟踪，最后通过正式的开发达到最终界限，并尽可能简化和详细说明。

# 算法定义

我们即将处理的算法涉及一个具有完美平衡限制的二叉树。根据定义，二叉树是由一组节点和另一组表示节点之间连接的边组成的对，因此该组中的每个节点都与恰好两个被称为子节点的节点相连。而且，在所有可以从此定义中形成的[***树***](/5-types-of-binary-tree-with-cool-illustrations-9b335c430254)中，我们这里只关心那些被称为[***完美***](https://www.geeksforgeeks.org/perfect-binary-tree/)的树。

一个[***完美***](https://cs.stackexchange.com/q/153285)二叉树的特点是其叶子节点的深度相等，即最后一层的节点，以及其余节点的子节点数恒定为二。树中一个节点的深度，反过来，是从根节点到该节点的路径长度。因此，数据结构的外观将类似于：

![](../Images/cc13a8472549053c3e0866b672947a52.png)

图片来源：作者提供。

在这个特殊的情况下，我们正在处理一个深度为2的完美二叉树，因为最后一层的节点满足具有相同深度的条件，即等于该值。此外，在图中，节点被以某种方式编号，这在本上下文中会有所帮助。具体来说，每个节点对应的整数来自于从根节点开始执行的[***广度优先遍历***](https://www.youtube.com/watch?v=oDqjPvD54Ss)，这等同于给定树层次结构的[***层次遍历***](https://www.baeldung.com/cs/level-order-traversal-binary-tree)。在这种情况下，如果遍历的节点从0开始编号，则会形成如上所示的标号，其中每一层包含所有分配给介于**2^l-1**和**2^(l+1)-2**之间的整数的节点，**l**表示层级。要看到这个表达式的来源，只需找到一个函数，它以层级**l**为输入，返回该层级区间中的最小整数，以及另一个计算相反值的函数，即最大值。

首先，设**m(l)**为返回最小值的函数。因此，通过观察随着输入增加该序列应遵循的模式，我们注意到其模式为**{0,1,3,7,15,31,63…}**。而且，当我们在OEIS中搜索它的初始值时，找到了与序列[***A000225***](https://oeis.org/A000225)的匹配。根据该序列的定义，其值由表达式**2^l — 1**给出，但是，要理解为什么这个序列能描述**m(l)**的进展，有必要建立两个相邻的评估**m(l)**和**m(l+1)**之间的关系，这将导致这样的公式。然后，如果我们考虑一个层级**l**的最小值和下一个层级的最小值，我们可以从假设开始，即这两者之间的差值始终等于具有最少节点的层级中的节点数。例如，在第1层中只有两个节点，它们的标签为**{1,2}**。该层的最小值为1，下一层的最小值为3，因此可以容易地验证**3=1+2**，也就是说，第**{1,2}**层的最小值加上该层中的节点数。通过这个假设，再加上一个层级的节点数在二叉树中恰好为[**2^l**](https://courses.cs.vt.edu/~cs3114/Fall09/wmcquain/Notes/T03a.BinaryTreeTheorems.pdf)个节点，我们得出了**m(l)**的以下公式：

![](../Images/25084d906558e9dc5fb5820be6193455.png)

图片来源：作者提供。

总结来说，**m(l)**表示前一层**m(l-1)**的最小整数加上其中的节点数**2^(l-1)**，再加上基本情况**m(0)=0**。

![](../Images/2c0b2549198f22ae42f32429fc8c8fec.png)

图片来源：作者提供。

所以，当通过评估递归项扩展**m(l)**时，会出现一个模式，这样这个函数就可以被表征。简而言之，从**m(l-l)**到**l-1**的每一个2的幂都被汇总。最后，通过求解求和，我们得到与[***A000225***](https://oeis.org/A000225)定义中相同的表达式。因此，我们现在继续推导在层级**l**上的最大整数，这由一个新的函数**M(l)**表示。在这种情况下，其评估所形成的序列为**{0,2,6,14,30,62…}**，该序列也在OEIS中记录为[***A000918***](https://oeis.org/A000918)。为了推导它，我们可以利用**m(l)**的结果，因此，通过知道每一层中存在的节点数，**M(l)**可以定义为每一层**m(l)**中的最小整数加上该层的节点数。

![](../Images/f18c4b0b7f8c055cfbc71828aa76d00e.png)

作者提供的图片。

为了得到最终表达式**2^(l+1)-2**，我们将**m(l)**与该层级的节点数（去掉一个最小值）相加。而且，由于这个值与**m(l)**相符，我们可以得出结论**M(l)=2m(l)**。

在定义了算法将要操作的数据结构，并发现一些可能对复杂度分析有用的属性后，下面引入了该算法的伪代码表达：

![](../Images/afd683c191414b6cca210ecf354b7c89.png)

作者提供的图片。

起初，尽管我们稍后会详细展开，输入由一个表示二叉树的向量*(数组)*组成，记作**L**。通过这个向量，数组中每个对应树中节点的元素将通过for循环线性遍历。在每次迭代中，都会初始化一个临时变量**pos**来存储数组元素，因此它将具有相同的类型*(整数)*。此外，在迭代过程中，所有从树的根节点到由当前for循环元素表示的节点所形成的路径节点都将通过嵌套其中的while循环进行遍历。为此，设定退出条件**pos>0**，这对应于**pos**已经到达根节点的情况。只要这个条件未被满足，**pos**将更新为其父节点的值，因此，假设输入结构是正确的，就可以保证对于树中的每一个节点，while循环始终会到达根节点，从而终止。

## 输入特征

为了理解这个过程，熟悉输入格式是至关重要的。特别是，二叉树如何以[***数组***](https://youtu.be/zuWvrqcZwuU?si=_JNNft-71S-TRZeR)的形式表示，这是算法使用的结构。为此，为了简化这种表示，对树节点的标签进行了一次转换，使得它们最初被标记的宽度优先遍历从根节点开始，从整数1开始。换句话说，所有节点的原始标签上都加上了1。

![](../Images/9ad99efb02da3bdcd5db7e344e60eac8.png)

图片来自作者。

上述转换的结果如上所示。正如所示，各个层次标签的最小值和最大值也已被修改。尽管如此，由于该转换的特性，只需对函数**m(l)**和**M(l)**应用其逆变换，就可以正确地重新标定标签序列。

![](../Images/35881a10ceb78e35ae97cfec5bfe24ad.png)

图片来自作者。

因此，如果节点上的转换是将其标签加1，那么其逆变换就是减去这个数量。这样，在对两个函数应用逆转换后，我们得到了上面的表达式，模拟了每个树层次的最小值和最大值标签序列。另一方面，通过新的标签表示，数据结构可以被表示为数组，就像我们的算法所接收的输入一样。类似地，由于它是一个完美的树，我们知道它在节点数量以及节点在层次结构中的位置上将具有规则的结构。因此，考虑输入数组**L[n+1]**，我们可以将其索引与存储在这些位置的值相关联。

例如，如上图所示，在树的“链接”表示旁边，我们可以将每个节点的标签映射到数组索引，从而使**L[1]**表示根节点的实例，**L[2]**和**L[3]**表示它们各自的子节点，依此类推，直到终端节点。然而，也有必要明确表示它们的边，因此决定在数组中存储一个给定节点的父节点标签，索引由某个特定值确定。简而言之，对于数组中的每个节点**i**（*索引*），存储在**L[i]**中的值对应于**i**的父节点标签。然而，出于正确性的考虑，列表的第一个索引**L[0]**不被认为对应任何节点。此外，它的值被设定为-1，以表示在层次结构中它上面没有节点。

鉴于这一想法，研究序列**{-1,0,1,1,1,2,2…}** ***(***[***A123108***](https://oeis.org/A123108)***)***的性质是值得的，甚至找到一个函数来扩展其值，这在分析中将非常有价值。因此，首先需要考虑如何确定给定节点**i**的子节点和父节点**L[i]**。

![](../Images/46554b6a43a053ba6e9b26131db34491.png)

作者图片。

关于给定节点**i**的子节点，如果考虑到原始结构的任何子树也是一个完美的树，那么可以推断**m(l)**将在子树范围内发挥作用，结果是任何节点与其左子节点之间的标签差异为**i**（在此，i下标为2^l，两者等价），这与下级别的节点数量相符。

![](../Images/36da8e732d33e53b7b35abc2c6596fa9.png)

作者图片。

此外，为了验证这一点在所有子树中都成立，分别将偏移量**α**和**β**附加到左子节点和父节点的标签上，最终得出等式**2α=β**。

![](../Images/876a29c3daa79e6df8250474cb846842.png)

作者图片。

假设偏移量在其级别上不超过节点限制，那么位于其最小值**m(l+1)**和自身之间的子节点级别上的节点数量是上一级父节点同等数量的两倍。因此，根据完美二叉树的定义，通过在每一层节点数量翻倍，得出一个结论：某个**i**的左子节点的标签由表达式**2i**给出，其右子节点的标签为**2i+1**。同样，节点**i**总是有一个父节点，除非它是根节点，其父节点为**L[0]**，这不被视为树节点。

![](../Images/37ab4baf65c40a3d5289a41fadee1277.png)

作者图片。

为了确定输出父节点标签的函数，我们首先定义函数**Cleft(i)**和**Cright(i)**，它们分别获取相应的子节点。这样，如果这些函数以某种方式转换标签，使得结果等同于在层级结构中的下降，那么它们的反函数将导致相反的效果，这在我们想要找回父节点时是预期的。将**P(i)**定义为返回**i**的父节点的函数，也可以等价地表示为向量**L[i]**中的值，在计算时根据输入的性质需要做出区分。也就是说，如果节点的标签是偶数，这意味着它是某个节点的左子节点，那么将调用**Cleft(i)**的反函数。另一方面，如果标签是奇数，函数**P(i)**的表达式就是**Cright(i)**的反变换。

![](../Images/ace2a7d60c9c75a0a21c4fb9148d683d.png)

作者图片。

从图形上看，对于偶数和奇数标签节点的这两种公式，随着**i**的增大，增长趋势渐近相似。由于地板函数的性质，对于偶数标签，可以通过**i/2**相关的界限和常数约束**P(i)**的值。结果，得出以下性质：

![](../Images/7f7efa75e194640014edf1d4ed677639.png)

作者图片。

通过观察上述图形，无法保证**P(i)**的两个子表达式的渐近增长完全相等。但是，在推导了奇数情况的边界并确定依赖关系的阶数为**O(i)**后，我们可以计算当节点标签趋于无穷大时，两个函数的比值的极限，结果表明它们的增长是等效的，正如预期的那样。

![](../Images/8216159f5513bc4c8236273b0221ba0b.png)

图片由作者提供。

因此，为了简化，提供一个单一的**P(i)**公式无论接收到何种输入是方便的，因此最简单的选项是考虑偶数情况的增长阶数**i/2**，因为剩余的情况有相同的渐近增长。

![](../Images/74836524eed23cd5ef1fad632dc9e016.png)

图片由作者提供。

然而，**i/2**操作对于标签为奇数的节点并不返回整数，因此为了应对这一问题，决定对**i/2**应用地板函数。通过[***floor***](https://proofwiki.org/wiki/Floor_is_between_Number_and_One_Less)函数的性质，**Floor[i/2]**的值可以通过原始函数和其减去1的相同值来类似地界定。但是，由于目标是得到**P(i)**的正确表达式，而不是一个适用于渐近分析的近似表达式，因此仍然认为有必要从**i/2**的地板值来定义它。

![](../Images/2bf6995e7ca79c6fe3a4816217032f5d.png)

图片由作者提供。

选择这种定义的主要原因来自于输入数组的形式定义：

![](../Images/3f60f6c84ffd954310cb1c7329f7319c.png)

图片由作者提供。

由于**L**包含由每个数组索引确定的父节点标签，因此可以通过**P(i)**函数来描述它们，其中**i**在此情况下是一个有效的索引。换句话说，第一个值**L[0]**必须等于-1，这用一种特殊的方式表示，不使用**P(i)**，因为它无法生成该值。然后，基数组**{-1}**与序列**{P(1), P(2), P(3)…}**[***连接***](https://math.stackexchange.com/a/3459732)，该序列的长度为节点总数，值对应于标签序列**{1, 2, 3…}**的父节点。

```py
GenerateTree[n_] := Flatten[{-1, Table[i/2, {i, 1, n}]}]
GenerateTree[15]
```

一旦输入数组中的序列被建模，上述是生成一个包含15个节点的树所需的[***Wolfram***](https://www.wolfram.com/)代码，结果是**L={-1, 1/2, 1, 3/2, 2, 5/2, 3, 7/2, 4, 9/2, 5, 11/2, 6, 13/2, 7, 15/2}**。正如预期的那样，通过不使用**P(i)**中的Floor函数，具有奇数索引的节点返回有理数，因此在重新定义了适当的**P(i)**函数后，得到了正确的序列**L={-1, 0, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7}**：

```py
GenerateTree[n_] := Flatten[{-1, Table[i/2 // Floor, {i, 1, n}]}]
GenerateTree[15]
```

## 输入可视化

除了构建数组之外，还应当将其可视化，以确保其中包含的索引和值与其定义一致。为此，[***Wolfram***](https://reference.wolfram.com/language/guide/DataVisualization.html)的图形功能被用来自动化树形可视化过程，基于由**GenerateTree[]**生成的序列：

```py
PlotBinaryTreeFromList[treeList_List] := 
 Module[{n = Length[treeList], edges},
  edges = Flatten[Table[{i -> 2 i, i -> 2 i + 1}, {i, 1, Floor[n/2]}]];
  edges = Select[edges, #[[2]] <= n &];
  TreePlot[edges, VertexLabeling -> True, 
   VertexRenderingFunction -> ({Inset[treeList[[#2]], #1]} &), 
   DirectedEdges -> False, ImageSize -> Full]]
n = 31;
treeList = GenerateTree[n]
PlotBinaryTreeFromList[Drop[treeList, 1]]
```

当构建一个包含31个节点的树时，**L={-1, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3 … 14, 14, 15, 15}**，其图形大致如下所示：

![](../Images/3e111466c29f7cb4151cd53115534a55.png)

图片由作者提供。

具体来说，蓝色文本表示父节点的索引，而其他黑色文本则表示该节点的标签。

## 实现

现在，在输入已明确定义的情况下，我们可以更抽象地理解树遍历操作实际执行的内容。一方面，外部的[***For[]***](https://reference.wolfram.com/language/ref/For.html)循环按从最低级别到根节点所在级别的顺序遍历所有节点。对于每个节点，[***While[]***](https://reference.wolfram.com/language/ref/While.html)循环则按逆序遍历从根节点到访问节点的路径，尽管时间复杂度界限的关键因素是其长度。

```py
TreeIteration[v_List] := Module[{n, pos}, n = Length[v];
  For[i = n, i >= 0, i--,
   pos = v[[i]];
   Print["FOR: ", i];
   While[pos > 0,
    Print["While: ", pos];
    pos = v[[pos + 1]];
    ]]]
```

因此，在Wolfram中实现后，加入了一些[***Print[]***](https://reference.wolfram.com/language/ref/Print.html)语句，用于在执行过程中显示它遍历的节点的父节点索引，从而更容易重建其执行痕迹。

## 输出

```py
n = 7;
treeList = GenerateTree[n]
TreeIteration[treeList]
PlotBinaryTreeFromList[Drop[treeList, 1]]
```

运行算法时使用一个包含7个节点的树，表示为**L={-1, 0, 1, 1, 1, 1, 2, 2, 2, 3, 3}**，结果如下所示：

```py
FOR: 8
While: 3
While: 1
FOR: 7
While: 3
While: 1
FOR: 6
While: 2
While: 1
FOR: 5
While: 2
While: 1
FOR: 4
While: 1
FOR: 3
While: 1
FOR: 2
FOR: 1
FOR: 0
```

乍一看，痕迹并不十分直观，因此应当将其与树形图结合查看：

![](../Images/f2f3bb5b7ca324310b2f1143268ccf54.png)

图片由作者提供

在for循环的第一次迭代中，遍历从最低级别的最后一个节点开始，该节点的父节点索引为3。随后，while循环也会访问此节点，直到在下一次迭代中到达根节点并结束。在随后的for迭代中，执行相同的过程，不同之处在于它从索引为6的节点开始，而该节点的父节点与之前相同。因此，可以注意到，for循环实际上在遍历树中所有连接每个节点与根节点的路径。

# 分析

在算法就位并且完全了解了输入和操作之后，适宜继续进行其分析，既包括内存分析也包括时间分析。一方面，内存占用的分析在这种情况下是直截了当的，因为该算法不需要额外的内存来执行任务，除了存储每次迭代中遍历的节点的整数值 pos。因此，表示额外[***内存消耗***](https://www.theodinproject.com/lessons/javascript-space-complexity)的渐近边界是常数 **O(1)**。如果考虑输入占用的空间，则需要大约 **O(n)** 量级的内存，其中 **n** 是树中节点的数量，或者更精确地说是 **O(2^d)**，其中 **d** 是树的[***深度***](https://cs.stackexchange.com/q/6161)。

另一方面，为了确定时间复杂度的边界，我们必须定义一个[***基本操作***](https://www.cs.utexas.edu/~mitra/csSpring2017/cs313/lectures/algo.html)来进行计算。对于这个算法，它被定义为在 while 循环内部执行的赋值操作，从抽象层面上看，可以认为是沿着节点与其父节点之间的边进行遍历。因此，为了确定该操作被调用的次数，首先将算法的成本分解为两个函数。一方面，表示整个算法执行总成本的 for 循环的成本 **Tf(n)**。而这又被定义为 while 循环所产生的成本总和，标记为 **Tw(i)**。

![](../Images/19078da9140ae40df70f20436e6de1b5.png)

图片由作者提供。

对于数组中所有的节点 **i**，我们需要确定从根节点到 **i** 的路径遍历中涉及了多少基本操作，因此我们附加了相应的 **Tw(i)** 评估。具体来说，该函数将返回由某个输入节点引起的赋值操作的确切数量。因此，由于我们知道第一个 **L[0]** 无法走到任何路径到根节点，它不被计数，从而保持总和的限制在 1 到树中节点 **n** 的数量之间。

在继续之前，我们首先演示一下，将函数 **P(i)** 应用于树中位于层级 **l** 的节点 **i**，会导致标签上升到位于直接上层的节点，因为在此分析中考虑的基本操作等同于 **pos=P(pos)**，主要由于输入特征：

![](../Images/ca9f58c1cf3c1fca77412363cfff91d5.png)

图片由作者提供。

如所示，我们从一个不等式开始，任何节点都必须满足该不等式，并且与其所在层次相关，其标签被**m(l)**和**M(l)**函数所界定，假设**l**是其层次。然后，应用**P**后，可以进行一些简化，得出结论：**P(i)**位于**2^(l-1)**和**2^l-1**之间，这两个值分别与**m(l-1)**和**M(l-1)**相符，表明经过变换后，得到的节点位于**l-1**层次。通过这一点，我们证明了经过若干次while循环迭代后，存储在pos中的节点会接近树的根节点。因此，如果这些迭代足够多，路径一定会到达根节点并终止。尽管如此，若考虑到无限树的情况，这一点可能不成立。

## 方法一

目前，我们知道复杂度由**Tf(n)**主导，尽管没有**Tw(i)**的确切表达式，因此我们继续讨论三种不同的方法来刻画这个函数，从而分析执行时间的整体渐进增长。

无论剩余函数如何计算，所有分析中都会满足对树节点的约束。也就是说，除了根节点外，每个节点都有唯一的父节点，因此我们可以确保从某一节点（位于层次**l**）到根节点的路径长度等于**l**。主要是由于上述证明的性质，尽管也可以通过意识到路径上的每个节点都位于不同层次这一点来证明，节点的层次可以从0变化到**l**。然后，随着while循环遍历路径上的每个节点，可以得出结论，**Tw(i)**中计数的操作恰好为**l**。

![](../Images/8b9cf656b598bc8afd4915196459a405.png)

图片来源：作者。

现在，分析集中于计算给定节点的层次，因此我们从上面的不等式开始。也就是说，节点**i**的标签位于层次**l**，其值被**m(l)**和**M(l)**所界定，得出两个条件，从而可以准确地量化层次：

![](../Images/b57480f336aa49bdf130d145597ab539.png)

图片来源：作者。

一方面，从不等式的左侧解出，可以得到一个简化为对**log_2(i)**的下取整操作的条件，由其定义可得。由此可以推断出，层次等于该值，尽管原始不等式的另一个条件仍需验证。

![](../Images/748b5612af530c4f808dac61fcdf6905.png)

图片来源：作者。

从右侧开始，我们得到了**l**的下界，这在表面上似乎与之前的内容相互补充。然而，在进行运算并应用天花板函数的定义后，我们得出了以下的层次公式，因为其值是满足上述最后不等式的最小整数。

![](../Images/025f2be6ece4a8dadebc9b58862813a3.png)

图片来源：作者。

总结到目前为止，我们已经推导出了多个节点**i**的层级表达式，起初这些表达式可能被认为是该值的界限，鉴于它们的性质。然而，层级必须是整数，因此可以考虑检查它们之间的距离，以确保它们足够小，从而能够唯一确定一个值。

![](../Images/9a230abd713b2181cd165e191d4463ae.png)

图片来自作者。

总之，[***已证明***](https://math.stackexchange.com/a/4977835/988049)，对于节点标签可能具有的所有值，这两个表达式是相同的。因此，节点的层级可以通过上述公式中的任意一个来推导，左边的公式是最简单的，因此将在分析中使用。

![](../Images/eab719432eb37b6ad80a2c4c6d1b1dc0.png)

图片来自作者。

由于**i**的层级与while循环中的基本操作一致，成本**Tw(i)**的定义类似于从节点的层级出发的路径，该路径必须开始于顶部。

![](../Images/33b7c46d3f398d660fded47e55c960e7.png)

图片来自作者。

接下来，利用每次迭代的成本表达式作为初始节点的函数，我们可以尝试找出树的所有节点所产生的成本之和。但是，由于每个加数中都有一个取整函数，我们将首先研究不应用此函数对最终界限的影响，以简化求和，并研究在取整函数可以省略的情况下结果的界限。

![](../Images/fa16e308f35a73c9c6ab9da1e23d1dec.png)

图片来自作者

如果我们绘制**Tf(n)**在一个适当范围内的**n**，可以发现去掉每个加数取整后的函数与原始函数之间有轻微的差异。特别是，直接对对数值求和而不做任何额外变换的函数，似乎是实际复杂度的上界，因此，如果我们继续求解每一项直接为**log_2(i)**的和，我们可以得到一个渐近上可能大于实际复杂度的界限，从而确立了上界：

![](../Images/394d275fcd0c052862dbbdb8a95bcf50.png)

图片来自作者。

通过将求和表达式转化为闭式形式，我们可以假设该算法的执行时间不超过关于输入树节点数量的阶次[**O(log(n!))**](https://stackoverflow.com/q/8118221)。然而，这个上界可以进一步简化。例如，如果我们考虑在每次迭代中，for 循环执行的次数与n节点数量相等，每次执行的工作量与树的最大层级成正比，且不超过该最大层级，我们会得到一个上界阶次为[**O(n log(n))**](https://cs.stackexchange.com/a/70211)。因此，如果我们通过比较[***比较***](https://en.wikipedia.org/wiki/Asymptotic_analysis#:~:text=)-,if%20and%20only%20if,-(de%C2%A0Bruijn)的极限比值，得出与之前的阶次[**O(log(n!))**](https://math.stackexchange.com/a/4416026)相比，当输入趋于无穷大时它们是等价的，从而简化了算法运行时的上界为**O(n log(n))**。

![](../Images/fc7e1a707bd3e3767ec5b620451a725d.png)

图片来自作者。

在此时，算法的上界确保了其运行时开销在输入增长方面不会超过**O(n log(n))**的阶次。然而，分析的重点在于尽可能地限制成本，也就是说，找到一个[***紧确界***](https://cs.stackexchange.com/q/74013)，而不是上界，因为在某些情况下，上界与紧确界可能会有显著差异。为此，需要为上述的求和式**Tf(n)**找到一个闭式，尤其是在应用向下取整函数于加数时。直观上，应用向下取整将会在某种程度上减少每一项的值，并且由于上限和树的大小之间的依赖关系，最终的值可能会有所不同。

![](../Images/8e6697aef1b2fb5fed3f1e221ce911bc.png)

图片来自作者。

首先，为了使**log_2(i)**成为整数并避免应用向下取整转换，节点标签必须是**2^l**的形式，其中**l**必须指的是它所在的层级。

![](../Images/682fc7ab1ad33f5c26d9d56ea614c519.png)

图片来自作者。

与**m(l)**一致，以上已显示所有标签为该层级最小值的节点**i=m(l)**，其**log_2(i)**将是一个整数，即**l**。

![](../Images/80a29ed7f387c3babfa3e950ba122fdc.png)

图片来自作者。

因此，通过将**m(l)**和**M(l)**之间的所有标签作为输入传递给**floor(log_2(i))**函数，应该可以得到该层级的值，已经发现该值与该层级的“代表性”**m(l)**节点的值一致。简而言之，这允许假设同一层级的每个节点都将承担相同的成本**Tw(i)**，因为从任一节点到根节点的路径长度恰好等于l。

![](../Images/90f5e366636951adb12795c02eefc167.png)

图片来自作者。

随后，推导出每一层级的节点数，正如没有这一步骤时的直觉猜测，它是**2^l**，也就是说，如果每一层的节点数是上一层的两倍，那么对于某一层，这个数量将由[***分支因子***](https://www.sciencedirect.com/topics/computer-science/branching-factor#:~:text=Branching%20Factor%20is%20defined%20as,tree%20or%20graph%20data%20structure.)与其自身**l**次相乘得到。

![](../Images/fa7f01ede5c0b7a63beaf0e8bddae0a5.png)

图片由作者提供。

总之，算法在同一层级**l**的所有节点的运行时成本是到根节点路径长度与该层级节点数的乘积。根据这个结果，可以得出一个依赖于树深度**d**的**Tf(n)**的闭式：

![](../Images/e3e2a8d0b798abc85ea021cad2d7208e.png)

图片由作者提供。

通过将总和重写为从0到[***深度***](https://cs.stackexchange.com/a/6162)的层级函数，我们得到了上述表达式，通过定义**d**与节点总数**n**之间的关系，可以具体化此表达式：

![](../Images/93bf746a8bc021ce11b721fbb91ed6ac.png)

图片由作者提供。

由于n是最后一个节点的标签，**floor(log_2(n))**可以确保返回最后一层的值，而这个值与深度**d**相符。因此，通过上述完整成本**Tf(n)**的公式，我们得出了以下紧密的界限：

![](../Images/bec73bb33d09427e1067b6053f565596.png)

图片由作者提供。

在这一点上，值得尝试简化它，使其呈现出更简洁的表达式。为此，我们继续计算它与之前的上界的比率，这将主要显示两者之间的差异，以防它们是[***渐近等价***](https://artofproblemsolving.com/wiki/index.php/Asymptotic_equivalence)，否则它们会在相反的情况下发散（*尽管它也可能收敛到0*）。

![](../Images/6f61ea3ae674b3eb38e06c38459e0479.png)

图片由作者提供。

然而，比率的极限对于两个上界产生相同的结果，是渐近等价的。并且，由于它们位于一个实数区间内，可以推断出，紧密的界限至少在渐近意义上等价于上界，因为比率表示在无穷大时的差异可以忽略不计。

![](../Images/ed3ba3f5fb35ed62ad591db497430a5d.png)

图片由作者提供。

最后，算法的时间复杂度由最高阶决定，正如我们下面将看到的，可以通过几种方式来实现。在继续之前，值得注意的是，紧密界限的两个表达式之间的关系。后者直接依赖于节点的数量，而原始的可以通过重写上述表达式，将**n**替换为最后一层节点的数量来形成，这有助于更好地理解运行时间与所涉及数据结构的属性之间的依赖关系。

## 方法2

另一种进行分析的方法是定义输入数组中包含的每个值：

![](../Images/3ad17c7dc32722e37ce4e3dd3e0cd4f0.png)

图片来自作者。

每个值通过具体的评估**P(i)**来标识，从中可以推断出以下约束：

![](../Images/df8740005edd52fcf50443d2ffa1f6af.png)

图片来自作者。

通过将**P(i)**表示为树中的上升，任何输入范围在**[0,n]**之间的值都将始终返回一个位于相同区间内的结果，这导致了while循环中遍历的形式化，我们将由此得到**Tw(i)**：

![](../Images/56b21bf79dcfde3f8af3f0df09a946a1.png)

图片来自作者。

在遍历开始时，选择任何节点**i**，向其父节点**P(i)**上升，然后向其祖先**P(P(i))**上升，依此类推，直到到达标签为1的根节点。实际上，循环在到达“节点”**L[0]**时停止，但这里假设它在根节点处停止，因为成本差异将是恒定的。因此，上文我们通过[***组合***](https://math.stackexchange.com/a/248229/988049) **P(i)**若干次来形式化这个过程，正如我们所知，这与到根节点的路径长度相吻合，可以设定为节点的层级l。

![](../Images/f4e31948aa81627b9047a1273e588505.png)

图片来自作者。

采用这种方法，成本**Tw(i)**定义为输入节点的层级，也可以通过找到满足上面等式的整数来获得。

![](../Images/280dab5964a86670cdea4782c2f2e214.png)

图片来自作者。

此时，在获取导致重复组合结果为1的整数l时，我们首先应用[***地板函数的属性***](https://en.wikipedia.org/wiki/Floor_and_ceiling_functions#cite_ref-18:~:text=be%20proved%20similarly.-,Nested%20divisions,-%5Bedit%5D)来描述组合的封闭形式。同时，[***可以证明***](https://math.stackexchange.com/q/233670/988049)函数P的组合结果为上述[***表达式***](https://math.stackexchange.com/q/4977869/988049)。

![](../Images/95216cfd8ccc4286713abfa93727c010.png)

图片来自作者。

此后，按照地板函数的定义，在[***组合***](https://reference.wolfram.com/language/ref/Nest.html)的闭式和应达到的结果之间建立了不等式。即，等式规定在进行**l**次组合后，根的值正好达到，尽管由于地板函数的参数可能大于1，我们从推导出的不等式开始。最后，我们得出某个节点**i**级别的表达式，并用它来求解**Tf(n)**，从而得出复杂度。

![](../Images/df8b9d9273ce80cc06d06d6bc5a96dde.png)

图片来源：作者。

当用节点**i**的级别替换**Tw(i)**时，产生的求和与之前分析中解决的求和是等价的，因此最终表达式也是等价的。

![](../Images/c7b72b0a7ee17a4bec3f57054dff44bf.png)

图片来源：作者。

最终，从该过程中得出的紧束缚是**nlog(n)**阶，与之前推导出的结果一致。反过来，它也可以重新写成树深度的函数，这在某些情况下是有用的。

## 方法 3

最后，我们将探索一种替代方法来执行此分析并获得先前的渐近束缚。在这种情况下，我们将从存储在数组中的父节点标签**i**开始。此标签在低级别表示为正整数，特别是在[***二进制（base 2）](https://www.sciencedirect.com/topics/computer-science/binary-number-system)表示中。因此，它的二进制形式可以表示如下：

![](../Images/a09213565412f3c00b02e8c083b61712.png)

图片来源：作者。

一方面，它被定义为按相应进制的值对位进行加权求和，紧凑形式上，它被形式化为一组位，子标记表示该值。

![](../Images/02443051deee30807a09c041babbbae1.png)

图片来源：作者。

每个位是整数0或1，其子标属于从0到**B(i)-1**的整数区间，其中**B(i)**是返回整数**i**的二进制表示长度的函数。

![](../Images/85f2cf552697bf2065113e63190b52f7.png)

图片来源：作者。

至于其公式，已被[***证明***](https://math.stackexchange.com/a/1508909/988049)描述在二进制中表示一个整数所需的位数由上述等式给出。先验地，对数项与描述节点**i**所在级别的表达式相同，因此我们可以开始阐明其余的过程。

![](../Images/d09cafc7c97469a9b442f08b540847ca.png)

图片来源：作者。

要计算**Tw(i)**，必须考虑**P(i)**对节点标签的二进制表示的影响。简而言之，通过重复应用**P(i)**得到的标签必须为1，或者为了简便起见，取为0。因此，通过将标签除以2并应用向下取整函数，可以确保在二进制中此函数的等效操作是右移操作。因此，在**B(i)**移位后，得到的标签将为0，结束while循环的路径，并产生与**floor(log_2(i))+1**成正比的成本。

![](../Images/6a8ad8e685b01d846ca836fab61f3757.png)

图片来源：作者。

同样地，当在总体成本的和中代入**B(i)**时，在本分析中我们最终得到了一个额外的项**n**，该项由于比最终值小，渐近上可以忽略不计。

![](../Images/d315226a23a8b559ff330b8fbe3fc100.png)

图片来源：作者。

总结来说，通过这个过程，得出了相同的紧界限，保持了算法的运行时成本为**nlog(n)**的阶。

## 时间测量

最后，在理论分析后，将收集实验测量数据，记录算法在不同输入大小下的运行时间，以展示运行时增长与紧界限匹配的好坏。

```py
data = Flatten[
   ParallelTable[
    Table[{n, 
      AbsoluteTiming[TreeIteration[GenerateTree[n]]][[1]]}, {index, 0,
       n}], {n, 1, 300}], 1];
```

为此，在测量过程中使用了多个Wolfram函数。其中最重要的是[***AbsoluteTiming[]***](https://reference.wolfram.com/language/ref/AbsoluteTiming.html)，它记录了运行包含n个节点的树所需的时间（秒）。在这里，我们并没有选择2的幂次方的**n**值，而是简单地假设输入是一个完整的树，而不是一个完美的树，以观察执行时间如何随节点数的变化而增长。然后，测量从1到300的n值，对于每个相应节点数进行**n**次运行。

```py
nonlinearModel = NonlinearModelFit[points, a*x*Log[x], {a}, x]
ListPlot[{points, Table[{x, nonlinearModel[x]}, {x, 0, 300}]}, 
 PlotStyle -> {Red, Green}, ImageSize -> Large, 
 AxesLabel -> {"n", "Time (s)"}]
```

之后，定义了一个拟合模型形式为***c*nlog(n)***，其中***c***表示一个常数，作为参数调整其值，以适应由[***NonLinearModelFit[]***](https://reference.wolfram.com/language/ref/NonlinearModelFit.html)函数指定的测量数据集。

![](../Images/c036f7e4b106acc6a129bc72e6a56edf.png)

图片来源：作者。

一旦模型拟合完成，生成的最优结果，其解释在与数据点绘制时会显得更加有意义：

![](../Images/c45129341efb7df0a50d5559ed570aed.png)

图片来源：作者。

如图所示，由于测量过程中的实际干扰，数据集显示出一些变异性。然而，随着n的增加，增长趋势明显类似于**nlog(n)**的顺序，这一点与模型的位置相比也非常显著，模型位于两个区域之间的平均值以下，而这两个区域明显显示出更高的测量密度。

![](../Images/4018972fde6479c87a4a0d722a4b4905.png)

图片由作者提供。

最后，通过前面的拟合结果和[***调整后的 R²***](/r-squared-vs-adjusted-r-squared-simplified-543993e69558)值为 0.934551，可以得出结论，模型正确捕捉到了数据集的增长趋势。然而，其变异性转化为常数 c 值的轻微不确定性。

# 结论

算法的正式分析通过 **Θ(nlog(n))** 的阶数来表征其执行时间的渐进增长。这个界限是通过三种不同的方法计算得出的，尽管它们都基于相同的思想，即确定每个树节点的深度。在第一种方法中，层级被用作深度的度量，这相当于 **P(i)** 必须与自身组合的次数，才能到达根节点的标签，进而对应于用二进制表示初始节点 **i** 标签所需的位数。

此外，最后值得一提的是，这次分析中大部分涉及的 Wolfram 代码是由[***GPT-4o***](https://openai.com/index/hello-gpt-4o/)模型生成的，来自[***ChatGPT***](https://openai.com/chatgpt/)。

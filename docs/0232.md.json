["```py\nfunc Choice[T any](\n arr []T,\n size int,\n replace bool,\n probs []float64,\n rng *rand.Rand,\n) ([]T, error) {}\n```", "```py\nfunc CDF(probs []float64) []float64 {\n cdf := make([]float64, len(probs))\n cum := 0.0\n\n for i := range cdf {\n  cum += probs[i]\n  cdf[i] = cum\n }\n\n return cdf\n}\n```", "```py\nfunc FindIndexFromRight(val float64, cdf []float64) int {\n for i, cumProb := range cdf {\n  if cumProb >= val {\n   return i\n  }\n }\n\n return len(cdf) - 1\n}\n```", "```py\nfunc Choice[T any](\n arr []T,\n size int,\n replace bool,\n probs []float64,\n rng *rand.Rand,\n) ([]T, error) {\n if !replace && (size > len(arr)) {\n  return nil, errors.New(\"cannot sample more than array size without replacements\")\n }\n\n samples := make([]T, size)\n probsCopy := make([]float64, len(probs))\n copy(probsCopy, probs)\n\n for i := 0; i < size; i++ {\n  cdf := CDF(probsCopy)\n\n  if !replace {\n   total := cdf[len(cdf)-1]\n   for cdfInd := range cdf {\n    cdf[cdfInd] /= total\n   }\n  }\n\n  randFloat := rng.Float64()\n  sampledIndex := FindIndexFromRight(randFloat, cdf)\n  samples[i] = arr[sampledIndex]\n\n  if !replace {\n   probsCopy[sampledIndex] = 0.0\n  }\n }\n\n return samples, nil\n}\n```", "```py\nrngSource := rand.NewSource(time.Now().UnixNano())\nrng := rand.New(rngSource)\n\narr := []string{\"A\", \"B\", \"C\", \"D\"}\nprobs := []float64{0.1, 0.6, 0.2, 0.1}\n\nsamples, err := Choice(arr, 3, false, probs, rng)\nif err != nil {\n log.Fatal(err)\n}\n\nfmt.Println(\"Samples: \", samples)\n```"]
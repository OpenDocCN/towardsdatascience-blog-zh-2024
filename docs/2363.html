<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Nine Rules for Running Rust on WASM WASI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Nine Rules for Running Rust on WASM WASI</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a?source=collection_archive---------1-----------------------#2024-09-28">https://towardsdatascience.com/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a?source=collection_archive---------1-----------------------#2024-09-28</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="3bb6" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Practical Lessons from Porting <code class="cx hd he hf hg b">range-set-blaze</code> to this Container-Like Environment</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hh hi hj hk hl ab"><div><div class="ab hm"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@carlmkadie?source=post_page---byline--550cd14c252a--------------------------------" rel="noopener follow"><div class="l hn ho by hp hq"><div class="l ed"><img alt="Carl M. Kadie" class="l ep by dd de cx" src="../Images/9dbe27c76e9567136e5a7dc587f1fb15.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*RGViuuvF-_GQ-LXuVDQN7w.jpeg"/><div class="hr by l dd de em n hs eo"/></div></div></a></div></div><div class="ht ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--550cd14c252a--------------------------------" rel="noopener follow"><div class="l hu hv by hp hw"><div class="l ed"><img alt="Towards Data Science" class="l ep by br hx cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hr by l br hx em n hs eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hy ab q"><div class="ab q hz"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b ia ib bk"><a class="af ag ah ai aj ak al am an ao ap aq ar ic" data-testid="authorName" href="https://medium.com/@carlmkadie?source=post_page---byline--550cd14c252a--------------------------------" rel="noopener follow">Carl M. Kadie</a></p></div></div></div><span class="id ie" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b ia ib dx"><button class="if ig ah ai aj ak al am an ao ap aq ar ih ii ij" disabled="">Follow</button></p></div></div></span></div></div><div class="l ik"><span class="bf b bg z dx"><div class="ab cn il im in"><div class="io ip ab"><div class="bf b bg z dx ab iq"><span class="ir l ik">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar ic ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--550cd14c252a--------------------------------" rel="noopener follow"><p class="bf b bg z is it iu iv iw ix iy iz bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="id ie" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">13 min read</span><div class="ja jb l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Sep 28, 2024</span></div></span></div></span></div></div></div><div class="ab cp jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr"><div class="h k w ea eb q"><div class="kh l"><div class="ab q ki kj"><div class="pw-multi-vote-icon ed ir kk kl km"><div class=""><div class="kn ko kp kq kr ks kt am ku kv kw km"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kx ky kz la lb lc ld"><p class="bf b dy z dx"><span class="ko">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kn lg lh ab q ee li lj" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lf"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count le lf">4</span></p></button></div></div></div><div class="ab q js jt ju jv jw jx jy jz ka kb kc kd ke kf kg"><div class="lk k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al ll an ao ap ih lm ln lo" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lp cn"><div class="l ae"><div class="ab cb"><div class="lq lr ls lt lu lv ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al ll an ao ap ih lw lx lj ly lz ma mb mc s md me mf mg mh mi mj u mk ml mm"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al ll an ao ap ih lw lx lj ly lz ma mb mc s md me mf mg mh mi mj u mk ml mm"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al ll an ao ap ih lw lx lj ly lz ma mb mc s md me mf mg mh mi mj u mk ml mm"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mq mr ms mt mu mv mn mo paragraph-image"><div role="button" tabindex="0" class="mw mx ed my bh mz"><div class="mn mo mp"><img src="../Images/b2aeccd7db0b3d1c20858eb872f60daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wufrom42nQEGeKOpr1rCdg.png"/></div></div><figcaption class="nb nc nd mn mo ne nf bf b bg z dx">Rust Running on a Container-Like Environment — Source: <a class="af ng" href="https://openai.com/dall-e-2/" rel="noopener ugc nofollow" target="_blank">https://openai.com/dall-e-2/</a>. All other figures from the author.</figcaption></figure><p id="c78a" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Do you want your Rust code to run everywhere — from large servers to web pages, robots, and even watches? In this first of three articles [<a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a" rel="noopener">1</a>, <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1" rel="noopener">2</a>, <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e" rel="noopener">3</a>], I’ll detail the steps to make that happen.</p><p id="50ee" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Running Rust in constrained environments presents challenges. Your code may not have access to a complete operating system such as Linux, Windows, or macOS. You may have limited (or no) access to files, networks, time, random numbers, and even memory. We’ll explore workarounds and solutions.</p><p id="403e" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">This first article focuses on running code on “WASM WASI”, a container-like environment. We’ll see that WASM WASI may (or may not) be useful in its own right. However, it is valuable as a first step toward running Rust in browsers or embedded systems.</p><p id="6b93" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Porting code to run on WASM WASI requires many steps and choices. Navigating these choices can be time consuming. Missing a step can lead to failure. We’ll reduce this complication by offering nine rules, which we’ll explore in detail:</p><ol class=""><li id="8f3c" class="nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe of bk">Prepare for disappointment: WASM WASI is easy, but — for now — mostly useless — except as a steppingstone.</li><li id="058d" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc od oe of bk">Understand Rust targets.</li><li id="30ba" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc od oe of bk">Install the <code class="cx hd he hf hg b">wasm32-wasip1</code> target and WASMTIME, then create “Hello, WebAssembly!”.</li><li id="770d" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc od oe of bk">Understand conditional compilation.</li><li id="e727" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc od oe of bk">Run regular tests but with the WASM WASI target.</li><li id="0b52" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc od oe of bk">Understand Cargo features.</li><li id="9990" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc od oe of bk">Change the things you can: dependency issues by choosing Cargo features, 64-bit/32-bit issues.</li><li id="ea33" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc od oe of bk">Accept that you cannot change everything: Networking, Tokio, Rayon, etc.</li><li id="597d" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc od oe of bk">Add WASM WASI to your CI (continuous integration) tests.</li></ol><blockquote class="ol om on"><p id="6ab7" class="nh ni oo nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Aside: These articles are based on a three-hour workshop that I presented at <a class="af ng" href="https://rustconf.com/programs/#755" rel="noopener ugc nofollow" target="_blank">RustConf24</a> in Montreal. Thanks to the participants of that workshop. A special thanks, also, to the volunteers from the Seattle Rust Meetup who helped test this material. These articles replace <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2" rel="noopener">an article I wrote last year</a> with updated information.</p></blockquote><p id="8ba7" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Before we look at the rules one by one, let’s define our terms.</p><ul class=""><li id="0d4d" class="nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc op oe of bk"><strong class="nj fr">Native:</strong> Your home OS (Linux, Windows, macOS)</li><li id="3641" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc op oe of bk"><strong class="nj fr">Standard library (std)</strong>: Provides Rust’s core functionality — <code class="cx hd he hf hg b">Vec</code>, <code class="cx hd he hf hg b">String</code>, file input/output, networking, time.</li><li id="3ead" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc op oe of bk"><strong class="nj fr">WASM</strong>: WebAssembly (WASM) is a binary instruction format that runs in most browsers (and beyond).</li><li id="f375" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc op oe of bk"><strong class="nj fr">WASI</strong>: WebAssembly System Interface (WASI) allows outside-the-browser WASM to access file I/O, networking (not yet), and time handling.</li><li id="a6bc" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc op oe of bk"><strong class="nj fr">no_std</strong>: Instructs a Rust program not to use the full standard library, making it suitable for small, embedded devices or highly resource-constrained environments.</li><li id="1014" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc op oe of bk"><strong class="nj fr">alloc</strong>: Provides heap memory allocation capabilities (<code class="cx hd he hf hg b">Vec</code>, <code class="cx hd he hf hg b">String</code>, etc.) in <code class="cx hd he hf hg b">no_std</code> environments, essential for dynamically managing memory.</li></ul><p id="1fcf" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">With these terms in mind, we can visualize the environments we want our code to run in as a Venn diagram of progressively tighter constraints. This article details how to move from native to WASM WASI. <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1" rel="noopener">The second article</a> tells how to then move to WASM in the Browser. The <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e" rel="noopener">final article</a> covers running Rust in <code class="cx hd he hf hg b">no_std</code> environments, both with and without <code class="cx hd he hf hg b">alloc</code>, ideal for embedded systems.</p><figure class="mq mr ms mt mu mv mn mo paragraph-image"><div role="button" tabindex="0" class="mw mx ed my bh mz"><div class="mn mo oq"><img src="../Images/867094390e12910af5d9c304494db513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*infEhwykY8rpF-Z9X9E9Zw.png"/></div></div></figure></div></div></div><div class="ab cb or os ot ou" role="separator"><span class="ov by bm ow ox oy"/><span class="ov by bm ow ox oy"/><span class="ov by bm ow ox"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="93f7" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Based on my experience with <code class="cx hd he hf hg b"><a class="af ng" href="https://github.com/CarlKCarlK/range-set-blaze" rel="noopener ugc nofollow" target="_blank">range-set-blaze</a></code>, a data structure project, here are the decisions I recommend, described one at a time. To avoid wishy-washiness, I’ll express them as rules.</p><h1 id="9237" class="oz pa fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">Rule 1: Prepare for disappointment: WASM WASI is easy, but — for now — mostly useless — except as a steppingstone.</h1><p id="5987" class="pw-post-body-paragraph nh ni fq nj b go pv nl nm gr pw no np nq px ns nt nu py nw nx ny pz oa ob oc fj bk">In 2019, Docker co-creator Solomon Hykes <a class="af ng" href="https://x.com/solomonstre/status/1111004913222324225" rel="noopener ugc nofollow" target="_blank">tweeted</a>:</p><blockquote class="qa"><p id="5b96" class="qb qc fq bf qd qe qf qg qh qi qj oc dx">If WASM+WASI existed in 2008, we wouldn’t have needed to created Docker. That’s how important it is. Webassembly on the server is the future of computing. A standardized system interface was the missing link. Let’s hope WASI is up to the task.</p></blockquote><p id="9464" class="pw-post-body-paragraph nh ni fq nj b go qk nl nm gr ql no np nq qm ns nt nu qn nw nx ny qo oa ob oc fj bk">Today, if you follow technology news, you’ll see optimistic headlines like these:</p><figure class="mq mr ms mt mu mv mn mo paragraph-image"><div role="button" tabindex="0" class="mw mx ed my bh mz"><div class="mn mo qp"><img src="../Images/480c34163ac2f64c108340b17c9a2b74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZBBQscFbU6lpiBXGksoQQ.png"/></div></div></figure><p id="0423" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">If WASM WASI were truly ready and useful, everyone would already be using it. The fact that we keep seeing these headlines suggests it’s not yet ready. In other words, they wouldn’t need to keep insisting that WASM WASI is ready if it really were.</p><p id="8b44" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">As of WASI Preview 1, here is how things stand: You can access some file operations, environment variables, and have access to time and random number generation. However, there is no support for networking.</p><p id="60ed" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">WASM WASI <em class="oo">might</em> be useful for certain AWS Lambda-style web services, but even that’s uncertain. Because wouldn’t you prefer to compile your Rust code natively and run twice as fast at half the cost compared to WASM WASI?</p><p id="17eb" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Maybe WASM WASI is useful for plug ins and extensions. In genomics, I have a Rust extension for Python, which I compile for 25 different combinations (5 versions of Python across 5 OS targets). Even with that, I don’t cover every possible OS and chip family. Could I replace those OS targets with WASM WASI? No, it would be too slow. Could I add WASM WASI as a sixth “catch-all” target? Maybe, but if I really need portability, I’m already required to support Python and should just use Python.</p><p id="f87e" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">So, what is WASM WASI good for? Right now, its main value lies in being a step toward running code in the browser or on embedded systems.</p><h1 id="2fce" class="oz pa fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">Rule 2: Understand Rust targets.</h1><p id="161e" class="pw-post-body-paragraph nh ni fq nj b go pv nl nm gr pw no np nq px ns nt nu py nw nx ny pz oa ob oc fj bk">In Rule 1, I mentioned “OS targets” in passing. Let’s look deeper into Rust targets — essential information not just for WASM WASI, but also for general Rust development.</p><p id="6766" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">On my Windows machine, I can compile a Rust project to run on Linux or macOS. Similarly, from a Linux machine, I can compile a Rust project to target Windows or macOS. Here are the commands I use to add and check the Linux target to a Windows machine:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="7f17" class="qt pa fq hg b bg qu qv l qw qx">rustup target add x86_64-unknown-linux-gnu<br/>cargo check --target x86_64-unknown-linux-gnu</span></pre><blockquote class="ol om on"><p id="bae3" class="nh ni oo nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Aside: While <code class="cx hd he hf hg b">cargo check</code> verifies that the code compiles, building a fully functional executable requires additional tools. To cross-compile from Windows to Linux (GNU), you’ll also need to install the Linux GNU C/C++ compiler and the corresponding toolchain. That can be tricky. Fortunately, for the WASM targets we care about, the required toolchain is easy to install.</p></blockquote><p id="ac69" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">To see all the targets that Rust supports, use the command:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="2dfc" class="qt pa fq hg b bg qu qv l qw qx">rustc --print target-list</span></pre><p id="48bb" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">It will list over 200 targets including <code class="cx hd he hf hg b">x86_64-unknown-linux-gnu</code>, <code class="cx hd he hf hg b">wasm32-wasip1</code>, and <code class="cx hd he hf hg b">wasm32-unknown-unknown</code>.</p><p id="db65" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Target names contain up to four parts: CPU family, vendor, OS, and environment (for example, GNU vs LVMM):</p><figure class="mq mr ms mt mu mv mn mo paragraph-image"><div role="button" tabindex="0" class="mw mx ed my bh mz"><div class="mn mo qy"><img src="../Images/106509d86795e2a7eb85e55a4162ad49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UsCLYGXhPIaPrnr7OveB0w.png"/></div></div><figcaption class="nb nc nd mn mo ne nf bf b bg z dx">Target Name parts — figure from author</figcaption></figure><p id="8186" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Now that we understand something of targets, let’s go ahead and install the one we need for WASM WASI.</p><h1 id="0b0d" class="oz pa fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">Rule 3: Install the wasm32-wasip1 target and WASMTIME, then create “Hello, WebAssembly!”.</h1><p id="b48e" class="pw-post-body-paragraph nh ni fq nj b go pv nl nm gr pw no np nq px ns nt nu py nw nx ny pz oa ob oc fj bk">To run our Rust code on WASM outside of a browser, we need to target <code class="cx hd he hf hg b">wasm32-wasip1</code> (32-bit WebAssembly with WASI Preview 1). We’ll also install WASMTIME, a runtime that allows us to run WebAssembly modules outside of the browser, using WASI.</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="ae7d" class="qt pa fq hg b bg qu qv l qw qx">rustup target add wasm32-wasip1<br/>cargo install wasmtime-cli</span></pre><p id="ee15" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">To test our setup, let’s create a new “Hello, WebAssembly!” Rust project using <code class="cx hd he hf hg b">cargo new</code>. This initializes a new Rust package:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="a310" class="qt pa fq hg b bg qu qv l qw qx">cargo new hello_wasi<br/>cd hello_wasi</span></pre><p id="4221" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Edit <code class="cx hd he hf hg b">src/main.rs</code> to read:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="ad5f" class="qt pa fq hg b bg qu qv l qw qx">fn main() {<br/>    #[cfg(not(target_arch = "wasm32"))]<br/>    println!("Hello, world!");<br/>    #[cfg(target_arch = "wasm32")]<br/>    println!("Hello, WebAssembly!");<br/>}</span></pre><blockquote class="ol om on"><p id="496b" class="nh ni oo nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Aside: We’ll look deeper into the <code class="cx hd he hf hg b">#[cfg(...)]</code> attribute, which enables conditional compilation, in Rule 4.</p></blockquote><p id="2317" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Now, run the project with <code class="cx hd he hf hg b">cargo run</code>, and you should see <code class="cx hd he hf hg b">Hello, world!</code> printed to the console.</p><p id="cca3" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Next, create a <code class="cx hd he hf hg b">.cargo/config.toml</code> file, which specifies how Rust should run and test the project when targeting WASM WASI.</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="2f7c" class="qt pa fq hg b bg qu qv l qw qx">[target.wasm32-wasip1]<br/>runner = "wasmtime run --dir ."</span></pre><blockquote class="ol om on"><p id="280a" class="nh ni oo nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Aside: This <code class="cx hd he hf hg b">.cargo/config.toml</code> file is different from the main <code class="cx hd he hf hg b">Cargo.toml</code> file, which defines your project’s dependencies and metadata.</p></blockquote><p id="ad61" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Now, if you say:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="522b" class="qt pa fq hg b bg qu qv l qw qx">cargo run --target wasm32-wasip1</span></pre><p id="1ab2" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">You should see <code class="cx hd he hf hg b">Hello, WebAssembly!</code>. Congratulations! You’ve just successfully run some Rust code in the container-like WASM WASI environment.</p><h1 id="3c3b" class="oz pa fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">Rule 4: Understand conditional compilation.</h1><p id="0a22" class="pw-post-body-paragraph nh ni fq nj b go pv nl nm gr pw no np nq px ns nt nu py nw nx ny pz oa ob oc fj bk">Now, let’s investigate <code class="cx hd he hf hg b">#[cfg(...)]</code>—an essential tool for conditionally compiling code in Rust. In Rule 3, we saw:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="8192" class="qt pa fq hg b bg qu qv l qw qx">fn main() {<br/>    #[cfg(not(target_arch = "wasm32"))]<br/>    println!("Hello, world!");<br/>    #[cfg(target_arch = "wasm32")]<br/>    println!("Hello, WebAssembly!");<br/>}</span></pre><p id="6b17" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">The <code class="cx hd he hf hg b">#[cfg(...)]</code> lines tell the Rust compiler to include or exclude certain code items based on specific conditions. A “code item” refers to a unit of code such as a function, statement, or expression.</p><p id="9138" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">With <code class="cx hd he hf hg b">#[cfg(…)]</code> lines, you can conditionally compile your code. In other words, you can create different versions of your code for different situations. For example, when compiling for the <code class="cx hd he hf hg b">wasm32</code> target, the compiler ignores the <code class="cx hd he hf hg b">#[cfg(not(target_arch = "wasm32"))]</code> block and only includes the following:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="13c9" class="qt pa fq hg b bg qu qv l qw qx">fn main() {<br/>    println!("Hello, WebAssembly!");<br/>}</span></pre><p id="af55" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">You specify conditions via expressions, for example, <code class="cx hd he hf hg b">target_arch = "wasm32"</code>. Supported keys include <code class="cx hd he hf hg b">target_os</code> and <code class="cx hd he hf hg b">target_arch</code>. See the Rust Reference for <a class="af ng" href="https://doc.rust-lang.org/reference/conditional-compilation.html#set-configuration-options" rel="noopener ugc nofollow" target="_blank">the full list</a> of supported keys. You can also create expressions with Cargo features, which we will learn about in Rule 6.</p><p id="691f" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">You may combine expressions with the logical operators <code class="cx hd he hf hg b">not</code>, <code class="cx hd he hf hg b">any</code>, and <code class="cx hd he hf hg b">all</code>. Rust’s conditional compilation doesn’t use traditional <code class="cx hd he hf hg b">if...then...else</code> statements. Instead, you must use <code class="cx hd he hf hg b">#[cfg(...)]</code> and its negation to handle different cases:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="214d" class="qt pa fq hg b bg qu qv l qw qx">#[cfg(not(target_arch = "wasm32"))]<br/>...<br/>#[cfg(target_arch = "wasm32")]<br/>...</span></pre><p id="335d" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">To conditionally compile an entire file, place <code class="cx hd he hf hg b">#![cfg(...)]</code> at the top of the file. (Notice the “!”). This is useful when a file is only relevant for a specific target or configuration.</p><p id="d376" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">You can also use <code class="cx hd he hf hg b">cfg</code> expressions in <code class="cx hd he hf hg b">Cargo.toml</code> to conditionally include dependencies. This allows you to tailor dependencies to different targets. For example, this says “depend on Criterion with Rayon when not targeting <code class="cx hd he hf hg b">wasm32</code>”.</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="27cd" class="qt pa fq hg b bg qu qv l qw qx">[target.'cfg(not(target_arch = "wasm32"))'.dev-dependencies]<br/>criterion = { version = "0.5.1", features = ["rayon"] }</span></pre><blockquote class="ol om on"><p id="440c" class="nh ni oo nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Aside: For more information on using <code class="cx hd he hf hg b">cfg</code> expressions in <code class="cx hd he hf hg b">Cargo.toml</code>, see my article: <a class="af ng" href="https://medium.com/towards-data-science/nine-rust-cargo-toml-wats-and-wat-nots-1e5e02e41648" rel="noopener">Nine Rust Cargo.toml Wats and Wat Nots</a>: Master Cargo.toml formatting rules and avoid frustration | <em class="fq">Towards Data Science (medium.com)</em>.</p></blockquote><h1 id="f739" class="oz pa fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">Rule 5: Run regular tests but with the WASM WASI target.</h1><p id="d88e" class="pw-post-body-paragraph nh ni fq nj b go pv nl nm gr pw no np nq px ns nt nu py nw nx ny pz oa ob oc fj bk">It’s time to try to run <em class="oo">your </em>project on WASM WASI. As described in Rule 3, create a <code class="cx hd he hf hg b">.cargo/config.toml</code> file for your project. It tells Cargo how to run and test your project on WASM WASI.</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="610a" class="qt pa fq hg b bg qu qv l qw qx">[target.wasm32-wasip1]<br/>runner = "wasmtime run --dir ."</span></pre><p id="ac20" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Next, <a class="af ng" href="https://doc.rust-lang.org/rust-by-example/testing.html" rel="noopener ugc nofollow" target="_blank">your project — like all good code — should already contain tests</a>. My <code class="cx hd he hf hg b">range-set-blaze</code> project includes, for example, this test:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="3721" class="qt pa fq hg b bg qu qv l qw qx">#[test]<br/>fn insert_255u8() {<br/>    let range_set_blaze = RangeSetBlaze::&lt;u8&gt;::from_iter([255]);<br/>    assert!(range_set_blaze.to_string() == "255..=255");<br/>}</span></pre><p id="04a1" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Let’s now attempt to run your project’s tests on WASM WASI. Use the following command:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="493f" class="qt pa fq hg b bg qu qv l qw qx">cargo test --target wasm32-wasip1</span></pre><p id="3591" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">If this works, you may be done — but it probably won’t work. When I try this on <code class="cx hd he hf hg b">range-set-blaze</code>, I get this error message that complains about using Rayon on WASM.</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="2f9a" class="qt pa fq hg b bg qu qv l qw qx"> error: Rayon cannot be used when targeting wasi32. Try disabling default features.<br/>  --&gt; C:\Users\carlk\.cargo\registry\src\index.crates.io-6f17d22bba15001f\criterion-0.5.1\src\lib.rs:31:1<br/>   |<br/>31 | compile_error!("Rayon cannot be used when targeting wasi32. Try disabling default features.");</span></pre><p id="1291" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">To fix this error, we must first understand Cargo features.</p><h1 id="0eb7" class="oz pa fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">Rule 6: Understand Cargo features.</h1><p id="33ed" class="pw-post-body-paragraph nh ni fq nj b go pv nl nm gr pw no np nq px ns nt nu py nw nx ny pz oa ob oc fj bk">To resolve issues like the Rayon error in Rule 5, it’s important to understand how Cargo features work.</p><p id="9227" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">In <code class="cx hd he hf hg b">Cargo.toml</code>, an optional <code class="cx hd he hf hg b">[features]</code> section allows you to define different configurations, or versions, of your project depending on which features are enabled or disabled. For example, here is a simplified part of the <code class="cx hd he hf hg b">Cargo.toml</code> file from the <a class="af ng" href="https://github.com/bheisler/criterion.rs/blob/master/Cargo.toml" rel="noopener ugc nofollow" target="_blank">Criterion benchmarking project</a>:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="8f39" class="qt pa fq hg b bg qu qv l qw qx">[features]<br/>default = ["rayon", "plotters", "cargo_bench_support"]<br/>rayon = ["dep:rayon"]<br/>plotters = ["dep:plotters"]<br/>html_reports = []<br/>cargo_bench_support = []<br/><br/>[dependencies]<br/>#...<br/># Optional dependencies<br/>rayon = { version = "1.3", optional = true }<br/>plotters = { version = "^0.3.1", optional = true, default-features = false, features = [<br/>    "svg_backend",<br/>    "area_series",<br/>    "line_series",<br/>] }</span></pre><p id="9459" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">This defines four Cargo features: <code class="cx hd he hf hg b">rayon</code>, <code class="cx hd he hf hg b">plotters</code>, <code class="cx hd he hf hg b">html_reports</code>, and <code class="cx hd he hf hg b">cargo_bench_support</code>. Since each feature can be included or excluded, these four features create 16 possible configurations of the project. Note also the special default Cargo feature.</p><p id="fa65" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">A Cargo feature can include other Cargo features. In the example, the special <code class="cx hd he hf hg b">default</code> Cargo feature includes three other Cargo features — <code class="cx hd he hf hg b">rayon</code>, <code class="cx hd he hf hg b">plotters</code>, and <code class="cx hd he hf hg b">cargo_bench_support</code>.</p><p id="1b49" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">A Cargo feature can include a dependency. The <code class="cx hd he hf hg b">rayon</code> Cargo feature above includes the <code class="cx hd he hf hg b">rayon</code> crate as a dependent package.</p><p id="346a" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Moreover, dependent packages may have their own Cargo features. For example, the <code class="cx hd he hf hg b">plotters</code> Cargo feature above includes the <code class="cx hd he hf hg b">plotters</code> dependent package with the following Cargo features enabled: <code class="cx hd he hf hg b">svg_backend</code>, <code class="cx hd he hf hg b">area_series</code>, and <code class="cx hd he hf hg b">line_series</code>.</p><p id="2621" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">You can specify which Cargo features to enable or disable when running <code class="cx hd he hf hg b">cargo check</code>, <code class="cx hd he hf hg b">cargo build</code>, <code class="cx hd he hf hg b">cargo run</code>, or <code class="cx hd he hf hg b">cargo test</code>. For instance, if you’re working on the Criterion project and want to check only the <code class="cx hd he hf hg b">html_reports</code> feature without any defaults, you can run:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="a730" class="qt pa fq hg b bg qu qv l qw qx">cargo check --no-default-features --features html_reports</span></pre><p id="fa00" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">This command tells Cargo not to include any Cargo features by default but to specifically enable the <code class="cx hd he hf hg b">html_reports</code> Cargo feature.</p><p id="d390" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Within your Rust code, you can include/exclude code items based on enabled Cargo features. The syntax uses <code class="cx hd he hf hg b">#cfg(…)</code>, as per Rule 4:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="ec76" class="qt pa fq hg b bg qu qv l qw qx">#[cfg(feature = "html_reports")]<br/>SOME_CODE_ITEM</span></pre><p id="e991" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">With this understanding of Cargo features, we can now attempt to fix the <code class="cx hd he hf hg b">Rayon</code> error we encountered when running tests on WASM WASI.</p><h1 id="cbb1" class="oz pa fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">Rule 7: Change the things you can: dependency issues by choosing Cargo features, 64-bit/32-bit issues.</h1><p id="634d" class="pw-post-body-paragraph nh ni fq nj b go pv nl nm gr pw no np nq px ns nt nu py nw nx ny pz oa ob oc fj bk">When we tried running <code class="cx hd he hf hg b">cargo test --target wasm32-wasip1</code>, part of the error message stated: <code class="cx hd he hf hg b">Criterion ... Rayon cannot be used when targeting wasi32. Try disabling default features.</code> This suggests we should disable Criterion’s <code class="cx hd he hf hg b">rayon</code> Cargo feature when targeting WASM WASI.</p><p id="b7d1" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">To do this, we need to make two changes in our <code class="cx hd he hf hg b">Cargo.toml</code>. First, we need to disable the <code class="cx hd he hf hg b">rayon</code> feature from Criterion in the <code class="cx hd he hf hg b">[dev-dependencies]</code> section. So, this starting configuration:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="df40" class="qt pa fq hg b bg qu qv l qw qx">[dev-dependencies]<br/>criterion = { version = "0.5.1", features = ["html_reports"] }</span></pre><p id="653d" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">becomes this, where we explicitly turn off the default features for Criterion and then enable all the Cargo features except <code class="cx hd he hf hg b">rayon</code>.</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="4b69" class="qt pa fq hg b bg qu qv l qw qx">[dev-dependencies]<br/>criterion = { version = "0.5.1", features = [<br/>        "html_reports",<br/>        "plotters",<br/>        "cargo_bench_support"],<br/>      default-features = false }</span></pre><p id="530c" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Next, to ensure <code class="cx hd he hf hg b">rayon</code> is still used for non-WASM targets, we add it back in with a conditional dependency in <code class="cx hd he hf hg b">Cargo.toml</code> as follows:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="79a0" class="qt pa fq hg b bg qu qv l qw qx">[target.'cfg(not(target_arch = "wasm32"))'.dev-dependencies]<br/>criterion = { version = "0.5.1", features = ["rayon"] }</span></pre><p id="8d76" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">In general, when targeting WASM WASI, you may need to modify your dependencies and their Cargo features to ensure compatibility. Sometimes this process is straightforward, but other times it can be challenging — or even impossible, as we’ll discuss in Rule 8.</p><blockquote class="ol om on"><p id="5165" class="nh ni oo nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Aside: In the <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e" rel="noopener">third article</a> in this series — about <code class="cx hd he hf hg b">no_std</code> and embedded — we go deeper into strategies for fixing dependencies.</p></blockquote><p id="7a7b" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">After running the tests again, we move past the previous error, only to encounter a new one, which is progress!</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="e9d5" class="qt pa fq hg b bg qu qv l qw qx">#[test]<br/>fn test_demo_i32_len() {<br/>    assert_eq!(demo_i32_len(i32::MIN..=i32::MAX), u32::MAX as usize + 1);<br/>                                                  ^^^^^^^^^^^^^^^^^^^^^ attempt to compute <br/>`usize::MAX + 1_usize`, which would overflow<br/>}</span></pre><p id="9a3f" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">The compiler complains that <code class="cx hd he hf hg b">u32::MAX as usize + 1</code> overflows. On 64-bit Windows the expression doesn’t overflow because <code class="cx hd he hf hg b">usize</code> is the same as <code class="cx hd he hf hg b">u64</code> and can hold <code class="cx hd he hf hg b">u32::MAX as usize + 1</code>. WASM, however, is a 32-bit environment so <code class="cx hd he hf hg b">usize</code> is the same as <code class="cx hd he hf hg b">u32</code> and the expression is one too big.</p><p id="32df" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">The fix here is to replace <code class="cx hd he hf hg b">usize</code> with <code class="cx hd he hf hg b">u64</code>, ensuring that the expression doesn’t overflow. More generally, the compiler won’t always catch these issues, so it’s important to review your use of <code class="cx hd he hf hg b">usize</code> and <code class="cx hd he hf hg b">isize</code>. If you’re referring to the size or index of a Rust data structure, <code class="cx hd he hf hg b">usize</code> is correct. However, if you’re dealing with values that exceed 32-bit limits, you should use <code class="cx hd he hf hg b">u64</code> or <code class="cx hd he hf hg b">i64</code>.</p><blockquote class="ol om on"><p id="a467" class="nh ni oo nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk"><strong class="nj fr">Aside</strong>: In a 32-bit environment, a Rust array, <code class="cx hd he hf hg b">Vec</code>, <code class="cx hd he hf hg b">BTreeSet</code>, etc., can theoretically hold up to 2³²−1 = 4,294,967,295 elements. However, this is only a theoretical limit based on addressable memory.</p><p id="eeeb" class="nh ni oo nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk"><strong class="nj fr">Aside Aside</strong>: The actual maximum number of elements is even more limited. <a class="af ng" href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset" rel="noopener ugc nofollow" target="_blank">Rust limits our allocations to an </a><code class="cx hd he hf hg b"><a class="af ng" href="https://doc.rust-lang.org/std/primitive.pointer.html#method.offset" rel="noopener ugc nofollow" target="_blank">isize</a></code>, so 2³¹−1 (about 2 billion) bytes. If each element is, for example, 2 bytes, we can have at most about 1 billion elements.</p></blockquote><p id="aec8" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">So, we’ve fixed the dependency issue and addressed a <code class="cx hd he hf hg b">usize</code> overflow. But can we fix everything? Unfortunately, the answer is no.</p><h1 id="87eb" class="oz pa fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">Rule 8: Accept that you cannot change everything: Networking, Tokio, Rayon, etc.</h1><p id="a82c" class="pw-post-body-paragraph nh ni fq nj b go pv nl nm gr pw no np nq px ns nt nu py nw nx ny pz oa ob oc fj bk">WASM WASI Preview 1 (the current version) supports file access (within a specified directory), reading environment variables, and working with time and random numbers. However, its capabilities are limited compared to what you might expect from a full operating system.</p><p id="e48a" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">If your project requires access to networking, asynchronous tasks with Tokio, or multithreading with Rayon, Unfortunately, these features aren’t supported in Preview 1.</p><p id="b5fe" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Fortunately, WASM WASI Preview 2 is expected to improve upon these limitations, offering more features, including better support for networking and possibly asynchronous tasks.</p><h1 id="cee4" class="oz pa fq bf pb pc pd gq pe pf pg gt ph pi pj pk pl pm pn po pp pq pr ps pt pu bk">Rule 9: Add WASM WASI to your CI (continuous integration) tests.</h1><p id="b187" class="pw-post-body-paragraph nh ni fq nj b go pv nl nm gr pw no np nq px ns nt nu py nw nx ny pz oa ob oc fj bk">So, your tests pass on WASM WASI, and your project runs successfully. Are you done? Not quite. Because, as I like to say:</p><blockquote class="qa"><p id="bf9a" class="qb qc fq bf qd qe qf qg qh qi qj oc dx">If it’s not in CI, it doesn’t exist.</p></blockquote><p id="a544" class="pw-post-body-paragraph nh ni fq nj b go qk nl nm gr ql no np nq qm ns nt nu qn nw nx ny qo oa ob oc fj bk">Continuous integration (CI) is a system that can automatically run your tests every time you update your code, ensuring that your code continues to work as expected. By adding WASM WASI to your CI, you can guarantee that future changes won’t break your project’s compatibility with the WASM WASI target.</p><p id="5a95" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">In my case, my project is hosted on GitHub, and I use GitHub Actions as my CI system. Here’s the configuration I added to <code class="cx hd he hf hg b">.github/workflows/ci.yml</code> to test my project on WASM WASI:</p><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="0034" class="qt pa fq hg b bg qu qv l qw qx">test_wasip1:<br/>      name: Test WASI P1<br/>      runs-on: ubuntu-latest<br/>      steps:<br/>        - name: Checkout<br/>          uses: actions/checkout@v4<br/>        - name: Set up Rust<br/>          uses: dtolnay/rust-toolchain@master<br/>          with:<br/>            toolchain: stable<br/>            targets: wasm32-wasip1<br/>        - name: Install Wasmtime<br/>          run: |<br/>            curl https://wasmtime.dev/install.sh -sSf | bash<br/>            echo "${HOME}/.wasmtime/bin" &gt;&gt; $GITHUB_PATH<br/>        - name: Run WASI tests<br/>          run: cargo test --verbose --target wasm32-wasip1</span></pre><p id="e468" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">By integrating WASM WASI into CI, I can confidently add new code to my project. CI will automatically test that all my code continues to support WASM WASI in the future.</p></div></div></div><div class="ab cb or os ot ou" role="separator"><span class="ov by bm ow ox oy"/><span class="ov by bm ow ox oy"/><span class="ov by bm ow ox"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="4f15" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">So, there you have it — nine rules for porting your Rust code to WASM WASI. Here is what surprised me about porting to WASM WASI:</p><p id="da1a" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk"><strong class="nj fr">The Bad:</strong></p><ul class=""><li id="693b" class="nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc op oe of bk">Running on WASM WASI offers little utility today. It, however, holds the potential to be useful tomorrow.</li><li id="3be0" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc op oe of bk">In Rust, there’s a common saying: “If it compiles, it works.” Unfortunately, this doesn’t always hold true for WASM WASI. If you use an unsupported feature, like networking, the compiler won’t catch the error. Instead, it will fail at runtime. For example, this code compiles and runs on WASM WASI but always returns an error because networking isn’t supported.</li></ul><pre class="mq mr ms mt mu qq hg qr bp qs bb bk"><span id="3e75" class="qt pa fq hg b bg qu qv l qw qx">use std::net::TcpStream;<br/><br/>fn main() {<br/>    match TcpStream::connect("crates.io:80") {<br/>        Ok(_) =&gt; println!("Successfully connected."),<br/>        Err(e) =&gt; println!("Failed to connect: {e}"),<br/>    }<br/>}</span></pre><p id="5717" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk"><strong class="nj fr">The Good:</strong></p><ul class=""><li id="1368" class="nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc op oe of bk">Running on WASM WASI is a good first step toward <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1" rel="noopener">running your code in the browser</a> and on embedded systems.</li><li id="b1d4" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc op oe of bk">You can run Rust code on WASM WASI without needing to port to <code class="cx hd he hf hg b">no_std</code>. (Porting to <code class="cx hd he hf hg b">no_std</code> is the topic of the <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e" rel="noopener">third article</a> of this series.)</li><li id="8656" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc op oe of bk">You can run standard Rust tests on WASM WASI, making it easy to verify your code.</li><li id="fd7e" class="nh ni fq nj b go og nl nm gr oh no np nq oi ns nt nu oj nw nx ny ok oa ob oc op oe of bk">The <code class="cx hd he hf hg b">.cargo/config.toml</code> file and Rust’s <code class="cx hd he hf hg b">--target</code> option make it incredibly straightforward to configure and run your code on different targets—including WASM WASI.</li></ul><p id="7a40" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk">Stay tuned! In <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1" rel="noopener">the next article</a>, you’ll see how to port your Rust code to run on WASM in the browser — an ability I find super useful. After that, the <a class="af ng" href="https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e" rel="noopener">final article</a> will explain porting code to embedded systems, which I find incredibly cool.</p><p id="f18a" class="pw-post-body-paragraph nh ni fq nj b go nk nl nm gr nn no np nq nr ns nt nu nv nw nx ny nz oa ob oc fj bk"><em class="oo">Aside: </em>Interested in future articles? <em class="oo">Please </em><a class="af ng" href="https://medium.com/@carlmkadie" rel="noopener"><em class="oo">follow me on Medium</em></a><em class="oo">. I write about Rust and Python, scientific programming, machine learning, and statistics. I tend to write about one article per month.</em></p></div></div></div></div>    
</body>
</html>
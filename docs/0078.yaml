- en: 'Probabilistic Data Structures Decoded: Enhancing Performance in Modern Computing'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概率数据结构解码：提升现代计算性能
- en: 原文：[https://towardsdatascience.com/probabilistic-data-structures-decoded-enhancing-performance-in-modern-computing-17f700e6ea47?source=collection_archive---------5-----------------------#2024-01-09](https://towardsdatascience.com/probabilistic-data-structures-decoded-enhancing-performance-in-modern-computing-17f700e6ea47?source=collection_archive---------5-----------------------#2024-01-09)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/probabilistic-data-structures-decoded-enhancing-performance-in-modern-computing-17f700e6ea47?source=collection_archive---------5-----------------------#2024-01-09](https://towardsdatascience.com/probabilistic-data-structures-decoded-enhancing-performance-in-modern-computing-17f700e6ea47?source=collection_archive---------5-----------------------#2024-01-09)
- en: The Ultimate Guide to Understanding and Implementing Bloom Filters and Count
    Min Sketch in Python
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布隆过滤器与Count Min Sketch在Python中的实现与理解终极指南
- en: '[](https://namanagr03.medium.com/?source=post_page---byline--17f700e6ea47--------------------------------)[![Naman
    Agrawal](../Images/6bb885397aec17f5029cfac7f01edad9.png)](https://namanagr03.medium.com/?source=post_page---byline--17f700e6ea47--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--17f700e6ea47--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--17f700e6ea47--------------------------------)
    [Naman Agrawal](https://namanagr03.medium.com/?source=post_page---byline--17f700e6ea47--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://namanagr03.medium.com/?source=post_page---byline--17f700e6ea47--------------------------------)[![Naman
    Agrawal](../Images/6bb885397aec17f5029cfac7f01edad9.png)](https://namanagr03.medium.com/?source=post_page---byline--17f700e6ea47--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--17f700e6ea47--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--17f700e6ea47--------------------------------)
    [Naman Agrawal](https://namanagr03.medium.com/?source=post_page---byline--17f700e6ea47--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--17f700e6ea47--------------------------------)
    ·26 min read·Jan 9, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--17f700e6ea47--------------------------------)
    ·阅读时间：26分钟·2024年1月9日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/4192b4e13217e5e16700e6354b81f9c6.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4192b4e13217e5e16700e6354b81f9c6.png)'
- en: 'Photo by Google DeepMind: [https://www.pexels.com/photo/an-artist-s-illustration-of-artificial-intelligence-ai-this-image-visualises-the-input-and-output-of-neural-networks-and-how-ai-systems-perceive-data-it-was-created-by-rose-pilkington-17485706/](https://www.pexels.com/photo/an-artist-s-illustration-of-artificial-intelligence-ai-this-image-visualises-the-input-and-output-of-neural-networks-and-how-ai-systems-perceive-data-it-was-created-by-rose-pilkington-17485706/)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来自 Google DeepMind：[https://www.pexels.com/photo/an-artist-s-illustration-of-artificial-intelligence-ai-this-image-visualises-the-input-and-output-of-neural-networks-and-how-ai-systems-perceive-data-it-was-created-by-rose-pilkington-17485706/](https://www.pexels.com/photo/an-artist-s-illustration-of-artificial-intelligence-ai-this-image-visualises-the-input-and-output-of-neural-networks-and-how-ai-systems-perceive-data-it-was-created-by-rose-pilkington-17485706/)
- en: Contents
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 介绍
- en: What is a Probabilistic Data Structure?
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是概率数据结构？
- en: Bloom Filters
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布隆过滤器
- en: 3.1 How Do They Work
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.1 它们是如何工作的
- en: 3.2 Implementing Bloom Filters in Python
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.2 用Python实现布隆过滤器
- en: '3.3 Bloom Filters: Time & Space Complexity Analysis'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.3 布隆过滤器：时间与空间复杂度分析
- en: '3.4 Bloom Filters: The Math'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.4 布隆过滤器：数学分析
- en: Count Min Sketch
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Count Min Sketch
- en: 3.1 How Do They Work
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.1 它们是如何工作的
- en: 3.2 Implementing Count Min Sketch in Python
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.2 用Python实现Count Min Sketch
- en: '3.3 Count Min Sketch: Time & Space Complexity Analysis'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.3 Count Min Sketch：时间与空间复杂度分析
- en: '3.4 Count Min Sketch: The Math'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.4 Count Min Sketch：数学分析
- en: The Bottom Line
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结论
- en: References
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考文献
- en: '**Note:** The entire code file used in this article is available at the following
    repository: [https://github.com/namanlab/Probabilistic_Data_Structures](https://github.com/namanlab/Probabilistic_Data_Structures)'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 本文中使用的完整代码文件可以在以下仓库中找到：[https://github.com/namanlab/Probabilistic_Data_Structures](https://github.com/namanlab/Probabilistic_Data_Structures)'
- en: Introduction
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Computer science enthusiasts often find themselves enamored by the subtle charm
    of algorithms — the silent workhorses that streamline our digital interactions.
    At its core, programming is all about getting tasks done through the use of efficient
    algorithms synchronized with optimal data structures. That’s why there’s a whole
    field in Computer Science dedicated to the design and analysis of algorithms given
    their role as the architects of the digital age, quietly shaping our technological
    experiences with a blend of logic and precision.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学爱好者常常被算法的微妙魅力所吸引——这些默默无闻的工作马简化了我们的数字交互。编程的核心就是通过高效的算法与最佳数据结构的同步使用来完成任务。这也是为什么计算机科学中有一个专门的领域致力于算法的设计与分析，因为它们作为数字时代的建筑师，默默地塑造着我们的技术体验，融合了逻辑与精确。
- en: A traditional curriculum in data structures and algorithms often exposes students
    to some of the fundamental data structures (deterministic) such as Arrays, Linked
    Lists, Stacks and Queues, Binary Search Trees, AVL trees, Heaps, Hash Maps, and
    of course Graphs. Indeed, the study of such data structures and the associated
    algorithms constitutes the foundation for the development of much more sophisticated
    programs aimed at solving a variety of tasks. In this article, I will introduce
    probabilistic data structures such as Bloom Filters and Count-Min Sketch, some
    of the lesser-known data structures. While some introductory courses do talk about
    a few of these briefly, they constitute a subset of those data structures that
    are often neglected, yet come out as important ideas in various academic discussions.
    In this article, we will describe what probabilistic data structures are, their
    significance, examples, and their implementation, as well as go through some of
    the math required to better gauge their performance. Let’s begin!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的数据结构与算法课程通常会让学生接触一些基本的确定性数据结构，例如数组、链表、栈和队列、二叉搜索树、AVL树、堆、哈希映射，当然还有图。事实上，学习这些数据结构及相关算法构成了开发更复杂程序的基础，这些程序旨在解决各种任务。在本文中，我将介绍概率数据结构，如布隆过滤器和计数最小草图，这些较为鲜为人知的数据结构。虽然一些入门课程简要提到过这些，但它们只是通常被忽视的数据结构中的一部分，然而它们却在各种学术讨论中展现出重要性。在本文中，我们将描述什么是概率数据结构，它们的重要性，示例及其实现，并通过一些所需的数学知识来更好地评估它们的性能。让我们开始吧！
- en: What is a Probabilistic Data Structure?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是概率数据结构？
- en: Probabilistic data structures are clever tools in computer science that provide
    fast and memory-efficient approximations of certain operations. Unlike deterministic
    data structures, which always give precise and accurate results, probabilistic
    ones sacrifice a bit of accuracy for added efficiency. In simple terms, these
    structures use randomness to quickly estimate answers to questions without storing
    all the exact details; somewhat like smart shortcuts, making educated guesses
    rather than doing the full work.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 概率数据结构是计算机科学中的巧妙工具，它们提供了某些操作的快速且节省内存的近似值。与总是给出精确结果的确定性数据结构不同，概率数据结构为了提高效率，会牺牲一点准确性。简单来说，这些结构利用随机性快速估算问题的答案，而不需要存储所有精确的细节；有点像智能捷径，通过做出合理的猜测而不是执行所有的工作。
- en: Take the example of a bloom filter, a probabilistic data structure quite similar
    to HashSet. It helps you check whether an element is likely in a set or definitely
    not. It might say ”possibly in the set” or ”definitely not in the set,” but it
    won’t guarantee ”definitely in the set.” This uncertainty allows it to be fast
    and save a lot more memory than a traditional hash set.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以布隆过滤器为例，它是一种与 HashSet 非常相似的概率数据结构。它帮助你检查一个元素是否可能在一个集合中，或者肯定不在。它可能会说“可能在集合中”或者“肯定不在集合中”，但不会保证“肯定在集合中”。这种不确定性使它能够更快速，并比传统的哈希集节省更多内存。
- en: Deterministic data structures such as linked lists and AVL trees that we commonly
    encounter, on the other hand, give you 100% sure answers. For example, if you
    ask whether an element is in a hash set, it’ll say ”yes” or ”no” without any doubt.
    However, this certainty often comes at the cost of using more memory or taking
    longer to process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们常见的确定性数据结构，如链表和 AVL 树，则会给出 100% 确定的答案。例如，如果你询问某个元素是否在哈希集内，它会毫不犹豫地回答“是”或“否”。然而，这种确定性往往以使用更多内存或更长时间的处理为代价。
- en: 'The over-arching idea is that probabilistic data structures trade a bit of
    accuracy for speed and efficiency, making them handy in situations where you can
    tolerate a small chance of error. They’re like quick and savvy assistants that
    provide close-to-perfect answers without doing all the heavy lifting. Imagine
    you have a huge collection of data and want to perform operations like searching,
    inserting, or checking membership. Deterministic structures guarantee correctness
    but may become sluggish when dealing with massive datasets. Probabilistic structures,
    by embracing a bit of uncertainty, provide a way to handle these tasks swiftly
    and with reduced memory requirements. For the rest of this article, we will explore
    some of the commonly used probabilistic data structures: Bloom Filters and Count-Min
    Sketch. Let’s start with Bloom Filters!'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总体的思路是，概率数据结构通过牺牲一点准确性来换取速度和效率，这使得它们在可以容忍少量错误的情况下非常有用。它们就像快速而聪明的助手，提供几乎完美的答案，却不需要做所有繁重的工作。假设你有一个庞大的数据集，并且需要执行像搜索、插入或检查成员资格之类的操作。确定性结构能够保证正确性，但在处理海量数据时可能会变得缓慢。通过接受一定的不确定性，概率结构提供了一种快速处理这些任务并减少内存需求的方法。在接下来的文章中，我们将探讨一些常用的概率数据结构：布隆过滤器和计数最小概述。让我们从布隆过滤器开始！
- en: Bloom Filters
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布隆过滤器
- en: 'Bloom filters are designed for quick and memory-efficient membership tests
    i.e., they help answer the question: ”Is this element a member of a set?” They
    are particularly handy in scenarios where speed and resource conservation are
    critical, such as database lookups, network routers, and caching systems.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 布隆过滤器旨在提供快速且内存高效的成员资格测试，即它们帮助回答这样的问题：“这个元素是集合的成员吗？”它们在速度和资源节省至关重要的场景中尤为有用，比如数据库查找、网络路由器和缓存系统。
- en: How Do They Work?
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它们是如何工作的？
- en: A bloom filter is implemented as an m-sized bit array, which is just an array
    of size m that is filled with either 0 or 1\. An empty bloom filter is initially
    filled with all 0s. Whenever an element is added, a set of hash functions maps
    the element to a set of indices. A hash function is a function that transforms
    input data of any size into a small integer (called a hash code or hash value)
    that can be used as the index.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 布隆过滤器实现为一个大小为 m 的位数组，实际上就是一个大小为 m 的数组，数组中的每个元素是 0 或 1。一个空的布隆过滤器最初用全 0 填充。每当添加一个元素时，一组哈希函数将元素映射到一组索引。哈希函数是将任何大小的输入数据转换为一个小的整数（称为哈希值或哈希码），该整数可以作为索引使用。
- en: Recall, how a traditional hash set works. A traditional hash set applies just
    one hash function on the input data (the element to be added to the set) and produces
    a hash code corresponding to the index to which the element is added to the table.
    While this approach provides a simple and fast way to organize and retrieve data
    (usually in constant, O(1) time), it comes with inherent memory inefficiencies,
    primarily related to collisions and fixed-size tables.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下传统哈希集合的工作原理。传统的哈希集合对输入数据（即要添加到集合中的元素）应用一个哈希函数，并生成一个哈希值，该值对应于元素在表中的索引位置。尽管这种方法提供了一种简单且快速的组织和检索数据的方式（通常是常数时间
    O(1)），但它存在固有的内存低效问题，主要与哈希冲突和固定大小的表有关。
- en: The use of a single hash function can lead to collisions, where different elements
    produce the same hash code and attempt to occupy the same index in the hash table.
    This affects the efficiency of the hash set, as it necessitates additional mechanisms
    to handle and resolve such conflicts. Moreover, the fixed size of the hash table
    leads to inefficiencies in adapting to varying workloads. As the number of elements
    increases or decreases, the load factor (the ratio of elements to the table size)
    may become unfavorable. This can lead to increased collisions and degradation
    of performance. To counter this, hash sets often need to be resized, a process
    that involves creating a new, larger table and rehashing all existing elements.
    This operation, while necessary, introduces additional computational overhead
    and memory requirements.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单一哈希函数可能导致哈希冲突，即不同的元素生成相同的哈希值并试图占用哈希表中的相同索引。这会影响哈希集合的效率，因为需要额外的机制来处理和解决此类冲突。此外，哈希表的固定大小导致在处理不同工作负载时效率低下。随着元素数量的增加或减少，负载因子（元素与表大小的比例）可能变得不利。这可能导致更多的哈希冲突和性能下降。为了解决这个问题，哈希集合通常需要重新调整大小，这一过程涉及创建一个新的、更大的表并重新哈希所有现有元素。尽管这个操作是必要的，但它会引入额外的计算开销和内存需求。
- en: A bloom filter on the other hand doesn’t need such a large table, it can do
    the job with a smaller m-sized array and through the use of multiple hash functions
    (say, k different hash functions) instead of just a single one. The filter works
    by applying all the k hash functions on the input data and marking all the k output
    indices as 1 in the original array. Here’s an example to show how it works.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Bloom Filter 不需要如此大的表格，它可以通过较小的 m 大小数组并使用多个哈希函数（例如，k 个不同的哈希函数）来完成工作，而不是仅仅使用一个。该过滤器的工作原理是对输入数据应用所有
    k 个哈希函数，并将所有 k 个输出索引在原数组中标记为 1。以下是一个示例，展示其工作原理。
- en: 'Suppose, we have an m = 5-bit sized array initially filled with 0s and k =
    2 hash functions. Usually, the hash functions we use must satisfy two key properties:
    i) they should be fast to compute, and ii) the output should be more or less uniformly
    distributed to minimize the risk of false positives (don’t worry, details will
    be discussed later). Next, we add the elements 64 and 78 to the array.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 m = 5 位大小的数组，最初填充为 0，且有 k = 2 个哈希函数。通常，我们使用的哈希函数必须满足两个关键特性：i) 它们应该计算快速，ii)
    输出应该大致均匀分布，以尽量减少假阳性的风险（别担心，细节稍后会讨论）。接下来，我们将元素 64 和 78 添加到数组中。
- en: '![](../Images/bcefca769e3234baab4a582897714f1f.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bcefca769e3234baab4a582897714f1f.png)'
- en: Bloom Filter Example [Image by Author]
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Bloom Filter 示例 [图片由作者提供]
- en: The above diagram illustrates the process of adding the entries to the array.
    Once the entries have been added, we can do the membership test. Suppose, we test
    for the membership of element 36\. If h1 and h2 produce index 0 and 3, we can
    easily see that index 0 has not been occupied yet. This means, that for certain
    the element is not present in the set. However, we may get the index 2 instead
    of 3, which is already marked as occupied. This may lead us to the wrong conclusion
    that 36 is present in the set, even though this was never the case. This is a
    situation of false positives, that is why we say that a bloom filter can only
    guarantee when an element is not present. If the element is said to be present,
    there is still the possibility that it might not be, although the probability
    of such a case can be made quite small by adjusting the values of m and k.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了将条目添加到数组中的过程。一旦条目被添加，我们就可以进行成员测试。假设我们测试元素 36 的成员资格。如果 h1 和 h2 产生索引 0 和
    3，我们可以很容易地看到索引 0 尚未被占用。这意味着该元素一定不在集合中。然而，我们可能会得到索引 2 而不是 3，而索引 2 已经被标记为已占用。这可能导致我们错误地得出结论，认为
    36 在集合中，即使实际上并非如此。这就是假阳性的情况，这也是为什么我们说 Bloom Filter 只能保证当元素不在时。如果元素被认为存在，仍然有可能它并不在，尽管通过调整
    m 和 k 的值，可以将这种情况的概率降到很小。
- en: 'If you’re still not clear, it may help to imagine a bloom filter as a compact
    checklist with empty boxes. This checklist represents a set that is initially
    empty. When you add an element to the set, the bloom filter fills in certain boxes
    based on the element’s characteristics: each element is hashed multiple times
    using different hash functions which determine which boxes to mark in the checklist.
    Multiple hash functions ensure that different parts of the checklist are affected,
    making it more resilient to false positives. When you want to check if an element
    is in the set, you hash it using the same functions that marked the boxes during
    insertion. If all the corresponding boxes are marked, the bloom filter suggests
    that the element might be in the set. However, false positives can occur — the
    filter might claim an element is in the set when it’s not. False negatives, on
    the other hand, never happen. If the boxes aren’t marked, the element is definitely
    not in the set.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然不清楚，可以将 Bloom Filter 想象成一个紧凑的检查表，里面有空框。这个检查表代表一个最初为空的集合。当你向集合中添加一个元素时，Bloom
    Filter 会根据该元素的特征填写某些框：每个元素都会使用不同的哈希函数进行多次哈希，从而决定标记哪些框。多个哈希函数确保检查表的不同部分受到影响，从而使其对假阳性更具弹性。当你想检查某个元素是否在集合中时，你使用在插入时标记框的相同哈希函数进行哈希。如果所有相应的框都被标记，那么
    Bloom Filter 会提示该元素可能在集合中。然而，假阳性可能会发生——过滤器可能会错误地声明元素在集合中，而实际上并不在。另一方面，假阴性永远不会发生。如果框没有被标记，则该元素一定不在集合中。
- en: As you can see, bloom filters offer speed and efficiency at the expense of some
    trade-offs. They can produce false positives, but never false negatives. They
    are fantastic for scenarios where saving memory and quickly filtering out non-members
    is crucial, but may not be ideal for applications where absolute certainty is
    required. Now, let’s try to implement them in Python!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，布隆过滤器在速度和效率方面提供了优势，但也有一些权衡。它们可能会产生假阳性，但绝不会产生假阴性。它们非常适合需要节省内存并快速筛选出非成员的场景，但可能不适用于那些需要绝对确定性的应用。现在，让我们尝试用
    Python 实现它们吧！
- en: Implementing Bloom Filters in Python
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用 Python 实现布隆过滤器
- en: Following is the Python implementation of a Bloom Filter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是布隆过滤器的 Python 实现。
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the above code, we’ve used the bitarray library for a more memory-efficient
    representation of the filter. You can install it using: *pip3 install bitarray*
    command.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了 bitarray 库来更高效地表示过滤器。你可以通过以下命令安装它：*pip3 install bitarray*。
- en: The BloomFilter class is initialized with a specified size (representing the
    number of bits in the internal bit array) and the number of hash functions to
    use. The class has methods to add elements to the filter (add) and check for their
    probable presence (contains). The hash function method is a private function generating
    hash values based on the SHA-256 algorithm (it’s a good choice since it is known
    to produce uniformly distributed outputs).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: BloomFilter 类通过指定的大小（表示内部位数组的位数）和使用的哈希函数数量进行初始化。该类具有将元素添加到过滤器中（add）和检查元素可能存在的（contains）方法。哈希函数方法是一个私有函数，基于
    SHA-256 算法生成哈希值（它是一个不错的选择，因为它已知能产生均匀分布的输出）。
- en: 'Bloom Filters: Time & Space Complexity Analysis'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布隆过滤器：时间与空间复杂度分析
- en: Let’s also do a quick time and space analysis of bloom filters. In terms of
    time complexity, both adding elements (add operation) and checking for their probable
    presence (contains operation) are constant time operations — O(k), where k is
    the number of hash functions. This is because the filter involves multiple hash
    functions, each contributing a constant time to the overall process (assuming
    that hash functions can be evaluated in constant time).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来做一个简短的时间和空间复杂度分析。在时间复杂度方面，添加元素（add 操作）和检查其可能存在（contains 操作）都是常数时间操作 — O(k)，其中
    k 是哈希函数的数量。这是因为过滤器涉及多个哈希函数，每个哈希函数对整体过程贡献一个常数时间（假设哈希函数可以在常数时间内计算）。
- en: In terms of space complexity, Bloom Filters are memory-efficient since they
    use a fixed-size bit array. The space required is proportional to the size of
    the array and the number of hash functions employed. The space complexity is O(m),
    where m is the size of the bit array. The space efficiency is especially advantageous
    when dealing with large datasets, as the filter can represent a set of elements
    using significantly less memory compared to other data structures.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在空间复杂度方面，布隆过滤器具有内存高效的特点，因为它们使用固定大小的位数组。所需的空间与数组的大小和使用的哈希函数数量成正比。空间复杂度是 O(m)，其中
    m 是位数组的大小。当处理大型数据集时，空间效率尤为有利，因为过滤器可以用比其他数据结构少得多的内存表示一个元素集合。
- en: 'Bloom Filters: The Math'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布隆过滤器：数学分析
- en: Finally, when it comes to probabilistic data structures, it becomes quintessential
    to at least propose a bound on the error they can make since they aren’t perfect,
    unlike their deterministic counterparts. Here, we will go through some math to
    quantify the probability of making a false positive error and use that to derive
    meaningful insights.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，谈到概率数据结构时，提出它们可能产生的误差界限变得至关重要，因为与确定性数据结构不同，它们并不是完美的。在这里，我们将通过一些数学推导来量化产生假阳性错误的概率，并利用这个概率来得出有意义的结论。
- en: 'First, suppose we have an m-sized bit array along with k hash functions. Furthermore,
    we assume that our hash functions work uniformly, i.e., for any given input they
    are equally likely to select any of the m lots in the array. Then, the probability
    of a particular index i being selected is:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设我们有一个大小为 m 的位数组以及 k 个哈希函数。此外，我们假设哈希函数是均匀工作的，即对于任何给定的输入，它们选择位数组中任意 m 个位置的概率是相等的。那么，某个特定索引
    i 被选中的概率是：
- en: '![](../Images/e80200507ce7dad84a05d8863c43a2f4.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e80200507ce7dad84a05d8863c43a2f4.png)'
- en: 'Consequently, the probability that the ith index of the bit array is not selected
    is:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，位数组中第 i 个索引未被选中的概率是：
- en: '![](../Images/e8ed8d08a2fc10072ddbf1a69f602c6a.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e8ed8d08a2fc10072ddbf1a69f602c6a.png)'
- en: 'Now, we bring in the k hash functions. We assume that each of them works independently
    and produces an output. Further, suppose n elements have been already inserted
    into the array. This means, that the hash functions were used independently for
    a total of nk times. The probability that the ith index is still empty is therefore:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们引入k个哈希函数。我们假设它们每个都独立工作并产生一个输出。此外，假设n个元素已经插入到数组中。这意味着，哈希函数总共已独立使用了nk次。因此，第i个索引仍为空的概率为：
- en: '![](../Images/33e2cfe401208c6572672d72e75267c7.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/33e2cfe401208c6572672d72e75267c7.png)'
- en: 'Thus, the probability that the ith index is occupied is now:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第i个索引被占用的概率现在是：
- en: '![](../Images/7e9c2161cbccc6035cd98e945f5346e7.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7e9c2161cbccc6035cd98e945f5346e7.png)'
- en: 'When does a false positive occur? When the index returned by all the elements
    is 1 even though the element is not present in the set. This happens when the
    indices produced by all the k hash functions turn out to be occupied. Again, by
    the independence of the hash function assumption, this amounts to the following
    probability:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候会出现假阳性？当所有元素返回的索引值都是1，即使该元素并不在集合中时，就会发生假阳性。当所有k个哈希函数生成的索引都被占用时，就会发生这种情况。再次根据哈希函数独立性的假设，这就变成了以下概率：
- en: '![](../Images/89250e768d46d0986904e7c3603fd322.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/89250e768d46d0986904e7c3603fd322.png)'
- en: 'For sufficiently large values of m, we can approximate the above probability
    into a much simpler expression:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于足够大的m值，我们可以将上述概率近似为一个更简单的表达式：
- en: '![](../Images/6c5c50cc8ccef57b8a0c48625db778fd.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6c5c50cc8ccef57b8a0c48625db778fd.png)'
- en: Can we use this to find the optimal value of k that minimizes ε? Sure, it’s
    just a simple calculus exercise. We simply take the derivative of the above function
    with respect to k and set it to 0\. But, before that, we can simplify the function
    a bit by taking logarithms on both sides,
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否用这个方法找到最小化ε的最优k值？当然，这是一个简单的微积分练习。我们只需要对上述函数关于k求导并令其为0。但在此之前，我们可以通过对两边取对数来简化该函数，
- en: '![](../Images/1ce2d350910f32f4293ac3c38f071448.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1ce2d350910f32f4293ac3c38f071448.png)'
- en: 'This gives us the value of k that minimizes the false positive rate. To ensure
    that this is really the minimum of the error function, we would ideally want to
    calculate the second derivative of f(k) and verify our calculation. For the sake
    of simplicity, we’ve omitted the proof here, but it should be straightforward
    to show using simple calculus. Next, using the optimal value of k, we can find
    the minimum value of the error function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了最小化假阳性率的k值。为了确保这是误差函数的最小值，我们理想情况下需要计算f(k)的二阶导数并验证我们的计算。为了简化起见，我们在这里省略了证明，但通过简单的微积分可以很容易地展示。接下来，使用k的最优值，我们可以找到误差函数的最小值：
- en: '![](../Images/652c08b0ad3c78c713fc89639bdc0a7b.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/652c08b0ad3c78c713fc89639bdc0a7b.png)'
- en: 'Using the above expression, we can also solve for the optimal value of m:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述表达式，我们还可以求出m的最优值：
- en: '![](../Images/18611cdcf57b590e8ccf447ee95def6d.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/18611cdcf57b590e8ccf447ee95def6d.png)'
- en: Okay, that’s a lot of math. Let’s try to understand what and why we’ve done.
    First, we just used some simple probabilistic expressions to find the probability
    that the slot at the ith index remains empty after n elements have been inserted
    using k hash functions. Using this, we obtained the probability of false positive
    error as a function of n, k, and m. Then, we minimized the function with respect
    to k. Using this optimal value of k, we found the minimum value of the error function.
    Solving this for m allows us to determine the minimum size of the bit array such
    that we can tolerate a given value of error.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这涉及了很多数学内容。让我们试着理解我们做了什么以及为什么这么做。首先，我们只是使用了一些简单的概率表达式，找出了在插入n个元素并使用k个哈希函数后，第i个索引位置仍然为空的概率。通过这个，我们得到了假阳性误差的概率，它是n、k和m的函数。然后，我们对k进行了最小化处理。使用这个最优的k值，我们找到了误差函数的最小值。求解这个值对于m来说，让我们能够确定位数组的最小大小，从而容忍给定的误差值。
- en: 'Let’s take an example to better gauge these results. Suppose we want to implement
    a bloom filter and need to find the right values of m and k. We expect about 200,000
    elements to be inserted i.e., n = 200000, and the max false positive error we
    can tolerate is about 1% i.e., ε ̄ = 0.01 Then, the optimal values of m and k
    can be found as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子来更好地理解这些结果。假设我们要实现一个布隆过滤器，并需要找到m和k的合适值。我们预计大约会插入200,000个元素，即n = 200000，而我们可以容忍的最大假阳性误差约为1%，即ε
    ̄ = 0.01。那么，m和k的最优值可以通过以下方式找到：
- en: '![](../Images/452b4f6caf8198282ecbb033bb760d25.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/452b4f6caf8198282ecbb033bb760d25.png)'
- en: 'Using these calculations, we can optimize our original bloom filter implementation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些计算，我们可以优化原始的布隆过滤器实现：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this implementation, the OptimizedBloomFilter class dynamically calculates
    the optimal values for m and k based on the provided expected number of elements
    (n) and acceptable false positive rate (p). The calculate parameters method handles
    this calculation. The rest of the implementation remains similar to the previous
    version, with the optimized parameters improving space efficiency and minimizing
    the probability of false positives.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，`OptimizedBloomFilter`类根据提供的期望元素数量（n）和可接受的假阳性率（p）动态计算m和k的最佳值。`calculate
    parameters`方法负责执行此计算。其余实现与之前版本类似，优化后的参数提高了空间效率并最小化了假阳性的概率。
- en: 'This concludes our discussion on bloom filters. Hope you enjoyed reading so
    far! In the next section, we will discuss another important probabilistic data
    structure: Count Min Sketch.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们关于布隆过滤器的讨论。希望你到目前为止阅读愉快！在下一节中，我们将讨论另一种重要的概率数据结构：计数最小草图（Count Min Sketch）。
- en: Count Min Sketch
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数最小草图（Count Min Sketch）
- en: 'In this section, we will discuss another interesting probabilistic data structure:
    Count Min Sketch. Count Min Sketch is somewhat like an extension of Bloom Filters.
    Just as the probabilistic counterpart of a hash set is a bloom filter, the counterpart
    of a multi-set is a count min sketch.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论另一种有趣的概率数据结构：计数最小草图。计数最小草图在某种程度上是布隆过滤器的扩展。就像哈希集合的概率对应物是布隆过滤器一样，多重集合的对应物就是计数最小草图。
- en: 'A multi-set is essentially a set that also keeps count of the frequency or
    number of occurrences of an element in the input data stream. For instance, if
    input data is [2, 3, 3, 4, 1, 1, 0, 1, 0], a set would simply be the collection
    of unique elements i.e., {0, 1, 2, 3, 4}. But, a multi-set would also record the
    frequency, { 0: 2, 1: 3, 2: 1, 3: 3, 4: 1 }, which can be queried as per requirement.
    A traditional hash table uses the same data structure as a hash set but also records
    the frequency count of each element. While it is extremely efficient and can be
    queried in O(1), there may be a large memory cost to store all the elements as
    well as additional overhead to handle collisions.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '多重集合本质上是一个集合，它还记录了元素在输入数据流中出现的频率或次数。例如，如果输入数据是[2, 3, 3, 4, 1, 1, 0, 1, 0]，则一个集合仅仅是唯一元素的集合，即{0,
    1, 2, 3, 4}。但是，一个多重集合还会记录频率，即{0: 2, 1: 3, 2: 1, 3: 3, 4: 1}，可以根据需求进行查询。传统的哈希表使用与哈希集合相同的数据结构，但也记录了每个元素的频率计数。虽然它非常高效并且可以在O(1)时间内查询，但存储所有元素可能会有较大的内存开销，同时处理冲突时还会有额外的开销。'
- en: Just as before, count min sketch can be much more efficient than the deterministic
    hash table by significantly reducing the memory requirements and removing the
    unnecessary computational cost in handling collisions. But, it must pay the price
    of accuracy, which fortunately can be accounted for by adjusting for the values
    of m and k as before. Let us take a closer look at how count min sketch works.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，计数最小草图通过显著减少内存需求并去除处理冲突时的不必要计算开销，通常比确定性的哈希表更高效。但是，它必须付出准确性的代价，幸运的是，可以通过像以前一样调整m和k的值来解决这个问题。让我们更仔细地了解计数最小草图是如何工作的。
- en: How Do They Work?
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它们是如何工作的？
- en: The core idea behind Count Min Sketch involves using multiple hash functions
    to map input elements to an array of counters. The array is organized as a two-dimensional
    matrix, consisting of m columns and k rows with each row corresponding to the
    hash functions and the columns representing the counters. When an element is encountered
    in the data stream, it is hashed using each of the hash functions, and the corresponding
    counters in the matrix are incremented. Due to the nature of hash functions, collisions
    are inevitable. However, the use of multiple hash functions and a two-dimensional
    matrix allows Count Min Sketch to distribute the collisions across different counters.
    This distribution helps in reducing the impact of collisions on the accuracy of
    the counts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 计数最小草图的核心思想是使用多个哈希函数将输入元素映射到一个计数器数组。该数组被组织为一个二维矩阵，包含m列和k行，每行对应一个哈希函数，列代表计数器。当数据流中遇到一个元素时，它会使用每个哈希函数进行哈希处理，并相应地增加矩阵中的计数器。由于哈希函数的性质，冲突是不可避免的。然而，使用多个哈希函数和二维矩阵可以使计数最小草图将冲突分布到不同的计数器中。这种分布有助于减少冲突对计数准确性的影响。
- en: 'Suppose, we have an m = 5 (number of columns) and k = 2 (number of rows) hash
    functions. This means, we only need an array of size m×k = 5×2\. Initially, the
    array is filled with all 0s. Next, we add the elements 2, 3, 2, 2, and 1 to the
    set. The process is similar to that of a bloom filter. We apply the k hash filters
    on the input data (the element to be added) and get k indices. Let ji be the output
    of the ith hash function. Then, we increment the jith index of the ith row by
    1\. The following figure illustrates how it’s done:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有 m = 5（列数）和 k = 2（行数）个哈希函数。这意味着我们只需要一个大小为 m×k = 5×2 的数组。最初，该数组的所有元素都是 0。接下来，我们将元素
    2、3、2、2 和 1 添加到集合中。这个过程与布隆过滤器类似。我们对输入数据（待添加的元素）应用 k 个哈希函数，得到 k 个索引。假设 ji 是第 i
    个哈希函数的输出。然后，我们将第 i 行的 jith 索引值加 1。下图展示了这个过程的具体操作：
- en: '![](../Images/e2f74d630ade158add500c26316a616f.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e2f74d630ade158add500c26316a616f.png)'
- en: Count Min Sketch Example [Image by Author]
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Count Min Sketch 示例 [作者提供的图片]
- en: To estimate the frequency of an element, one looks up the counters corresponding
    to its hashed values and selects the minimum count among them. This minimum count
    provides an approximation of the true frequency. By repeating this process for
    multiple elements and taking the minimum counts, one can obtain approximate frequency
    estimates for various items in the data stream. For instance, if we query for
    the frequency of 2 in the set, we look at the minimum of 3 and 4 which is 3, and
    this is indeed the frequency of 2 in the input stream. Similarly, the frequency
    of 1 is the minimum of 1 and 4, which is 1, again the correct output. It is important
    to note that count min sketch only provides a maximum bound on the frequency of
    an element. This bound is derived from the way the algorithm distributes counts
    across different counters. It may be possible that the indices corresponding to
    the output of all the k hash functions on the input data might be incremented,
    not because of the addition of that element per se, but all the other elements
    in that set. An example is shown below, when we add 4 to the set as well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要估计一个元素的频率，需要查找与其哈希值对应的计数器，并选择其中的最小计数。这个最小计数提供了对真实频率的近似值。通过对多个元素重复这一过程并取最小计数，可以获得数据流中各个项的近似频率估计。例如，如果我们查询集合中数字
    2 的频率，我们查看 3 和 4 的最小值，即 3，这实际上就是输入流中 2 的频率。类似地，数字 1 的频率是 1 和 4 的最小值，即 1，仍然是正确的输出。需要注意的是，Count
    Min Sketch 仅提供元素频率的最大边界。这个边界是通过算法如何将计数分配到不同计数器的方式得出的。可能会发生这样的情况：所有 k 个哈希函数对输入数据的输出对应的索引可能都会被递增，这并不是因为该元素本身的加入，而是由于该集合中的其他所有元素的影响。下方是一个示例，当我们向集合中添加
    4 时的情况。
- en: '![](../Images/de2dd71a25353c509686e5b9429e3913.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/de2dd71a25353c509686e5b9429e3913.png)'
- en: Count Min Sketch Example (False Positive) [Image by Author]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Count Min Sketch 示例（假阳性）[作者提供的图片]
- en: Now if we try to query the frequency for 4, we look at the minimum of 4 and
    2, which is 2, higher than the actual frequency of 1\. This is because the indices
    corresponding to the output of the hash functions were already filled with those
    from the other elements due to collisions. The output isn’t perfect, but it is
    still an upper bound on the actual frequency.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试查询数字 4 的频率，我们查看 4 和 2 的最小值，即 2，这比实际的频率 1 要高。这是因为与哈希函数输出相关的索引已经被其他元素填充，发生了冲突。输出虽然不完美，但仍然是实际频率的上限。
- en: As before, the parameters ’m’ and ’k’ in the Count Min Sketch matrix play a
    crucial role in balancing memory usage and accuracy. The number of rows ’m’ determines
    the number of hash functions employed, while the number of columns ’k’ dictates
    the size of each row and, consequently, the amount of memory used. Adjusting these
    parameters allows users to control the trade-off between space efficiency and
    estimation accuracy based on the specific requirements of their application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Count Min Sketch 矩阵中的参数 'm' 和 'k' 在平衡内存使用和准确性方面起着至关重要的作用。行数 'm' 决定了使用的哈希函数数量，而列数
    'k' 则决定了每行的大小，从而影响所用内存量。调整这些参数可以让用户根据应用的具体要求控制空间效率和估计准确性之间的权衡。
- en: Implementing Count Min Sketch in Python
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中实现 Count Min Sketch
- en: Following is the Python implementation of a Count Min Sketch.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Count Min Sketch 的 Python 实现。
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the above code, the CountMinSketch class is initialized with specified m
    and k parameters, representing the number of counters in each hash function’s
    array and the number of hash functions, respectively. The sketch is updated with
    occurrences of items, and estimates of item counts can be obtained. The hash function
    method is responsible for generating hash values, and the example usage section
    demonstrates how to use the Count-Min Sketch to estimate counts for specific items
    in a streaming fashion. As in the case of bloom filters, the SHA-256 algorithm
    is used for hashing since it is known to produce uniformly distributed outputs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Count Min Sketch: Time & Space Complexity Analysis'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s also do a quick time and space analysis of the count min sketch. In terms
    of time complexity, both the addition of elements (incrementing counters) and
    the estimation of their frequencies in Count Min Sketch are constant time operations:
    O(k). The constant factor is influenced by the number of hash functions (’k’)
    and the size of the matrix (’m’). However, assuming that hash functions can be
    evaluated in constant time, the overall complexity remains constant. The operations
    involve multiple hash functions, each contributing a constant time to the overall
    process.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Regarding space complexity, Count Min Sketch is memory-efficient due to its
    use of a compact matrix structure. The space required is proportional to the product
    of the number of rows (’m’) and the number of counters per row (’k’). Thus, the
    space complexity is expressed as O(m * k). We have the flexibility to adjust the
    values of ’m’ and ’k’ to strike a balance between space efficiency and estimation
    accuracy. Smaller values result in reduced memory usage but may lead to more estimation
    errors, while larger values improve accuracy at the expense of increased memory
    requirements. This tunability makes Count Min Sketch a versatile solution for
    scenarios where memory constraints are critical, and approximate frequency counts
    are acceptable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Count Min Sketch: The Math'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As before, using our knowledge of probability theory, we can optimize the count
    min sketch i.e., find the values of m and k that minimize the possibility of an
    error. First, let us formalize the notations. Let hat-fₓ denote the frequency
    estimate for the element x and fₓ denote the actual frequency of that element.
    Based on our earlier discussion, we must have:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/930919c0257cbf1e2b2f1b63d93ff125.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'i.e., we are always sure that our estimate is at least the actual frequency
    count. But is this enough? A stupid algorithm that always outputs a very large
    number can also achieve this. What makes the count min sketch so special is that
    we can upper bound not only the actual frequency fₓ but also the deviation of
    the estimated frequency hat-fₓ from the actual frequency (probabilistic-ally of
    course). Using an optimal value of m and k, we can guarantee the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/137f0ee281a9576a8c9fb6a9d348f661.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'i.e., the probability that the estimated frequency exceeds the actual frequency
    by a value of more than or equal to εn (n is the size of the input stream) is
    at least (1 − δ), where ε and δ can be made as small as required. The values of
    m and k that satisfy this are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cd4813fc28efb1f0a71352535e2f74cb.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: As we can see, the number of columns (m) controls for the max value of deviation
    (hat-fₓ −fₓ ), while the number of rows/hash functions (k) controls for the probabilistic
    guarantee, 1 − δ. The proof of this is quite convoluted and requires some intermediate
    knowledge of probability theory like random variables and Markov inequality. I
    will be going through this proof in detail in the following paragraphs. If you’re
    curious and have the necessary prerequisites, you may continue reading.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s begin with the proof. First, we define certain quantities: Let αᵢ,
    ₕᵢ₍ₓ₎ denote the value in the ith row and hᵢ(x) the column of the count min sketch
    array. This is simply the frequency estimate of x as per the ith row/ith hash
    function used. This means that the estimated frequency is simply the minimum of
    this value for all rows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/816700ab8f3054b96763e00135ada35f.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'We now define the random variable Zᵢ (called over-count) as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cfda04f9b26574ad76ebbc97c8d645e9.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Next, we define an indicator random variable Xᵢ,ᵧ to check if a collision has
    occurred in the ith row with some other element y ≠ x. Formally,
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4dae31722d2ff1cdf4c9f193755fe928.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Now, let’s think of the relationship between Zᵢ and Xᵢ,ᵧ Recall that Zᵢ is
    the over-count i.e., the value by which αᵢ, ₕᵢ₍ₓ₎ exceeds the actual frequency
    fₓ. When does this happen? This happens when there are collisions with elements
    y ≠ x. This allows us to define the following relation:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4a7c559b4e11d039caec84d056d2d5b1.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: 'Note that we’ve weighted the sum with the actual frequency estimates of y since
    the elements may occur multiple times, each time causing the overcount to increase.
    The next step involves finding the expected value of Zᵢ or the over-count using
    properties of expectation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/61c49c4da41ce40dc16335d536be62d7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'where n denotes the expected length of the input stream, which is more than
    or equal to the sum of the frequencies of all the other elements. Finally, we
    use Markov’s inequality to find the probability that Zᵢ exceeds its expectation
    multiplied by a constant:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3d80bdbe1caa09ee8ccd0a529425515a.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: 'The above is just the direct use of Markov’s inequality. We may now use the
    fact that E [Zᵢ] ≤ n/m to get:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/44fa4d57df89fc32e9bffee19a71aa86.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Recall the expression we want to prove. All we want on the right-hand side of
    the inequality in the probability term is εn. Currently, we have an/m. Taking
    a = mε will allow us to get this term. Therefore,
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3aa530c03256b0ee476535a955e98415.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'Now we substitute in m = e/ε to get:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/070aab6abb8b36d25b182ad432ef9cb3.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'The above must be true for all Zᵢ from i = 1 to i = k. Thus, we can write:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bdc29310badf3cceb511d254432eba55.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'Since the above expression holds for all i, it must also hold for the minimum:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/878f45a3df2d2327e196d2935615c338.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we take the complement of the above probability and substitute for
    the value of k:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8038942a83fefb97db26aaada0973176.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'This completes the proof. From this, we can conclude that to achieve a max
    deviation of εn with a probabilistic guarantee of 1 − δ, we need the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/576644e30b9173c9941a9d03ea1af174.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Using these calculations, we can optimize our original count min sketch implementation:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this implementation, the OptimizedCountMinSketch class dynamically calculates
    the optimal values for m and k based on the provided max deviation tolerance (epsilon)
    and probabilistic requirement (delta). The calculate parameters method handles
    this calculation. The rest of the implementation remains similar to the previous
    version, with the optimized parameters achieving the required guarantee.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion on Count Min Sketch.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The Bottom Line
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Donald Knuth, the father of the analysis of algorithms had said,
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: “An algorithm must be seen to be believed”.
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Indeed, the ability to appreciate an algorithm comes, not only from using it,
    but understanding how it works and why it works. In this article, I’ve tried to
    describe the inner workings of two important probabilistic data structures and
    their algorithms. We talked about their performance relative to their deterministic
    counterparts, and implementation, as well as used some math to quantify their
    error bound. Although quite important in literature, these data structures merely
    constitute the surface of an ocean of other probabilistic data structures such
    as skip lists, hyper log-log, treap, quotient filter, min hash, etc. Many of these
    are very interesting and have a lot of potential applications in the field of
    computer science. I hope to go through some of these in further detail in my subsequent
    articles.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Hope you enjoyed reading this article! In case you have any doubts or suggestions,
    do reply in the comment box. Please feel free to contact me via [mail](mailto:naman.agr03@gmail.com).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: If you liked my article and want to read more of them, please follow me.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** All images (except for the cover image) have been made by the author.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: References
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bloom filter — Wikipedia — en.wikipedia.org. [https://en.wikipedia.org/wiki/Bloom_filter.](https://en.wikipedia.org/wiki/Bloom_filter.)
    [Accessed 07–01- 2024].
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bloom Filters — Introduction and Implementation — GeeksforGeeks — geeksforgeeks.org.
    [https://www.](https://www.) geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/.
    [Accessed 07–01–2024].
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Count-Min Sketch Data Structure with Implementation — GeeksforGeeks — geeksforgeeks.org.
    [https://www.](https://www.) geeksforgeeks.org/count-min-sketch-in-java-with-examples/.
    [Accessed 07–01–2024].
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Count-Min Sketch 数据结构与实现 — GeeksforGeeks — geeksforgeeks.org. [https://www.](https://www.)
    geeksforgeeks.org/count-min-sketch-in-java-with-examples/. [访问日期 2024年1月7日]。
- en: Counting Bloom Filters — Introduction and Implementation — GeeksforGeeks — geeksforgeeks.org.
    [https://www.](https://www.) geeksforgeeks.org/counting-bloom-filters-introduction-and-implementation/.
    [Accessed 07–01–2024].
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Counting Bloom Filters — 介绍与实现 — GeeksforGeeks — geeksforgeeks.org. [https://www.](https://www.)
    geeksforgeeks.org/counting-bloom-filters-introduction-and-implementation/. [访问日期
    2024年1月7日]。
- en: Count–min sketch — Wikipedia — en.wikipedia.org. [https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch.](https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch.)
    [Accessed 07–01–2024].
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Count–min sketch — 维基百科 — en.wikipedia.org. [https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch.](https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch.)
    [访问日期 2024年1月7日]。
- en: Humberto Villalta. Bloom Filter Mathematical Proof — humberto521336\. [https://medium.com/@humberto521336/](https://medium.com/@humberto521336/)
    bloom-filters-mathematical-proof-8aa2e5d7b06b. [Accessed 07–01–2024].
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Humberto Villalta. Bloom Filter 数学证明 — humberto521336\. [https://medium.com/@humberto521336/](https://medium.com/@humberto521336/)
    bloom-filters-mathematical-proof-8aa2e5d7b06b. [访问日期 2024年1月7日]。

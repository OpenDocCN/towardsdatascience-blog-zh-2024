- en: 'Cyclic Partition: An Up to 1.5x Faster Partitioning Algorithm'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环划分：一种最多提高1.5倍速度的划分算法
- en: 原文：[https://towardsdatascience.com/cyclic-partition-an-up-to-1-5x-faster-partitioning-algorithm-e38bf7948a5f?source=collection_archive---------4-----------------------#2024-10-10](https://towardsdatascience.com/cyclic-partition-an-up-to-1-5x-faster-partitioning-algorithm-e38bf7948a5f?source=collection_archive---------4-----------------------#2024-10-10)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/cyclic-partition-an-up-to-1-5x-faster-partitioning-algorithm-e38bf7948a5f?source=collection_archive---------4-----------------------#2024-10-10](https://towardsdatascience.com/cyclic-partition-an-up-to-1-5x-faster-partitioning-algorithm-e38bf7948a5f?source=collection_archive---------4-----------------------#2024-10-10)
- en: A sequence partitioning algorithm that does minimal rearrangements of values
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一种最小化重新排列值的序列划分算法
- en: '[](https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------)[![Tigran
    Hayrapetyan](../Images/36efd337fef6ddc01a4261e301b9ac78.png)](https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------)
    [Tigran Hayrapetyan](https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------)[![Tigran
    Hayrapetyan](../Images/36efd337fef6ddc01a4261e301b9ac78.png)](https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------)
    [Tigran Hayrapetyan](https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------)
    ·19 min read·Oct 10, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------)
    ·19分钟阅读·2024年10月10日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/aaca4bc60dbe61ce5228172e0852c4cc.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/aaca4bc60dbe61ce5228172e0852c4cc.png)'
- en: 1\. Introduction
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 引言
- en: Sequence partitioning is a basic and frequently used algorithm in computer programming.
    Given a sequence of numbers “*A*”, and some value ‘*p*’ called pivot value, the
    purpose of a partitioning algorithm is to rearrange numbers inside “*A*” in such
    a way, so that all numbers less than ‘*p*’ come first, followed by the rest of
    the numbers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 序列划分是计算机编程中一种基础且常用的算法。给定一个数字序列“*A*”以及一个名为“*p*”的值（称为枢轴值），划分算法的目的是按照某种方式重新排列“*A*”中的数字，使得所有小于‘*p*’的数字排在前面，其余的数字排在后面。
- en: '![](../Images/6dd838ac6618329d70677b31f28cab20.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6dd838ac6618329d70677b31f28cab20.png)'
- en: '*An example of a sequence before and after partitioning by pivot value “p=20”.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个示例，展示了在枢轴值“p=20”划分前后的序列。*'
- en: After the algorithm, all the values which are less than 20 (light green)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法执行后，所有小于20的值（浅绿色）
- en: appear before the other values (yellow).*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 出现于其他值之前（黄色）。*
- en: 'There are different applications of partitioning, but the most popular are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 划分有不同的应用，但最常见的应用包括：
- en: QuickSort — which is generally nothing more than a partitioning algorithm, called
    through recursion multiple times on different sub-arrays of given array, until
    it becomes sorted.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序——它通常只不过是一个划分算法，通过递归多次调用在给定数组的不同子数组上，直到数组被排序。
- en: Finding the median value of a given sequence — which makes use of partitioning
    in order to efficiently cut down the search range, and to ultimately find the
    median in expected linear time.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找给定序列的中位数值——利用划分方法有效地缩小搜索范围，最终在线性时间内找到中位数。
- en: Sorting a sequence is an essential step to enable faster navigation over large
    amounts of data. Of the two common searching algorithms — linear search and binary
    search — the latter can only be used if the data in the array is sorted. Finding
    the median or k’th order statistic can be essential to understand the distribution
    of values in given unsorted data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 排序一个序列是加速大规模数据导航的关键步骤。在两种常见的搜索算法中——线性搜索和二分搜索——只有当数组中的数据已经排序时，二分搜索才能使用。查找中位数或第k阶统计量对于理解给定无序数据的分布非常关键。
- en: Currently there are different partitioning algorithms (also called — partition
    schemes), but the well-known ones are “Lomuto scheme” and “Hoare scheme”. Lomuto
    scheme is often intuitively easier to understand, while Hoare scheme does less
    rearrangements inside a given array, which is why it is often preferred in practice.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有不同的划分算法（也称为划分方案），但比较著名的有“Lomuto方案”和“Hoare方案”。Lomuto方案通常更容易直观理解，而Hoare方案在给定数组内部的重新排列较少，因此在实际应用中更为常见。
- en: What I am going to suggest in this story is a new partition scheme called “cyclic
    partition”, which is similar to Hoare scheme, but does 1.5 times fewer rearrangements
    (value assignments) inside the array. Thus, as it will be shown later, the number
    of value assignments becomes almost equal to the number of the values which are
    initially “not at their place”, and should be somehow moved. That fact allows
    me to consider this new partition scheme as a nearly optimal one.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这个故事中将要建议的是一种新的划分方案，叫做“循环划分”，它类似于Hoare方案，但在数组内部进行的重新排列（赋值）减少了1.5倍。因此，正如后续所展示的，赋值的数量几乎等于最初“未在其位置”的值的数量，而这些值应该以某种方式被移动。这一事实让我认为这个新的划分方案几乎是最优的。
- en: 'The next chapters are organized in the following way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将按照以下方式组织：
- en: In chapter 2 we will recall what is in-place partitioning (a property, which
    makes partitioning to be not a trivial task),
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第2章中，我们将回顾什么是原地划分（一个使得划分任务并非易事的特性），
- en: In chapter 3 we will recall the widely used Hoare partitioning scheme,
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第3章中，我们将回顾广泛使用的Hoare划分方案，
- en: In chapter 4 I’ll present “cycles of assignments”, and we will see why some
    rearrangements of a sequence might require more value assignments, than other
    rearrangements of the same sequence,
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第4章中，我将介绍“赋值周期”，并展示为什么某些序列的重新排列可能需要比其他重新排列更多的赋值，
- en: Chapter 5 will use some properties of “cycles of assignments”, and derive the
    new “cyclic partition” scheme, as an optimized variant of Hoare scheme,
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5章将使用“赋值周期”的一些性质，推导出新的“循环划分”方案，作为Hoare方案的优化变体，
- en: And finally, chapter 6 will present an experimental comparison between the Hoare
    scheme and cyclic partition, for arrays of small and large data types.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，第6章将展示Hoare方案和循环划分在小型和大型数据类型数组上的实验比较。
- en: An implementation of Cyclic partition in the C++ language, as well as its benchmarking
    with the currently standard Hoare scheme, are present on GitHub, and are referenced
    at the end of this story [1].
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “循环划分”在C++语言中的实现，以及与当前标准Hoare方案的基准比较，已经在GitHub上展示，并在本故事的最后引用[1]。
- en: 2\. Recalling in-place sequence partitioning
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 回顾原地序列划分
- en: 'Partitioning a sequence will not be a difficult task, if the input and output
    sequences would reside in computer memory in 2 different arrays. If that would
    be the case, then one of methods might be to:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入和输出序列位于计算机内存中的两个不同数组中，划分序列将不再是一个困难的任务。如果是这种情况，可能的方法之一是：
- en: Calculate how many values in “*A*” are less than ‘*p*’ (this will give us final
    length of the left part of output sequence),
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算在“A”中有多少个值小于‘p’（这将给出输出序列左部分的最终长度），
- en: Scan the input array “*A*” from left to right, and append every current value
    “*A*[*i*]” either to the left part or to the right part, depending on whether
    it is less than ‘*p*’ or not.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左到右扫描输入数组“A”，并根据当前值“A[*i*]”是否小于‘p’，将其分别追加到左部分或右部分。
- en: 'Here are presented a few states of running such algorithm:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一些运行该算法的状态：
- en: '![](../Images/bd9f17358955113e3434fc0f0d8b6782.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/bd9f17358955113e3434fc0f0d8b6782.png)'
- en: '*During the first stage we calculate that there are only 7 values less than
    “p=20” (the light green ones), so we prepare to write the greater values into
    the output sequence, starting from index 7.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*在第一阶段，我们计算出有7个值小于“p=20”（这些是浅绿色的），因此我们准备从索引7开始将较大的值写入输出序列。*'
- en: '![](../Images/f9e1b2e33ffe1606a940fc89c9fef97a.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f9e1b2e33ffe1606a940fc89c9fef97a.png)'
- en: '*During the second stage, after scanning 5 values of the input sequence,'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*在第二阶段，在扫描了输入序列中的5个值后，'
- en: we append 3 of them to the left part of output sequence,
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其中的3个值追加到输出序列的左部分，
- en: and the other 2 to its right part.*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的2个追加到右部分。*
- en: '![](../Images/c82de73a14465cf291d01b03bf0b71ec.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c82de73a14465cf291d01b03bf0b71ec.png)'
- en: '*Continuing the second stage, we have scanned now 9 values from input sequence,'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*继续第二阶段，我们现在已经从输入序列中扫描了9个值，'
- en: placing 5 of them in the left part of output sequence, and the other 4 to its
    right part.*
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将其中5个放在输出序列的左侧部分，另4个放在右侧部分。*
- en: '![](../Images/4d3eb3d4846edf6d520b0800ab1312d9.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4d3eb3d4846edf6d520b0800ab1312d9.png)'
- en: '*The algorithm is completed. Both parts of the output sequence are now properly
    filled to the end.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法完成。输出序列的两个部分现在已正确填充到最后。'
- en: Note, the relative order of values in either left or right parts is preserved,
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，左侧或右侧部分的值的相对顺序被保留，
- en: upon how they were originally written in the input array.*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基于它们在输入数组中的原始写法。
- en: Other, shorter solutions also exist, such ones which have only one loop in the
    code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 也存在其他较短的解决方案，诸如代码中只有一个循环的那些。
- en: Now, the difficulty comes when we want to not use any extra memory, so the input
    sequence will be transformed into the partitioned output sequence just by moving
    values inside the only array. By the way, such kind of algorithms which don’t
    use extra memory are called in-place algorithms.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题在于我们希望不使用额外的内存，因此输入序列将通过仅在唯一数组内移动值来转换为划分后的输出序列。顺便说一下，这种不使用额外内存的算法被称为原地算法。
- en: '![](../Images/68571922f3140f447f263db1e119e387.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/68571922f3140f447f263db1e119e387.png)'
- en: '*Partitioning the same input sequence “A” in-place, by the same pivot value
    “p=20”.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*将相同的输入序列“A”原地划分，使用相同的枢轴值“p=20”。'
- en: Presented order of values corresponds to the input state of the sequence, and
    arrows for every value show
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的值的顺序对应于序列的输入状态，每个值的箭头显示
- en: if where to that value should be moved, in order for the entire sequence to
    become partitioned.*
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将该值移动到哪里，以便整个序列变得划分。*
- en: Before introducing my partitioning scheme, let’s review the existing and commonly
    used solution of in-place partitioning.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍我的划分方案之前，让我们回顾一下现有的、常用的原地划分解决方案。
- en: 3\. The currently used partitioning scheme
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 当前使用的划分方案
- en: 'After observing a few implementations of sorting in standard libraries of various
    programming languages, it looks like the most widely used partitioning algorithm
    is the Hoare scheme. I found out that it is used for example in:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察了几种编程语言标准库中的排序实现后，似乎最广泛使用的划分算法是霍尔方案。我发现它例如在以下实现中被使用：
- en: “std::sort()” implementation in STL for C++,
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++的STL中，使用了“std::sort()”实现，
- en: “Arrays.sort()” implementation in JDK for Java, for primitive data types.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java的JDK中，对于原始数据类型，使用了“Arrays.sort()”实现。
- en: In the partitioning based on the Hoare scheme, we scan the sequence simultaneously
    from both ends towards each other, searching in the left part such a value *A*[*i*]
    which is greater or equal to ‘*p*’, and searching in the right part such a value
    *A*[*j*] which is less than ‘*p*’. Once found, we know that those two values *A*[*i*]
    and *A*[*j*] are kind of “not at their proper places” (remember, the partitioned
    sequence should have the values less than ‘*p*’ coming first, and only then all
    the other values which are greater or equal to ‘*p*’), so we just swap *A*[*i*]
    and *A*[*j*]. After the swap, we continue the same way, simultaneously scanning
    array “*A*” with indexes *i* and *j*, until they become equal. Once they are,
    partitioning is completed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于霍尔方案的划分中，我们同时从序列的两端向中间扫描，在左侧部分寻找一个值 *A*[*i*]，它大于或等于‘*p*’，在右侧部分寻找一个值 *A*[*j*]，它小于‘*p*’。一旦找到，我们知道这两个值
    *A*[*i*] 和 *A*[*j*] 是“没有放在正确的位置”（记住，划分后的序列应当先放置小于‘*p*’的值，然后是大于或等于‘*p*’的值），因此我们交换
    *A*[*i*] 和 *A*[*j*]。交换后，我们继续以相同的方式，继续同时扫描数组“A”，使用索引 *i* 和 *j*，直到它们相等。一旦它们相等，划分完成。
- en: 'Let’s observe the Hoare scheme on another example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在另一个示例中观察霍尔方案：
- en: '![](../Images/7dcd2b1d0e8f69d3f0dedf521d6dbb2a.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7dcd2b1d0e8f69d3f0dedf521d6dbb2a.png)'
- en: '*The input sequence “A” of length ’N’, that should be partitioned by pivot
    value “p=20”.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入序列“A”长度为’N’，应根据枢轴值“p=20”进行划分。'
- en: Index i starts scanning from 0 upwards, and index j starts scanning from “N-1”
    downwards.*
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 索引i从0开始向上扫描，索引j从“N-1”开始向下扫描。*
- en: '![](../Images/66f4da72a6c895b44fd267f4334a48dd.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/66f4da72a6c895b44fd267f4334a48dd.png)'
- en: While increasing index i we meet value “A[2]=31” which is greater than ‘p’.
    Then, after decreasing index j
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引i增大时，我们遇到值“A[2]=31”，它大于‘p’。然后，在索引j减小时，
- en: we meet another value “A[10]=16” which is less than ‘p’. Those 2 are going to
    be swapped.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到另一个值“A[10]=16”，它小于‘p’。这两个值将被交换。
- en: '![](../Images/79f91856628c0ee07c14e66ec980cf0a.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/79f91856628c0ee07c14e66ec980cf0a.png)'
- en: '*After swapping “A[2]” and “A[10]” we continue increasing i from 2 and decreasing
    j from 10\. Index i will stop on value “A[4]=28” which is greater than ‘p’, and
    index j will stop on value “A[9]=5” which is less than ‘p’. Those 2 are also going
    to be swapped.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*在交换“A[2]”与“A[10]”之后，我们继续从2开始增加i，从10开始减少j。索引i将在值“A[4]=28”大于‘p’时停止，索引j将在值“A[9]=5”小于‘p’时停止。这两个值也将被交换。*'
- en: '![](../Images/524bca2c95f5430921fe6c0da6951fa9.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/524bca2c95f5430921fe6c0da6951fa9.png)'
- en: '*The algorithm continues the same way, and the numbers “A[5]=48” and “A[7]=3”
    are also going to be swapped.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法按相同的方式继续进行，数字“A[5]=48”和“A[7]=3”也将被交换。*'
- en: '![](../Images/3c4f00b7e95a7a7d27ff9ce5b00458a8.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3c4f00b7e95a7a7d27ff9ce5b00458a8.png)'
- en: '*After that, indexes ‘i’ and ‘j’ will become equal to each other. Partitioning
    is completed.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*之后，索引‘i’和‘j’将变得相等。划分完成。*'
- en: 'If writing the pseudo-code of partitioning by the Hoare scheme, we will have
    the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编写霍尔方案的划分伪代码，我们将得到如下内容：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here in lines 5 and 6 we set up start indexes for the 2 scans.
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在第5和第6行，我们设置了两个扫描的起始索引。
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lines 8–10 search from left for such a value, which should belong to the right
    part, after partitioning.
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第8到10行从左侧查找应该属于右部分的值，划分之后它应该属于右部分。
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Similarly, lines 11–13 search from right for such a value, which should belong
    to the left part.
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 类似地，第11到13行从右侧查找应该属于左部分的值。
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Lines 15–19 check for completion of the scans. Once indexes ‘i’ and ‘j’ meet,
    there are 2 cases: either “A[i]” belongs to the left part or to the right part.
    Depending on that, we return either ‘i’ or ‘i+1’, as return value of the function
    should be the start index of the right part.'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第15到19行检查扫描是否完成。一旦索引‘i’和‘j’相遇，就有两种情况：要么“A[i]”属于左部分，要么属于右部分。根据情况，我们返回‘i’或‘i+1’，因为函数的返回值应该是右部分的起始索引。
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Next, if the scans are not completed yet, lines 20–23 do swap those 2 values
    which are not at their proper places.
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 接下来，如果扫描尚未完成，第20到23行将交换那些未放置到正确位置的值。
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And finally, lines 24–26 advance the both indexes, in order to not re-check
    the already swapped values.
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后，第24到26行推进两个索引，以避免重新检查已交换的值。
- en: The time complexity of the algorithm is *O*(*N*), regardless of where the 2
    scans will meet each other, as together they always scan *N* values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的时间复杂度是*O*(*N*)，无论两个扫描何时相遇，因为它们总共扫描*N*个值。
- en: 'An important note here, if the array “*A*” has ‘*L*’ values which are “not
    at their places”, and should be swapped, then acting by Hoare scheme we will do
    “3**L*/2” assignments, because swapping 2 values requires 3 assignments:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的备注，如果数组“*A*”有‘*L*’个“未放置到正确位置”的值，且需要交换，那么按照霍尔方案操作时，我们将进行“3**L*/2”次赋值，因为交换两个值需要进行3次赋值：
- en: '![](../Images/7a689b04e744421351a03d3c693d8e7c.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7a689b04e744421351a03d3c693d8e7c.png)'
- en: '*Swapping values of 2 variables ‘a’ and ‘b’ requires to do 3 assignments, with
    help of ‘tmp’ variable.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*交换两个变量‘a’和‘b’的值需要通过‘tmp’变量进行3次赋值。*'
- en: 'Those assignments are:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些赋值是：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let me also emphasize here that ‘*L*’ is always an even number. That is because
    for every value “*A*[*i*]>=*p*” originally residing at the left area, there is
    another value “*A*[*j*]<*p*” originally residing at the right area, the ones which
    are being swapped. So, every swap rearranges 2 such values, and all rearrangements
    in Hoare scheme are being done only through swaps. That’s why the ‘*L*’ — the
    total number of values to be rearranged, is always an even number.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在这里强调，‘*L*’始终是一个偶数。这是因为，对于每个原本位于左侧区域、满足“A[*i*]>=*p*”的值，都有另一个原本位于右侧区域、满足“A[*j*]<*p*”的值，它们正被交换。所以，每次交换都会重新排列两个这样的值，霍尔方案中的所有重新排列都仅通过交换进行。这就是为什么‘*L*’——需要重新排列的总值数量，始终是一个偶数。
- en: 4\. Cycles of assignments
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 赋值循环
- en: This chapter might look as a deviation from the agenda of the story, but actually
    it isn’t, as we will need the knowledge about cycles of assignments in the next
    chapter, when optimizing the Hoare partitioning scheme.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本章看起来可能偏离了故事的议程，但实际上并非如此，因为在下一章优化霍尔划分方案时，我们将需要了解赋值的循环。
- en: Assume that we want to somehow rearrange the order of values in given sequence
    “*A*”. This should not necessarily be a partitioning, but any kind of rearrangement.
    Let me show that some rearrangements require more assignments than some others.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想以某种方式重新排列给定序列“*A*”中的值。这不一定是划分操作，但可以是任何形式的重新排列。让我展示一下，某些重新排列比其他重新排列需要更多的赋值。
- en: 'Case #1: Cyclic left-shift of a sequence'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 情况#1：序列的循环左移
- en: How many assignments should be done if we want to cyclic left shift the sequence
    “*A*” by 1 position?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将序列 “*A*” 循环左移 1 位，应该进行多少次赋值？
- en: '![](../Images/e553b939bc7c0ef82e6fe3a43c0d6926.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e553b939bc7c0ef82e6fe3a43c0d6926.png)'
- en: '*Example of cyclic left shift of sequence “A” of length N=12\.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*长度为 N=12 的序列 “A” 循环左移的示例\。'
- en: 'We see that the number of assignments needed is N+1=13, as we need to:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，所需的赋值次数是 N+1=13，因为我们需要：
- en: 1) store “A[0]” in the temporary variable “tmp”, then
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 1) 将 “A[0]” 存储到临时变量 “tmp” 中，然后
- en: 2) “N-1” times assign the right adjacent value to the current one, and finally
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 2) 将右侧相邻值赋给当前值，共 “N-1” 次，最后
- en: 3) assign “tmp” to the last value of the sequence “A[N-1]”.*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 3) 将 “tmp” 赋值给序列 “A[N-1]” 的最后一个值。*
- en: 'The needed operations to do that are:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的操作是：
- en: '[PRE2]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: … which results in 13 assignments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: … 结果是 13 次赋值。
- en: 'Case #2: Cyclic left-shift by 3 positions'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '案例 #2: 循环左移 3 位'
- en: 'In the next example we still want to do a cyclic left shift of the same sequence,
    but now by 3 positions to the left:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们仍然希望对相同的序列进行循环左移，但这次是左移 3 位：
- en: '![](../Images/f689ead42e953ba64e25a9fbba4927eb.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f689ead42e953ba64e25a9fbba4927eb.png)'
- en: '*Example of cyclic left shift by 3 of the sequence “A”, having length N=12.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环左移 3 位的 “A” 序列示例，长度 N=12。'
- en: We see that the values A[0], A[3], A[6] and A[9] are being exchanged between
    each other (blue arrows),
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，值 A[0]、A[3]、A[6] 和 A[9] 正在彼此之间交换（蓝色箭头），
- en: as well as values A[1], A[4], A[7] and A[10] do (pink arrows),
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，值 A[1]、A[4]、A[7] 和 A[10] 也会这样做（粉色箭头），
- en: and as the values A[2], A[5], A[8] and A[11] do exchange only between each other
    (yellow arrows).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 而且值 A[2]、A[5]、A[8] 和 A[11] 仅在彼此之间交换（黄色箭头）。
- en: The “tmp” variable is being assigned to and read from 3 times.*
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: “tmp” 变量被赋值并读取了 3 次。*
- en: Here we have 3 independent chains / cycles of assignments, each of length 4.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有 3 个独立的链/循环赋值，每个长度为 4。
- en: 'In order to properly exchange values between *A*[0], *A*[3], *A*[6] and *A*[9],
    the needed actions are:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地交换 *A*[0]、*A*[3]、*A*[6] 和 *A*[9] 之间的值，需要进行以下操作：
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: … which makes 5 assignments. Similarly, exchanging values inside groups (*A*[1],
    *A*[4], *A*[7], *A*[10]) and (*A*[2], *A*[5], *A*[8], *A*[11]) will require 5
    assignments each. And adding all that together gives 5*3=15 assignments required
    to cyclic left shift by 3 the sequence “*A*”, having *N*=12 values.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: … 这会导致 5 次赋值。类似地，交换组内的值（*A*[1]、*A*[4]、*A*[7]、*A*[10]）和（*A*[2]、*A*[5]、*A*[8]、*A*[11]）也需要各
    5 次赋值。将这些加在一起，总共需要 5*3=15 次赋值来对长度为 *N*=12 的序列 “*A*” 进行 3 位的循环左移。
- en: '*Case #3: Reversing a sequence*'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*案例 #3: 反转一个序列*'
- en: 'When reversing the sequence “*A*” of length ’*N*’, the actions performed are:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当反转长度为 ’*N*’ 的序列 “*A*” 时，执行的操作是：
- en: swap its first value with the last one, then
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其第一个值与最后一个值交换，然后
- en: swap the second value with the second one from right,
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第二个值与从右边数来的第二个值交换，
- en: swap the third value with the third one from right,
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第三个值与从右边数来的第三个值交换，
- en: … and so on.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: … 依此类推。
- en: '![](../Images/3421a95524897208559180641f413088.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3421a95524897208559180641f413088.png)'
- en: '*Example of reversing array “A”, having N=12 values.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*反转数组 “A” 的示例，长度 N=12。'
- en: We see that the values in pairs (A[0], A[11]), (A[1], A[10]), (A[2], A[9]),
    etc, are being swapped, independently from each other. The variable “tmp” is being
    assigned to and read from 6 times.*
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，值对（A[0]、A[11]）、（A[1]、A[10]）、（A[2]、A[9]）等正在彼此交换，互不影响。变量 “tmp” 被赋值并读取了 6
    次。*
- en: 'As every swap requires 3 assignments, and as for reversing entire sequence
    “*A*” we need to do ⌊*N*/2⌋ swaps, the total number of assignments results in:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次交换需要 3 次赋值，而且对于反转整个序列 “*A*” 我们需要做 ⌊*N*/2⌋ 次交换，总的赋值次数为：
- en: 3*⌊N/2⌋ = 3*⌊12/2⌋ = 3*6 = 18
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3*⌊N/2⌋ = 3*⌊12/2⌋ = 3*6 = 18
- en: 'And the exact sequence of assignments needed to do the reverse of “*A*” is:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 反转 “*A*” 所需的具体赋值顺序如下：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We have seen that rearranging values of the same sequence “*A*” might require
    different number of assignments, depending on how exactly the values are being
    rearranged.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，对同一序列 “*A*” 进行重新排列可能需要不同数量的赋值，具体取决于值是如何重新排列的。
- en: 'In the presented 3 examples, the sequence always had length of *N*=12, but
    the number of required assignments was different:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这 3 个示例中，序列的长度始终为 *N*=12，但所需的赋值次数是不同的：
- en: '![](../Images/6ae43094e570ff03c8f9ab450f725761.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6ae43094e570ff03c8f9ab450f725761.png)'
- en: More precisely, the number of assignments is equal to *N*+*C*, where “*C*” is
    the number of cycles, which originate during the rearrangement. Here by saying
    “cycle” I mean such a subset of variables of “*A*”, values of which are being
    rotated among each other.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，赋值次数等于 *N*+*C*，其中“*C*”是重排过程中产生的循环次数。在这里，所谓的“循环”是指“*A*”中的一组变量，其值在彼此之间进行旋转。
- en: 'In our case 1 (left shift by 1) we had only *C*=1 cycle of assignments, and
    all variables of “*A*” did participate in that cycle. That’s why overall number
    of assignments was:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况 1（左移 1）中，我们只有 *C*=1 次赋值循环，且所有“*A*”中的变量都参与了这个循环。这就是为什么总体赋值次数为：
- en: N+C = 12+1 = 13.
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: N+C = 12+1 = 13。
- en: 'In the case 2 (left shift by 3) we had *C*=3 cycles of assignments, with:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况 2（左移 3）中，我们有 *C*=3 次赋值循环，其中：
- en: — first cycle within variables (*A*[0], *A*[3], *A*[6], *A*[9]),
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: — 第一轮应用于变量（*A*[0]，*A*[3]，*A*[6]，*A*[9]），
- en: — second cycle applied to variables (*A*[1], *A*[4], *A*[7], *A*[10]) and
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: — 第二轮应用于变量（*A*[1]，*A*[4]，*A*[7]，*A*[10]）并且
- en: — third cycle applied to variables (*A*[2], *A*[5], *A*[8], *A*[11]).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: — 第三轮应用于变量（*A*[2]，*A*[5]，*A*[8]，*A*[11]）。
- en: 'That’s why the overall number of assignments was:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么总体赋值次数为：
- en: N+C = 12+3 = 15.
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: N+C = 12+3 = 15。
- en: 'And in our case 3 (reversing) we had ⌊*N*/2⌋ = 12/2 = 6 cycles. Those all were
    the shortest possible cycles, and were applied to pairs (*A*[0], *A*[11]), (*A*[1],
    *A*[10]), … and so on. That’s why the overall number of assignments was:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 而在我们的情况 3（反转）中，我们有 ⌊*N*/2⌋ = 12/2 = 6 次循环。所有这些都是最短的循环，并且应用于对（*A*[0]，*A*[11]），（*A*[1]，*A*[10]），……
    等等。这就是为什么总体赋值次数为：
- en: N+C = 12+6 = 18.
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: N+C = 12+6 = 18。
- en: Surely, in the presented examples the absolute difference in number of assignments
    is very small, and it will not play any role when writing high-performance code.
    But that is because we were considering a very short array of length “*N*=12”.
    For longer arrays, those differences in numbers of assignments will grow proportionally
    to *N*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在所展示的示例中，赋值数量的绝对差异非常小，在编写高性能代码时不会产生任何影响。但那是因为我们考虑的是一个非常短的数组，长度为“*N*=12”。对于更长的数组，这些赋值数量的差异将与
    *N* 成比例增长。
- en: Concluding this chapter, let’s keep in mind that the number of assignments needed
    to rearrange a sequence grows together with number of cycles, introduced by such
    rearrangement. And if we want to have a faster rearrangement, we should try to
    do it by such a scheme, which has the smallest possible number of cycles of assignments.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本章内容时，让我们记住，重新排列一个序列所需的赋值次数与由这种重新排列引入的循环次数是成正比的。如果我们想要更快速的重新排列，我们应该尝试通过一个赋值循环最少的方案来实现。
- en: '**5\. Optimizing the Hoare partitioning scheme**'
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**5\. 优化 Hoare 分区方案**'
- en: Now let’s observe the Hoare partitioning scheme once again, this time paying
    attention to how many cycles of assignments it introduces.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次观察 Hoare 分区方案，这次关注它引入了多少赋值循环。
- en: Let’s assume we have the same array “*A*” of length *N*, and a pivot value ‘*p*’
    according to which the partitioning must be made. Also let’s assume that there
    are ‘*L*’ values in the array which should be somehow rearranged, in order to
    bring “*A*” into a partitioned state. It turns out that Hoare partitioning scheme
    rearranges those ‘*L*’ values in the slowest possible way, because it introduces
    the maximal possible number of cycles of assignments, with every cycle consisting
    of only 2 values.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个相同长度为 *N* 的数组“*A*”，并且有一个分区值‘*p*’，根据该值必须进行分区。同时假设数组中有‘*L*’个值需要以某种方式重新排列，以将“*A*”带入分区状态。事实证明，Hoare
    分区方案以最慢的方式重新排列这些‘*L*’个值，因为它引入了最大数量的赋值循环，每个循环仅涉及 2 个值。
- en: '![](../Images/daecf43ab4e32d31447e30733c658d05.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/daecf43ab4e32d31447e30733c658d05.png)'
- en: '*Given pivot value “p=20”, the “L=8” values which should be rearranged are
    the ones to which'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*给定分区值“p=20”，需要重新排列的“L=8”个值是那些需要被重新安排的值，'
- en: arrows are coming (or going from).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头正在出现（或从中移动）。
- en: Hoare partitioning scheme introduces “L/2=4” cycles of assignments, each acting
    on just 2 values.*
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Hoare 分区方案引入了“L/2=4”个赋值循环，每个循环作用于 2 个值。*
- en: Moving 2 values over a cycle of length 2, which is essentially swapping them,
    requires 3 assignments. So the overall number of values assignments is “3**L*/2”
    for the Hoare partitioning scheme.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个长度为 2 的循环中交换 2 个值，本质上是交换它们，需要 3 次赋值。因此，Hoare 分区方案的总体赋值次数是“3**L*/2”。
- en: The idea which lies beneath the optimization that I am going to describe, comes
    from the fact that after partitioning a sequence, we are generally not interested
    in relative order of the values “*A*[*i*]<*p*”, which should finish at the left
    part of partitioned sequence, as well as we are not interested in the relative
    order of the ones, which should finish at the right part. The only thing that
    we are interested in, is for all values less than ‘*p*’ to come before the other
    ones. This fact allows us to alter the cycles of assignments in Hoare scheme,
    and to come up with only 1 cycle of assignments, containing all the ‘*L*’ values,
    which should somehow be rearranged.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我即将描述的优化背后的思想来源于这样一个事实：在划分序列后，我们通常不关心“*A*[*i*]<*p*”的值的相对顺序，它们应该位于划分序列的左侧部分；同样我们也不关心应位于右侧部分的那些值的相对顺序。我们唯一关心的，是所有小于‘*p*’的值应该出现在其他值之前。这个事实使我们能够改变霍尔方案中的赋值循环，并得出一个只包含所有需要重新排列的‘*L*’值的赋值循环。
- en: 'Let me first describe the altered partitioning scheme with the help of the
    following illustration:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先通过以下插图描述这个改进后的划分方案：
- en: '![](../Images/477f288a1d4e8beb24d2e2973a816044.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/477f288a1d4e8beb24d2e2973a816044.png)'
- en: '*The altered partitioning scheme, applied to the same sequence “A”.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*改进后的划分方案，应用于相同的序列“A”。'
- en: As the pivot “p=20” is not changed, the “L=8” values which should be rearranged
    are also the same.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于枢轴“p=20”没有改变，应该重新排列的“L=8”个值也保持不变。
- en: All the arrows represent the only cycle of assignments in the new scheme.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 所有箭头表示新方案中唯一的赋值循环。
- en: After moving all the ‘L’ values upon it, we will end up with an alternative
    partitioned sequence.*
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在将所有‘L’值移动到其上之后，我们将得到一个替代的划分序列。*
- en: So what are we doing here?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们在这里做了什么？
- en: 'As in the original Hoare scheme, at first we scan from the left and find such
    value “*A*[*i*]>=*p*” which should go to the right part. But instead of swapping
    it with some other value, we just remember it: “*tmp* := *A*[*i*]”.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与原始的霍尔方案一样，首先我们从左侧扫描，找到这样的值“*A*[*i*]>=*p*”，它应该移到右侧部分。但是我们并不与其他值交换，而是记住它：“*tmp*
    := *A*[*i*]”。
- en: Next we scan from right and find such value “*A*[*j*]<*p*” which should go to
    the left part. And we just do the assignment “*A*[*i*] := *A*[*j*]”, without loosing
    the value of “*A*[*i*]”, as it is already stored in “*tmp*”.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来我们从右侧扫描，找到这样的值“*A*[*j*]<*p*”，它应该移到左侧部分。然后我们执行赋值操作“*A*[*i*] := *A*[*j*]”，不会丢失“*A*[*i*]”的值，因为它已经存储在“*tmp*”中。
- en: Next we continue the scan from left, and find such value “*A*[*i*]>=*p*” which
    also should go to the right part. So we do the assignment “*A*[*j*] := *A*[*i*]”,
    without loosing value “*A*[*j*]”, as it is already assigned to the previous position
    of ‘*i*’.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来我们从左侧继续扫描，找到这样的值“*A*[*i*]>=*p*”，它也应该移到右侧部分。因此我们执行赋值操作“*A*[*j*] := *A*[*i*]”，不会丢失“*A*[*j*]”的值，因为它已经被赋值到‘*i*’的前一个位置。
- en: This pattern continues, and once indexes *i* and *j* meet each other, it remains
    to place some value greater than ‘*p*’ to “*A*[*j*]”, we just do “*A*[*j*] :=
    *tmp*”, as initially the variable “*tmp*” was holding the first value from left,
    greater than ‘*p*’. The partitioning is completed.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个模式会继续下去，当索引 *i* 和 *j* 相遇时，只需将大于‘*p*’的某个值放到“*A*[*j*]”，我们只需执行“*A*[*j*] := *tmp*”，因为最初变量“*tmp*”存储的是第一个大于‘*p*’的值。划分完成。
- en: As we see, here we have only 1 cycle of assignments which goes over all the
    ‘*L*’ values, and in order to properly rearrange them it requires just “*L*+1”
    value assignments, compared to the “3**L*/2” assignments of Hoare scheme.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这里只有1次赋值循环，遍历所有的‘*L*’值，为了正确地重新排列它们，只需要“*L*+1”次赋值，相比之下，霍尔方案需要“3**L*/2”次赋值。
- en: I prefer to call this new partitioning scheme a “Cyclic partition”, because
    all the ‘*L*’ values which should be somehow rearranged, now reside on a single
    cycle of assignments.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢称这个新的划分方案为“循环划分”，因为所有应该重新排列的‘*L*’值现在都位于一个赋值循环中。
- en: Here is the pseudo-code of the Cyclic partition algorithm. Compared to the pseudo-code
    of Hoare scheme the changes are insignificant, but **now we always do 1.5x fewer
    assignments**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是循环划分算法的伪代码。与霍尔方案的伪代码相比，变化微小，但**现在我们始终执行1.5倍更少的赋值**。
- en: '[PRE5]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here lines 5 and 6 set up the start indexes for both scans (‘i’ — from left
    to right, and ‘j’ — from right to left).
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这里第5行和第6行设置了两个扫描的起始索引（‘i’ — 从左到右，‘j’ — 从右到左）。
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lines 7–9 search from left for such a value “A[i]”, which should go to the right
    part. If it turns out that there is no such value, and all N items belong to the
    left part, lines 10 and 11 report that and finish the algorithm.
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第7至9行从左侧查找应当移到右侧部分的值“A[i]”。如果没有找到这样的值，且所有N个项都属于左侧部分，则第10和11行报告这一点并结束算法。
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Otherwise, if such value was found, at line 13 we remember it in the ‘tmp’ variable,
    thus opening a slot at index ‘i’ for placing another value there.
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 否则，如果找到了该值，第13行我们将其记住在‘tmp’变量中，从而为索引‘i’的槽开启了一个位置，以便放入另一个值。
- en: ''
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lines 15–19 search from right for such a value “A[j]” which should be moved
    to the left part. Once found, lines 20–22 place it into the empty slot at index
    ‘i’, after which the slot at index ‘j’ becomes empty, and waits for another value.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第15至19行从右侧查找应当移动到左侧部分的值“A[j]”。一旦找到，第20至22行将其放入索引‘i’的空槽中，之后索引‘j’的槽变为空，并等待另一个值。
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Similarly, lines 23–27 search from left for such a value “A[i]” which should
    be moved to the right part. Once found, lines 28–30 place it into the empty slot
    at index ‘j’, after which the slot at index ‘i’ again becomes empty, and waits
    for another value.
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 同样，第23至27行从左侧查找应当移动到右侧部分的值“A[i]”。一旦找到，第28至30行将其放入索引‘j’的空槽中，之后索引‘i’的槽变为空，并等待另一个值。
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This pattern is continued in the main loop of the algorithm, at lines 14–30.
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这种模式在算法的主循环中得以延续，位于第14至30行。
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once indexes ‘i’ and ‘j’ meet each other, we have an empty slot there, and lines
    31 and 32 assign the originally remembered value in ‘tmp’ variable there, so the
    index ‘j’ becomes the first one to hold such value which belongs to the right
    part.
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一旦索引‘i’和‘j’相遇，我们就在该位置有一个空槽，第31和32行将最初记住的‘tmp’变量中的值放入该槽中，之后索引‘j’成为持有该值的第一个位置，这个值属于右侧部分。
- en: ''
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The last line returns that index.
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一行返回那个索引。
- en: This way we can write 2 assignments of the cycle together in the loop’s body,
    because as it was proven in chapter 3, ‘*L*’ is always an even number.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以将循环体中的两个赋值操作合并在一起，因为正如第3章所证明的那样，‘*L*’总是一个偶数。
- en: Time complexity of this algorithm is also *O*(*N*), as we still scan the sequence
    from both ends. It just does 1.5x less value assignments, so the speed-up is reflected
    only in the constant factor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的时间复杂度也是*O*(*N*)，因为我们仍然是从两端扫描序列。它只是做了1.5倍更少的值赋值操作，因此加速仅反映在常数因子上。
- en: An implementation of Cyclic partition in the C++ language is present on GitHub,
    and is referenced at the end of this story [1].
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上有一个用C++语言实现的循环分区，可以在故事的最后找到引用[1]。
- en: I also want to show that the value ‘*L*’ figuring in the Hoare scheme can’t
    be lowered, regardless of what partitioning scheme we use. Assume that after partitioning,
    the length of the left part will be “*left_n*”, and length of the right part will
    be “*right_n*”. Now, if looking at the left-aligned “*left_n*”-long area of the
    original unpartitioned array, we will find some ‘*t1*’ values there, which are
    not at their final places. So those are such values which are greater or equal
    to ‘*p*’, and should be moved to the right part anyway.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想表明，在Hoare方案中出现的值‘*L*’无论我们使用什么分区方案，都无法降低。假设分区后，左侧部分的长度为“*left_n*”，右侧部分的长度为“*right_n*”。现在，如果查看原始未分区数组的左对齐“*left_n*”长区域，我们会发现其中有一些‘t1’值，它们还没有放到最终的位置。所以，这些是大于或等于‘*p*’的值，应该无论如何都要移动到右侧部分。
- en: '![](../Images/d395148fb74f9a7086da0d3df7bba2ad.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d395148fb74f9a7086da0d3df7bba2ad.png)'
- en: '*Illustration of the sequence before and after partitioning.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*分区前后序列的示意图。*'
- en: Length of the left part is “left_n=7” and length of the right part is “right_n=5”.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧部分的长度是“left_n=7”，右侧部分的长度是“right_n=5”。
- en: Among the first 7 values of the unpartitioned sequence there are “t1=3” of them
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在未分区序列的前7个值中，有“t1=3”个值。
- en: which are greater than “p=20” (the yellow ones), and should be somehow moved
    to the right part.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值大于“p=20”（黄色的值），应该以某种方式移动到右侧部分。
- en: And among the last 5 values of the unpartitioned sequence there are “t2=3” of
    them
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 而在未分区序列的最后5个值中，有“t2=3”个值。
- en: which are less than ‘p’ (the light green ones), and should be somehow moved
    to the left part.*
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值小于‘p’（浅绿色的值），应该以某种方式移动到左侧部分。*
- en: Similarly, if looking at the right-aligned “*right_n*”-long area of the original
    unpartitioned array, we will find some ‘*t2*’ values there, which are also not
    at their final places. Those are such values which are less than ‘*p*’, and should
    be moved to the left part. We can’t move less than ‘*t1*’ values from left to
    right, as well as we can’t move less than ‘*t2*’ values from right to left.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果观察原始未划分数组的右对齐的“*right_n*”长区域，我们将找到一些‘*t2*’值，它们也没有处于最终位置。这些值小于‘*p*’，应该移动到左边部分。我们不能把小于‘*t1*’的值从左移到右，也不能把小于‘*t2*’的值从右移到左。
- en: 'In the Hoare partitioning scheme, the ‘*t1*’ and ‘*t2*’ values are the ones
    which are swapped between each other. So there we have:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在霍尔划分方案中，‘*t1*’和‘*t2*’值是相互交换的。所以这里我们有：
- en: t1 = t2 = L/2,
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: t1 = t2 = L/2，
- en: or
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: t1 + t2 = L.
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: t1 + t2 = L。
- en: Which means that ‘*L*’ is actually the minimal amount of values which should
    be somehow rearranged, in order for the sequence to become partitioned. And the
    Cyclic partition algorithm rearranges them doing just “*L*+1” assignments. That’s
    why I allow myself to call this new partitioning scheme as “nearly optimal”.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着‘*L*’实际上是应该以某种方式重新排列的最小值数量，以使得序列能够被划分。而循环划分算法通过执行“*L*+1”次赋值来完成重新排列。这就是为什么我允许自己称这种新的划分方案为“几乎最优”的原因。
- en: 6\. Experimental results
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 实验结果
- en: It is already proven that the new partitioning scheme is doing fewer assignments
    of values, so we can expect it to run faster. However, before publishing the algorithm
    I wanted to collect the results also in an experimental way.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 已经证明新的划分方案进行的赋值操作更少，因此我们可以期望它运行得更快。然而，在发布算法之前，我希望以实验的方式收集结果。
- en: I have compared the running times when partitioning by the Hoare scheme and
    by Cyclic partition. All the experiments were performed on randomly shuffled arrays.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经比较了使用霍尔（Hoare）方案和循环划分（Cyclic partition）方案时的运行时间。所有实验都是在随机打乱的数组上进行的。
- en: 'The parameters by which the experiments were different are:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实验之间的不同参数是：
- en: '*N* — length of the array,'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N* — 数组的长度，'
- en: “left_part_percent” — percent of length of the left part (upon *N*), which results
    after partitioning,
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “left_part_percent” — 划分后左边部分的长度百分比（相对于*N*），
- en: running on array of primitive data type variables (32-bit integers) *vs.* on
    array of some kind of large objects (256-long static arrays of 16-bit integers).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始数据类型变量数组（32位整数）*vs.* 大对象数组（256长静态数组，包含16位整数）上的运行。
- en: I want to clarify why I found it necessary to run partitioning both on arrays
    of primitive data types, and on arrays of large objects. Here, by saying “large
    object” I mean such values, which occupy much more memory, compared to primitive
    data types. When partitioning primitive data types, assigning one variable to
    another will work as fast as almost all other instructions used in both algorithms
    (like incrementing an index or checking condition of the loop). Meanwhile when
    partitioning large objects, assigning one such object to another will take significantly
    more time, compared to other used instructions, and that is when we are interested
    to reduce the overall number of value assignments as much as that is possible.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我想澄清一下为什么我认为有必要对原始数据类型的数组和大对象的数组进行划分。在这里，所谓的“大对象”是指占用的内存比原始数据类型要多得多的值。当划分原始数据类型时，将一个变量赋值给另一个变量的速度与算法中几乎所有其他指令（如递增索引或检查循环条件）一样快。与此同时，当划分大对象时，将一个此类对象赋值给另一个将比其他使用的指令需要更多的时间，而这正是我们希望减少赋值总次数的原因。
- en: I’ll explain why I decided to run different experiments with different values
    of “left_part_percent” a bit later in this chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍后会解释为什么我决定在本章稍后进行不同的实验，使用不同的“left_part_percent”值。
- en: 'The experiments were performed with Google Benchmark, under the following system:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 实验是在以下系统上使用 Google Benchmark 执行的：
- en: 'CPU: Intel Core i7–11800H @ 2.30GHz'
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'CPU: Intel Core i7–11800H @ 2.30GHz'
- en: 'RAM: 16.0 GB'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '内存: 16.0 GB'
- en: 'OS: Windows 11 Home, 64-bit'
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '操作系统: Windows 11 Home, 64位'
- en: 'Compiler: MSVC 2022 ( /O2 /Ob2 /MD /GR /Gd )'
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '编译器: MSVC 2022 ( /O2 /Ob2 /MD /GR /Gd )'
- en: '*Partitioning arrays of a primitive data type*'
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*原始数据类型数组的划分*'
- en: 'Here are the results of running partition algorithms on arrays of primitive
    data type — 32 bit integer:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对原始数据类型数组（32位整数）运行划分算法的结果：
- en: '![](../Images/5dc5942fff1891d9586462a471299fdf.png)![](../Images/3635c3e77ec7d8b6b9fdbfefe66f71ed.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5dc5942fff1891d9586462a471299fdf.png)![](../Images/3635c3e77ec7d8b6b9fdbfefe66f71ed.png)'
- en: '*Running times of partitioning algorithms, on array of 32-bit integers, having
    length N=10''000.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*在包含32位整数的数组上的分区算法运行时间，数组长度为N=10''000。*'
- en: Blue bars correspond to partitioning by Hoare scheme,
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色柱状图对应于霍尔分区算法，
- en: while red bars correspond to the Cyclic partition algorithm.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 而红色柱状图则对应于循环分区算法。
- en: Partitioning algorithms are run for 5 different cases, based on “left_part_percent”
    — percent of the left part of array (upon N), that will appear after partitioning.
    The time is presented in nanoseconds.*
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 分区算法在5种不同的情况下运行，基于“left_part_percent”——分区后数组左部分所占百分比（基于N）。时间以纳秒为单位表示。*
- en: We see that there is no obvious correlation between value of “left_part_percent”
    and relative difference in running times of the 2 algorithms. This kind of behavior
    is expected.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，“left_part_percent”的值与两个算法运行时间的相对差异之间没有明显的关联。这种行为是预期中的。
- en: '*Partitioning arrays of “large objects”*'
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*分区“large objects”数组*'
- en: And here are the results of running the 2 partitioning algorithms on array of
    so called “large objects” — each of which is an 256-long static array of 16-bit
    random integers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是运行两个分区算法的结果，针对所谓的“large objects”数组——每个数组是一个包含256个16位随机整数的静态数组。
- en: '![](../Images/c96678e7fda50c54f2b241541c080557.png)![](../Images/f53f40b7b62dab8d72b720966896c573.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c96678e7fda50c54f2b241541c080557.png)![](../Images/f53f40b7b62dab8d72b720966896c573.png)'
- en: '*Running times of partitioning algorithms, on array of large objects'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*在“large objects”数组上的分区算法运行时间*'
- en: (256-long static arrays of random 16-bit integers), having length N=10'000.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: （256长的静态数组，包含随机的16位整数），长度为N=10'000。
- en: Blue bars correspond to partitioning by Hoare scheme,
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色柱状图对应于霍尔分区算法，
- en: while red bars correspond to the Cyclic partition algorithm.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 而红色柱状图则对应于循环分区算法。
- en: Partitioning algorithms are run for 5 different cases, based on “left_part_percent”
    — percent of the left part of array (upon N), that will appear after partitioning.
    The time is presented in nanoseconds.*
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 分区算法在5种不同的情况下运行，基于“left_part_percent”——分区后数组左部分所占百分比（基于N）。时间以纳秒为单位表示。*
- en: 'Now we see an obvious correlation: Cyclic partition outperforms the Hoare scheme
    as more, as the “left_part_percent” is closer to 50%. In other words, Cyclic partition
    works relatively faster when after partitioning the left and right parts of the
    array appear to have closer lengths. This is also an expected behavior.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到一个明显的关联：当“left_part_percent”接近50%时，循环分区算法的性能优于霍尔分区算法。换句话说，当分区后数组的左右部分长度接近时，循环分区算法的运行速度相对较快。这也是预期的行为。
- en: Explanation of the results
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果解释
- en: '*— Why does partitioning generally take longer, when “left_part_percent” is
    closer to 50%?*'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*— 为什么当“left_part_percent”接近50%时，分区通常需要更长时间？*'
- en: Let’s imagine for a moment a corner case — when after partitioning almost all
    values appear in left (or right) part. This will mean that almost all values of
    the array were less (or greater) than the pivot value. And it will mean that during
    the scan, all those values were considered to be already at their final positions,
    and very few assignments of values were performed. If trying to imagine the other
    case — when after partitioning the left and right parts appear to have almost
    equal length, it will mean that a lot of value assignments were performed (as
    initially all the values were randomly shuffled in the array).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时设想一个极端情况——当分区后几乎所有值出现在左边（或右边）部分时。这意味着几乎所有的数组值都小于（或大于）枢轴值。这还意味着在扫描过程中，所有这些值被认为已经位于最终位置，只有很少的值进行了赋值操作。如果设想另一种情况——当分区后，左右部分的长度几乎相等时，这将意味着进行了大量的值赋值操作（因为最初数组中的所有值都是随机打乱的）。
- en: '*— When looking at partitioning of “large objects”, why does the difference
    in running time of the 2 algorithms become greater when “left_part_percent” gets
    closer to 50%?*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*— 为什么在分区“large objects”时，当“left_part_percent”接近50%时，两个算法的运行时间差异会更大？*'
- en: The previous explanation shows that when “left_part_percent” gets closer to
    50%, there arises need to do more assignments of values in the array. In previous
    chapters we also have shown that Cyclic partition always makes 1.5x less value
    assignments, compared to Hoare scheme. So that difference of 1.5 times brings
    more impact on overall running time when we generally need to do more rearrangements
    of values in the array.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的解释表明，当“left_part_percent”接近 50% 时，就需要在数组中进行更多的值赋值。在前面的章节中，我们也展示过，相较于 Hoare
    算法，循环分区总是会减少 1.5 倍的值赋值次数。因此，这 1.5 倍的差异在整体运行时间上会带来更大的影响，尤其是在我们通常需要做更多值重新排列的时候。
- en: '*— Why is the absolute time (in nanoseconds) greater when partitioning “large
    objects”, rather than when partitioning 32-bit integers?*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*— 为什么在分区“大型对象”时，绝对时间（以纳秒为单位）比分区 32 位整数时更长？*'
- en: This one is simple — because assigning one “large object” to another takes much
    more time, than assigning one primitive data type to another.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题很简单——因为将一个“大型对象”赋值给另一个对象，所花费的时间要比将一个原始数据类型赋值给另一个原始数据类型要长得多。
- en: I also run all the experiments on arrays with different lengths, but the overall
    picture didn’t change.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我也在不同长度的数组上进行了所有实验，但整体结果并没有改变。
- en: 7\. Conclusion
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7\. 结论
- en: In this story I introduced an altered partitioning scheme, called “Cyclic partition”.
    It always makes 1.5 times fewer value assignments, compared to the currently used
    Hoare partitioning scheme.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本故事中，我介绍了一种修改过的分区方案，称为“循环分区”。与当前使用的 Hoare 分区方案相比，它总是能减少 1.5 倍的值赋值次数。
- en: Surely, when partitioning a sequence, value assignment is not the only type
    of operation performed. Besides it, partitioning algorithms check values of input
    sequence “*A*” for being less or greater than the pivot value ‘*p*’, as well as
    they do increments and decrements of indexes over “*A*”. The amounts of comparisons,
    increments and decrements are not affected by introducing “cyclic partition”,
    so we can’t just expect it to run 1.5x faster. However, when partitioning an array
    of complex data types, where value assignment is significantly more time-consuming
    than simply incrementing or decrementing an index, the overall algorithm can actually
    run up to 1.5 times faster.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在对序列进行分区时，值赋值并不是唯一的操作类型。除了赋值之外，分区算法还需要检查输入序列“*A*”中的值是否小于或大于枢轴值‘*p*’，并且还会对“*A*”中的索引进行增减操作。比较次数、增减操作的次数与引入“循环分区”没有关系，因此我们不能仅仅期待它能跑得
    1.5 倍更快。然而，当分区一个包含复杂数据类型的数组时，值赋值操作比简单的索引增减操作要耗时得多，因此整体算法的执行时间可能会加快最多 1.5 倍。
- en: The partitioning procedure is the main routine of the QuickSort algorithm, as
    well as of the algorithm for finding the median of an unsorted array, or finding
    its *k*-th order statistic. So we can also expect for those algorithms to have
    a performance gain up to 1.5 times, when working on complex data types.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 分区过程是快速排序算法的主要步骤，同时也是查找无序数组中中位数或查找其 *k* 次序统计量的算法步骤。所以我们也可以预期，当处理复杂数据类型时，这些算法的性能提升可以达到
    1.5 倍。
- en: 'My gratitudes to:'
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我感谢：
- en: — Roza Galstyan, for reviewing the draft of the story and suggesting useful
    enhancements,
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — Roza Galstyan，感谢她审阅故事草稿并提出有益的改进建议，
- en: — David Ayrapetyan, for the spell check ( [https://www.linkedin.com/in/davidayrapetyan/](https://www.linkedin.com/in/davidayrapetyan/)
    ),
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — David Ayrapetyan，感谢他进行拼写检查（ [https://www.linkedin.com/in/davidayrapetyan/](https://www.linkedin.com/in/davidayrapetyan/)
    ），
- en: — Asya Papyan, for careful design of all used illustrations ( [https://www.behance.net/asyapapyan](https://www.behance.net/asyapapyan)
    ).
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — Asya Papyan，感谢她精心设计了所有使用的插图（ [https://www.behance.net/asyapapyan](https://www.behance.net/asyapapyan)
    ）。
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you enjoyed this story, feel free to find and connect me on LinkedIn ( [https://www.linkedin.com/in/tigran-hayrapetyan-cs/](https://www.linkedin.com/in/tigran-hayrapetyan-cs/)
    ).
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你喜欢这个故事，可以在 LinkedIn 上找到我并联系我（ [https://www.linkedin.com/in/tigran-hayrapetyan-cs/](https://www.linkedin.com/in/tigran-hayrapetyan-cs/)
    ）。
- en: ''
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All used images, unless otherwise noted, are designed by request of the author.
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有使用的图片，除非另有说明，都是根据作者的要求设计的。
- en: 'References:'
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献：
- en: '[1] — Implementation of Cyclic partition in C++ : [https://github.com/tigranh/cyclic_partition](https://github.com/tigranh/cyclic_partition)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] — C++ 中循环分区的实现： [https://github.com/tigranh/cyclic_partition](https://github.com/tigranh/cyclic_partition)'

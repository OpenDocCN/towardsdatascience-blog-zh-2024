<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Performant IPv4 Range Spark Joins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Performant IPv4 Range Spark Joins</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/performant-ipv4-range-spark-joins-95143b305436?source=collection_archive---------3-----------------------#2024-01-25">https://towardsdatascience.com/performant-ipv4-range-spark-joins-95143b305436?source=collection_archive---------3-----------------------#2024-01-25</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="e10a" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">A Practical guide to optimizing non-equi joins in Spark</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@jean-claude.cote?source=post_page---byline--95143b305436--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Jean-Claude Cote" class="l ep by dd de cx" src="../Images/aea2df9c7b95fc85cc336f64d64b0a76.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*ZDeTO2JYRo3sVd9Y_iIQ-w.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--95143b305436--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@jean-claude.cote?source=post_page---byline--95143b305436--------------------------------" rel="noopener follow">Jean-Claude Cote</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--95143b305436--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">9 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Jan 25, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">1</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/e2dd3d2557024e0fd123571495dea461.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kylRIj1THWjnUhQaPGIS5Q.jpeg"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Photo by John Lee on Unsplash</figcaption></figure><p id="b9cd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Enriching network events with IP geolocation information is a crucial task, especially for organizations like the <a class="af ny" href="https://www.cyber.gc.ca/en" rel="noopener ugc nofollow" target="_blank">Canadian Centre for Cyber Security</a>, the national CSIRT of Canada. In this article, we will demonstrate how to optimize Spark SQL joins, specifically focusing on scenarios involving non-equality conditions — a common challenge when working with IP geolocation data.</p><p id="392e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As cybersecurity practitioners, our reliance on enriching network events with IP geolocation databases necessitates efficient strategies for handling non-equi joins. While numerous articles shed light on various join strategies supported by Spark, the practical application of these strategies remains a prevalent concern for professionals in the field.</p><p id="d3ab" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">David Vrba’s insightful article, <a class="af ny" rel="noopener" target="_blank" href="/about-joins-in-spark-3-0-1e0ea083ea86">“About Joins in Spark 3.0”</a>, published on Towards Data Science, serves as a valuable resource. It explains the conditions guiding Spark’s selection of specific join strategies. In his article, David briefly suggests that optimizing non-equi joins involves transforming them into equi-joins.</p><p id="f6f7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This write-up aims to provide a practical guide for optimizing the performance of a non-equi JOIN, with a specific focus on joining with IP ranges in a geolocation table.</p><p id="aaa7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To exemplify these optimizations, we will revisit the geolocation table introduced <a class="af ny" rel="noopener" target="_blank" href="/unleashing-the-power-of-sql-analytical-window-functions-a-deep-dive-into-fusing-ipv4-blocks-62bf2b3405e0">in our previous article</a>.</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="bb25" class="od oe fq oa b bg of og l oh oi">+----------+--------+---------+-----------+-----------+<br/>| start_ip | end_ip | country |    city   |   owner   |<br/>+----------+--------+---------+-----------+-----------+<br/>| 1        | 2      | ca      | Toronto   | Telus     |<br/>| 3        | 4      | ca      | Quebec    | Rogers    |<br/>| 5        | 8      | ca      | Vancouver | Bell      |<br/>| 10       | 14     | ca      | Montreal  | Telus     |<br/>| 19       | 22     | ca      | Ottawa    | Rogers    |<br/>| 23       | 29     | ca      | Calgary   | Videotron |<br/>+----------+--------+---------+-----------+-----------+</span></pre><h2 id="0857" class="oj oe fq bf ok ol om on oo op oq or os nl ot ou ov np ow ox oy nt oz pa pb pc bk">Equi-Join</h2><p id="097b" class="pw-post-body-paragraph nc nd fq ne b go pd ng nh gr pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx fj bk">To illustrate Spark’s execution of an equi-join, we’ll initiate our exploration by considering a hypothetical scenario. Suppose we have a table of events, each event being associated with a specific <code class="cx pi pj pk oa b">owner</code>denoted by the <code class="cx pi pj pk oa b">event_owner</code> column.</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="def8" class="od oe fq oa b bg of og l oh oi">+------------+--------------+<br/>| event_time | event_owner  |<br/>+------------+--------------+<br/>| 2024-01-01 | Telus        |<br/>| 2024-01-02 | Bell         |<br/>| 2024-01-03 | Rogers       |<br/>| 2024-01-04 | Videotron    |<br/>| 2024-01-05 | Telus        |<br/>| 2024-01-06 | Videotron    |<br/>| 2024-01-07 | Rogers       |<br/>| 2024-01-08 | Bell         |<br/>+------------+--------------+</span></pre><p id="1b5b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let’s take a closer look at how Spark handles this equi-join:</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="76d6" class="od oe fq oa b bg of og l oh oi">SELECT<br/>  *<br/>FROM<br/>  events<br/>  JOIN geolocation<br/>  ON (event_owner = owner)</span></pre><p id="a1bd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this example, the equi-join is established between the <code class="cx pi pj pk oa b">events</code> table and the <code class="cx pi pj pk oa b">geolocation</code> table. The linking criterion is based on the equality of the <code class="cx pi pj pk oa b">event_owner</code> column in the <code class="cx pi pj pk oa b">events</code> table and the <code class="cx pi pj pk oa b">owner</code> column in the <code class="cx pi pj pk oa b">geolocation</code> table.</p><p id="9470" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">As explained by David Vrba in his blog post:</p><blockquote class="pl pm pn"><p id="154b" class="nc nd po ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Spark will plan the join with SMJ if there is an equi-condition and the joining keys are sortable</p></blockquote><p id="e011" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Spark will execute a Sort Merge Join, distributing the rows of the two tables by hashing the <code class="cx pi pj pk oa b">event_owner</code> on the left side and the <code class="cx pi pj pk oa b">owner</code> on the right side. Rows from both tables that hash to the same Spark partition will be processed by the same Spark task—a unit of work. For example, Task-1 might receive:</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="d4e8" class="od oe fq oa b bg of og l oh oi">+----------+-------+---------+-----------+-----------+<br/>| start_ip | end_ip| country |   city    |   owner   |<br/>+----------+-------+---------+-----------+-----------+<br/>| 1        | 2     | ca      | Toronto   | Telus     |<br/>| 10       | 14    | ca      | Montreal  | Telus     |<br/>+----------+-------+---------+-----------+-----------+<br/><br/>+------------+--------------+<br/>| event_time | event_owner  |<br/>+------------+--------------+<br/>| 2024-01-01 | Telus        |<br/>| 2024-01-05 | Telus        |<br/>+------------+--------------+</span></pre><p id="c9b1" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Notice how Task-1 handles only a subset of the data. The join problem is divided into multiple smaller tasks, where only a subset of the rows from both the left and right sides is required. Furthermore, the left and right side rows processed by Task-1 have to match. This is true because every occurrence of “Telus” will hash to the same partition, regardless of whether it comes from the <code class="cx pi pj pk oa b">events</code> or <code class="cx pi pj pk oa b">geolocation</code> tables. We can be certain that no other Task-X will have rows with an<code class="cx pi pj pk oa b"> owner</code> of “Telus”.</p><p id="4e51" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Once the data is divided as shown above, Spark will sort both sides, hence the name of the join strategy, Sort Merge Join. The merge is performed by taking the first row on the left and testing if it matches the right. Once the rows on the right no longer match, Spark will pull rows from the left. It will keep dequeuing each side until no rows are left on either side.</p><h2 id="c15c" class="oj oe fq bf ok ol om on oo op oq or os nl ot ou ov np ow ox oy nt oz pa pb pc bk">Non-equi Join</h2><p id="35f2" class="pw-post-body-paragraph nc nd fq ne b go pd ng nh gr pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx fj bk">Now that we have a better understanding of how equi-joins are performed, let’s contrast it with a non-equi join. Suppose we have events with an <code class="cx pi pj pk oa b">event_ip</code>, and we want to add geolocation information to this table.</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="f1d8" class="od oe fq oa b bg of og l oh oi">+------------+----------+<br/>| event_time | event_ip |<br/>+------------+----------+<br/>| 2024-01-01 |    6     |<br/>| 2024-01-02 |   14     |<br/>| 2024-01-03 |   18     |<br/>| 2024-01-04 |   27     |<br/>| 2024-01-05 |    9     |<br/>| 2024-01-06 |   23     |<br/>| 2024-01-07 |   15     |<br/>| 2024-01-08 |    1     |<br/>+------------+----------+</span></pre><p id="110c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To execute this join, we need to determine the IP range within which the <code class="cx pi pj pk oa b">event_ip</code> falls. We accomplish this with the following condition:</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="f3bb" class="od oe fq oa b bg of og l oh oi">SELECT<br/>  *<br/>FROM<br/>  events<br/>  JOIN geolocation<br/>  ON (event_ip &gt;= start_ip and event_ip &lt;= end_ip)</span></pre><p id="eb71" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, let’s consider how Spark will execute this join. On the right side (the geolocation table), there is no key by which Spark can hash and distribute the rows. It is impossible to divide this problem into smaller tasks that can be distributed across the compute cluster and performed in parallel.</p><p id="aa5d" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In a situation like this, Spark is forced to employ more resource-intensive join strategies. As stated by David Vrba:</p><blockquote class="pl pm pn"><p id="b956" class="nc nd po ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">If there is no equi-condition, Spark has to use BroadcastNestedLoopJoin (BNLJ) or cartesian product (CPJ).</p></blockquote><p id="edcd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Both of these strategies involve brute-forcing the problem; for every row on the left side, Spark will test the “between” condition on every single row of the right side. It has no other choice. If the table on the right is small enough, Spark can optimize by copying the right-side table to every task reading the left side, a scenario known as the BNLJ case. However, if the left side is too large, each task will need to read both the right and left sides of the table, referred to as the CPJ case. In either case, both strategies are highly costly.</p><p id="b22c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">So, how can we improve this situation? The trick is to introduce an equality in the join condition. For example, we could simply unroll all the IP ranges in the geolocation table, producing a row for every IP found in the IP ranges.</p><p id="51f7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This is easily achievable in Spark; we can execute the following SQL to unroll all the IP ranges:</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="29b2" class="od oe fq oa b bg of og l oh oi">SELECT<br/>  country,<br/>  city,<br/>  owner,<br/>  explode(sequence(start_ip, end_ip)) AS ip<br/>FROM<br/>  geolocation</span></pre><p id="eca6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The <a class="af ny" href="https://spark.apache.org/docs/latest/api/sql/#sequence" rel="noopener ugc nofollow" target="_blank">sequence</a> function creates an array with the IP values from <code class="cx pi pj pk oa b">start_ip </code>to <code class="cx pi pj pk oa b">end_ip</code>. The <a class="af ny" href="https://spark.apache.org/docs/latest/api/sql/#explode" rel="noopener ugc nofollow" target="_blank">explode</a> function unrolls this array into individual rows.</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="fe82" class="od oe fq oa b bg of og l oh oi">+---------+---------+---------+-----------+<br/>| country |   city    |  owner    |   ip   |<br/>+---------+---------+---------+-----------+<br/>|   ca    | Toronto   |  Telus    |   1    |<br/>|   ca    | Toronto   |  Telus    |   2    |<br/>|   ca    | Quebec    |  Rogers   |   3    |<br/>|   ca    | Quebec    |  Rogers   |   4    |<br/>|   ca    | Vancouver |  Bell     |   5    |<br/>|   ca    | Vancouver |  Bell     |   6    |<br/>|   ca    | Vancouver |  Bell     |   7    |<br/>|   ca    | Vancouver |  Bell     |   8    |<br/>|   ca    | Montreal  |  Telus    |  10    |<br/>|   ca    | Montreal  |  Telus    |  11    |<br/>|   ca    | Montreal  |  Telus    |  12    |<br/>|   ca    | Montreal  |  Telus    |  13    |<br/>|   ca    | Montreal  |  Telus    |  14    |<br/>|   ca    | Ottawa    |  Rogers   |  19    |<br/>|   ca    | Ottawa    |  Rogers   |  20    |<br/>|   ca    | Ottawa    |  Rogers   |  21    |<br/>|   ca    | Ottawa    |  Rogers   |  22    |<br/>|   ca    | Calgary   | Videotron |  23    |<br/>|   ca    | Calgary   | Videotron |  24    |<br/>|   ca    | Calgary   | Videotron |  25    |<br/>|   ca    | Calgary   | Videotron |  26    |<br/>|   ca    | Calgary   | Videotron |  27    |<br/>|   ca    | Calgary   | Videotron |  28    |<br/>|   ca    | Calgary   | Videotron |  29    |<br/>+---------+---------+---------+-----------+</span></pre><p id="8941" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">With a key on both sides, we can now execute an equi-join, and Spark can efficiently distribute the problem, resulting in optimal performance. However, in practice, this scenario is not realistic, as a genuine geolocation table often contains billions of rows.</p><p id="10bc" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To address this, we can enhance the efficiency by increasing the coarseness of this mapping. Instead of mapping IP ranges to each individual IP, we can map the IP ranges to segments within the IP space. Let’s assume we divide the IP space into segments of 5. The segmented space would look something like this:</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="03c5" class="od oe fq oa b bg of og l oh oi">+---------------+-------------+-----------+<br/>| segment_start | segment_end | bucket_id |<br/>+---------------+-------------+-----------+<br/>|       1       |      5      |     0     |<br/>|       6       |     10      |     1     |<br/>|      11       |     15      |     2     |<br/>|      16       |     20      |     3     |<br/>|      21       |     25      |     4     |<br/>|      26       |     30      |     5     |<br/>+---------------+-------------+-----------+</span></pre><p id="85df" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, our objective is to map the IP ranges to the segments they overlap with. Similar to what we did earlier, we can unroll the IP ranges, but this time, we’ll do it in segments of 5.</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="c368" class="od oe fq oa b bg of og l oh oi">SELECT<br/>  country,<br/>  city,<br/>  owner,<br/>  explode(sequence(start_ip / 5, end_ip / 5)) AS bucket_id<br/>FROM<br/>  geolocations</span></pre><p id="db1c" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We observe that certain IP ranges share a <code class="cx pi pj pk oa b">bucket_id</code>. Ranges 1–2 and 3–4 both fall within the segment 1–5.</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="e9ce" class="od oe fq oa b bg of og l oh oi">+----------+--------+---------+-----------+-----------+-----------+<br/>| start_ip | end_ip | country |    city   |   owner   | bucket_id |<br/>+----------+--------+---------+-----------+-----------+-----------+<br/>|    1     |    2   |   ca    | Toronto   |   Telus   |     0     |<br/>|    3     |    4   |   ca    | Quebec    |  Rogers   |     0     |<br/>|    5     |    8   |   ca    | Vancouver |   Bell    |     1     |<br/>|   10     |   14   |   ca    | Montreal  |   Telus   |     2     |<br/>|   19     |   22   |   ca    |  Ottawa   |  Rogers   |     3     |<br/>|   19     |   22   |   ca    |  Ottawa   |  Rogers   |     4     |<br/>|   23     |   29   |   ca    | Calgary   | Videotron |     4     |<br/>|   23     |   29   |   ca    | Calgary   | Videotron |     5     |<br/>+----------+--------+---------+-----------+-----------+-----------+</span></pre><p id="e9c4" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Additionally, we notice that some IP ranges are duplicated. The last two rows for the IP range 23–29 overlap with segments 20–25 and 26–30. Similar to the scenario where we unrolled individual IPs, we are still duplicating rows, but to a much lesser extent.</p><p id="792e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, we can utilize this bucketed table to perform our join.</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="cf3f" class="od oe fq oa b bg of og l oh oi">SELECT<br/>  *<br/>FROM<br/>  events<br/>  JOIN geolocation<br/>  ON (<br/>    event_ip / 5 = bucket_id<br/>    AND event_ip &gt;= start_ip<br/>    AND event_ip &lt;= end_ip<br/>  )</span></pre><p id="dd51" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The equality in the join enables Spark to perform a Sort Merge Join (SMJ) strategy. The “between” condition eliminates cases where IP ranges share the same <code class="cx pi pj pk oa b">bucket_id</code>.</p><p id="1ff6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this illustration, we used segments of 5; however, in reality, we would segment the IP space into segments of 256. This is because the global IP address space is overseen by the Internet Assigned Numbers Authority (IANA), and traditionally, IANA allocates address space in blocks of 256 IPs.</p><p id="8a9b" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Analyzing the IP ranges in a genuine geolocation table using the Spark <code class="cx pi pj pk oa b">approx_percentile</code> function reveals that most records have spans of less than 256, while very few are larger than 256.</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="904f" class="od oe fq oa b bg of og l oh oi">SELECT <br/>    approx_percentile(<br/>        end_ip - start_ip, <br/>        array(0.800, 0.900, 0.950, 0.990, 0.999, 0.9999),<br/>        10000)<br/>FROM<br/>    geolocation</span></pre><p id="1061" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">This implies that most IP ranges are assigned a <code class="cx pi pj pk oa b">bucket_id</code>, while the few larger ones are unrolled, resulting in the unrolled table containing approximately an extra 10% of rows.</p><p id="26d2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A query executed with a genuine geolocation table might resemble the following:</p><pre class="mm mn mo mp mq nz oa ob bp oc bb bk"><span id="ff58" class="od oe fq oa b bg of og l oh oi">WITH<br/>  b_geo AS (<br/>    SELECT<br/>      explode(<br/>        sequence(<br/>          CAST(start_ip / 256 AS INT), <br/>          CAST(end_ip / 256 AS INT))) AS bucket_id,<br/>      *<br/>    FROM<br/>      geolocation<br/>  ),<br/>  b_events AS (<br/>    SELECT<br/>      CAST(event_ip / 256 AS INT) AS bucket_id,<br/>      *<br/>    FROM<br/>      events<br/>  )<br/><br/>SELECT<br/>  *<br/>FROM<br/>  b_events<br/>  JOIN b_geo<br/>  ON (<br/>    b_events.bucket_id = b_geo.bucket_id<br/>    AND b_events.event_ip &gt;= b_geo.start_ip<br/>    AND b_events.event_ip &lt;= b_geo.end_ip<br/>  );</span></pre><h2 id="aa74" class="oj oe fq bf ok ol om on oo op oq or os nl ot ou ov np ow ox oy nt oz pa pb pc bk">Conclusion</h2><p id="271f" class="pw-post-body-paragraph nc nd fq ne b go pd ng nh gr pe nj nk nl pf nn no np pg nr ns nt ph nv nw nx fj bk">In conclusion, this article has presented a practical demonstration of converting a non-equi join into an equi-join through the implementation of a mapping technique that involves segmenting IP ranges. It’s crucial to note that this approach extends beyond IP addresses and can be applied to any dataset characterized by bands or ranges.</p><p id="2473" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The ability to effectively map and segment data is a valuable tool in the arsenal of data engineers and analysts, providing a pragmatic solution to the challenges posed by non-equality conditions in Spark SQL joins.</p></div></div></div></div>    
</body>
</html>
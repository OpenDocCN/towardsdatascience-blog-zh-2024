["```py\nimport numpy as np\nimport numpy.random as rnd\nimport matplotlib.pyplot as plt\n\nx = np.arange(-10,10, 0.01)\ny = x**2\nplt.plot(x,y, lw=3)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.grid(True)\nplt.show()\n```", "```py\ndef function(x):\n  y = []\n  for i in x:\n    if i>-3:\n      y.append(i**2-4*i+i**3)\n    else:\n      y.append(0.2*i**2)\n  return y\nx = np.arange(-10,3, 0.001)\ny = function(x)\nplt.plot(x,y, lw=3)\nplt.title('Function to optimize')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.grid(True)\nplt.show()\n```", "```py\nPOP_SIZE = 10 #population size \nMAX_ITER = 30 #the amount of optimization iterations\nw = 0.2 #inertia weight\nc1 = 1 #personal acceleration factor\nc2 = 2 #social acceleration factor\n```", "```py\ndef populate(size):\n  x1,x2 = -10, 3 #x1, x2 = right and left boundaries of our X axis\n  pop = rnd.uniform(x1,x2, size) # size = amount of particles in population\n  return pop\n```", "```py\nx1=populate(50) \ny1=function(x1)\n\nplt.plot(x,y, lw=3, label='Func to optimize')\nplt.plot(x1,y1,marker='o', ls='', label='Particles')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.grid(True)\nplt.show()\n```", "```py\n\"\"\"Particle Swarm Optimization (PSO)\"\"\"\nparticles = populate(POP_SIZE) #generating a set of particles\nvelocities = np.zeros(np.shape(particles)) #velocities of the particles\ngains = -np.array(function(particles)) #calculating function values for the population\n\nbest_positions = np.copy(particles) #it's our first iteration, so all positions are the best\nswarm_best_position = particles[np.argmax(gains)] #x with with the highest gain\nswarm_best_gain = np.max(gains) #highest gain\n\nl = np.empty((MAX_ITER, POP_SIZE)) #array to collect all pops to visualize afterwards\n\nfor i in range(MAX_ITER):\n\n    l[i] = np.array(np.copy(particles)) #collecting a pop to visualize\n\n    r1 = rnd.uniform(0, 1, POP_SIZE) #defining a random coefficient for personal behavior\n    r2 = rnd.uniform(0, 1, POP_SIZE) #defining a random coefficient for social behavior\n\n    velocities = np.array(w * velocities + c1 * r1 * (best_positions - particles) + c2 * r2 * (swarm_best_position - particles)) #calculating velocities\n\n    particles+=velocities #updating position by adding the velocity\n\n    new_gains = -np.array(function(particles)) #calculating new gains\n\n    idx = np.where(new_gains > gains) #getting index of Xs, which have a greater gain now\n    best_positions[idx] = particles[idx] #updating the best positions with the new particles\n    gains[idx] = new_gains[idx] #updating gains\n\n    if np.max(new_gains) > swarm_best_gain: #if current maxima is greateer than across all previous iters, than assign\n        swarm_best_position = particles[np.argmax(new_gains)] #assigning the best candidate solution\n        swarm_best_gain = np.max(new_gains) #assigning the best gain\n\n    print(f'Iteration {i+1} \\tGain: {swarm_best_gain}')\n```"]
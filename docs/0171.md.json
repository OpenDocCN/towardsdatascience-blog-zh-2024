["```py\ndef get_information(entity: str, type: str) -> str:\n    candidates = get_candidates(entity, type)\n    if not candidates:\n        return \"No information was found about the movie or person in the database\"\n    elif len(candidates) > 1:\n        newline = \"\\n\"\n        return (\n            \"Need additional information, which of these \"\n            f\"did you mean: {newline + newline.join(str(d) for d in candidates)}\"\n        )\n    data = graph.query(\n        description_query, params={\"candidate\": candidates[0][\"candidate\"]}\n    )\n    return data[0][\"context\"]\n```", "```py\ndocker-compose up\n```", "```py\ndef get_information(entity: str, type: str) -> str:\n    # Use full text index to find relevant movies or people\n    candidates = get_candidates(entity, type)\n    if not candidates:\n        return \"No information was found about the movie or person in the database\"\n    elif len(candidates) > 1:\n        newline = \"\\n\"\n        return (\n            \"Need additional information, which of these \"\n            f\"did you mean: {newline + newline.join(str(d) for d in candidates)}\"\n        )\n    data = graph.query(\n        description_query, params={\"candidate\": candidates[0][\"candidate\"]}\n    )\n    return data[0][\"context\"]\n```", "```py\nprint(get_information(\"John\", \"person\"))\n# Need additional information, which of these did you mean: \n# {'candidate': 'John Lodge', 'label': 'Person'}\n# {'candidate': 'John Warren', 'label': 'Person'}\n# {'candidate': 'John Gray', 'label': 'Person'}\n```", "```py\nprint(get_information(\"Keanu Reeves\", \"person\"))\n# type:Actor\n# title: Keanu Reeves\n# year: \n# ACTED_IN: Matrix Reloaded, The, Side by Side, Matrix Revolutions, The, Sweet November, Replacements, The, Hardball, Matrix, The, Constantine, Bill & Ted's Bogus Journey, Street Kings, Lake House, The, Chain Reaction, Walk in the Clouds, A, Little Buddha, Bill & Ted's Excellent Adventure, The Devil's Advocate, Johnny Mnemonic, Speed, Feeling Minnesota, The Neon Demon, 47 Ronin, Henry's Crime, Day the Earth Stood Still, The, John Wick, River's Edge, Man of Tai Chi, Dracula (Bram Stoker's Dracula), Point Break, My Own Private Idaho, Scanner Darkly, A, Something's Gotta Give, Watcher, The, Gift, The\n# DIRECTED: Man of Tai Chi\n```", "```py\nclass InformationInput(BaseModel):\n    entity: str = Field(description=\"movie or a person mentioned in the question\")\n    entity_type: str = Field(\n        description=\"type of the entity. Available options are 'movie' or 'person'\"\n    )\n```", "```py\nclass InformationTool(BaseTool):\n    name = \"Information\"\n    description = (\n        \"useful for when you need to answer questions about various actors or movies\"\n    )\n    args_schema: Type[BaseModel] = InformationInput\n\n    def _run(\n        self,\n        entity: str,\n        entity_type: str,\n        run_manager: Optional[CallbackManagerForToolRun] = None,\n    ) -> str:\n        \"\"\"Use the tool.\"\"\"\n        return get_information(entity, entity_type)\n```", "```py\ndef recommend_movie(movie: Optional[str] = None, genre: Optional[str] = None) -> str:\n    \"\"\"\n    Recommends movies based on user's history and preference\n    for a specific movie and/or genre.\n    Returns:\n        str: A string containing a list of recommended movies, or an error message.\n    \"\"\"\n    user_id = get_user_id()\n    params = {\"user_id\": user_id, \"genre\": genre}\n    if not movie and not genre:\n        # Try to recommend a movie based on the information in the db\n        response = graph.query(recommendation_query_db_history, params)\n        try:\n            return \", \".join([el[\"movie\"] for el in response])\n        except Exception:\n            return \"Can you tell us about some of the movies you liked?\"\n    if not movie and genre:\n        # Recommend top voted movies in the genre the user haven't seen before\n        response = graph.query(recommendation_query_genre, params)\n        try:\n            return \", \".join([el[\"movie\"] for el in response])\n        except Exception:\n            return \"Something went wrong\"\n\n    candidates = get_candidates(movie, \"movie\")\n    if not candidates:\n        return \"The movie you mentioned wasn't found in the database\"\n    params[\"movieTitles\"] = [el[\"candidate\"] for el in candidates]\n    query = recommendation_query_movie(bool(genre))\n    response = graph.query(query, params)\n    try:\n        return \", \".join([el[\"movie\"] for el in response])\n    except Exception:\n        return \"Something went wrong\"\n```", "```py\nclass RecommenderInput(BaseModel):\n    movie: Optional[str] = Field(description=\"movie used for recommendation\")\n    genre: Optional[str] = Field(\n        description=(\n            \"genre used for recommendation. Available options are:\" f\"{all_genres}\"\n        )\n    )\n```", "```py\nclass RecommenderTool(BaseTool):\n    name = \"Recommender\"\n    description = \"useful for when you need to recommend a movie\"\n    args_schema: Type[BaseModel] = RecommenderInput\n\n    def _run(\n        self,\n        movie: Optional[str] = None,\n        genre: Optional[str] = None,\n        run_manager: Optional[CallbackManagerForToolRun] = None,\n    ) -> str:\n        \"\"\"Use the tool.\"\"\"\n        return recommend_movie(movie, genre)\n```", "```py\ndef store_movie_rating(movie: str, rating: int):\n    user_id = get_user_id()\n    candidates = get_candidates(movie, \"movie\")\n    if not candidates:\n        return \"This movie is not in our database\"\n    response = graph.query(\n        store_rating_query,\n        params={\"user_id\": user_id, \"candidates\": candidates, \"rating\": rating},\n    )\n    try:\n        return response[0][\"response\"]\n    except Exception as e:\n        print(e)\n        return \"Something went wrong\"\n\nclass MemoryInput(BaseModel):\n    movie: str = Field(description=\"movie the user liked\")\n    rating: int = Field(\n        description=(\n            \"Rating from 1 to 5, where one represents heavy dislike \"\n            \"and 5 represent the user loved the movie\"\n        )\n    )\n```", "```py\nllm = ChatOpenAI(temperature=0, model=\"gpt-4\", streaming=True)\ntools = [InformationTool(), RecommenderTool(), MemoryTool()]\n\nllm_with_tools = llm.bind(functions=[format_tool_to_openai_function(t) for t in tools])\n\nprompt = ChatPromptTemplate.from_messages(\n    [\n        (\n            \"system\",\n            \"You are a helpful assistant that finds information about movies \"\n            \" and recommends them. If tools require follow up questions, \"\n            \"make sure to ask the user for clarification. Make sure to include any \"\n            \"available options that need to be clarified in the follow up questions \"\n            \"Do only the things the user specifically requested. \",\n        ),\n        MessagesPlaceholder(variable_name=\"chat_history\"),\n        (\"user\", \"{input}\"),\n        MessagesPlaceholder(variable_name=\"agent_scratchpad\"),\n    ]\n)\n\nagent = (\n    {\n        \"input\": lambda x: x[\"input\"],\n        \"chat_history\": lambda x: _format_chat_history(x[\"chat_history\"])\n        if x.get(\"chat_history\")\n        else [],\n        \"agent_scratchpad\": lambda x: format_to_openai_function_messages(\n            x[\"intermediate_steps\"]\n        ),\n    }\n    | prompt\n    | llm_with_tools\n    | OpenAIFunctionsAgentOutputParser()\n)\n\nagent_executor = AgentExecutor(agent=agent, tools=tools, verbose=True).with_types(\n    input_type=AgentInput, output_type=Output\n)\n```", "```py\nasync def get_agent_response(\n    input: str, stream_handler: StreamHandler, chat_history: Optional[List[Tuple]] = []\n):\n    url = \"http://api:8080/movie-agent/\"\n    st.session_state[\"generated\"].append(\"\")\n    remote_runnable = RemoteRunnable(url)\n    async for chunk in remote_runnable.astream_log(\n        {\"input\": input, \"chat_history\": chat_history}\n    ):\n        log_entry = chunk.ops[0]\n        value = log_entry.get(\"value\")\n        if isinstance(value, dict) and isinstance(value.get(\"steps\"), list):\n            for step in value.get(\"steps\"):\n                stream_handler.new_status(step[\"action\"].log.strip(\"\\n\"))\n        elif isinstance(value, str):\n            st.session_state[\"generated\"][-1] += value\n            stream_handler.new_token(value)\n```"]
- en: 'NuCS: A Constraint Solver for Research, Teaching, and Production Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/nucs-7b260afc2fe4?source=collection_archive---------11-----------------------#2024-11-22](https://towardsdatascience.com/nucs-7b260afc2fe4?source=collection_archive---------11-----------------------#2024-11-22)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/495306191bc8964f9fe64b4124ca060f.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Eric Prouzet](https://unsplash.com/@eprouzet?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Blazing-fast constraint solving in pure Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@yangeorget?source=post_page---byline--7b260afc2fe4--------------------------------)[![Yan
    Georget](../Images/4555bf99c8c71f6a3c905e828819c599.png)](https://medium.com/@yangeorget?source=post_page---byline--7b260afc2fe4--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--7b260afc2fe4--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--7b260afc2fe4--------------------------------)
    [Yan Georget](https://medium.com/@yangeorget?source=post_page---byline--7b260afc2fe4--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--7b260afc2fe4--------------------------------)
    ·6 min read·Nov 22, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: TLDR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[NuCS](https://github.com/yangeorget/nucs) is a **Python library** for solving
    Constraint Satisfaction and Optimisation Problems (CSP and COP) that I am developing
    as a side project. Because it is 100% written in Python, NuCS is easy to install
    and allows to model complex problems in a few lines of code. The NuCS solver is
    also very fast because it is powered by [**Numpy**](https://numpy.org/) and [**Numba**](https://numba.pydata.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Many problems can be formulated as CSPs. This is why a constraint library such
    as NuCS can benefit a lot of developers or data scientists.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider the famous N-queens problem which consists in placing *N* queens
    on a *N x N* chessboard such that the queens don't threaten each other.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/12beb4d111f5e0a9295ba09c194decc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A solution to the 8-queens problem. Source: [Yue Guo](http://yue-guo.com/wp-content/uploads/2019/02/N_queen.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **14200** solutions to the **12-queens** problems are found in less than
    **2s** on a MacBook Pro M2 running:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.11,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numpy 2.0.1,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numba 0.60.0 and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NuCS 3.0.0.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is constraint programming ?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Constraint programming** is a paradigm for solving combinatorial problems.
    In constraint programming, users declaratively state the constraints on the feasible
    solutions for a set of decision variables. Constraints specify the properties
    of a solution to be found. The solver combines constraint propagation and backtracking
    to find the solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, here is a model for the [Magic Sequence Problem](https://www.csplib.org/Problems/prob019)
    (find a sequence *x_0, … x_n-1* such that, for each *i* in *[0, n-1],* *x_i* is
    the number of occurrences of *i* in the sequence) using NuCS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In NuCS, a constraint is named a propagator.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The propagator (here *ALG_COUNT_EQ*) simply states that *x_i* is the number
    of occurrences of *i* in the sequence. The following two *ALG_AFFINE_EQ* propagators
    are redundant, meaning that they are not necessary for NuCS to find the solution
    but they speed up the resolution process.
  prefs: []
  type: TYPE_NORMAL
- en: See [the documentation](https://nucs.readthedocs.io/en/latest/reference.html#propagators)
    for a complete list of propagator supported by NuCS. Note that most propagators
    in NuCS are **global** (aka *n*-ary) and implement **state-of-art** propagation
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is the language of choice for data scientists: it has a simple syntax,
    a growing community and a great number of data science and machine learning libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But on the other hand, Python is known to be a slow language : maybe 50 to
    100 times slower than C depending on the benchmarks.'
  prefs: []
  type: TYPE_NORMAL
- en: The choice of Python for developing a high performance constraint programming
    library was not so obvious but we will see that the combined use of Numpy (high
    performance computing package) and Numba (Just-In-Time compilation for Python)
    helps a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Many attempts have been made to write constraint solvers in Python, but these
    are either slow or are only **wrappers** and depend on **external** solvers written
    in Java or C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: Numpy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[NumPy](https://numpy.org/) brings the computational power of languages like
    C and Fortran to Python.'
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://numpy.org/?source=post_page-----7b260afc2fe4--------------------------------)
    [## NumPy'
  prefs: []
  type: TYPE_NORMAL
- en: Powerful N-dimensional arrays Fast and versatile, the NumPy vectorization, indexing,
    and broadcasting concepts are the…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: numpy.org](https://numpy.org/?source=post_page-----7b260afc2fe4--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: In NuCS, everything is a Numpy array.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This allows to leverage Numpy's indexing and broadcasting capabilities and to
    write compact propagators such as *Max_i x_i <= y*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Numba
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numba is an open source **Just-In-Time** compiler that translates a subset of
    Python and NumPy code into fast machine code.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://numba.pydata.org/?source=post_page-----7b260afc2fe4--------------------------------)
    [## Numba: A High Performance Python Compiler'
  prefs: []
  type: TYPE_NORMAL
- en: '@njit(parallel=True) def simulator(out): # iterate loop in parallel for i in
    prange(out.shape[0]): out[i] = run_sim()…'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: numba.pydata.org](https://numba.pydata.org/?source=post_page-----7b260afc2fe4--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we find the 14200 solutions to the **12-queens** problems
    (note that we use a single processor here).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We achieve a **x60** speed-up by enabling Just-In-Time compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to let Numba JIT-compile your code, you should :'
  prefs: []
  type: TYPE_NORMAL
- en: avoid OOP,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use supported types or Numpy arrays,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use a subset of the Python language,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use a subset of Numpy's functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In NuCS, these guidelines have been successfully implemented for :'
  prefs: []
  type: TYPE_NORMAL
- en: '**propagators** (see [https://nucs.readthedocs.io/en/latest/reference.html#propagators](https://nucs.readthedocs.io/en/latest/reference.html#propagators)
    for the list of propagators implemented in NuCS),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**consistency algorithms** (see [https://nucs.readthedocs.io/en/latest/reference.html#consistency-algorithms](https://nucs.readthedocs.io/en/latest/reference.html#consistency-algorithms)
    for the list of consistency algorithms implemented in NuCS),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**heuristics** (see [https://nucs.readthedocs.io/en/latest/reference.html#heuristics](https://nucs.readthedocs.io/en/latest/reference.html#heuristics)
    for the list of heuristics implemented in NuCS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to Numpy and Numba, NuCS achieves performance similar to that of solvers
    written in Java or C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, since the Python code is compiled and the result cached, performance
    will always be significantly better when you run your program a second time.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NuCS comes with many [models](https://nucs.readthedocs.io/en/latest/reference.html#examples)
    for classic constraint programming problems such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'some crypto-arithmetic puzzles: **Alpha**, **Donald**,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **Balanced Incomplete Block Design** problem,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **Golomb ruler** problem,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **knapsack** problem,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **magic sequenc**e problem,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **magic square** problem,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **quasigroup** problem,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **n-queens** problem,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **Schur lemma** problem,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **sports tournament scheduling** problem,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the **Sudoku** problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of these examples require some advanced techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: redundant constraints,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: custom heuristics,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: custom consistency algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of these models are also available in [CSPLib](https://www.csplib.org/Languages/NuCS/models/),
    the bible for anything CSP related.
  prefs: []
  type: TYPE_NORMAL
- en: Statistics and Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When solutions are searched for, NuCS also aggregates some [statistics](https://nucs.readthedocs.io/en/latest/reference.html#statistics):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: bound consistency was computed 262006 times,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2268895 propagators were applied but without effect 990435 times while inconsistencies
    were detected 116806 times,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: they were 131000 choices and backtracks, with a maximum choice depth of 10,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: finally, 14200 solutions were found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with the model and understanding how it affects the statistics has proven
    to be a very useful exercise in getting the most out of NuCS.
  prefs: []
  type: TYPE_NORMAL
- en: NuCS also comes with some basic logging capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, NuCS is a very open platform were almost anything can be customized:'
  prefs: []
  type: TYPE_NORMAL
- en: propagators,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: consistency algorithms,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: heuristics,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: solvers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following **Golomb ruler** example, a custom consistency algorithm is
    registered before being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In conclusion, NuCS is a constraint solver library with a lot of features.
    Although it is written entirely in Python, it is very fast and can be used for
    a wide range of applications: research, teaching and production.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t hesitate to contact me on Github if you’d like to take part in NuCS development!
  prefs: []
  type: TYPE_NORMAL
- en: 'Some useful links to go further:'
  prefs: []
  type: TYPE_NORMAL
- en: 'the source code: [https://github.com/yangeorget/nucs](https://github.com/yangeorget/nucs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the documention: [https://nucs.readthedocs.io/en/latest/index.html](https://nucs.readthedocs.io/en/latest/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'the Pip package: [https://pypi.org/project/NUCS/](https://pypi.org/project/NUCS/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you enjoyed this article about NuCS, please clap **50** times !
  prefs: []
  type: TYPE_NORMAL

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>AI Math: The Bias-Variance Trade-off in Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>AI Math: The Bias-Variance Trade-off in Deep Learning</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/ai-math-the-bias-variance-trade-off-in-deep-learning-e444f80053dd?source=collection_archive---------2-----------------------#2024-11-29">https://towardsdatascience.com/ai-math-the-bias-variance-trade-off-in-deep-learning-e444f80053dd?source=collection_archive---------2-----------------------#2024-11-29</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="5232" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">A visual tour from classical statistics to the nuances of deep learning</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@TarikDzekman?source=post_page---byline--e444f80053dd--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Tarik Dzekman" class="l ep by dd de cx" src="../Images/0c66b22ecbdbbce79b2516e555c67432.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/2*89BjkQMI4MLzZQvGJu4k3Q.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--e444f80053dd--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@TarikDzekman?source=post_page---byline--e444f80053dd--------------------------------" rel="noopener follow">Tarik Dzekman</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--e444f80053dd--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">47 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Nov 29, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">1</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div></div></div><div class="mj"><div class="ab cb"><div class="lm mk ln ml lo mm cf mn cg mo ci bh"><figure class="ms mt mu mv mw mj mx my paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq mr"><img src="../Images/f11bbf2a6adb14782f156aecfeccb623.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*BeQ2h3qftp--CFxKY2rW8w@2x.jpeg"/></div></div><figcaption class="ne nf ng mp mq nh ni bf b bg z dx">Source: All images by author unless otherwise indicated.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="9ec0" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In deep learning the bias-variance trade-off is not straightforward and can often be the wrong thing to pay attention to. To understand why, we need to take a tour through inferential statistics, classical statistical learning methods, and machine learning robustness. We’ll end the article by touching on overparameterisation and the double descent phenomena.</p><p id="4a78" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><em class="of">Suggested background: Probability, Random Variables, Statistics, Linear Algebra, Calculus, Machine Learning, Deep Learning.</em></p><h1 id="6b4d" class="og oh fq bf oi oj ok gq ol om on gt oo op oq or os ot ou ov ow ox oy oz pa pb bk">Bias and Variance in Inferential Statistics</h1><p id="1710" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk"><em class="of">Note: We are going to gloss some math in this section in favour of visual intuition. Given my focus on deep learning the particulars of inferential statistics would blow out the length of an already long article.</em></p><p id="e29f" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Imagine you travel back in time and take the place of a statistician in Allied Command during World War II. An intelligence officer tells you the following information:</p><ol class=""><li id="6a40" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">The Germans stamp sequential serial numbers on their tanks. So a tank with serial number 115 means it was the 115th tank produced. To date the Germans have produced an unknown number of tanks (<em class="of">N</em>).</li><li id="bb13" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">When the allies destroy a tank we can find a serial number printed on it. The “destroyability” of a tank is independent of its serial number.</li><li id="b3c8" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">We have a sample (size <em class="of">k</em>) of serial numbers, <em class="of">X = (x₁, x₂, … xₖ)</em>.</li><li id="ad19" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">We need to use this sample to create an estimator <em class="of">N*</em>.</li></ol><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq pp"><img src="../Images/ac8f081d8cfd8c2f6b4a3d170942e72e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q-txpnc5REA_dBBBL5NpzA.png"/></div></div></figure><p id="d1b3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This is known as <a class="af pq" href="https://en.wikipedia.org/wiki/German_tank_problem" rel="noopener ugc nofollow" target="_blank">the German Tank Problem</a>. In essence:</p><blockquote class="pr"><p id="2035" class="ps pt fq bf pu pv pw px py pz qa oe dx">Given a manufacturing process which generates sequential serial numbers, how can you estimate the total production volume from a random sample?</p></blockquote><h2 id="c32c" class="qb oh fq bf oi qc qd qe ol qf qg qh oo ns qi qj qk nw ql qm qn oa qo qp qq qr bk">Exploring an estimator</h2><p id="cdcd" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">We’re going to start by looking at one possible estimator and explore its mathematical properties:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq qs"><img src="../Images/b118b475c5a0062e92ed3a93cc8cca78.png" data-original-src="https://miro.medium.com/v2/resize:fit:574/format:webp/1*PE9y36IPDSHHqtn8NoiNuw.png"/></div></figure><ul class=""><li id="a542" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk"><em class="of">N* </em>is our estimator for <em class="of">N</em></li><li id="ff41" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk"><em class="of">X</em> is a random sample of size <em class="of">k</em></li><li id="5991" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk"><em class="of">m=max(X) is </em>the largest serial number observed in the sample</li></ul><p id="a313" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We can use a Monte Carlo simulation to calculate the expected performance of <em class="of">N*</em>:</p><ul class=""><li id="dbd4" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">Draw <em class="of">N</em> from a log-normal distribution (mean=200, large variance)</li><li id="bc85" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">Draw <em class="of">k</em> from a Poisson distribution (<em class="of">λ=20</em>)</li><li id="e5fb" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">For 10,000 iterations, sample k values from <em class="of">[1..N]</em> and compute <em class="of">N*</em></li></ul><p id="b407" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This simulates a range of <em class="of">possible worlds</em> in which the sample data was collected. The plot below shows 100 iterations of the simulation for different values of <em class="of">N</em>, <em class="of">k</em>, and <em class="of">N*</em>.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq qu"><img src="../Images/a63fceef9942ca861a065659aa104f71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kTG4amydzBupOCxwChLL8A.png"/></div></div></figure><h2 id="fc40" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Unbiased estimator</h2><p id="5623" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">We can see that the estimates are generally very accurate — sometimes over estimating the true value and sometimes underestimating it. We can plot the errors across all 10k iterations and see how they are distributed:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq ra"><img src="../Images/2b193f2886e83468391ac9d831db1438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EA8kvbppAmnL-t8G6RUcmw.png"/></div></div></figure><p id="e40b" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The plot shows that the mean error of <em class="of">N*</em> is zero. That’s because this is a well known unbiased estimator. This means that on average errors cancel out, and <em class="of">N*</em> approximates <em class="of">N</em> <strong class="nl fr">in expectation</strong>. i.e. Averaged across all possible worlds.</p><p id="a960" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Formally, the bias of an estimator of <em class="of">N</em> is expressed as:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq rb"><img src="../Images/ff14a7382502e86cd1b2265da03a1cf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*57t_rrKUhNIATGRcr2GAJg.png"/></div></figure><p id="7311" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The bias is the expected (signed) error of the estimator over <em class="of">all possible </em>samples for a fixed <em class="of">N</em> and <em class="of">k</em>. If the expected error is 0 that means the estimator is unbiased. This is usually written as just the expectation over <em class="of">X</em> rather than <em class="of">X|N,k</em>. I’ve used extra subscripts just to emphasise a point.</p><p id="f832" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Note that this is sometimes written as:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq rc"><img src="../Images/db9ed9117d6e2a92217bd6821ed9f39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*Uu3LEE1jvoCz9qTyUl4bIg.png"/></div></figure><p id="fe3a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In this situation we can show that the extra expectation is not necessary. <em class="of">N </em>is an unknown but concrete value and the same is true of the expected value of <em class="of">N*</em>. The expected value of a constant is just the constant so we can drop the extra notation.</p><h2 id="a586" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Variance of an estimator</h2><p id="6e91" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Variance quantifies how much the estimates will vary across different possible worlds. Our error plot shows estimates cluster around 0, with slight skew due to priors on <em class="of">N</em> and <em class="of">k</em>. If we look at the ratio <em class="of">k/N</em> we can see how the estimator performs with larger and larger samples:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rd"><img src="../Images/b0a5f69491abf909022f4a74307e87b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NiM_KiZOWPIdvt8P"/></div></div></figure><p id="6490" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The intuitive result is that for an unbiased estimator, collecting a larger sample leads to more accurate results. The true variance of <em class="of">N*</em> is:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq re"><img src="../Images/14baeea9bebe95b89c5dff933f3f5f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*I_9ly145rfs6iDlRDV5kYQ.png"/></div></figure><p id="8123" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The standard deviation (<em class="of">N/k</em>) can be thought of as the average gap between elements in a random sample of size <em class="of">k</em>. For example: if the true value is <em class="of">N=200</em> and the sample size is <em class="of">k=10</em>, then the average gap between values in the sample is <em class="of">20</em>. Hence, we would expect most estimates to be in the range <em class="of">200±40</em>.</p><p id="8763" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It can be shown that this is the minimum variance that can be achieved by any unbiased estimator. In frequentist statistics this is known as the <a class="af pq" href="https://en.wikipedia.org/wiki/Minimum-variance_unbiased_estimator" rel="noopener ugc nofollow" target="_blank">Uniformly Minimum Variance Unbiased Estimator (UMVUE)</a>. Put another way: to achieve lower variance you need a biased estimator.</p><p id="b291" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Formally, the variance of an estimator of <em class="of">N</em> is expressed as:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq rf"><img src="../Images/19a154e0e7a92440478e456f56d04a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*7zU8pVqUJBaNJ1_RJNGRbw.png"/></div></figure><p id="7332" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Notice that the variance is the expectation around the <em class="of">estimated value</em> rather than around the true value. If we had a biased estimator we would be evaluating the spread around that biased estimate.</p><p id="d945" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Test your understanding: do you see why we need the expectation around the outer term? <em class="of">N* </em>is a random variable and so we need an expectation over all possible <em class="of">X</em> in order to get a concrete value for it.</p><h2 id="f83d" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Sufficient information</h2><p id="8349" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">There’s something you may have noticed about our estimator: it seemingly throws away a lot of information in our sample. If our sample has <strong class="nl fr">k</strong> values why should our estimator use <strong class="nl fr">only 1 value</strong>?</p><p id="61ae" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">First, some quick definitions:</p><ul class=""><li id="a235" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">A “statistic” is a function of data (usually of a sample).</li><li id="7125" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">A “sufficient statistic” is one that contains the maximal “information” about the population parameter we are trying to estimate.</li></ul><p id="82b3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It’s possible to show that there isn’t any extra information in the sample once we know the maximum and the sample size <em class="of">k</em>. The reason concerns the <a class="af pq" href="https://en.wikipedia.org/wiki/Likelihood_function" rel="noopener ugc nofollow" target="_blank">likelihood function</a> for values of <em class="of">N</em> given a sample <em class="of">X</em>.</p><p id="bace" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><strong class="nl fr">The likelihood function</strong></p><p id="2f4c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Consider all possible <em class="of">k</em>-sized subsets of <em class="of">[1..N]</em>. For any given sample the only possible values of <em class="of">N</em> are in the range <em class="of">[max(X), ∞]</em>. i.e. It’s not possible to get a sample containing <em class="of">max(X) </em>if<em class="of"> N&lt;max(X)</em>. The probability of getting any one <em class="of">k</em>-sized sample is based on how many ways there are of <a class="af pq" href="https://en.wikipedia.org/wiki/Combination" rel="noopener ugc nofollow" target="_blank">choosing</a> a set of size <em class="of">k</em> from <em class="of">N</em> possible values. The likelihood function is shown below. Notice how the likelihood function for a fixed sample is only concerned with <em class="of">k</em> and <em class="of">m=max(X)</em>.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq rg"><img src="../Images/1b00bbed70f3e52d1aac79449858be98.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*24LCsRskMuegDKGKfr7yLQ.png"/></div></figure><p id="56bd" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">A likelihood function <em class="of">ℒ(θ;x)</em> measures how probable an observation <em class="of">x</em> is under different values of <em class="of">θ </em>(e.g. <em class="of">N</em>). We can use it to find a value of <em class="of">θ</em> which maximises the probability of seeing <em class="of">x</em> without telling us anything about the probability of <em class="of">θ </em>itself.</p><p id="5ec5" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><strong class="nl fr">Maximum likelihood</strong></p><p id="5176" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Suppose <em class="of">k=5</em> and <em class="of">m=60</em>, then <em class="of">N ≥ 60.</em> The maximum likelihood occurs at <em class="of">N=m=60</em>. While most values of N are unlikely the likelihood function identifies <em class="of">N=60</em> as most likely for this sample.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rh"><img src="../Images/b7910f6bfcb72a3ab6af91fa4456a647.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4h3dTIWUFBDjlpasS7Nf9A.png"/></div></div></figure><p id="f0d0" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">First, notice that all values of <em class="of">N</em> are very unlikely. Then, remember that for a fixed value of (<em class="of">m, k</em>) the likelihood function tells us the probability of seeing that value of <em class="of">m</em> for each possible value of <em class="of">N</em>. Just because <em class="of">m=60 </em>is most probable at <em class="of">N=60</em> doesn’t make it a good estimate!</p><blockquote class="pr"><p id="7192" class="ps pt fq bf pu pv pw px py pz qa oe dx"><strong class="al">The most likely estimate is not necessarily the best one.</strong></p></blockquote><p id="e6fd" class="pw-post-body-paragraph nj nk fq nl b go ri nn no gr rj nq nr ns rk nu nv nw rl ny nz oa rm oc od oe fj bk"><strong class="nl fr">Fisher information</strong></p><p id="6953" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><a class="af pq" href="https://en.wikipedia.org/wiki/Fisher_information" rel="noopener ugc nofollow" target="_blank">Fisher information</a> quantifies sample informativeness. If many values of <em class="of">N</em> are likely, information is low; if there’s a sharp likelihood peak <strong class="nl fr">around the true value</strong> then information is high. As a rough guide, Fisher information tells us how much we could possibly know about the true distribution from a random sample.</p><p id="7b96" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><strong class="nl fr">A sufficient statistic</strong></p><p id="94e4" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">A “sufficient statistic” contains all of the information about the parameter in question. I won’t go into the proof here but a statistic is sufficient if it is the Maximum Likelihood Estimator (MLE). If the MLE is biased we can use “bias correction” to produce a better estimate <strong class="nl fr">but we can’t find another statistic which provides more information</strong>.</p><p id="2d38" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><strong class="nl fr">An intuitive explanation</strong></p><p id="9c2f" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Not all sample data provides useful information. Specific to the German Tank Problem we can see that:</p><ul class=""><li id="8b4a" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">The sample probability depends on <em class="of">k</em> and <em class="of">max⁡(X)</em>.</li><li id="51f3" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">Values of <em class="of">N</em> near <em class="of">max⁡(X) </em>are more likely to produce samples which happen to contain <em class="of">max(X)</em>.</li><li id="8b9a" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">All <em class="of">k</em>-sized samples containing <em class="of">max⁡(X) </em>are <strong class="nl fr">equally probable</strong>.</li><li id="587e" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">So the sample contains no more information about the true value of <em class="of">N</em> beyond knowing <em class="of">k</em> and <em class="of">max(X)</em>.</li></ul><h2 id="be02" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">A biased estimator</h2><p id="3241" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Using <em class="of">max(X)=m</em> as an estimator would almost always underestimate <em class="of">N </em>as the probability of getting <em class="of">N</em> in a sample is <em class="of">1/(N choose k).</em> On the other hand, if we did get a sample which contained <em class="of">N</em> our original estimator <em class="of">N*</em> could give a big overestimate. Suppose <em class="of">k=1 </em>and our sample happened to contain <em class="of">N=1000</em>. Then our estimate of <em class="of">N*=2m-1=1999</em> would be much too large.</p><p id="95fa" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It’s hopefully obvious that this is a terrible argument for using <em class="of">max(X)</em> as our estimator for <em class="of">N</em>. To check let’s compare the Mean Square Error (MSE) of the two estimators to see how they perform:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rn"><img src="../Images/3802f34fe887a2ac22e0d5cd466086d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rd8z7cBztPj13s_v"/></div></div></figure><p id="276c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Notice how much worse the estimator <em class="of">max(X)</em> is. Note that almost all of that error is attributed to its bias. If we plot the distribution of estimated values we can see that <em class="of">max(X)</em> consistently produces estimates in a narrower range.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq qu"><img src="../Images/191dd43aa6a09050593499508cbda2ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6E051VsYqsNwyTkNOagaYA.png"/></div></div></figure><p id="b00d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">I’ll skip the proof and we’ll rely on the visualisation to see that <em class="of">max(X)</em> has a significantly lower variance than <em class="of">N*</em>. Just remember that the proper definition for estimator variance is the expected spread around the expected estimated value.</p><h2 id="b490" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">The bias-variance decomposition</h2><p id="a62b" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">By convention the total error we are trying to minimise is the mean square error (MSE). If you’re curious you can read this discussion about <a class="af pq" href="https://stats.stackexchange.com/questions/470626/why-is-using-squared-error-the-standard-when-absolute-error-is-more-relevant-to" rel="noopener ugc nofollow" target="_blank">why we use MSE</a>. I’ll leave off the subscripts this time but remember that we are calculating the expectation over all possible samples:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq ro"><img src="../Images/95ea308b6a311b24572fdc988827f983.png" data-original-src="https://miro.medium.com/v2/resize:fit:558/format:webp/1*7jFUMoI91r8V5rY0Ogmr2w.png"/></div></figure><p id="3fbc" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This this can be factored into a bias² term and a variance term. The derivation is useful to understand. We start by introducing <em class="of">-E[N*]+E[N*]</em>, then grouping terms, and expanding the quadratic:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq rp"><img src="../Images/db49180f69c7850086d6a8c03b3cd131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVjMAG5dHH9_9IkOFb5tNA.png"/></div></div></figure><p id="683a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The biggest confusion may come at the second last line:</p><ul class=""><li id="a3cc" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">The left term is bias² if we ignore the redundant expectation.</li><li id="bfd1" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The centre term comes to 0 after expanding and applying the expectation operator over the expanded terms.</li><li id="efa7" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The right term is just variance depending on which term is subtracted before squaring the result.</li></ul><p id="c720" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">A more general derivation can be found on the <a class="af pq" href="https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff#Derivation" rel="noopener ugc nofollow" target="_blank">Wikipedia article on the bias-variance trade-off</a>.</p><p id="9700" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The total expected error is a combination of the error from the bias of our estimator and the variance. Here’s a subtle question: if the model is biased then shouldn’t a high variance allow it to sometimes get an accurate answer? Why would the total expected error be a <strong class="nl fr">sum</strong> of bias² and variance instead of some other function that takes this into account?</p><p id="7553" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The decomposition above explains how it happens mathematically but perhaps not intuitively. For building intuition, consider the effect that squaring has on highly inaccurate estimates. Also consider that the bias² itself is not sufficient to account for all of the expected squared error.</p><h2 id="baa0" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">An optimal estimator?</h2><p id="11a6" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">We’ve shown the <em class="of">expected error </em>for our estimator. On average, given a random sample, how far off would our estimator be from the true value that generated that sample? An estimator that’s consistently off but predicts a narrower spread might be better than an estimator which is consistently on-point but has a much wider spread of predictions around that point.</p><p id="3cf5" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Can we find a balance point in the German Tank Problem where we trade off bias and variance to make a better estimate? Ignoring a constant term (+ C) such a function would look like this:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq rq"><img src="../Images/dbe546c49e2e9fed4e5f9db734610d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*Usm6Pfo9Suv2vKhLa58mZQ.png"/></div></figure><p id="fa66" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This will sit somewhere between <em class="of">g(k)=1</em> and <em class="of">g(k)=(1+1/k)</em>. Can you work out why? Using <em class="of">1 * m</em> is the MLE which is biased but low variance. Using <em class="of">(1+1/k) </em>is just <em class="of">N*</em> without a constant. We know that <em class="of">N*</em> is an unbiased estimator (UMVUE) with higher variance then <em class="of">m</em>. So somewhere between the MLE and the UMVUE we could find the “optimal” estimator.</p><p id="f8f5" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It turns out we can’t find an optimal function <em class="of">g(k)</em> without knowing the true value of <em class="of">N</em>, which is the number we are trying to estimate!</p><p id="d722" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The Wikipedia page on the problem describes Bayesian Inference techniques which require a prior on <em class="of">N</em>. This prior is something that <em class="of">you</em> choose when doing your analysis. And we can use it to at least set reasonable bounds using our world knowledge. e.g. we know that they have at least <em class="of">m</em> tanks, and probably less than 100,000. But the prior has to be subjective. What should the distribution look like in the range <em class="of">[m,100000]</em>? Should it be uniform? Bayesian Inference is a fascinating topic but I’ll leave the discussion there.</p><p id="599a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Finally consider that the estimator with the lowest error is biased. This is our first hint that the bias-variance trade-off isn’t always the most important thing to consider. For inference purposes we probably want to consider the problem in terms of <a class="af pq" href="https://en.wikipedia.org/wiki/Statistical_risk" rel="noopener ugc nofollow" target="_blank">statistical risk</a> which might prioritise unbiased estimators in favour of more accurate ones.</p><h2 id="1ffe" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">How did the allies do?</h2><p id="6ee3" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">The allies actually did use the techniques described here except they were trying to determine German tank production on a monthly basis. And of course they didn’t have access to Python or the ability to run Monte Carlo simulations. Let’s look at how the estimator used in this article performed against traditional intelligence gathering methods (i.e. spying):</p><pre class="ms mt mu mv mw rr rs rt bp ru bb bk"><span id="b257" class="rv oh fq rs b bg rw rx l ry rz">| Month       | N*    | Spying | German records |<br/>|-------------|-------|--------|----------------|<br/>| June 1940   | 169   | 1,000  | 122            |<br/>| June 1941   | 244   | 1,550  | 271            |<br/>| August 1942 | 327   | 1,550  | 342            |<br/><br/><br/>Source: Wikipedia - The German Tank Problem</span></pre><p id="4e2e" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We can see that the statistical estimates performed well and were significantly more accurate than the estimates made from spying.</p><h2 id="ecab" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Reflection</h2><p id="6415" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">The German Tank Problem is a tricky example and we skipped a lot of mathematical details that are important to statisticians. But we’ve introduced a few key ideas:</p><ul class=""><li id="59fc" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">The Mean Square Error (MSE) of an estimator can be decomposed into Bias and Variance.</li><li id="ac03" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">Bias represents the expected (signed) error of an estimator averaged over all possible samples (i.e. all possible worlds).</li><li id="2a87" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The variance represents the expected spread of the estimates<em class="of"> </em>averaged over all possible samples (i.e. all possible worlds).</li><li id="5f39" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">It’s likely that the best estimator (one with lowest MSE) is biased. We offset the error from the bias with lower variance, meaning that the estimate is more likely to be closer to the true value even though the estimator is biased in expectation.</li><li id="abe6" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The likelihood of a population parameter concerns which values of that parameter make a sample most probable. It does not have anything to do with the probability of a population parameter.</li><li id="5b03" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The Maximum Likelihood Estimator (MLE) is a function of a sample which identifies the most likely population parameter that could have produced that sample.</li><li id="5a4a" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The MLE is not necessarily the best estimator. We saw very obviously that the most likely value can be quite far away from the true value that generated a sample.</li><li id="d721" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">Fisher information is the amount of information about the parameter contained in a sample, roughly measured as the curvature of the likelihood plot around the true value.</li></ul><h1 id="b079" class="og oh fq bf oi oj ok gq ol om on gt oo op oq or os ot ou ov ow ox oy oz pa pb bk">Generalised Linear Models</h1><p id="2253" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">From here I will use a distinction described in the paper <a class="af pq" href="https://med.stanford.edu/content/dam/sm/dbds/documents/biostats-workshop/paper-1-.pdf" rel="noopener ugc nofollow" target="_blank">Prediction, Estimation, and Attribution</a>:</p><ul class=""><li id="cf7b" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk"><strong class="nl fr">Prediction </strong>concerns empirical accuracy of a predictive model built from a sample of data.</li><li id="ce6b" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk"><strong class="nl fr">Estimation</strong> concerns estimating the parameters of a distribution that generated the sample data.</li></ul><p id="b207" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Additionally we’ll consider the following concepts which are described in more detail in the book <a class="af pq" href="https://hastie.su.domains/ElemStatLearn/" rel="noopener ugc nofollow" target="_blank">Elements of Statistical Learning</a>:</p><ul class=""><li id="fa06" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">A statistical process creates a joint probability distribution <em class="of">f(X,Y)</em> where a bold <strong class="nl fr"><em class="of">X</em></strong> or <strong class="nl fr"><em class="of">Y</em></strong> indicate vectors rather than scalars.</li><li id="29a1" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">Training data <em class="of">D</em> is a sample drawn from the joint distribution <em class="of">f(X,Y)</em> containing tuples of the form <em class="of">(x,y)</em>.</li><li id="3830" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">A predictive model <em class="of">h(x;D)</em> is trained on a dataset <em class="of">D</em> and makes a prediction about a target variable <em class="of">y∈Y</em> from observations <em class="of">x∈X</em>. It may be written as <em class="of">h(x;D)=E[Y | x∈X].</em></li><li id="6b13" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">A loss function <em class="of">ℓ(y, h(x;D))</em> which calculates the error of a model at predicting the true value of <em class="of">y</em> for a particular tuple <em class="of">(x,y)</em>. For regression this is typically the Mean Square Error (MSE).</li></ul><p id="0f0e" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Additionally, I introduce the following notation specific to this article:</p><ul class=""><li id="cad5" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">A latent variable <em class="of">Z</em> forms part of the joint distribution <em class="of">f(X,Y,Z)</em> but is never observed in training data <em class="of">D</em>. So even though <em class="of">Z</em> forms part of the full distribution, observations can only take the form <em class="of">(x,y)</em>.</li><li id="4ed8" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">A random variable <em class="of">W</em> accounts for an endogenous sampling bias. This means that certain combinations of <em class="of">(x,y)</em> may be sparse and less likely to be found in our training data <em class="of">D</em>. This is opposed to an exogenous sampling bias where the sampling procedure we use means that not all observations are truly iid with respect to <em class="of">f(X,Y)</em>. You can learn more about the effects of sampling bias in my article on <a class="af pq" href="https://medium.com/towards-data-science/why-scaling-works-inductive-biases-vs-the-bitter-lesson-9c2782f99b18" rel="noopener">why scaling works</a>.</li></ul><h2 id="aa3e" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Example problem – House prices</h2><p id="64c7" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">We’re going to generate a synthetic dataset where the size of a house (in square meters) is used to predict the sale value. This seemingly simple problem has a lot to teach us about how our models work. Here is some added complexity:</p><ol class=""><li id="71a1" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">There’s a latent variable that influences the selling price: how far away is the house from the beach? Perhaps houses close to the beach are more expensive but they’re also more likely to only have 2–3 bedrooms.</li><li id="dbdf" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">Any training sample <em class="of">D </em>has an endogenous bias because there are few small houses (1 bedroom) and particularly large ones (4+ bedrooms) so they are less likely to be put up for sale.</li></ol><p id="fcaa" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Between the latent variable and the sample bias we have the kind of complexities that exist in real world datasets. We imagine a function which deterministically calculates the sale price from certain attributes:</p><p id="117a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><em class="of">f*(x,z)=y</em> where <em class="of">x</em>=size, <em class="of">z</em>=distance to beach, and <em class="of">y</em>=selling price</p><p id="1e70" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The relationship between size, distance to beach, and price, is captured in this surface plot:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq sa"><img src="../Images/27196d0c8e469257d77cf0380ebc9a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*CkIDXWfcBoh31YjEy_cAIg.png"/></div></figure><p id="b752" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Now consider that you might have 2 houses with the same size and same distance to the beach, yet they sell for different prices. This means the relationship between our variables is not deterministic. For every combination (size, distance, price) we have some probability density of seeing a house with those values in our training data. This is given by the joint probability density function <em class="of">f(X,Y,Z)</em>. To visualise this joint density we use a pair plot:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sb"><img src="../Images/dc5c3865eeff487953288a18aac5dd05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnvPuZ31EV1GXpkz304vdA.png"/></div></div></figure><p id="c9be" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">If our only observed variable is size then the relationship to price is not straightforward. For example, suppose we took the average distance to the beach for a house of a certain size. In this case that would be a tricky expected value to calculate. Instead we can use simulations and apply some smoothing to approximate the relationship:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sc"><img src="../Images/688311d4fb01e42e40f721b620eae0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7_rTXVi2xC_m_tL0zWykA.png"/></div></div></figure><p id="dcbc" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">For particularly large houses the effect of distance is compounded. So a large house close to the beach is much more expensive than the same size house further away. Both are expensive but the variance is significantly different at the high-end. This will make it difficult to predict the true shape of the relationship at the tail end.</p><p id="1adb" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Additionally, we must consider the endogenous bias in our sample. The probability of being sold (<em class="of">W</em>) is affected by all attributes which we can show in this pair plot:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sd"><img src="../Images/24d4bc0e712d8c941ef3d81fb40283f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jw9PTSuGot7oIPMHkINX-g.png"/></div></div></figure><p id="e5b0" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">How might we think about this new attribute (<em class="of">W</em>)? Fewer small/large houses are built so fewer are put up for sale. In reality there are many factors that impact whether or not a property is listed for sale including people’s willingness to sell. This endogenous bias affects our probability density function <em class="of">f(X, Z, Y)</em> by making certain combinations less likely without affecting the relationship between variables <em class="of">f*(x,z)=y</em>.</p><p id="ebfa" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We adjust the pair plot to show the updated relationship between variables given the endogenous bias of seeing a particular house on the market.</p></div></div><div class="mj"><div class="ab cb"><div class="lm mk ln ml lo mm cf mn cg mo ci bh"><figure class="ms mt mu mv mw mj mx my paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq se"><img src="../Images/e8ea99b74a458f0d44f23cc3faaab289.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*ZO6vVi3rQye3tMV5KvXXSQ.png"/></div></div></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="ef20" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Notice that there is a slight but observable change in the apparent relationship between house size and price.</p><h2 id="2062" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">What does our model capture?</h2><p id="2225" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Let’s take another look at the plot which shows the relationship of price and size directly.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sc"><img src="../Images/688311d4fb01e42e40f721b620eae0e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M7_rTXVi2xC_m_tL0zWykA.png"/></div></div></figure><p id="6600" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">When we analyse the bias/variance of a model are we analysing the error against this function? <strong class="nl fr">No, we are not</strong>. We are building a model of the statistical process which generates our data — a process which includes the endogenous bias. This means the expected error is the expectation over all possible samples from our distribution.</p><p id="a8e8" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Put another way: the bias-variance trade-off of a regression model concerns the expected error of that model across all possible worlds. Because the expected value is weighed by the probability of seeing particular values it will be affected by endogenous sampling bias.</p><p id="970e" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It feels strange that the probability of a house being sold should influence the calculations we make about the relationship between the size of the house and its sale price. Yet this calculation is at the very heart of the bias-variance trade-off.</p><h2 id="c49e" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Error decomposition of regression</h2><p id="a904" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">In the German Tank Problem the probability of our sample was conditioned on the value we were trying to predict <em class="of">f(X|N)</em>. In regression there’s a joint probability distribution between predictor and target values <em class="of">f(X, Y)</em>. This means that the relationship between the variables has some inherent variation which can’t be accounted for. In truth there are probably more latent variables we aren’t considering but that’s a debate for another time. This variability leads to an irreducible error term which is why we describe it as predicting the <strong class="nl fr">expected value</strong> of <em class="of">y</em> given observations <em class="of">x</em>.</p><p id="b127" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Note that this irreducible error is sometimes called “aleatoric uncertainty”. This is contrasted with “epistemic uncertainty” caused by a lack of knowledge. An under specified model may lead to epistemic uncertainty but even a perfect model has to face aleatoric uncertainty.</p><p id="1201" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This new structure means that the expected MSE is decomposed into bias, variance, and an irreducible error term:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sf"><img src="../Images/11c00d2bbebc417cb7a3be085e6ac6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjhXWQEOZjupQ8xjjIB2Ng.png"/></div></div></figure><p id="1570" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In this decomposition I’m showing again the subscripts for the expectation to clearly show what each expectation is conditioned on. The new term (h-bar) is the expected value of our model averaged over all possible datasets that could have been used to construct our model. Think of possible worlds in which we collect a training dataset and creating an ensemble model that averages all predictions across all possible worlds.</p><p id="bc2c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The expected error of our model needs to be an integral over:</p><ol class=""><li id="ec05" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">All possible data sets (<em class="of">D</em>) we could use to train our model (<em class="of">h</em>)</li><li id="bca0" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">All possible values of <em class="of">x ∈ X</em> (weighted by their marginal probabilities)</li><li id="a0d7" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">All possible values of <em class="of">y ∈ Y </em>(similarly weighted)</li></ol><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sg"><img src="../Images/274fd47f3232f53903d484a30f1f1adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7qReKAr2DyrEW0HwMaQ7Uw.png"/></div></div></figure><p id="c812" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Interestingly it’s also the expectation over a fixed size training set — the fact that sample size might be dependent on the variables isn’t captured in this decomposition.</p><p id="c4bb" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">More importantly this integral is completely intractable for our problem. In fact <strong class="nl fr">calculating the expected error is generally intractable</strong> for non-trivial problems. This is true even knowing the real process used to generate this synthetic data. Instead we’re going to run some simulations using different samples and average out the errors to see how different models perform.</p><h2 id="8d52" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Model complexity</h2><p id="35bf" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">If you know anything about the bias-variance trade-off then you probably know bias comes from “underfitting” and variance comes from “overfitting”. It’s not immediately obvious why a model which overfits should have low bias, or why a model which underfits should have low variance. These terms are <em class="of">typically</em> associated with model complexity, but what exactly does it mean?</p><p id="4ab4" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Here are 6 possible worlds in which 35 houses were put on sale. In each instance we use polynomial regression to fit terms from [x⁰…x⁵] and we compare the predicted polynomial against the true expected price for that size. Notice how different training samples create wildly different polynomial predictions:</p></div></div><div class="mj"><div class="ab cb"><div class="lm mk ln ml lo mm cf mn cg mo ci bh"><figure class="ms mt mu mv mw mj mx my paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sh"><img src="../Images/1ec3bbc004ca74f3dbd03c19e7bb87f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*gnSsRrjSgl_4OTSHYrpGOQ.png"/></div></div></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="8405" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">But remember — in terms of the bias-variance trade-off we are not evaluating our model against the true relationship. That true relationship ignores the endogenous sampling bias. Instead we can adjust the “true” relationship based on the effects of <em class="of">W</em> to factor in the probability of being sold. Now we can see predictions that match closer to the adjusted true relationship:</p></div></div><div class="mj"><div class="ab cb"><div class="lm mk ln ml lo mm cf mn cg mo ci bh"><figure class="ms mt mu mv mw mj mx my paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sh"><img src="../Images/8a8183f60952e59bd1f69a026d08bd59.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*uHBsgFEQCHBfWdqdRwmnew.png"/></div></div></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="ef80" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We can find the expected value of predictions by simulating 1,000 possible worlds. This is the expected prediction for each polynomial degree based on the size of the house:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq si"><img src="../Images/f75a8d392a6c7e78acd1489cddbeaf56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWM2dEojHAGdrLieWXIAaQ.png"/></div></div></figure><p id="b192" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Notice how these models do particularly poorly at the low end. This is entirely due to the endogenous sampling bias because we are unlikely to see many particularly small houses for sale. Also notice that the models tend to do poorly for particularly large houses, which has a combined effect from both the endogenous sampling bias and the latent variable.</p><p id="7e47" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Now we take the model function <em class="of">h</em> and include an additional term <em class="of">λ</em> which represents the hyperparameters used for a particular class of models. Rather than polynomial degree we’ll have <em class="of">λ</em> represent the subset for the number of polynomial terms being used. For our simulations we’ll do a brute force check of all combinations up 5 terms with a polynomial degree of 10 and select the ones with the best training error. Ideally this would be done with cross-validation but we’ll skip this as it’s not a useful technique in deep learning. Also note that with 5 terms and 1000 simulations a brute force search is already quite slow.</p><p id="6b6c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Next we introduce a function <em class="of">g(λ)=c</em> which represents the “complexity” of the model based on the hyperparameters selected. In this case <em class="of">g</em> is just the identity function and the complexity is entirely concerned with the subset of polynomial terms used.</p><p id="eb0a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The expected error of a fixed model architecture with varying complexity is given by:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq sj"><img src="../Images/7afb29a270a8a7c36d74afa5dd05560d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*pMEJJ_t3enbQLjDjcAweag.png"/></div></figure><p id="2690" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Now instead of calculating the expected prediction by polynomial degree we instead use the subset selection size. Averaged over 1,000 simulations we get the following predictions:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sk"><img src="../Images/ed5a06b00534f0381b1842fb3a89fcd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzvJVSvfntRtN-UbviFzog.png"/></div></div></figure><p id="8bf7" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Further, we can plot the total expected error (weighted by probability of seeing a house of that size) and decompose the error into a bias and variance term:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq si"><img src="../Images/d5309c6e8eb9c4e0b30455b23ecf49d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uopg3VbRfT_laLEINFj9-A.png"/></div></div></figure><p id="d133" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Once again remember that to get the expected error we are averaging over all possible worlds. We can see that:</p><ul class=""><li id="83ae" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">Bias² decreases as the model complexity increases.</li><li id="3252" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">Variance increases as the model complexity increases.</li><li id="a8d4" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The total error decreases, hits a minimum point, and then rises.</li><li id="f3d5" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">In this problem the total error also has a strong contribution from the irreducible error.</li></ul><p id="0456" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Using some assumptions we can identify some attributes of the expected error for any model <em class="of">h</em>. The core assumptions are:</p><ul class=""><li id="1738" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">At low complexity the total error is dominated by bias, while at high complexity total error is dominated by variance. With bias ≫ variance at the minimum complexity and variance ≫ bias at high complexity.</li><li id="7dbb" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">As a function of complexity, bias is monotonically decreasing and variance is monotonically increasing.</li><li id="f4ca" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The complexity function<em class="of"> g </em>is differentiable.</li></ul><p id="fd21" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Based on these assumptions we can expect most models to behave similarly to the plot above. First the total error drops to some optimal point and then it starts to increase as increased complexity leads to more variance. To find the optimal complexity we start by taking the partial derivative of our error decomposition with respect to the complexity:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sl"><img src="../Images/d4bb1e09eeccbb39bd45fbd78da336a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*176lkQIRgMFkklR6IFNsog.png"/></div></div></figure><p id="77e6" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The inflection point happens when the partial derivative is 0.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sm"><img src="../Images/100c5ba3878fa784fe3ab876e7aae592.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LALZpFFFfkQPfWUFISs5DA.png"/></div></div></figure><p id="9995" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">At the optimal point the derivative of the bias² is the negative of the variance. And without further assumptions that’s actually all we can say about the optimal error. For example, here are random bias and variance functions which happen to meet the assumptions listed. The point at which their derivatives are inverses of each other is the point at which the total error is minimised:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sn"><img src="../Images/4948bbe43cf81ff7d3195054a28a3c3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*94sgpPxtsQJA80bHu-sIjg.png"/></div></div></figure><p id="d538" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">If we add an extra assumption that bias and variance are symmetric around the optimal point then we can narrow down the lowest error to be at <em class="of">Bias²(c*)=Var(c*)</em>. If you play around with a few options you will notice that the optimal point tends to be near the point at which bias² and variance terms are equal. But without the added assumption that’s not guaranteed.</p><h2 id="75ae" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Implications</h2><p id="0a4b" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">We know that calculating the optimal point is intractable. But it’s generally understood that low bias inherently leads to exploding variance due to the impacts of model complexity. Think about that for a moment: the implication is that you can’t have a model that both performs well and is unbiased.</p><h2 id="a70f" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Generalisation error</h2><p id="42d0" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Because we can’t literally average over all possible worlds we need some other way of calculating the the total expected error of our model. The Generalisation error captures the performance of a model on unseen data. It’s the gap between how well a model fits its training data and how well it performs on the underlying data distribution. For an arbitrary loss function <em class="of">ℓ</em> we can state the generalisation error as:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq so"><img src="../Images/6c8ed5cc03729c45c8d40cb0b5eaa6e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:792/format:webp/1*YTrKV0DteBYDl2_EaXTOnQ.png"/></div></figure><p id="69f3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Note that even here we can’t possibly calculate the expected performance of our model across all possible combinations of <em class="of">(x,y)</em>. We approximate the generalisation error by collecting a new independent dataset to evaluate on. There are different ways we could evaluate performance:</p><ol class=""><li id="cacc" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">In-sample error: Training error computed on the data used to fit the model. This is often misleadingly low for overfit models and will not capture generalisation capability.</li><li id="493b" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">Out-of-sample error (OOS): Performance on a held-out sample from the same distribution as our training set. This is the gold standard for assessing generalisation.</li><li id="4cbf" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">Out-of-distribution error (OOD): The performance on data that does not belong to the training distribution. Think of a house pricing model trained on urban areas tested on rural houses — it’s likely to fail.</li></ol><p id="6c2c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">These concepts tie into what we’ve already explored in the bias-variance trade-off. Biased models will fail to capture the relationships between the variables and so the relationships they do describe won’t fit on to OOS examples. But high variance models can produce wildly different predictions depending on the sample that they saw. Even though they may have low bias (in expectation) <strong class="nl fr">that’s only because the magnitudes of their errors cancel out</strong>.</p><p id="d09c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let’s now consider two concepts closely related to bias and variance:</p><ul class=""><li id="1c57" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk"><strong class="nl fr">Overfitting</strong> is best thought of as a consequence of model capacity and training data availability. When a model has too many parameters relative to the size or diversity of the training data, it fits not just the underlying signal but also the noise in the data.</li><li id="65cc" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk"><strong class="nl fr">Underfitting</strong> on the other hand is a consequences of underspecification. The model is not sufficiently complex to capture the details of the underlying distribution. This is usually due to too few parameters relative to the complexity of the best fit curve.</li></ul><p id="e7e6" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let’s take a look at one of the possible worlds from our simulation. Here we zoom in on the large-size high-price portion of our sample. Notice how more complex models attempt to draw a curve that essentially connects all of the observed points. If the sample were slightly different the shape of these curves could be wildly different. On the other hand the low complexity models (e.g. the <em class="of">y=mx+b</em> or <em class="of">y=b</em> lines) aren’t able to capture the curvature at the tails of the dataset.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sp"><img src="../Images/efa6c9b4cd57665ca461d428c00b3d4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_1y62aZ6LCiWcR8HR9r9Og.png"/></div></div></figure><h2 id="2a28" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">A quick note on regularisation</h2><p id="5b85" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">L1 and L2 regularisation used in Lasso and Ridge regression are techniques that limit the complexity in an interesting way. Instead of reducing the number of parameters they encourage smaller coefficients which in turn produces smoother plots that are less likely to oscillate between points in the training data. This has the effect of reducing model complexity and hence increasing bias. The general idea is that the increase in bias is more than made up for by the reduced variance. Entire textbooks have been written on this topic so I won’t cover regularisation in this article.</p><h2 id="19c0" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Validation and test sets</h2><p id="4cba" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">If there’s one lesson we can take from our exploration of bias, variance, and generalisation error it’s this: models must be evaluated on data they have never seen before. The concept is straightforward, but its application is often misunderstood.</p><p id="dde7" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Validation and test sets help mitigate the risk of overfitting by acting as a proxy for real-world performance. Let’s start with a clear distinction:</p><ul class=""><li id="7ca5" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk"><strong class="nl fr">Validation set: </strong>Used during model development to tune hyperparameters and select the best-performing model variant.</li><li id="585f" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk"><strong class="nl fr">Test set: </strong>A completely held-out dataset used to evaluate the final model after all training and tuning are complete.</li></ul><p id="dc31" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The goal of using these sets is to approximate the expected out-of-sample performance. But there’s a catch. If you use the validation set too often, it becomes part of the training process, introducing an unseen data leakage problem. You may “overfit” the hyperparameters to the validation set and so fail to capture the real nature of the relationship. That is why it’s useful to have a separate test set for evaluating the performance of your final model. The performance on the test set acts as a proxy for our total error calculation. The chief problem is: how should we structure our test set?</p><h2 id="1560" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Tail risks and stratification</h2><p id="f4ad" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Remember that estimation requires knowledge of the distribution’s shape while prediction focuses only on maximizing empirical accuracy. For empirical accuracy we need to think about risk mitigation. An automated algorithm for setting prices may do well in expectation yet pose significant tail risks.</p><p id="554b" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Significantly under-pricing high-end homes would result in opportunistic buyers taking advantage of undervalued assets. Significantly over-pricing high-end homes would result in no one buying. The asymmetry of the real world doesn’t match the symmetry of expected values.</p><blockquote class="pr"><p id="9833" class="ps pt fq bf pu pv pw px py pz qa oe dx"><strong class="al">Even though the model performs well<em class="sq"> i</em></strong><em class="sq">n expectation</em><strong class="al"> it fails spectacularly when deployed in the real world</strong>.</p></blockquote><p id="855c" class="pw-post-body-paragraph nj nk fq nl b go ri nn no gr rj nq nr ns rk nu nv nw rl ny nz oa rm oc od oe fj bk">This is why stratification can be a vital component of setting up a test set. This might involve dropping examples from overly dense regions of the sampling space until there’s a uniform distribution across the entire domain. This test set would <em class="of">not</em> be iid to our training data and so it does not measure the generalisation error as described in the equation we saw earlier.</p><p id="9152" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Another option would need to use a different loss function <em class="of">ℓ </em>(i.e. not MSE but one that factors in our risk requirements). This loss function may change the dynamics of the error decomposition and may favour a significantly underfit model.</p><h2 id="63a1" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">What does our model say about the real world?</h2><p id="0f51" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Finally consider what we are trying to achieve. In deep learning we may have the goal of training general purpose agents. What does the bias-variance trade-off tell us about <a class="af pq" href="https://medium.com/towards-data-science/what-do-large-language-models-understand-befdb4411b77" rel="noopener">whether or not Large Language Models understand the text they are reading</a>? Nothing. If we want to assess whether or not our training process creates an accurate model of the world we need to consider the out of distribution (OOD) error. For models that have any hope of being general they must work OOD. For that we’ll need to leave the realm of statistics and finally make our way into the territory of machine learning.</p><h2 id="b5d4" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Reflection</h2><p id="cce9" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">In the previous section we learned about the core concepts of bias and variance. In this section we had a more complex problem that articulated how bias and variance relate to the expected performance of our model given different training data.</p><p id="a621" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We added some complexity with latent variables affecting our models performance at the tails — leading to potential tail risks. We also had an endogenous sampling bias which meant that an assessment of expected error may not describe the true underlying relationship.</p><p id="6672" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We introduced the idea of validation and test sets as methods for helping determine OOS performance to test our models generalisation error. We also talked about alternative test set constructions that throw away iid assumptions but may result in models with lower tail risks.</p><p id="5ec2" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We also introduced some key assumptions that aren’t going to apply once we enter the realm of deep learning. Before we get there we’re going to apply all these lessons to design robust machine learning algorithms.</p><h1 id="2b90" class="og oh fq bf oi oj ok gq ol om on gt oo op oq or os ot ou ov ow ox oy oz pa pb bk">Robust Machine Learning</h1><p id="932e" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">In deep learning we often deal with large datasets and complicated models. This combination can lead to model training times of many hours (and sometimes even weeks or months). When faced with the reality of hours spent training a single model the prospect of using techniques like cross-validation is daunting. And yet, at the end of the training process we often have strong demands for performance given such a large investment in time and compute.</p><h2 id="64f0" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Two views of robustness</h2><p id="9af9" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Parts of this section focus on ideas from the paper <a class="af pq" href="https://arxiv.org/pdf/2404.00897" rel="noopener ugc nofollow" target="_blank">Machine Learning Robustness: A Primer</a>. Robust models are described as ones which continue to perform well when deployed despite encountering inputs which may be different to their training observations. They provide the following useful examples of how inputs can change in production:</p><blockquote class="sr ss st"><p id="a9ba" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><strong class="nl fr">Examples of variations and changes in the input data:</strong></p><p id="ca44" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">— Variations in input features or object recognition patterns that challenge the inductive bias learned by the model from the training data.</p><p id="4596" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">— Production data distribution shifts due to naturally occurring distortions, such as lighting conditions or other environmental factors.</p><p id="bd5e" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">— Malicious input alterations that are deliberately introduced by an attacker to fool the model or even steer its prediction in a desired direction.</p><p id="af41" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">— Gradual data drift resulting from external factors, such as evolution in social behavior and economic conditions.</p><p id="75aa" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><strong class="nl fr">Examples of model flaws and threats to stable predictive performance:</strong></p><p id="57d5" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">— Exploitation of irrelevant patterns and spurious correlations that will not hold up in production settings.</p><p id="5815" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">— Difficulty in adapting to edge-case scenarios that are often underrepresented by training samples.</p><p id="961b" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">— Susceptibility to adversarial attacks and data poisonings that target the vulnerabilities of overparametrized modern ML models.</p><p id="f46a" class="nj nk of nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">— Inability of the model to generalize well to gradually-drifted data, leading to concept drift as its learned concepts become obsolete or less representative of the current data distribution.</p></blockquote><p id="1e84" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We’re going to contrast that with the paper <a class="af pq" href="https://arxiv.org/abs/2106.05522v4" rel="noopener ugc nofollow" target="_blank">A Mathematical Foundation for Robust Machine Learning based on Bias-Variance Trade-off</a>. Note that this paper was withdrawn because “several theorem and propositions that are highly-related were not mentioned”. However, it still provides an effective overview of robustness from the perspective of the bias-variance trade-off. We’ll look at this paper first and consider how the shape of the decision boundary of a model is affected by complexity and training data.</p><h2 id="6bd6" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Error decomposition for classification</h2><p id="4556" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">In binary classification we train a model to predict a probability for class 1 (vs class 0). This represents the expected value for the target variable (<em class="of">y∈{0,1}</em>) given observation <em class="of">x</em>. The total error is the difference between the predicted probability and the expected value. The loss for a single item is most simply measured as:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq su"><img src="../Images/bfd9110f79e82ecae3bc39e5b66ac7ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*neSUDurgZ5zqJNp7GmXzmw.png"/></div></figure><p id="f71c" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This effectively measures the distance of the predicted probability from the true class and dynamically adjusts based on whether the true class is equal to 0 or 1.</p><p id="9f0d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We note that <a class="af pq" href="https://rasbt.github.io/mlxtend/user_guide/evaluate/bias_variance_decomp/" rel="noopener ugc nofollow" target="_blank">the bias-variance decomposition for classification</a> is more complicated. In the section on the German Tank Problem I pointed out that a biased model may still be correct because the variance could (by chance) push the prediction closer to the truth. When using the squared loss this is completely cancelled out by the fact that the expected loss increases much more for highly incorrect estimates. So any potential benefit from high variance is overshadowed by estimates which are significantly off target.</p><p id="e113" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In the binary classification case this is not necessarily true. Bias, variance, and total error must be in the range (0,1). If the model is completely biased (bias=1) then the model always predicts the wrong class in expectation. Any variance actually makes the correct prediction more likely! Hence, in this particular scenario <em class="of">Err=Bias-Var</em>.</p><p id="e9f3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">If we add a reasonable assumption that the sum of the bias and variance must be less than or equal to 1 we get the standard decomposition except that the total error is simply <em class="of">Err=Bias+Var</em> rather than Bias².</p><h2 id="5149" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Model complexity is complicated</h2><p id="5119" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">In deep learning you might think that model complexity is entirely concerned with the number of parameters in the network. But consider that neural networks are trained with stochastic gradient descent and take time to converge on a solution. In order for the model to overfit it needs time to learn a transformation connecting all of the training data points. So model complexity is not just a function of number of parameters but also of the number of epochs training on the same set of data.</p><p id="ba6b" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This means our function <em class="of">g(λ)=c</em> is not straightforward as with the case of polynomial regression. Additionally, techniques like early stopping explicitly address the variance of our model by stopping training once error rates start to increase on a validation set.</p><p id="1908" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">According to the paper are 3 main types of hyperparameters that affect bias and variance:</p><ul class=""><li id="2b08" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk"><strong class="nl fr">Type I</strong>: A hyperparameter is used to balance bias and variance directly (e.g. as the weight applied to a regularisation term like weight decay).</li><li id="f4ab" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk"><strong class="nl fr">Type II</strong>: Indirectly affecting bias and variance by adjusting the loss signal from individual training examples (e.g. reducing or increasing the penalty for large prediction errors).</li><li id="0ef2" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk"><strong class="nl fr">Type III</strong>: Control parts of the training procedure which affect model complexity (e.g. number of epochs training a neural network, early stopping, or the depth of a decision tree).</li></ul><h2 id="d70d" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Easy vs hard examples</h2><p id="73d0" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">A dataset is considered “harder” to learn from if a model has a larger expected generalisation error when trained on that dataset. Formally:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq sv"><img src="../Images/62342f623665a3305d225f9dbedf3f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*Jtyy2Ig3ON2i3ZklikniWA.png"/></div></figure><p id="3e0a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk"><em class="of">Note: “for all λ” is a strong condition that may not always hold. A dataset may be harder to learn from under some hyperparameters but not others.</em></p><p id="7aec" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We make an assumption that the optimal complexity (<em class="of">c*</em>) for the harder dataset is greater than the optimal complexity of an easier dataset. We can plot the expected error of models trained on the two dataset like this:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sw"><img src="../Images/18325b3f382d9c23a11628a8c5700739.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cnnV7bQJy7zN16HWAJEQGA.png"/></div></div><figcaption class="ne nf ng mp mq nh ni bf b bg z dx">Source: A Mathematical Foundation for Robust Machine Learning based on Bias-Variance Trade-off</figcaption></figure><p id="0f9f" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Given our assumptions, the distinction between “easy” and “hard” datasets leads to an interesting consequence: choosing optimal hyperparameters on a “harder” dataset necessarily leads the model to be more complex.</p><p id="a530" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">If we partition the training data into “easy” and “hard” subsets we can use similar logic to conclude that a subset of the data is harder to learn from. This can be extended to classify an individual example <em class="of">(x,y)</em> as easy or hard. Consider the reasons that an example might be hard to learn from:</p><ul class=""><li id="9ec8" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">Noisy labels (i.e. badly annotated data)</li><li id="2a90" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">Sparse region of the feature space</li><li id="beca" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">A necessarily complex classification boundary</li></ul><p id="4d3e" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Now consider the <a class="af pq" href="https://arxiv.org/abs/1708.02002" rel="noopener ugc nofollow" target="_blank">focal loss</a> which is expressed as:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq sx"><img src="../Images/8de4246aa61464ebd7c5768ff9ed8ed6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*HajD9MXQvJ2oA317BA9vRg.png"/></div></figure><p id="d42d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This is similar to using a loss weighting on specific examples to give the model a stronger learning signal in trickier parts of the feature space. One common weighting method is to weight by inverse frequency which gives a higher loss to examples of the sparser class. The focal loss has the effect of automatically determining what makes an example hard based on the current state of the model. The model’s current confidence is used to dynamically adjust the loss in difficult regions of the feature space. So if the model is overly confident and incorrect, that sends a stronger signal than if the model is confident but correct.</p><p id="e525" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The weighting parameter <em class="of">γ</em> is an example of a Type II hyperparameter which adjusts the loss signal from training examples. If an example is hard to learn from then focal loss would ideally encourage the model to become more complex in that part of the feature space. Yet there are many reasons an example may be hard to learn from so this is not always desirable.</p><h2 id="2242" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Shape of the decision boundary</h2><p id="f420" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Here I’ve created a 2D dataset with simple shapes in repeated patterns acting as a decision boundary. I’ve also added a few “dead zones” where data is much harder to sample. With ~100,000 data points a human can look at the plot and quickly see what the boundaries should be.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq sy"><img src="../Images/45ae3cd336c95af90257ed635a81c33d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EbJ-70d1_9qRix888UTfFw.png"/></div></div></figure><p id="c3bb" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Despite the dead zones you can easily see the boundary because billions of years of natural selection have equipped you with general pattern recognition capabilities. It will not be so easy for a neural network trained from scratch. For this exercise we won’t apply explicit regularisation (weight decay, dropout) which would discourage it from overfitting the training data. Yet it’s worth noting that layer norm, skip connections, and even stochastic gradient descent can act as <strong class="nl fr">implicit regularisers</strong>.</p><p id="a1d9" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Here the number of parameters (<em class="of">p</em>) is roughly equal to the number of examples (<em class="of">N</em>). We’ll focus only on the training loss to observe how the model overfits. The following 2 models are trained with fairly large batch sizes for 3000 epochs. The predicted boundary from the model on the left uses a standard binary cross entropy loss while the one on the right uses the focal loss:</p></div></div><div class="mj bh"><figure class="ms mt mu mv mw mj bh paragraph-image"><img src="../Images/6a024af1917da95681b5f5376254cd2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:4800/format:webp/1*uCIol_2pC-AEL06y3ug7fg.png"/></figure></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="2a7b" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The first thing to notice is that even though there’s no explicit regularisation there are relatively smooth boundaries. For example, in the top left there happened to be a bit of sparse sampling (by chance) yet both models prefer to cut off one tip of the star rather than predicting a more complex shape around the individual points. This is an important reminder that many architectural decisions act as implicit regularisers.</p><p id="3d62" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">From our analysis we would expect focal loss to predict complicated boundaries in areas of natural complexity. Ideally, this would be an advantage of using the focal loss. But if we inspect one of the areas of natural complexity we see that both models fail to identify that there is an additional shape inside the circles.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq sz"><img src="../Images/4ccf85133e8875fc508b606435e17543.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*uMsQo4x_RQQMBwIIR970sQ.png"/></div></figure><p id="f1e3" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In regions of sparse data (dead zones) we would expect focal loss to create more complex boundaries. This isn’t necessarily desirable. If the model hasn’t learned any of the underlying patterns of the data then there are infinitely many ways to draw a boundary around sparse points. Here we can contrast two sparse areas and notice that focal loss has predicted a more complex boundary than the cross entropy:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq ta"><img src="../Images/f7568d867ef9ca4a78a17332918eb0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*obZQYyFWk4LHcnPharmvwQ.png"/></div></div></figure><p id="caa2" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The top row is from the central star and we can see that the focal loss has learned more about the pattern. The predicted boundary in the sparse region is more complex but also more correct. The bottom row is from the lower right corner and we can see that the predicted boundary is more complicated but it hasn’t learned a pattern about the shape. The smooth boundary predicted by BCE might be more desirable than the strange shape predicted by focal loss.</p><p id="408e" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This qualitative analysis doesn’t help in determining which one is better. How can we quantify it? The two loss functions produce different values that can’t be compared directly. Instead we’re going to compare the accuracy of predictions. We’ll use a standard F1 score but note that different risk profiles might prefer extra weight on recall or precision.</p><p id="1f32" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">To assess generalisation capability we use a validation set that’s iid with our training sample. We can also use early stopping to prevent both approaches from overfitting. If we compare the validation losses of the two models we see a slight boost in F1 scores using focal loss vs binary cross entropy.</p><ul class=""><li id="8ba4" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk"><strong class="nl fr">BCE Loss</strong>: 0.936 (Validation F1)</li><li id="4c09" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk"><strong class="nl fr">Focal Loss</strong>: 0.954 (Validation F1)</li></ul><p id="cd4f" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">So it seems that the model trained with focal loss performs slightly better when applied on unseen data. So far, so good, right?</p><h2 id="b791" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">The trouble with iid generalisation</h2><p id="c353" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">In the standard definition of generalisation, future observations are assumed to be iid with our training distribution. But this won’t help if we want our model to learn an effective representation of the underlying process that generated the data. In this example that process involves the shapes and the symmetries that determine the decision boundary. If our model has an internal representation of those shapes and symmetries then it should perform equally well in those sparsely sampled “dead zones”.</p><p id="846b" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Neither model will ever work OOD because they’ve only seen data from one distribution and cannot generalise. And it would be unfair to expect otherwise. However, we can focus on robustness in the sparse sampling regions. In the paper Machine Learning Robustness: A Primer, they mostly talk about samples from the tail of the distribution which is something we saw in our house prices models. But here we have a situation where sampling is sparse but it has nothing to do with an explicit “tail”. I will continue to refer to this as an “endogenous sampling bias” to highlight that tails are not explicitly required for sparsity.</p><p id="3ced" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In this view of robustness the endogenous sampling bias is one possibility where models may not generalise. For more powerful models we can also explore OOD and adversarial data. Consider an image model which is trained to recognise objects in urban areas but fails to work in a jungle. That would be a situation where we would expect a powerful enough model to work OOD. Adversarial examples on the other hand would involve adding noise to an image to change the statistical distribution of colours in a way that’s imperceptible to humans but causes miss-classification from a non-robust model. But building models that resist adversarial and OOD perturbations is out of scope for this already long article.</p><h2 id="d2fd" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Robustness to perturbation</h2><p id="b0de" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">So how do we quantify this robustness? We’ll start with an accuracy function <em class="of">A</em> (we previously used the F1 score). Then we consider a perturbation function <em class="of">φ</em> which we can apply on both individual points or on an entire dataset. Note that this perturbation function should preserve the relationship between predictor <em class="of">x</em> and target <em class="of">y</em>. (i.e. we are not purposely mislabelling examples).</p><p id="d5a6" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Consider a model designed to predict house prices in any city, an OOD perturbation may involve finding samples from cities not in the training data. In our example we’ll focus on a modified version of the dataset which samples exclusively from the sparse regions.</p><p id="3275" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The robustness score (<em class="of">R</em>) of a model (<em class="of">h</em>) is a measure of how well the model performs under a perturbed dataset compared to a clean dataset:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div class="mp mq tb"><img src="../Images/e76d6b3ecd6f3f362297e0d9abedb811.png" data-original-src="https://miro.medium.com/v2/resize:fit:318/format:webp/1*Btm_VlE50h0eFGoSZwFIyA.png"/></div></figure><p id="9170" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Consider the two models trained to predict a decision boundary: one trained with focal loss and one with binary cross entropy. Focal loss performed slightly better on the validation set which was iid with the training data. Yet we used that dataset for early stopping so there is some subtle information leakage. Let’s compare results on:</p><ol class=""><li id="8e18" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">A validation set iid to our training set and used for early stopping.</li><li id="ec13" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">A test set iid to our training set.</li><li id="4a2e" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">A perturbed (<em class="of">φ</em>) test set where we only sample from the sparse regions I’ve called “dead zones”.</li></ol><pre class="ms mt mu mv mw rr rs rt bp ru bb bk"><span id="2b82" class="rv oh fq rs b bg rw rx l ry rz">| Loss Type  | Val (iid) F1  | Test (iid) F1   | Test (φ) F1 |   R(φ)  |<br/>|------------|---------------|-----------------|-------------|---------|<br/>| BCE Loss   |    0.936      |    0.959        |   0.834     | 0.869   |<br/>| Focal Loss |    0.954      |    0.941        |   0.822     | 0.874   |</span></pre><p id="f87f" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The standard bias-variance decomposition suggested that we might get more robust results with focal loss by allowing increased complexity on hard examples. We knew that this might not be ideal in all circumstances so we evaluated on a validation set to confirm. So far so good. But now that we look at the performance on a perturbed test set we can see that focal loss performed slightly worse! Yet we also see that focal loss has a slightly higher robustness score. <em class="of">So what is going on here?</em></p><p id="e10a" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">I ran this experiment several times, each time yielding slightly different results. This was one surprising instance I wanted to highlight. The bias-variance decomposition is about how our model will perform in expectation (across different possible worlds). By contrast this robustness approach tells us how <em class="of">these specific models</em> perform under perturbation. But we may need more considerations for model selection.</p><p id="0147" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">There are a lot of subtle lessons in these results:</p><ol class=""><li id="ced8" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">If we make significant decisions on our validation set (e.g. early stopping) then it becomes vital to have a separate test set.</li><li id="4051" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">Even training on the same dataset we can get varied results. When training neural networks there are multiple sources of randomness. We will go into this further in the last section of this article.</li><li id="feee" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">A weaker model may be more robust to perturbations. So model selection needs to consider more than just the robustness score.</li><li id="14fd" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">We may need to evaluate models on multiple perturbations to make informed decisions.</li></ol><h2 id="7e9a" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Comparing approaches to robustness</h2><p id="b152" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">In one approach to robustness we consider the impact of hyperparameters on model performance through the lens of the bias-variance trade-off. We can use this knowledge to understand how different kinds of training examples affect our training process. For example, we know that miss-labelled data is particularly bad to use with focal loss. We can consider whether particularly hard examples could be excluded from our training data to produce more robust models. And we can better understand the role of regularisation by consider the types of hyperparameters and how they impact bias and variance.</p><p id="cbbe" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The other perspective largely disregards the bias variance trade-off and focuses on how our model performs on perturbed inputs. For us, this meant focusing on sparsely sampled regions but may also include out of distribution (OOD) and adversarial data. One drawback to this approach is that it is evaluative and doesn’t necessarily tell us how to construct better models short of training on more (and more varied) data. A more significant drawback is that weaker models may exhibit more robustness and so we can’t exclusively use robustness score for model selection.</p><h2 id="dcb7" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Regularisation and robustness</h2><p id="81f9" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">If we take the standard model trained with cross entropy loss we can plot the performance on different metrics over time: training loss, validation loss, validation_<em class="of">φ</em> loss, validation accuracy, and validation_<em class="of">φ</em> accuracy. We can compare the training process under the presence of different kinds of regularisation to see how it affects generalisation capability.</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq tc"><img src="../Images/d7d858a6fad9c619970cc158619a8db0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsTbsf6uPNRiHqnZSpQETg.png"/></div></div></figure><p id="5651" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In this particular problem we can make some unusual observations</p><ol class=""><li id="c09f" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">As we would expect without regularisation, as the training loss tends towards 0 the validation loss starts to increase.</li><li id="3831" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">The validation_<em class="of">φ</em> loss increases much more significantly because it only contains examples from the sparse “dead zones”.</li><li id="0dcd" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">But the validation accuracy doesn’t actually get worse as the validation loss increases. What is going on here? This is something I’ve actually seen in real datasets. The model’s accuracy improves but it also becomes increasingly confident in its outputs, so when it is wrong the loss is quite high. Using the model’s probabilities becomes useless as they all tend to 99.99% regardless of how well the model does.</li><li id="366e" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">Adding regularisation prevents the validation losses from blowing up as the training loss cannot go to 0. However, it can also negatively impact the validation accuracy.</li><li id="f7d9" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">Adding dropout and weight decay is better than just dropout, but both are worse than using no regularisation in terms of accuracy.</li></ol><h2 id="4006" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Reflection</h2><p id="2711" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">If you’ve stuck with me this far into the article I hope you’ve developed an appreciation for the limitations of the bias-variance trade-off. It will always be useful to have an understanding of the typical relationship between model complexity and expected performance. But we’ve seen some interesting observations that challenge the default assumptions:</p><ul class=""><li id="53e4" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">Model complexity can change in different parts of the feature space. Hence, a single measure of complexity vs bias/variance doesn’t always capture the whole story.</li><li id="2747" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The standard measures of generalisation error don’t capture all types of generalisation, particularly lacking in robustness under perturbation.</li><li id="f795" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">Parts of our training sample can be harder to learn from than others and there are multiple ways in which a training example can be considered “hard”. Complexity might be necessary in naturally complex regions of the feature space but problematic in sparse areas. This sparsity can be driven by endogenous sampling bias and so comparing performance to an iid test set can give false impressions.</li><li id="15e3" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">As always we need to factor in risk and risk minimisation. If you expect all future inputs to be iid with the training data it would be detrimental to focus on sparse regions or OOD data. Especially if tail risks don’t carry major consequences. On the other hand we’ve seen that tail risks can have unique consequences so it’s important to construct an appropriate test set for your particular problem.</li><li id="f907" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">Simply testing a model’s robustness to perturbations isn’t sufficient for model selection. A decision about the generalisation capability of a model can only be done under a proper risk assessment.</li><li id="0dd2" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The bias-variance trade-off only concerns the expected loss for models averaged over possible worlds. It doesn’t necessarily tell us how accurate our model will be using hard classification boundaries. This can lead to counter-intuitive results.</li></ul><h1 id="9a04" class="og oh fq bf oi oj ok gq ol om on gt oo op oq or os ot ou ov ow ox oy oz pa pb bk">Deep Learning and Over-parametrisation</h1><p id="b952" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Let’s review some of the assumptions that were key to our bias-variance decomposition:</p><ul class=""><li id="2512" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">At low complexity, the total error is dominated by bias, while at high complexity total error is dominated by variance. With bias ≫ variance at the minimum complexity.</li><li id="85dd" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">As a function of complexity bias is monotonically decreasing and variance is monotonically increasing.</li><li id="3b93" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">The complexity function<em class="of"> g </em>is differentiable.</li></ul><p id="5f5d" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">It turns out that with sufficiently deep neural networks those first two assumptions are incorrect. And that last assumption may just be a convenient fiction to simplify some calculations. We won’t question that one but we’ll be taking a look at the first two.</p><p id="2b53" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Let’s briefly review what it means to overfit:</p><ul class=""><li id="cc67" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe qt pi pj bk">A model overfits when it fails to distinguish noise (aleatoric uncertainty) from intrinsic variation. This means that a trained model may behave wildly differently given different training data (i.e. variance across different possible worlds).</li><li id="9889" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe qt pi pj bk">We notice a model has overfit when it fails to generalise to an unseen test set. This typically means performance on test data that’s iid with the training data. We may focus on different measures of robustness and so craft a test set which is OOS, stratified, OOD, or adversarial.</li></ul><p id="d4d4" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We’ve so far assumed that the only way to get truly low bias is if a model is overly complex. And we’ve assumed that this complexity leads to high variance between models trained on different data. We’ve also established that many hyperparameters contribute to complexity including the number of epochs of stochastic gradient descent.</p><h2 id="5562" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Overparameterisation and memorisation</h2><p id="145d" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">You may have heard that a large neural network can simply memorise the training data. But what does that mean? Given sufficient parameters the model doesn’t need to learn the relationships between features and outputs. Instead it can store a function which responds perfectly to the features of every training example completely independently. It would be like writing an explicit if statement for every combination of features and simply producing the average output for that feature. Consider our decision boundary dataset where every example is completely separable. That would mean 100% accuracy for everything in the training set.</p><p id="d4a2" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">If a model has sufficient parameters then the gradient descent algorithm will naturally use all of that space to do such memorisation. In general it’s believed that this is much simpler than finding the underlying relationship between the features and the target values. This is considered the case when <em class="of">p ≫ N</em> (the number of trainable parameters is significantly larger than the number of examples).</p><p id="69fe" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">But there are 2 situations where a model can learn to generalise despite having memorised training data:</p><ol class=""><li id="b92e" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">Having too few parameters leads to weak models. Adding more parameters leads to a seemingly optimal level of complexity. Continuing to add parameters makes the model perform worse as it starts to fit to noise in the training data. Once the number of parameters exceeds the number of training examples the model <em class="of">may</em> start to perform better. Once <em class="of">p ≫ N</em> the model reaches another optimal point.</li><li id="a0a5" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">Train a model until the training and validation losses begin to diverge. The training loss tends towards 0 as the model memorises the training data but the validation loss blows up and reaches a peak. After some (extended) training time the validation loss starts to decrease.</li></ol><p id="5619" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This is known as the “double descent” phenomena where additional complexity actually leads to better generalisation.</p><h2 id="e130" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Does double descent require mislabelling?</h2><p id="9874" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">One general consensus is that label noise is sufficient but not necessary for double descent to occur. For example, the paper <a class="af pq" href="https://arxiv.org/pdf/2310.13572" rel="noopener ugc nofollow" target="_blank">Unravelling The Enigma of Double Descent</a> found that overparameterised networks will learn to assign the mislabelled class to points in the training data instead of learning to ignore the noise. However, a model may “isolate” these points and learn general features around them. It mainly focuses on the learned features within the hidden states of neural networks and shows that separability of those learned features can make labels noisy even without mislabelling.</p><p id="a762" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The paper <a class="af pq" href="https://arxiv.org/pdf/2303.14151" rel="noopener ugc nofollow" target="_blank">Double Descent Demystified</a> describes several necessary conditions for double descent to occur in generalised linear models. These criteria largely focus on variance within the data (as opposed to model variance) which make it difficult for a model to correctly learn the relationships between predictor and target variables. Any of these conditions can contribute to double descent:</p><ol class=""><li id="4fdc" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">The presence of singular values.</li><li id="2415" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">That the test set distribution is not effectively captured by features which account for the most variance in the training data.</li><li id="8774" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">A lack of variance for a perfectly fit model (i.e. a perfectly fit model seems to have no aleatoric uncertainty).</li></ol><p id="1fa4" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">This paper also captures the double descent phenomena for a toy problem with this visualisation:</p><figure class="ms mt mu mv mw mj mp mq paragraph-image"><div role="button" tabindex="0" class="mz na ed nb bh nc"><div class="mp mq td"><img src="../Images/5d9ab5b8e05827b68246befb2167ca51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOwN2IbAN_J6jG3XcWVi6w.png"/></div></div><figcaption class="ne nf ng mp mq nh ni bf b bg z dx">Source: Double Descent Demystified: Identifying, Interpreting &amp; Ablating the Sources of a Deep Learning Puzzle</figcaption></figure><p id="c23b" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">By contrast the paper <a class="af pq" href="https://proceedings.neurips.cc/paper_files/paper/2020/file/7d420e2b2939762031eed0447a9be19f-Paper.pdf" rel="noopener ugc nofollow" target="_blank">Understanding Double Descent Requires a Fine-Grained Bias-Variance Decomposition</a> gives a detailed mathematical breakdown of different sources of noise and their impact on variance:</p><ol class=""><li id="0394" class="nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe ph pi pj bk">Sampling — the general idea that fitting a model to different datasets leads to models with different predictions (<em class="of">V_D</em>)</li><li id="dedd" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">Optimisation — the effects of parameters initialisation but potentially also the nature of stochastic gradient descent (<em class="of">V_P</em>).</li><li id="b88a" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">Label noise — generally mislabelled examples (<em class="of">V_ϵ</em><strong class="nl fr">).</strong></li><li id="859b" class="nj nk fq nl b go pk nn no gr pl nq nr ns pm nu nv nw pn ny nz oa po oc od oe ph pi pj bk">The potential interactions between the 3 sources of variance.</li></ol><p id="7a43" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">The paper goes on to show that some of these variance terms actually contribute to the total error as part of a model’s bias. Additionally, you can condition the expectation calculation first on V_D or V_P and it means you reach different conclusions depending on how you do the calculation. A proper decomposition involves understanding how the total variance comes together from interactions between the 3 sources of variance. The conclusion is that while label noise exacerbates double descent it is not necessary.</p><h2 id="0877" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Regularisation and double descent</h2><p id="07ab" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Another consensus from these papers is that regularisation may prevent double descent. But as we saw in the previous section that does not necessarily mean that the regularised model will generalise better to unseen data. It more seems to be the case that regularisation acts as a floor for the training loss, preventing the model from taking the training loss arbitrarily low. But as we know from the bias-variance trade-off, that could limit complexity and introduce bias to our models.</p><h2 id="e8a7" class="qb oh fq bf oi qc qv qe ol qf qw qh oo ns qx qj qk nw qy qm qn oa qz qp qq qr bk">Reflection</h2><p id="cdc2" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">Double descent is an interesting phenomenon that challenges many of the assumptions used throughout this article. We can see that under the right circumstances increasing complexity doesn’t necessarily degrade a model’s ability to generalise.</p><p id="b3db" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Should we think of highly complex models as special cases or do they call into question the entire bias-variance trade-off. Personally, I think that the core assumptions hold true in most cases and that highly complex models are just a special case. I think the bias-variance trade-off has other weaknesses but the core assumptions tend to be valid.</p><h1 id="ef8f" class="og oh fq bf oi oj ok gq ol om on gt oo op oq or os ot ou ov ow ox oy oz pa pb bk">Conclusion</h1><p id="164a" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">The bias-variance trade-off is relatively straightforward when it comes to statistical inference and more typical statistical models. I didn’t go into other machine learning methods like decisions trees or support vector machines, but much of what we’ve discussed continues to apply there. But even in these settings we need to consider more factors than how well our model may perform if averaged over all possible worlds. Mainly because we’re comparing the performance against future data assumed to be iid with our training set.</p><p id="2b36" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Even if our model will only ever see data that looks like our training distribution we can still face large consequences with tail risks. Most <a class="af pq" href="https://medium.com/management-matters/managing-risks-in-deploying-generative-ai-393254259497" rel="noopener">machine learning projects need a proper risk assessment</a> to understand the consequences of mistakes. Instead of evaluating models under iid assumptions we should be constructing validation and test sets which fit into an appropriate risk framework.</p><p id="c103" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Additionally, models which are supposed to have general capabilities need to be evaluated on OOD data. Models which perform critical functions need to be evaluated adversarially. It’s also worth pointing out that the bias-variance trade-off isn’t necessarily valid in the setting of reinforcement learning. Consider <a class="af pq" href="https://medium.com/towards-data-science/exploring-the-ai-alignment-problem-with-gridworlds-2683f2f5af38" rel="noopener">the alignment problem in AI safety</a> which considers model performance beyond explicitly stated objectives.</p><p id="1248" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">We’ve also seen that in the case of large overparameterised models the standard assumptions about over- and underfitting simply don’t hold. The double descent phenomena is complex and still poorly understood. Yet it holds an important lesson about trusting the validity of strongly held assumptions.</p><p id="2eed" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">For those who’ve continued this far I want to make one last connection between the different sections of this article. In the section in inferential statistics I explained that Fisher information describes the amount of information a sample can contain about the distribution the sample was drawn from. In various parts of this article I’ve also mentioned that there are infinitely many ways to draw a decision boundary around sparsely sampled points. There’s an interesting question about whether there’s enough information in a sample to draw conclusions about sparse regions.</p><p id="0416" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">In my article on <a class="af pq" href="https://medium.com/towards-data-science/why-scaling-works-inductive-biases-vs-the-bitter-lesson-9c2782f99b18" rel="noopener">why scaling works</a> I talk about the concept of an inductive prior. This is something introduced by the training process or model architecture we’ve chosen. These inductive priors bias the model into making certain kinds of inferences. For example, regularisation might encourage the model to make smooth rather than jagged boundaries. With a different kind of inductive prior it’s possible for a model to glean more information from a sample than would be possible with weaker priors. For example, there are ways to encourage symmetry, translation invariance, and even detecting repeated patterns. These are normally applied through feature engineering or through architecture decisions like convolutions or the attention mechanism.</p><h1 id="5301" class="og oh fq bf oi oj ok gq ol om on gt oo op oq or os ot ou ov ow ox oy oz pa pb bk">Afterword</h1><p id="b270" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">I first started putting together the notes for this article over a year ago. I had one experiment where focal loss was vital for getting decent performance from my model. Then I had several experiments in a row where focal loss performed terribly for no apparent reason. I started digging into the bias-variance trade-off which led me down a rabbit hole. Eventually I learned more about double descent and realised that the bias-variance trade-off had a lot more nuance than I’d previously believed. In that time I read and annotated several papers on the topic and all my notes were just collecting digital dust.</p><p id="cb00" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">Recently I realised that over the years I’ve read a lot of terrible articles on the bias-variance trade-off. The idea I felt was missing is that we are calculating an expectation over “possible worlds”. That insight might not resonate with everyone but it seems vital to me.</p><p id="170e" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">I also want to comment on a popular visualisation about bias vs variance which uses archery shots spread around a target. I feel that this visual is misleading because it makes it seem that bias and variance are about individual predictions of a single model. Yet the math behind the bias-variance error decomposition is clearly about performance averaged across possible worlds. I’ve purposely avoided that visualisation for that reason.</p><p id="d2a6" class="pw-post-body-paragraph nj nk fq nl b go nm nn no gr np nq nr ns nt nu nv nw nx ny nz oa ob oc od oe fj bk">I’m not sure how many people will make it all the way through to the end. I put these notes together long before I started writing about AI and felt that I should put them to good use. I also just needed to get the ideas out of my head and written down. So if you’ve reached the end I hope you’ve found my observations insightful.</p><h1 id="435f" class="og oh fq bf oi oj ok gq ol om on gt oo op oq or os ot ou ov ow ox oy oz pa pb bk">References</h1><p id="8adc" class="pw-post-body-paragraph nj nk fq nl b go pc nn no gr pd nq nr ns pe nu nv nw pf ny nz oa pg oc od oe fj bk">[1] “German tank problem,” Wikipedia, Nov. 26, 2021. <a class="af pq" href="https://en.wikipedia.org/wiki/German_tank_problem" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/German_tank_problem</a><br/>[2] Wikipedia Contributors, “Minimum-variance unbiased estimator,” Wikipedia, Nov. 09, 2019. <a class="af pq" href="https://en.wikipedia.org/wiki/Minimum-variance_unbiased_estimator" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Minimum-variance_unbiased_estimator</a><br/>[3] “Likelihood function,” Wikipedia, Nov. 26, 2020. <a class="af pq" href="https://en.wikipedia.org/wiki/Likelihood_function" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Likelihood_function</a><br/>[4] “Fisher information,” Wikipedia, Nov. 23, 2023. <a class="af pq" href="https://en.wikipedia.org/wiki/Fisher_information" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Fisher_information</a><br/>[5] Why, “Why is using squared error the standard when absolute error is more relevant to most problems?,” Cross Validated, Jun. 05, 2020. <a class="af pq" href="https://stats.stackexchange.com/questions/470626/w" rel="noopener ugc nofollow" target="_blank">https://stats.stackexchange.com/questions/470626/w</a> (accessed Nov. 26, 2024).<br/>[6] Wikipedia Contributors, “Bias–variance tradeoff,” Wikipedia, Feb. 04, 2020. <a class="af pq" href="https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff</a><br/>[7] B. Efron, “Prediction, Estimation, and Attribution,” International Statistical Review, vol. 88, no. S1, Dec. 2020, doi: <a class="af pq" href="https://doi.org/10.1111/insr.12409" rel="noopener ugc nofollow" target="_blank">https://doi.org/10.1111/insr.12409</a>.<br/>[8] T. Hastie, R. Tibshirani, and J. H. Friedman, The Elements of Statistical Learning. Springer, 2009.<br/>[9] T. Dzekman, “Medium,” Medium, 2024. <a class="af pq" href="https://medium.com/towards-data-science/why-scalin" rel="noopener">https://medium.com/towards-data-science/why-scalin</a> (accessed Nov. 26, 2024).<br/>[10] H. Braiek and F. Khomh, “Machine Learning Robustness: A Primer,” 2024. Available: <a class="af pq" href="https://arxiv.org/pdf/2404.00897" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/pdf/2404.00897</a><br/>[11] O. Wu, W. Zhu, Y. Deng, H. Zhang, and Q. Hou, “A Mathematical Foundation for Robust Machine Learning based on Bias-Variance Trade-off,” arXiv.org, 2021. <a class="af pq" href="https://arxiv.org/abs/2106.05522v4" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2106.05522v4</a> (accessed Nov. 26, 2024).<br/>[12] “bias_variance_decomp: Bias-variance decomposition for classification and regression losses — mlxtend,” rasbt.github.io. <a class="af pq" href="https://rasbt.github.io/mlxtend/user_guide/evaluate/bias_variance_decomp/" rel="noopener ugc nofollow" target="_blank">https://rasbt.github.io/mlxtend/user_guide/evaluate/bias_variance_decomp</a><br/>[13] T.-Y. Lin, P. Goyal, R. Girshick, K. He, and P. Dollár, “Focal Loss for Dense Object Detection,” arXiv:1708.02002 [cs], Feb. 2018, Available: <a class="af pq" href="https://arxiv.org/abs/1708.02002" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1708.02002</a><br/>[14] Y. Gu, X. Zheng, and T. Aste, “Unraveling the Enigma of Double Descent: An In-depth Analysis through the Lens of Learned Feature Space,” arXiv.org, 2023. <a class="af pq" href="https://arxiv.org/abs/2310.13572" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2310.13572</a> (accessed Nov. 26, 2024).<br/>[15] R. Schaeffer et al., “Double Descent Demystified: Identifying, Interpreting &amp; Ablating the Sources of a Deep Learning Puzzle,” arXiv.org, 2023. <a class="af pq" href="https://arxiv.org/abs/2303.14151" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/2303.14151</a> (accessed Nov. 26, 2024).<br/>[16] B. Adlam and J. Pennington, “Understanding Double Descent Requires a Fine-Grained Bias-Variance Decomposition,” Neural Information Processing Systems, vol. 33, pp. 11022–11032, Jan. 2020.</p></div></div></div></div>    
</body>
</html>
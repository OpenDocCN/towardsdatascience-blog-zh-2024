["```py\n# import functions with input events and actions\nfrom events import (\n   simulate_chicken_intrusion,\n   initiate_shooing_chicken,\n)\nfrom actions import (\n  spoil_the_lawn,\n  start_lawn_cleaning,\n  one_more_juice\n)\n\n# define states\nSTART = 0\nCHICKEN_PRESENT = 1\nNO_CHICKEN = 2\nLAWN_SPOILING = 3\nENGINER_REST = 4\nEND = 5\n\n# initialise simulation step and duration\nsim_step = 0\nmax_sim_steps = 8\n\n# initialise states\nprev_state = None\ncurrent_state = START\n\n# monitor for events\nwhile current_state != END:\n   # update state transitions\n   if current_state == START:\n       current_state = NO_CHICKEN\n       prev_state = START\n   elif current_state == NO_CHICKEN:\n       if prev_state == CHICKEN_PRESENT:\n           start_lawn_cleaning()\n       if simulate_chicken_intrusion():\n           current_state = CHICKEN_PRESENT\n       else:\n           current_state = ENGINER_REST\n       prev_state = NO_CHICKEN\n   elif current_state == CHICKEN_PRESENT:\n       if initiate_shooing_chicken():\n           current_state = NO_CHICKEN\n       else:\n           current_state = LAWN_SPOILING\n       prev_state = CHICKEN_PRESENT\n   elif current_state == LAWN_SPOILING:\n       spoil_the_lawn()\n       current_state = CHICKEN_PRESENT\n       prev_state = LAWN_SPOILING\n   elif current_state == ENGINER_REST:\n       one_more_juice()\n       current_state = NO_CHICKEN\n       prev_state = ENGINER_REST\n\n   sim_step += 1\n   if sim_step >= max_sim_steps:\n       current_state = END\n```", "```py\nclass AbstractSimulation(abc.ABC):\n   @abc.abstractmethod\n   def step(self) -> Tuple[int, List['AbstractState']]:\n       pass\n\n   @abc.abstractmethod\n   def run(self) -> Iterator[Tuple[int, List['AbstractState']]]:\n       pass\n```", "```py\nclass AbstractState(abc.ABC):\n   def __init__(self, state_machine: AbstractSimulation):\n       super().__init__()\n       self.state_machine = state_machine\n\n   def __eq__(self, other):\n       return self.__class__ is other.__class__\n\n   @abc.abstractmethod\n   def transit(self) -> 'AbstractState':\n       pass\n```", "```py\nclass AbstractYardState(AbstractState, abc.ABC):\n   state_machine: AbstractYardSimulation\n```", "```py\nclass AbstractTarget(int, abc.ABC):\n   @property\n   @abc.abstractmethod\n   def health(self) -> float:\n       pass\n\n   @property\n   @abc.abstractmethod\n   def damage(self) -> float:\n       pass\n\n   @property\n   @abc.abstractmethod\n   def frequency(self) -> float:\n       pass\n```", "```py\nclass Chicken(AbstractTarget):\n   @property\n   def health(self) -> float:\n       return 4\n\n   @property\n   def damage(self) -> float:\n       return 10\n\n   @property\n   def frequency(self) -> float:\n       return 9\n```", "```py\nclass Start(AbstractYardState):\n   def transit(self) -> 'Spawn':\n       return Spawn(self.state_machine)\n```", "```py\nclass Spawn(AbstractYardState):\n   def transit(self) -> Union['Intrusion', 'Empty', 'End']:\n       self.state_machine.stayed_steps += 1\n\n       self.state_machine.simulate_intrusion()\n\n       next_state: Union['Intrusion', 'Empty', 'End']\n       if self.state_machine.max_steps_reached:\n           next_state = End(self.state_machine)\n       elif self.state_machine.bird_present:\n           next_state = Intrusion(self.state_machine)\n       else:\n           next_state = Empty(self.state_machine)\n\n       return next_state\n```", "```py\nclass IntrusionStatus(AbstractYardState):\n   intruder_class: Target\n\n   def transit(self) -> Union['Detected', 'NotDetected']:\n       self.state_machine.simulate_detection()\n       self.intruder_class = self.state_machine.intruder_class\n\n       next_state: Union['Detected', 'NotDetected']\n       if self.state_machine.predicted_bird:\n           next_state = Detected(self.state_machine)\n       else:\n           next_state = NotDetected(self.state_machine)\n\n       return next_state\n```", "```py\nclass DetectionStatus(AbstractYardState):\n   detected_class: Target\n\n   def transit(self) -> 'DetectionStatus':\n       self.detected_class = self.state_machine.detected_class\n\n       return self\n```", "```py\nclass Detected(DetectionStatus):\n   def transit(self) -> 'Sprinkling':\n       super().transit()\n\n       return Sprinkling(self.state_machine)\n\nclass NotDetected(DetectionStatus):\n   def transit(self) -> Union['Attacking', 'NotAttacked']:\n       super().transit()\n\n       next_state: Union['Attacking', 'NotAttacked']\n       if self.state_machine.bird_present:\n           next_state = Attacking(self.state_machine)\n       else:\n           next_state = NotAttacked(self.state_machine)\n\n       return next_state\n```", "```py\nclass Sprinkling(AbstractYardState):\n   def transit(self) -> Union['Hit', 'Miss']:\n       self.state_machine.simulate_sprinkling()\n\n       next_state: Union['Hit', 'Miss']\n       if self.state_machine.hit_successfully:\n           next_state = Hit(self.state_machine)\n       else:\n           next_state = Miss(self.state_machine)\n\n       return next_state\n```", "```py\nclass Hit(AbstractYardState):\n   def transit(self) -> 'Leaving':\n       return Leaving(self.state_machine)\n```", "```py\nclass Miss(AbstractYardState):\n   def transit(self) -> Union['Attacking', 'Spawn']:\n       next_state: Union['Attacking', 'Spawn']\n       if self.state_machine.bird_present:\n           next_state = Attacking(self.state_machine)\n       else:\n           next_state = Spawn(self.state_machine)\n\n       return next_state\n```", "```py\nclass Attacking(AbstractYardState):\n   def transit(self) -> Union['Attacked', 'NotAttacked']:\n       self.state_machine.simulate_spoiling()\n\n       next_state: Union['Attacked', 'NotAttacked']\n       if self.state_machine.spoiled:\n           next_state = Attacked(self.state_machine)\n       else:\n           next_state = NotAttacked(self.state_machine)\n\n       return next_state\n\nclass Attacked(AfterAttacking):\n   def transit(self) -> Union['Leaving', 'Spawn']:\n       return super().transit()\n\nclass NotAttacked(AfterAttacking):\n   def transit(self) -> Union['Leaving', 'Spawn']:\n       return super().transit()\n```", "```py\nclass AfterAttacking(AbstractYardState):\n   def transit(self) -> Union['Leaving', 'Spawn']:\n       next_state: Union['Leaving', 'Spawn']\n       if self.state_machine.max_stay_reached:\n           next_state = Leaving(self.state_machine)\n       else:\n           next_state = Spawn(self.state_machine)\n\n       return next_state\n```", "```py\nclass End(AbstractYardState):\n   def transit(self) -> 'End':\n       return self\n```", "```py\ndef step(self) -> Tuple[int, List[AbstractYardState]]:\n   self.step_idx += 1\n\n   transitions = list()\n   while True:\n       next_state = self.current_state.transit()\n       transitions.append(next_state)\n       self.current_state = next_state\n\n       if self.current_state in (Spawn(self), End(self)):\n           break\n\n   return self.step_idx, transitions\n```", "```py\ndef run(self) -> Iterator[Tuple[int, List[AbstractYardState]]]:\n   while self.current_state != End(self):\n       yield self.step()\n```", "```py\ndef reset(self) -> 'YardSimulation':\n   self.current_state = Start(self)\n   self.intruder_class = Target.EMPTY\n   self.detected_class = Target.EMPTY\n   self.hit_successfully = False\n   self.spoiled = False\n   self.stayed_steps = 0\n\n   return self\n```", "```py\ndef simulate_intrusion(self) -> Target:\n   if not self.bird_present:\n       self.intruder_class = self.spawn_target()\n\n   return self.intruder_class\n```", "```py\n@property\ndef bird_present(self) -> bool:\n   return self.intruder_class != Target.EMPTY\n```", "```py\ndef simulate_detection(self) -> Target:\n   self.detected_class = self.get_random_target(self.intruder_class)\n\n   return self.detected_class\n```", "```py\ndef simulate_sprinkling(self) -> bool:\n   self.hit_successfully = self.bird_present and (self.rng.uniform() <= self.hit_proba) and self.target_vulnerable\n\n   return self.hit_successfully\n```", "```py\ndef simulate_spoiling(self) -> bool:\n   self.spoiled = self.bird_present and (self.rng.uniform() <= self.shit_proba)\n   if self.spoiled:\n       self.lawn_damage[self.intruder_class] += self.intruder_class.damage\n\n   return self.spoiled\n```", "```py\nsim = YardSimulation(detector_matrix=detector_matrix, num_steps=num_steps)\n```", "```py\nfor step_idx, states in sim.run():\n   print(f'\\t{step_idx:0>3}: {\" -> \".join(map(str, states))}')\n```", "```py\ndef simulate_sprinkling(self) -> bool:\n   ...\n   self.water_consumption[self.detected_class] += self.detected_class.health\n   ...\n\ndef simulate_spoiling(self) -> bool:\n   ...\n   if self.spoiled:\n       self.lawn_damage[self.intruder_class] += self.intruder_class.damage\n   ...\n```", "```py\nwater_sprinkling_total = sum(sim.water_consumption.values())\nlawn_damage_total = sum(sim.lawn_damage.values())\n```", "```py\ndetector_matrix_baseline = np.full(\n     (len(Target),) * 2,  # size of the confusion matrix (3 x 3)\n     len(Target) ** -1    # prediction probability for each class is the same and equals to 1/3 \n)\ndetector_matrix_perfect = np.eye(len(Target))\n```"]
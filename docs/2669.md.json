["```py\nimport torch\nimport neuronxcc.nki as nki\nimport neuronxcc.nki.language as nl\nimport numpy as np\n\nsimulate = False\n\ntry:\n    # if torch libraries are installed assume that we are running on Neuron\n    import torch_xla.core.xla_model as xm\n    import torch_neuronx\n    from torch_neuronx import nki_jit\n\n    device = xm.xla_device()\n\n    # empty implementation \n    def debug_print(*args, **kwargs):\n        pass\nexcept:\n    # if torch libraries are not installed assume that we are running on CPU\n    # and program script to use nki simulation\n    simulate = True\n    nki_jit = nki.trace\n    debug_print = nl.device_print\n    device = 'cpu'\n\n@nki_jit\ndef giou_kernel(preds_ptr,\n                targets_ptr,\n                output_ptr):\n    epsilon = 1e-5\n    TILE_M = nl.tile_size.pmax  # 128\n    TILE_N = nl.tile_size.psum_fmax  # 512\n    TILE_N_OUT = TILE_N // 4\n\n    p_1, p_2 = preds_ptr.shape\n    t_1, t_2 = targets_ptr.shape\n    o_1, o_2 = output_ptr.shape\n\n    #  verify input\n    # batch size must be multiple of 128\n    assert p_1 % TILE_M == 0\n    assert p_1 == t_1\n    assert p_1 == o_1\n    # num boxes box *4 must be multiple of 512\n    assert p_2 % TILE_N == 0\n    assert p_2 == t_2\n    assert p_2 // 4 == o_2\n\n    num_tiles_m = p_1 // TILE_M\n    num_tiles_n = p_2 // TILE_N\n\n    # Generate tensors for advanced indexing\n    i_p = nl.arange(TILE_M)[:, None]\n    i_f = nl.arange(TILE_N // 4)[None, :]\n    i_f_0 = (4 * i_f)\n    i_f_1 = (4 * i_f + 1)\n    i_f_2 = (4 * i_f + 2)\n    i_f_3 = (4 * i_f + 3)\n\n    # Use affine_range to loop over tiles\n    for m in nl.affine_range(num_tiles_m):\n        for n in nl.affine_range(num_tiles_n):\n            # Load input data from HBM\n            preds = nl.load(preds_ptr[m * TILE_M:(m + 1) * TILE_M,\n                            n * TILE_N:(n + 1) * TILE_N])\n            targets = nl.load(targets_ptr[m * TILE_M:(m + 1) * TILE_M,\n                              n * TILE_N:(n + 1) * TILE_N])\n            debug_print('preds', preds)\n            preds_left = preds[i_p, i_f_0]\n            preds_top = preds[i_p, i_f_1]\n            preds_right = preds[i_p, i_f_2]\n            preds_bottom = preds[i_p, i_f_3]\n\n            gt_left = targets[i_p, i_f_0]\n            gt_top = targets[i_p, i_f_1]\n            gt_right = targets[i_p, i_f_2]\n            gt_bottom = targets[i_p, i_f_3]\n\n            # Compute the area of each box\n            area1 = (preds_right - preds_left) * (preds_bottom - preds_top)\n            area2 = (gt_right - gt_left) * (gt_bottom - gt_top)\n\n            # Compute the intersection\n            left = nl.maximum(preds_left, gt_left)\n            top = nl.maximum(preds_top, gt_top)\n            right = nl.minimum(preds_right, gt_right)\n            bottom = nl.minimum(preds_bottom, gt_bottom)\n\n            inter_w = nl.maximum(right - left, 0)\n            inter_h = nl.maximum(bottom - top, 0)\n            inter_area = inter_w * inter_h\n\n            union_area = area1 + area2 - inter_area\n\n            iou_val = inter_area / nl.maximum(union_area, epsilon)\n\n            # Compute the smallest enclosing box\n            enclose_left = nl.minimum(preds_left, gt_left)\n            enclose_top = nl.minimum(preds_top, gt_top)\n            enclose_right = nl.maximum(preds_right, gt_right)\n            enclose_bottom = nl.maximum(preds_bottom, gt_bottom)\n\n            enclose_w = nl.maximum(enclose_right - enclose_left, 0)\n            enclose_h = nl.maximum(enclose_bottom - enclose_top, 0)\n            enclose_area = enclose_w * enclose_h\n\n            # Compute GIOU\n            delta_area = (enclose_area - union_area)\n            enclose_area = nl.maximum(enclose_area, epsilon)\n            giou = iou_val - delta_area / enclose_area\n\n            # Store results\n            nl.store(output_ptr[m * TILE_M:(m + 1) * TILE_M,\n                     n * TILE_N_OUT:(n + 1) * TILE_N_OUT],\n                     giou) \n```", "```py\n# generate random data in np\nnp.random.seed(0)\nbatch_size = 1024\nn_boxes = 256\nimg_size = 256\nboxes = []\n\nfor i in range(2):\n    # Randomly generate box sizes and positions\n    box_sizes = np.random.randint(1, img_size, size=(batch_size,n_boxes,2))\n    top_left = np.random.randint(0, img_size-1, size=(batch_size,n_boxes,2))\n    bottom_right = np.clip(top_left + box_sizes, 0, img_size - 1)\n\n    # Concatenate top-left and bottom-right coordinates\n    rand_boxes = np.concatenate((top_left, bottom_right), axis=2)\n\n    boxes.append(rand_boxes.astype(np.float32))\n\nout = np.empty((batch_size, n_boxes), np.float32)\n\n# convert tensors to PyTorch\nt_boxes_0 = torch.tensor(boxes[0]).to(device)\nt_boxes_1 = torch.tensor(boxes[1]).to(device)\nt_out = torch.tensor(out).to(device)\n\nif simulate:\n    # the simulation API requires numpy input\n    nki.simulate_kernel(giou_kernel, \n                        boxes[0].reshape((batch_size, -1)),\n                        boxes[1].reshape((batch_size, -1)),\n                        out)\nelse:\n    giou_kernel(t_boxes_0.view((batch_size, -1)),\n                t_boxes_1.view((batch_size, -1)),\n                t_out) \n```", "```py\ndef torch_giou(boxes1, boxes2):\n    # loosely based on torchvision generalized_box_iou_loss code\n    epsilon = 1e-5\n\n    # Compute areas of both sets of boxes\n    area1 = (boxes1[...,2]-boxes1[...,0])*(boxes1[...,3]-boxes1[...,1])\n    area2 = (boxes2[...,2]-boxes2[...,0])*(boxes2[...,3]-boxes2[...,1])\n\n    # Corners of intersection\n    lt = torch.max(boxes1[..., :2], boxes2[..., :2])\n    rb = torch.min(boxes1[..., 2:], boxes2[..., 2:])\n\n    # Width and height of intersection\n    wh = (rb - lt).clamp(min=0)\n\n    # Area of the intersection\n    inter = wh[..., 0] * wh[..., 1]\n\n    # Union of the two boxes\n    union = area1 + area2 - inter\n    iou = inter / union.clamp(epsilon)\n\n    # Corners of enclosing box\n    lti = torch.min(boxes1[..., :2], boxes2[..., :2])\n    rbi = torch.max(boxes1[..., 2:], boxes2[..., 2:])\n\n    # Width and height of the enclosing box\n    whi = (rbi - lti).clamp(min=0)\n\n    # Area of the enclosing box\n    areai = (whi[..., 0] * whi[..., 1]).clamp(epsilon)\n\n    return iou - (areai - union) / areai\n```", "```py\nimport time\ndef benchmark(f, warmup_iters=20, ntrials: int = 100):\n    def run(*args, **kwargs):\n        # warmup\n        for _ in range(warmup_iters):\n            f(*args, **kwargs)\n        start_time = time.time()\n        for _ in range(ntrials):\n            f(*args, **kwargs)\n        end_time = time.time()\n        # Calculate average time per iteration\n        avg_time = (end_time - start_time) / ntrials\n        return avg_time\n\n    return run\n\navg_time = benchmark(torch_giou)(t_boxes_0, t_boxes_1)\nprint(f'torch_giou: {avg_time}')\n\navg_time = benchmark(giou_kernel)(t_boxes_0.view((batch_size, -1)),\n                                  t_boxes_1.view((batch_size, -1)),\n                                  t_out)\nprint(f'giou_kernel: {avg_time}')\n```", "```py\n#include <stdint.h>\n#include <stdlib.h>\n#include <torch/torch.h>\n#include <neuron/neuron-utils.hpp>\n#include <algorithm>\n\n// input boxes of shape 1024x256x4\n// output scores of shape 1024x256\ntorch::Tensor giou(const torch::Tensor& t_pred, \n                   const torch::Tensor& t_target) {\n  size_t num_samples = t_pred.sizes()[0];\n  size_t num_boxes = t_pred.sizes()[1];\n  torch::Tensor t_out = get_dst_tensor();\n\n  // get the number of GpSimd processors (8 in NeuronCoreV2) \n  uint32_t cpu_count = get_cpu_count();\n  // get index of current processor\n  uint32_t cpu_id = get_cpu_id();\n\n  // divide the batch size into 8 partitions \n  uint32_t partition = num_samples / cpu_count;\n\n  // use tcm buffers to load and write data\n  size_t tcm_in_size = num_boxes*4;\n  size_t tcm_out_size = num_boxes;\n  float *tcm_pred = (float*)torch::neuron::tcm_malloc(\n                                             sizeof(float)*tcm_in_size);\n  float *tcm_target = (float*)torch::neuron::tcm_malloc(\n                                             sizeof(float)*tcm_in_size);\n  float *tcm_output = (float*)torch::neuron::tcm_malloc(\n                                             sizeof(float)*tcm_in_size);\n  auto t_pred_tcm_acc = t_pred.tcm_accessor();\n  auto t_target_tcm_acc = t_target.tcm_accessor();\n  auto t_out_tcm_acc = t_out.tcm_accessor();\n\n  // iterate over each of the entries in the partition\n  for (size_t i = 0; i < partition; i++) {\n    // load the pred and target boxes into local memory\n    t_pred_tcm_acc.tensor_to_tcm<float>(tcm_pred,\n                                        partition*cpu_id + i*tcm_in_size,\n                                        tcm_in_size);\n    t_target_tcm_acc.tensor_to_tcm<float>(tcm_target,\n                                          partition*cpu_id + i*tcm_in_size,\n                                          tcm_in_size);\n\n    // iterate over each of the boxes in the entry\n    for (size_t j = 0; j < num_boxes; j++) {\n      const float epsilon = 1e-5;\n      const float* box1 = &tcm_pred[j * 4];\n      const float* box2 = &tcm_target[j * 4];\n      // Compute area of each box\n      float area1 = (box1[2] - box1[0]) * (box1[3] - box1[1]);\n      float area2 = (box2[2] - box2[0]) * (box2[3] - box2[1]);\n\n      // Compute the intersection\n      float left = std::max(box1[0], box2[0]);\n      float top = std::max(box1[1], box2[1]);\n      float right = std::min(box1[2], box2[2]);\n      float bottom = std::min(box1[3], box2[3]);\n\n      float inter_w = std::max(right - left, 0.f);\n      float inter_h = std::max(bottom - top, 0.f);\n      float inter_area = inter_w * inter_h;\n\n      // Compute the union area\n      float union_area = area1 + area2 - inter_area;\n\n      // IoU\n      float iou_val = inter_area / std::max(union_area, epsilon);\n\n      // Compute the smallest enclosing box\n      float enclose_left = std::min(box1[0], box2[0]);\n      float enclose_top = std::min(box1[1], box2[1]);\n      float enclose_right = std::max(box1[2], box2[2]);\n      float enclose_bottom = std::max(box1[3], box2[3]);\n\n      float enclose_w = std::max(enclose_right - enclose_left, 0.f);\n      float enclose_h = std::max(enclose_bottom - enclose_top, 0.f);\n      float enclose_area = std::max(enclose_w * enclose_h, epsilon);\n\n      float result = iou_val - (enclose_area-union_area)/enclose_area;\n      tcm_output[j] = result;\n    }\n\n    // write the giou scores of all boxes in the current entry\n    t_out_tcm_acc.tcm_to_tensor<float>(tcm_output,\n                                       partition*cpu_id + i*tcm_out_size,\n                                       tcm_out_size);\n  }\n\n  torch::neuron::tcm_free(tcm_pred);\n  torch::neuron::tcm_free(tcm_target);\n  return t_out;\n}\n```", "```py\n#include <stdint.h>\n#include <stdlib.h>\n#include <torch/torch.h>\n#include \"torchneuron/register.h\"\n\ntorch::Tensor giou_shape(torch::Tensor boxes1, torch::Tensor boxes2) {\n    torch::Tensor t_out = torch::zeros({boxes1.sizes()[0],\n                                        boxes1.sizes()[1]},\n                                       torch::kFloat);\n    return t_out;\n}\n\nNEURON_LIBRARY(my_ops, m) {\n  m.def(\"giou\", &giou_shape, \"giou\");\n}\n```", "```py\nimport os\nimport torch_neuronx\nfrom torch_neuronx.xla_impl import custom_op\n\ncustom_op.load(\n    name='giou',\n    compute_srcs=['giou.cpp'],\n    shape_srcs=['shape.cpp'],\n    build_directory=os.getcwd(),\n    multicore=True,\n    verbose=True\n)\n```", "```py\nfrom torch_neuronx.xla_impl import custom_op\ncustom_op.load_library('libgiou.so')\n\navg_time = benchmark(torch.ops.my_ops.giou)(t_boxes_0, t_boxes_1)\nprint(f'C++ giou: {avg_time}')\n```"]
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Coding in Cipher: Encrypted Data Structures and Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Coding in Cipher: Encrypted Data Structures and Algorithms</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/coding-in-cipher-encrypted-data-structures-and-algorithms-dd99e584a655?source=collection_archive---------11-----------------------#2024-05-09">https://towardsdatascience.com/coding-in-cipher-encrypted-data-structures-and-algorithms-dd99e584a655?source=collection_archive---------11-----------------------#2024-05-09</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><figure class="fr fs ft fu fv fw fo fp paragraph-image"><div role="button" tabindex="0" class="fx fy ed fz bh ga"><div class="fo fp fq"><img src="../Images/6a8a6b11fead440f4da38081f96c99fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KeUjLeOb9HAydGvdfAtvZQ.png"/></div></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">Image created by the author using Pixlr.com</figcaption></figure><div/><div><h2 id="600b" class="pw-subtitle-paragraph hh gj gk bf b hi hj hk hl hm hn ho hp hq hr hs ht hu hv hw cq dx">Welcome, developers! If you’ve spent time mastering data structures and algorithms, have you considered their encrypted data potential?</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hx hy hz ia ib ab"><div><div class="ab ic"><div><div class="bm" aria-hidden="false"><a href="https://alextmn1.medium.com/?source=post_page---byline--dd99e584a655--------------------------------" rel="noopener follow"><div class="l id ie by if ig"><div class="l ed"><img alt="Alex Shpurov" class="l ep by dd de cx" src="../Images/e563c8a09a4efe41dabc827b150b3dcb.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*5klTfdaXLJEzhLtbJAgK9w.png"/><div class="ih by l dd de em n ii eo"/></div></div></a></div></div><div class="ij ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--dd99e584a655--------------------------------" rel="noopener follow"><div class="l ik il by if im"><div class="l ed"><img alt="Towards Data Science" class="l ep by br in cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="ih by l br in em n ii eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="io ab q"><div class="ab q ip"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b iq ir bk"><a class="af ag ah ai aj ak al am an ao ap aq ar is" data-testid="authorName" href="https://alextmn1.medium.com/?source=post_page---byline--dd99e584a655--------------------------------" rel="noopener follow">Alex Shpurov</a></p></div></div></div><span class="it iu" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b iq ir dx"><button class="iv iw ah ai aj ak al am an ao ap aq ar ix iy iz" disabled="">Follow</button></p></div></div></span></div></div><div class="l ja"><span class="bf b bg z dx"><div class="ab cn jb jc jd"><div class="je jf ab"><div class="bf b bg z dx ab jg"><span class="jh l ja">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar is ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--dd99e584a655--------------------------------" rel="noopener follow"><p class="bf b bg z ji jj jk jl jm jn jo jp bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="it iu" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">12 min read</span><div class="jq jr l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">May 9, 2024</span></div></span></div></span></div></div></div><div class="ab cp js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh"><div class="h k w ea eb q"><div class="kx l"><div class="ab q ky kz"><div class="pw-multi-vote-icon ed jh la lb lc"><div class=""><div class="ld le lf lg lh li lj am lk ll lm lc"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l ln lo lp lq lr ls lt"><p class="bf b dy z dx"><span class="le">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao ld lu lv ab q ee lw lx" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="ly"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg></button></div></div></div><div class="ab q ki kj kk kl km kn ko kp kq kr ks kt ku kv kw"><div class="lz k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al ma an ao ap ix mb mc md" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep me cn"><div class="l ae"><div class="ab cb"><div class="mf mg mh mi mj gb ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al ma an ao ap ix mk ml lx mm mn mo mp mq s mr ms mt mu mv mw mx u my mz na"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al ma an ao ap ix mk ml lx mm mn mo mp mq s mr ms mt mu mv mw mx u my mz na"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al ma an ao ap ix mk ml lx mm mn mo mp mq s mr ms mt mu mv mw mx u my mz na"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><p id="28da" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Introducing the world of Fully Homomorphic Encryption (FHE), a groundbreaking approach that allows for computations on encrypted data without ever needing to decrypt it. This means you can perform operations on data while maintaining complete privacy. This employs post-quantum cryptographic methods, allowing encrypted data to remain secure on public networks such as clouds or blockchains.</p><p id="9338" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">In this series of articles, we explore how traditional data structures and algorithms, like binary search trees, sorting algorithms, and even dynamic programming techniques, can be implemented in an encrypted domain using FHE. Imagine performing a binary search on a dataset that remains entirely encrypted, or sorting data that is not visible in its raw form, all while ensuring that the privacy and security of the data are never compromised.</p><p id="a411" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">We’ll dive into how FHE works at a fundamental level and the implications it has for both data security and algorithm design. Later in this series we’ll also explore real-world applications and the potential challenges developers face when implementing these encrypted algorithms, such as fraud detection, payments, and more. This isn’t just about enhancing security; it’s about rethinking how we interact with data and pushing the boundaries of what’s possible in software development.</p><p id="9c79" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Whether you’re a seasoned developer or new to the concept of encrypted computing, this article will provide you with insights into how you can integrate advanced cryptographic techniques into your programming projects. Let’s embark on this journey together and unlock the potential of coding in cipher, transforming everyday data operations into secure, privacy-preserving computations that pave the way for a new era of secure digital innovation.</p><h1 id="9e35" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">Fully Homomorphic Encryption Basics</h1><p id="9f98" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk">The two primary types of operations that can be performed on ciphertexts in FHE are addition and multiplication, though these serve as building blocks for more complex operations. For instance, you can add two encrypted values, and the result, when decrypted, will be the sum of the original plaintext values. Complex computations can be constructed using combinations of these basic operations, allowing for algorithms and functions to be executed on encrypted data. For example, we have a function F that takes two input values <em class="oy">x</em> and <em class="oy">y</em> and computes <em class="oy">x + x * y.</em> A mathematical representation of this function is written as F<em class="oy">(x, y) = x + x * y</em>, which can also be represented as a circuit, which is in other words, a direct acyclic graph:</p><figure class="pa pb pc pd pe fw fo fp paragraph-image"><div class="fo fp oz"><img src="../Images/4a95c4f70c5e9626bcc574ba4e89b68e.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*eYEgaYaghuBKRET-FwFKTQ.png"/></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">FHE Circuit, <em class="pf">x + x * y</em></figcaption></figure><h1 id="9f20" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">Noise</h1><p id="a218" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk">While FHE allows computations on encrypted data, it comes with the added challenge of noise growth within ciphertexts, which can eventually lead to decryption errors if not properly managed. In FHE schemes, every ciphertext includes some amount of noise that ensures security. This noise is small initially but grows as more operations are performed on the ciphertext. When performing an addition operation, the noise is relatively small, however, when multiplying, the noise from each of the two ciphertexts multiplies together in the product. This in turn results in a much higher noise level. Specifically, if you multiply two ciphertexts with noise levels n1 and n2, the noise in the resulting ciphertext can be approximated as n1 * n2, or a function growing much faster than either n1 or n2 alone.</p><figure class="pa pb pc pd pe fw fo fp paragraph-image"><div role="button" tabindex="0" class="fx fy ed fz bh ga"><div class="fo fp pg"><img src="../Images/edf855e202d53f71d76c62e9ad037cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIrkyOnSokmX2P6aUvADGA.png"/></div></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">noise in FHE</figcaption></figure><p id="72dc" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">There are a few ways to mange the noise in FHE schemas, but for the sake of article length, the main focus is on the noise reduction technique called <em class="oy">bootstrapping</em>. Bootstrapping reduces the noise level of a ciphertext, thus restoring the noise budget and allowing more computations. Essentially, bootstrapping applies the decryption and re-encryption algorithms homomorphically. This requires evaluating the entire decryption circuit of the FHE scheme as an encrypted function. The output is a new ciphertext that represents the same plaintext as before but with reduced noise. Bootstrapping is a critical technique in FHE that allows for essentially unlimited computations on encrypted data.</p><h1 id="4bb9" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">From Theory to Practice</h1><p id="8695" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk">To make your very first steps in exploring FHE, you may delve into the premade circuits in the open source IDE found at <a class="af ph" href="http://fhe-studio.com" rel="noopener ugc nofollow" target="_blank">fhe-studio.com</a>, which is based on the <a class="af ph" href="https://docs.zama.ai/concrete" rel="noopener ugc nofollow" target="_blank">Concrete FHE library</a>. Concrete’s FHE schema (a variation of the TFHE schema) is binary based, so each bit is individually encrypted. The implementation automatically selects bits per integer using the developer’s example. Concrete also allows for automatic noise management, greatly reducing complexity and increasing accessibility for novice users. Let’s look into a simple <a class="af ph" href="https://fhe-studio.com/fhe-editor?id=65201a737b2b7b6f13517593" rel="noopener ugc nofollow" target="_blank">circuit that adds 2 numbers</a>:</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="04a1" class="pm ny gk pj b bg pn po l pp pq">from concrete import fhe<br/><br/>#1. define the circuit<br/>def add(x, y):<br/>    return x + y<br/><br/># 2. Compile the circuit<br/>compiler = fhe.Compiler(add, {"x": "encrypted", "y": "clear"})<br/><br/># examples to determine how many bits to use for integers<br/>inputset = [(2, 3), (0, 0), (1, 6), (7, 7), (7, 1)]<br/>circuit = compiler.compile(inputset)<br/><br/># 3. testing<br/>x = 4<br/>y = 4<br/><br/># clear evaluation (not encrypted)<br/>clear_evaluation = add(x, y)<br/><br/># encrypt data, run encrypted circuit, decrypt result<br/>homomorphic_evaluation = circuit.encrypt_run_decrypt(x, y)<br/><br/>print(x, "+", y, "=", clear_evaluation, "=", homomorphic_evaluation)</span></pre><p id="a028" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The compiler then compiles the circuit into a format called MLIR, which is visible to the user after compilation is complete:</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="1c9e" class="pm ny gk pj b bg pn po l pp pq">module {<br/>  func.func @main(%arg0: !FHE.eint&lt;4&gt;, %arg1: i5) -&gt; !FHE.eint&lt;4&gt; {<br/>    %0 = "FHE.add_eint_int"(%arg0, %arg1) : (!FHE.eint&lt;4&gt;, i5) -&gt; !FHE.eint&lt;4&gt;<br/>    return %0 : !FHE.eint&lt;4&gt;<br/>  }<br/>}</span></pre><p id="3689" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Once the circuit is compiled, you can add it into your <em class="oy">FHE Vault </em>and you can share your circuit for others to perform the same encrypted computations.</p><figure class="pa pb pc pd pe fw fo fp paragraph-image"><div class="fo fp pr"><img src="../Images/fd1c2ce5ca43be324a34cc11a8fc91a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/0*rh9NJWPVlC-2g2Yh.png"/></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">Encrypted Computations in the FHE Studio Cloud Vault</figcaption></figure><h1 id="12a4" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">FHE Operations</h1><p id="ce51" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk">The FHE schema used in the IDE natively supports the following operations:</p><p id="f72a" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">1. Addition<br/>2. Multiplication<br/>3. Extract a bit (since every bit is encrypted individually)<br/>4. Table lookup</p><p id="7334" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The first three are pretty straightforward, however, the last one requires some attention. Let’s look at the example below:</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="9dc0" class="pm ny gk pj b bg pn po l pp pq">table = fhe.LookupTable([2, -1, 3, 0])<br/><br/>@fhe.compiler({"x": "encrypted"})<br/>def f(x):<br/>    return table[x]</span></pre><p id="6ff7" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">It acts as a regular table — if x=0, then f = 2 and same for the rest: f(1) = -1; f(2) = 3; f(3) = 0.</p><p id="7f7c" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Table Lookups are very flexible. All operations except addition, subtraction, multiplication with non-encrypted values, tensor manipulation operations, and a few operations built with primitive operations (e.g. matmul, conv) are converted to Table Lookups under the hood. They allow <em class="oy">Concrete </em>to support many operations, but they are expensive. The exact cost depends on many variables (hardware used, error probability, etc.), but they are always much more expensive compared to other operations. You should try to avoid them as much as possible. While it’s not always possible to avoid them completely, you should try to reduce the total number of table lookups, instead replacing some of them with other primitive operations.</p><h1 id="bba2" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">IF Operator / Branching</h1><p id="04dc" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk">The IF operator is not native to FHE, and it needs to be used in an arithmetical way. Let’s look at the following example:</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="7326" class="pm ny gk pj b bg pn po l pp pq">if a &gt; 0:<br/>    c = 4<br/> else:<br/>    c = 5</span></pre><p id="f4e4" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">In FHE, we will have to take care of all the branching because it is not possible to directly see the data, so the code becomes the sum of two expressions where one is 0 , and the other is 1:</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="e5da" class="pm ny gk pj b bg pn po l pp pq">flag = a &gt; 0 # yields 1 or 0<br/>c = 4 * flag + 5 * (1 - flag)</span></pre><p id="7406" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Recall, that <em class="oy">a &gt; 0</em> is not a native in FHE. The most simple implementation is to use a lookup table . Let’s assume that the positive variable <em class="oy">a</em> is 2 bit, then a&gt; 0 for all the (4) outcomes, except when a equals 0. We can build a table for all the outcomes of the two bits of a: {0,1,1,1} . Then the circuit will look like this:</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="603d" class="pm ny gk pj b bg pn po l pp pq">table = fhe.LookupTable([0, 1, 1, 1])<br/><br/>@fhe.compiler({"a": "encrypted"})<br/>def f(a):<br/>    flag = table[a] # a &gt; 0, for 2bit a<br/>    return 4 * flag + 5 * (1 - flag)</span></pre><p id="64e9" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">It is important to note that, if <em class="oy">a</em> becomes larger than 2 bits, the size of the corresponding lookup table grows very fast, resulting in an increase in size of the evaluating key for the circuit. In Concrete FHE implementation this approach is a default functionality for the comparison operator. For example, <a class="af ph" href="https://fhe-studio.com/fhe-editor?id=65206121ff956a2c8e3a1d65" rel="noopener ugc nofollow" target="_blank">this circuit</a>:</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="4b23" class="pm ny gk pj b bg pn po l pp pq">from concrete import fhe<br/><br/>@fhe.compiler({"x": "encrypted"})<br/>def less_then_21(x):<br/>    return x &lt; 21<br/><br/>inputset = [1, 31]<br/><br/>circuit = less_then_21.compile(inputset)<br/><br/># result in 5bit integer<br/>x = 19<br/>homomorphic_evaluation = circuit.simulate(x)<br/>print(f"homomorphic_evaluation = {homomorphic_evaluation}")</span></pre><p id="709a" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Upon compiling and inspecting the MLIR (compiled circuit), we can observe the produced lookup table.</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="f9d7" class="pm ny gk pj b bg pn po l pp pq">module {<br/>  func.func @main(%arg0: !FHE.eint&lt;5&gt;) -&gt; !FHE.eint&lt;1&gt; {<br/>    %c21_i6 = arith.constant 21 : i6<br/>    %cst = arith.constant dense&lt;[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]&gt; : tensor&lt;32xi64&gt;<br/>    %0 = "FHE.apply_lookup_table"(%arg0, %cst) : (!FHE.eint&lt;5&gt;, tensor&lt;32xi64&gt;) -&gt; !FHE.eint&lt;1&gt;<br/>    return %0 : !FHE.eint&lt;1&gt;<br/>  }<br/>}</span></pre><h1 id="f87a" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">Comparing two number using carry</h1><p id="4139" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk">The method of comparing two binary numbers by using subtraction to determine which one is greater can be efficiently done in FHE using simple arithmetic. Binary comparison by subtraction leverages the properties of binary arithmetic. The core idea is that subtracting one number from another reveals information about their relative sizes based on the result and certain flags (like the carry flag in processors) set during the operation.</p><p id="343e" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">In binary subtraction, if A is greater than or equal to B, the result is non-negative. If B is greater, the result is negative, causing the carry flag to be 1.</p><figure class="pa pb pc pd pe fw fo fp paragraph-image"><div class="fo fp ps"><img src="../Images/32f46ed6b9d04989213d6841f3de3bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*XrDb59cF89-v1X7Ybg7_JQ.png"/></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">if A&gt;B then the carry flag is set to be 1</figcaption></figure><p id="1105" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">This is means, if A&gt;B, then carry=1, and 0 otherwise. We have to compute the carry bit form right to left and the last carry is the final result. To speed up FHE calculation we could compute 1+ A - B for each bit to make it positive. This example needs only 2 bits to hold the residual. Then we left shift (&lt;&lt;) the carry bit by 2 positions and add the residual. The total number of all outcomes will be 8, which we can use together with the lookup table to output the next carry bit, <a class="af ph" href="https://fhe-studio.com/fhe-editor?id=65ade87ae3b6f89b1e412fef" rel="noopener ugc nofollow" target="_blank">like in this circuit</a>.</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="c523" class="pm ny gk pj b bg pn po l pp pq"># two numbers are need to presented as  bit arrays<br/># ---------------------------<br/># 0 0000 -&gt; 1 less (1+0-1), set the curry bit<br/># 1 0001 -&gt; 0, equal (1+1-1) or (1+0-0)<br/># 2 0010 -&gt; 0, greater (1+1-0)<br/># 3 0100 -&gt; 0 (does not exists)<br/># carry bit set<br/># 5 1000 -&gt; 1<br/># 6 1100 -&gt; 1<br/># 7 1010 -&gt; 1<br/># 8 1010 -&gt; 1<br/><br/>from concrete import fhe<br/><br/>table = fhe.LookupTable([1,0,0,0,1,1,1,1])<br/><br/># result is 1 if less, 0 otherwise<br/>@fhe.compiler({"x": "encrypted", "y": "encrypted"})<br/>def fast_comparision(x, y):<br/>    carry = 0<br/><br/>    # for all the bits<br/>    for i in range(4):<br/>        s = 1 + x[i] - y[i]<br/>        # left shift by 2 (carry &lt;&lt; 4)<br/>        carry4 = carry*4 + s<br/>        carry = table[carry4]<br/><br/>    return curry<br/><br/>inputset = [([0,1, 1, 1], [1,0, 1,1])]<br/><br/>circuit = fast_comparision.compile(inputset)<br/><br/>homomorphic_evaluation = circuit.simulate([1,0,1, 0], [1,0,0,0])<br/>print("homomorphic_evaluation =", homomorphic_evaluation)</span></pre><p id="dbb6" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">This method is far more computationally expensive than just using a lookup table, like in the example before this one. However, the memory complexity is far less here, because the lookup table holds only 8 values, resulting in smaller evaluation keys. And yes, as usual, nothing is perfect, as there is a trade off between memory usage vs CPU usage and key sizes, depending on the method you select.</p><h1 id="2baa" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">Sorting</h1><p id="1592" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk"><a class="af ph" href="https://fhe-studio.com/fhe-editor?id=6639782cf9ed036703c04500" rel="noopener ugc nofollow" target="_blank">Let’s look at the Bubble Sort</a>, which is a simple comparison-based sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items, and swaps them if they are in the wrong order. The algorithm gets its name because smaller elements “bubble” to the top of the list (beginning of the array), while larger elements sink to the bottom (end of the array) with each iteration.</p><pre class="pa pb pc pd pe pi pj pk bp pl bb bk"><span id="f0ed" class="pm ny gk pj b bg pn po l pp pq">from concrete import fhe<br/>import numpy as np<br/><br/>@fhe.compiler({"in_array": "encrypted"})<br/>def bubble_sort(in_array):<br/>    for i in range(len(in_array)):<br/>        for j in range(len(in_array)-1):        <br/>            a = in_array[j]<br/>            b = in_array[j+1]<br/>            flag = a &gt; b<br/>            # if a &gt; b then swap the values<br/>            in_array[j] = flag * b + (1-flag) * a<br/>            in_array[j+1] = flag * a + (1-flag) * b<br/><br/>    return in_array<br/><br/>inputset = [[3,0,0,0]]<br/>circuit = bubble_sort.compile(inputset)<br/><br/>test = [3,2,0,1]<br/>test_clear = test.copy()<br/>test_fhe = test.copy()<br/><br/>clear_evaluation = bubble_sort(test_clear)<br/><br/>#homomorphic_evaluation = circuit.encrypt_run_decrypt(test_fhe)<br/>homomorphic_evaluation = circuit.simulate(test_fhe)<br/><br/>print(test, "=&gt; ", clear_evaluation, "=&gt;", homomorphic_evaluation)</span></pre><p id="3c19" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Bubble sort is quite slow [O(n²)] but very memory efficient [O(1)]. For a more CPU efficient algorithm, you can use <strong class="nd gl"><em class="oy">Merge Sort</em></strong>. It works on the principle of breaking down a list into smaller, more manageable parts (ideally down to individual elements), sorting those parts, and then merging them back together in the correct order.</p><figure class="pa pb pc pd pe fw fo fp paragraph-image"><div class="fo fp pt"><img src="../Images/3881292edb00fdc7ad4c8748d8a6f593.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*b9fzGTYIbswl2zoNRtpY6Q.png"/></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">merge sort</figcaption></figure><p id="8d1e" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The merge sort has a complexity of O(n log n) , making it one of the most efficient sorting algorithms for large datasets. However, the space complexity is O(n), as it requires additional space proportional to the array size for the temporary merging process.</p><h1 id="23c2" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">Dynamic programming</h1><p id="9b29" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk">Dynamic programming is a method for solving complex problems by breaking them down into simpler subproblems and solving each of these subproblems just once, storing their solutions. The idea is that if you can solve the smaller subproblems efficiently, you can then use these solutions to tackle the larger problem. Let’s take a Fibonacci numbers as an example.</p><p id="176f" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence typically goes 0, 1, 1, 2, 3, 5, 8, 13, and so forth. When solving for the nth Fibonacci number using dynamic programming, the approach can be significantly more efficient than the naive recursive approach by avoiding redundant calculations.</p><figure class="pa pb pc pd pe fw fo fp paragraph-image"><div class="fo fp pu"><img src="../Images/da1b690ff57dd9ba2b004b00626a3a28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*H9LupCP4aAxgBQpN970qLw.png"/></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">Fibonacci sequence: F[i] = F[i-1] + F[i-2]</figcaption></figure><p id="952d" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">As you can see, to solve for F(6), we need to resolve two subproblems recursively: F(5) and F(4) and so forth. You can note the solutions are overlapping, so the calculation of F(4) happens both on the left and on the right size of the tree. Obviously, we should cache each unique result and thus compute it only once. Then our tree becomes very simple. This approach is called memoization.</p><figure class="pa pb pc pd pe fw fo fp paragraph-image"><div class="fo fp pv"><img src="../Images/2460bd26251e8d69a0639c2c4a5cb982.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*0azPYqgwY--uAACiQPiwOg.png"/></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx">Fibonacci sequence with memoization</figcaption></figure><p id="8f8e" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">However, in the context of Fully Homomorphic Encryption (FHE), memoization cannot typically be used due to the fundamental characteristics and security constraints of FHE. The reason for this is that FHE allows operations to be performed on encrypted data, meaning the actual data values remain concealed throughout the computation.</p><p id="b514" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The other approach for dynamic programming is called <em class="oy">tabulation</em>. Tabulation is a bottom-up approach where you solve smaller subproblems first and use their solutions to build solutions to bigger problems. This method is particularly effective for FHE due to its non recursive nature. Tabulation uses a table where on each step, you update the current value. In this example we initialize a table of 6 elements with the base conditions requiring the first element to be 0 and the second element to be 1. The rest of the elements are then initialized to zero: [0,1,0,0,0,0]. Then, we progress from left to right.</p><figure class="pa pb pc pd pe fw fo fp paragraph-image"><div role="button" tabindex="0" class="fx fy ed fz bh ga"><div class="fo fp pw"><img src="../Images/22a2fccb9b65f403fe607d9d2303a14f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P4VooCD1bXM5FSL0.jpeg"/></div></div><figcaption class="gd ge gf fo fp gg gh bf b bg z dx"><em class="pf">tabulation, bottom up approach</em></figcaption></figure><p id="c61a" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk"><em class="oy">This article marks the beginning of a series on Encrypted Data Structures and Algorithms. Up next, I’ll delve into the use of Graphs and Trees, Machine Learning and AI within the realm of Fully Homomorphic Encryption (FHE). Subsequent installments will explore practical applications within financial industry.</em></p><p id="0fac" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">—</p><h1 id="2b61" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">Ready to Transform Your Coding with Encryption?</h1><p id="a0b1" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk">Dive deeper into the world of encrypted data structures and algorithms with the open source IDE at <a class="af ph" href="http://FHE-Studio.com" rel="noopener ugc nofollow" target="_blank">FHE-Studio.com</a>. Whether you’re looking to enhance your projects with top-tier security protocols or simply curious about the next generation of data privacy in software development, FHE Studio is a free and open source gateway to the FHE world. Develop, test and share your circuits, and get feedback from peers!</p><p id="0380" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Looking for specialized expertise? Our team at FHE Studio can help you integrate fully homomorphic encryption into your existing projects or develop new encrypted solutions tailored to your needs.</p><h1 id="d745" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">Support us</h1><p id="0e6f" class="pw-post-body-paragraph nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw fj bk">If you’ve found value in our project, <a class="af ph" href="https://github.com/sponsors/artifirm" rel="noopener ugc nofollow" target="_blank">consider supporting us</a>. We’re committed to keeping FHE-Studio open and accessible, and every contribution helps us expand the project.</p><h1 id="1c9f" class="nx ny gk bf nz oa ob hk oc od oe hn of og oh oi oj ok ol om on oo op oq or os bk">References</h1><ol class=""><li id="7f76" class="nb nc gk nd b hi ot nf ng hl ou ni nj nk ov nm nn no ow nq nr ns ox nu nv nw px py pz bk"><a class="af ph" href="https://fhe-studio.com/" rel="noopener ugc nofollow" target="_blank">FHE-STUDIO.COM</a>, an open source FHE IDE<br/>2. FHE Studio docs and sources, <a class="af ph" href="https://github.com/artifirm/fhe-studio-docs" rel="noopener ugc nofollow" target="_blank">https://github.com/artifirm</a><br/>3. Concrete FHE compiler: <a class="af ph" href="https://docs.zama.ai/concrete" rel="noopener ugc nofollow" target="_blank">https://docs.zama.ai/concrete</a><br/>4. Concrete ML is an open-source, privacy-preserving, machine learning framework based on Fully Homomorphic Encryption (FHE). <a class="af ph" href="https://docs.zama.ai/concrete-ml" rel="noopener ugc nofollow" target="_blank">https://docs.zama.ai/concrete-ml</a><br/>5. Microsoft SEAL, an open source FHE library <a class="af ph" href="https://www.microsoft.com/en-us/research/project/microsoft-seal/" rel="noopener ugc nofollow" target="_blank">https://www.microsoft.com/en-us/research/project/microsoft-seal/</a><br/>6. HELib, a FHE library <a class="af ph" href="https://github.com/homenc/HElib" rel="noopener ugc nofollow" target="_blank">https://github.com/homenc/HElib</a></li></ol><p id="1ca5" class="pw-post-body-paragraph nb nc gk nd b hi ne nf ng hl nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Unless otherwise noted, all images are by the author.</p></div></div></div></div>    
</body>
</html>
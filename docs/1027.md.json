["```py\nproject-root/\n│\n├── database/\n│ ├── db.py # Database connection and setup\n│ ├── models.py # Database models/schemas\n| └── utils.py # Database utilities\n│\n├── tools/\n│ ├── base.py # Base class for tools\n│ ├── add.py # Tool for adding data to the database\n│ ├── query.py # Tool for querying data from the database\n| └── utils.py # Tool utilities\n│\n├── agents/\n│ ├── base.py # Main AI agent logic\n│ ├── routing.py # Specialized agent for routing tasks\n│ ├── task.py # Tool wrapper for OpenAI subagents\n| └── utils.py # agent utilities\n│\n└── utils.py # Utility functions and classes\n```", "```py\n# database\\models.py\nfrom typing import Optional  \n\nfrom pydantic import BeforeValidator, model_validator  \nfrom sqlmodel import SQLModel, Field  \nfrom datetime import time, datetime  \nfrom typing_extensions import Annotated \n\ndef validate_date(v):  \n    if isinstance(v, datetime):  \n        return v  \n\n    for f in [\"%Y-%m-%d\", \"%Y-%m-%d %H:%M:%S\"]:  \n        try:  \n            return datetime.strptime(v, f)  \n        except ValueError:  \n            pass  \n\n    raise ValueError(\"Invalid date format\")  \n\ndef numeric_validator(v):  \n    if isinstance(v, int):  \n        return float(v)  \n    elif isinstance(v, float):  \n        return v  \n    raise ValueError(\"Value must be a number\")  \n\nDateFormat = Annotated[datetime, BeforeValidator(validate_date)]  \nNumeric = Annotated[float, BeforeValidator(numeric_validator)]\n\nclass Customer(SQLModel, table=True):  \n    id: Optional[int] = Field(primary_key=True, default=None)\n    company: str\n    first_name: str  \n    last_name: str  \n    phone: str  \n    address: str  \n    city: str  \n    zip: str  \n    country: str  \n\nclass Revenue(SQLModel, table=True):  \n    id: Optional[int] = Field(primary_key=True, default=None)  \n    description: str  \n    net_amount: Numeric  \n    gross_amount: Numeric  \n    tax_rate: Numeric  \n    date: DateFormat  \n\nclass Expense(SQLModel, table=True):  \n    id: Optional[int] = Field(primary_key=True, default=None)  \n    description: str  \n    net_amount: Numeric = Field(description=\"The net amount of the expense\")  \n    gross_amount: Numeric  \n    tax_rate: Numeric  \n    date: DateFormat\n```", "```py\n# database/db.py\nfrom database.models import *  \nfrom sqlmodel import SQLModel, create_engine  \nimport os  \n\n# local stored database  \nDATABASE_URL = \"sqlite:///app.db\"  \n\nengine = create_engine(DATABASE_URL, echo=True) \n\ndef create_db_and_tables():  \n    SQLModel.metadata.create_all(engine)  \n\ncreate_db_and_tables()\n```", "```py\n# tools/base.py\nfrom typing import Type, Callable, Union\n\nfrom tools.convert import convert_to_openai_tool\nfrom pydantic import BaseModel, ConfigDict\nfrom sqlmodel import SQLModel\n\nclass ToolResult(BaseModel):\n    content: str\n    success: bool\n\nclass Tool(BaseModel):\n    name: str\n    model: Union[Type[BaseModel], Type[SQLModel], None]\n    function: Callable\n    validate_missing: bool = True\n    parse_model: bool = False\n    exclude_keys: list[str] = [\"id\"]\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def run(self, **kwargs) -> ToolResult:\n        if self.validate_missing and model is not None:\n            missing_values = self.validate_input(**kwargs)\n            if missing_values:\n                content = f\"Missing values: {', '.join(missing_values)}\"\n                return ToolResult(content=content, success=False)\n\n        if self.parse_model:\n            if hasattr(self.model, \"model_validate\"):\n                input_ = self.model.model_validate(kwargs)\n            else:\n                input_ = self.model(**kwargs)\n            result = self.function(input_)\n\n        else:\n            result = self.function(**kwargs)\n        return ToolResult(content=str(result), success=True)\n\n    def validate_input(self, **kwargs):\n        if not self.validate_missing or not self.model:\n            return []\n        model_keys = set(self.model.__annotations__.keys()) - set(self.exclude_keys)\n        input_keys = set(kwargs.keys())\n        missing_values = model_keys - input_keys\n        return list(missing_values)\n\n    @property\n    def openai_tool_schema(self):\n        schema = convert_to_openai_tool(self.model)\n        # set function name\n        schema[\"function\"][\"name\"] = self.name\n\n        # remove required field\n        if schema[\"function\"][\"parameters\"].get(\"required\"):\n            del schema[\"function\"][\"parameters\"][\"required\"]\n        # remove exclude keys\n        if self.exclude_keys:\n            for key in self.exclude_keys:\n                if key in schema[\"function\"][\"parameters\"][\"properties\"]:\n                    del schema[\"function\"][\"parameters\"][\"properties\"][key]\n        return schema\n```", "```py\n# tools/convert.py\nfrom langchain_core.utils.function_calling import _rm_titles\nfrom typing import Type, Optional\nfrom langchain_core.utils.json_schema import dereference_refs\nfrom pydantic import BaseModel\n\ndef convert_to_openai_tool(\n        model: Type[BaseModel],\n        *,\n        name: Optional[str] = None,\n        description: Optional[str] = None,\n) -> dict:\n    \"\"\"Converts a Pydantic model to a function description for the OpenAI API.\"\"\"\n    function = convert_pydantic_to_openai_function(\n        model, name=name, description=description\n    )\n    return {\"type\": \"function\", \"function\": function}\n\ndef convert_pydantic_to_openai_function(\n        model: Type[BaseModel],\n        *,\n        name: Optional[str] = None,\n        description: Optional[str] = None,\n        rm_titles: bool = True,\n) -> dict:\n    \"\"\"Converts a Pydantic model to a function description for the OpenAI API.\"\"\"\n\n    model_schema = model.model_json_schema() if hasattr(model, \"model_json_schema\") else model.schema()\n\n    schema = dereference_refs(model_schema)\n    schema.pop(\"definitions\", None)\n    title = schema.pop(\"title\", \"\")\n    default_description = schema.pop(\"description\", \"\")\n    return {\n        \"name\": name or title,\n        \"description\": description or default_description,\n        \"parameters\": _rm_titles(schema) if rm_titles else schema,\n    }\n```", "```py\n# tools/base.py\nfrom typing import Type, Callable, Union\n\nfrom tools.convert import convert_to_openai_tool\nfrom pydantic import BaseModel\nfrom sqlmodel import SQLModel\n#...rest of the code ...\n```", "```py\n# tools/add.py\nfrom sqlmodel import SQLModel, Session, select\n\ndef add_row_to_table(model_instance: SQLModel):  \n    with Session(engine) as session:  \n        session.add(model_instance)  \n        session.commit()  \n        session.refresh(model_instance)  \n    return f\"Successfully added {model_instance} to the table\"\n```", "```py\n# tools/add.py\n# ...\ndef add_expense_to_table(**kwargs):\n    model_instance = Expense.model_validate(kwargs)\n    return add_row_to_table(model_instance)\n```", "```py\n# example usage\n\ndef add_entry_to_table(sql_model: Type[SQLModel]):  \n    # return a Callable that takes a SQLModel instance and adds it to the table  \n    return lambda **data: add_row_to_table(model_instance=sql_model.model_validate(data))\n\nadd_expense_to_table = add_entry_to_table(Expense)\n```", "```py\nadd_expense_tool = Tool(\n name=\"add_expense_tool\",\n description=\"useful for adding expenses to database\",\n function=add_entry_to_table(Expense),\n model=Expense,\n validate_missing=True\n)\n\nadd_revenue_tool = Tool(\n name=\"add_revenue_tool\",\n description=\"useful for adding revenue to database\",\n function=add_entry_to_table(Revenue),\n model=Revenue,\n validate_missing=True\n)\n```", "```py\nresult = database.execute(\n  select(Expense).where(Expense.description == \"Coffee\")\n)\n```", "```py\n# tools/query.py\nfrom typing import Union, Literal\nfrom pydantic import BaseModel\n\nclass WhereStatement(BaseModel):  \n    column: str  \n    operator: Literal[\"eq\", \"gt\", \"lt\", \"gte\", \"lte\", \"ne\", \"ct\"]  \n    value: str  \n\nclass QueryConfig(BaseModel):  \n    table_name: str  \n    columns: list[str]  \n    where: list[Union[WhereStatement, None]]\n```", "```py\n# tools/query.py\n# ...\nfrom database.models import Expense, Revenue, Customer\n\nTABLES = {\n    \"expense\": Expense,\n    \"revenue\": Revenue,\n    \"customer\": Customer\n}\n\ndef query_data_function(**kwargs) -> ToolResult:  \n    \"\"\"Query the database via natural language.\"\"\"\n    query_config = QueryConfig.model_validate(kwargs)\n\n    if query_config.table_name not in TABLES:  \n        return ToolResult(content=f\"Table name {query_config.table_name} not found in database models\", success=False)  \n\n    sql_model = TABLES[query_config.table_name]  \n\n    # query_config = validate_query_config(query_config, sql_model)  \n    data = sql_query_from_config(query_config, sql_model)  \n\n    return ToolResult(content=f\"Query results: {data}\", success=True)  \n\ndef sql_query_from_config(  \n        query_config: QueryConfig,  \n        sql_model: Type[SQLModel]):  \n\n    with Session(engine) as session:  \n        selection = []  \n        for column in query_config.select_columns:  \n            if column not in sql_model.__annotations__:  \n                return f\"Column {column} not found in model {sql_model.__name__}\"  \n            selection.append(getattr(sql_model, column))  \n\n        statement = select(*selection)  \n        wheres = query_config.where  \n        if wheres:  \n            for where in wheres:  \n\n                if where.column not in sql_model.__annotations__:  # noqa  \n                    return (f\"Column {where['column']} not found \"\n                       \"in model {sql_model.__name__}\")\n\n                elif where.operator == \"eq\":  \n                    statement = statement.where(\n                     getattr(sql_model, where.column) == where.value)  \n                elif where.operator == \"gt\":  \n                    statement = statement.where(\n                     getattr(sql_model, where.column) > where.value)  \n                elif where.operator == \"lt\":  \n                    statement = statement.where(\n                     getattr(sql_model, where.column) < where.value)  \n                elif where.operator == \"gte\":  \n                    statement = statement.where(\n                     getattr(sql_model, where.column) >= where.value)  \n                elif where.operator == \"lte\":  \n                    statement = statement.where(\n                     getattr(sql_model, where.column) <= where.value)  \n                elif where.operator == \"ne\":  \n                    statement = statement.where(\n                     getattr(sql_model, where.column) != where.value)  \n                elif where.operator == \"ct\":  \n                    statement = statement.where(\n                     getattr(sql_model, where.column).contains(where.value))  \n\n        result = session.exec(statement)  \n        data = result.all()  \n        try:  \n            data = [repr(d) for d in data]  \n        except:  \n            pass  \n    return data\n```", "```py\nquery_data_tool = Tool(  \n    name=\"query_data_tool\",  \n    description = \"useful to perform queries on a database table\",\n    model=QueryConfig,  \n    function=query_data_function, \n)\n```", "```py\nimport colorama  \nfrom colorama import Fore  \nfrom openai import OpenAI  \nfrom pydantic import BaseModel  \nfrom tools.base import Tool, ToolResult  \nfrom agents.utils import parse_function_args, run_tool_from_response  \n\nclass StepResult(BaseModel):  \n    event: str  \n    content: str  \n    success: bool  \n\nSYSTEM_MESSAGE = \"\"\"You are tasked with completing specific objectives and must report the outcomes. At your disposal, you have a variety of tools, each specialized in performing a distinct type of task.  \n\nFor successful task completion:  \nThought: Consider the task at hand and determine which tool is best suited based on its capabilities and the nature of the work. If you can complete the task or answer a question, soley by the information provided you can use the report_tool directly.  \n\nUse the report_tool with an instruction detailing the results of your work or to answer a user question.  \nIf you encounter an issue and cannot complete the task:  \n\nUse the report_tool to communicate the challenge or reason for the task's incompletion.  \nYou will receive feedback based on the outcomes of each tool's task execution or explanations for any tasks that couldn't be completed. This feedback loop is crucial for addressing and resolving any issues by strategically deploying the available tools.  \n\nReturn only one tool call at a time.  \n\n{context}  \n\"\"\"\n\nclass OpenAIAgent:  \n\n    def __init__(  \n            self,  \n            tools: list[Tool],  \n            client: OpenAI = OpenAI(),  \n            system_message: str = SYSTEM_MESSAGE,  \n            model_name: str = \"gpt-3.5-turbo-0125\",  \n            max_steps: int = 5,  \n            verbose: bool = True,  \n            examples: list[dict] = None,  \n            context: str = None,  \n            user_context: str = None  \n    ):  \n        self.tools = tools  \n        self.client = client  \n        self.model_name = model_name  \n        self.system_message = system_message  \n        self.step_history = []  \n        self.max_steps = max_steps  \n        self.verbose = verbose  \n        self.examples = examples or []  \n        self.context = context or \"\"  \n        self.user_context = user_context  \n\n    def to_console(self, tag: str, message: str, color: str = \"green\"):  \n        if self.verbose:  \n            color_prefix = Fore.__dict__[color.upper()]  \n            print(color_prefix + f\"{tag}: {message}{colorama.Style.RESET_ALL}\")  \n\n    def run(self, user_input: str, context: str = None):  \n\n        openai_tools = [tool.openai_tool_schema for tool in self.tools]  \n        system_message = self.system_message.format(context=context)  \n\n        if self.user_context:  \n            context = f\"{self.user_context}\\n{context}\" if context else self.user_context  \n\n        if context:  \n            user_input = f\"{context}\\n---\\n\\nUser Message: {user_input}\"  \n\n        self.to_console(\"START\", f\"Starting Agent with Input:\\n'''{user_input}'''\")  \n\n        self.step_history = [  \n            {\"role\": \"system\", \"content\": system_message},  \n            *self.examples,  \n            {\"role\": \"user\", \"content\": user_input}  \n        ]  \n\n        step_result = None  \n        i = 0  \n\n        while i < self.max_steps:  \n            step_result = self.run_step(self.step_history, openai_tools)  \n            if step_result.event == \"finish\":  \n                break  \n            elif step_result.event == \"error\":  \n                self.to_console(step_result.event, step_result.content, \"red\")  \n            else:  \n                self.to_console(step_result.event, step_result.content, \"yellow\")  \n\n            i += 1  \n\n        self.to_console(\"Final Result\", step_result.content, \"green\")  \n\n        return step_result.content  \n\n    def run_step(self, messages: list[dict], tools):  \n\n        # plan the next step  \n        response = self.client.chat.completions.create(  \n            model=self.model_name,  \n            messages=messages,  \n            tools=tools  \n        )  \n        # check for multiple tool calls  \n        if response.choices[0].message.tool_calls and len(response.choices[0].message.tool_calls) > 1:  \n            messages = [  \n                *self.step_history,  \n                {\"role\": \"user\", \"content\": \"Error: Please return only one tool call at a time.\"}  \n            ]  \n            return self.run_step(messages, tools)  \n\n        # add message to history  \n        self.step_history.append(response.choices[0].message)  \n        # check if tool call is present  \n        if not response.choices[0].message.tool_calls:  \n            msg = response.choices[0].message.content  \n            step_result = StepResult(event=\"Error\", content=f\"No tool calls were returned.\\nMessage: {msg}\", success=False)  \n            return step_result  \n\n        tool_name = response.choices[0].message.tool_calls[0].function.name  \n        tool_kwargs = parse_function_args(response)  \n\n        # execute the tool call  \n        self.to_console(\"Tool Call\", f\"Name: {tool_name}\\nArgs: {tool_kwargs}\", \"magenta\")  \n        tool_result = run_tool_from_response(response, tools=self.tools)  \n        tool_result_msg = self.tool_call_message(response, tool_result)  \n        self.step_history.append(tool_result_msg)  \n\n        if tool_name == \"report_tool\":  \n            try:  \n                step_result = StepResult(  \n                    event=\"finish\",  \n                    content=tool_result.content,  \n                    success=True  \n                )  \n            except:  \n                print(tool_result)  \n                raise ValueError(\"Report Tool failed to run.\")  \n\n            return step_result  \n\n        elif tool_result.success:  \n            step_result = StepResult(  \n                event=\"tool_result\",  \n                content=tool_result.content,  \n                success=True)  \n        else:  \n            step_result = StepResult(  \n                event=\"error\",  \n                content=tool_result.content,  \n                success=False  \n            )  \n\n        return step_result  \n\n    def tool_call_message(self, response, tool_result: ToolResult):  \n        tool_call = response.choices[0].message.tool_calls[0]  \n        return {  \n            \"tool_call_id\": tool_call.id,  \n            \"role\": \"tool\",  \n            \"name\": tool_call.function.name,  \n            \"content\": tool_result.content,  \n        }\n```", "```py\n# utils.py\nfrom typing import Type  \nimport types  \nimport typing  \n\nimport sqlalchemy  \nfrom pydantic import BaseModel\n\ndef orm_model_to_string(input_model_cls: Type[BaseModel]):  \n    \"\"\"Get the ORM model string from the input model\"\"\"  \n\n    def process_field(key, value):  \n        if key.startswith(\"__\"):  \n            return None  \n        if isinstance(value, typing._GenericAlias):  \n            if value.__origin__ == sqlalchemy.orm.base.Mapped:  \n                return None  \n            if isinstance(value, typing._AnnotatedAlias):  # noqa  \n                return key, value.__origin__  \n            elif isinstance(value, typing._UnionGenericAlias) or isinstance(value, types.UnionType):  \n                return key, value.__args__[0]  \n        return key, value  \n\n    fields = dict(filter(None, (process_field(k, v) for k, v in input_model_cls.__annotations__.items())))  \n    return \", \".join([f\"{k} = <{v.__name__}>\" for k, v in fields.items()])\n\ndef generate_context(*table_models) -> str:\n   context_str = \"You can access the following tables in database:\\n\"\n   for table in table_models:\n    context_str += f\" - {table.__name__}: {orm_model_to_string(table)}\\n\" \n   return context_str\n```", "```py\n# utils.py\nfrom datetime import datetime\n\n#... rest of utils.py ...\n\ndef weekday_by_date(date: datetime):\n    days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    return days[date.weekday()]\n\ndef date_to_string(date: datetime):\n    return f\"{weekday_by_date(date)} {parse_date(date)}\"\n\ndef parse_date(date: datetime):\n    return date.strftime(\"%Y-%m-%d\")\n```", "```py\n# utils.py\n\n# ...\n\ndef generate_query_context(*table_models) -> str:\n    today = f\"Today is {date_to_string(datetime.now())}\"\n    context_str = \"You can access the following tables in database:\\n\"\n    for table in table_models:\n        context_str += f\" - {table.__name__}: {orm_model_to_string(table)}\\n\" \n    return f\"{today}\\n{context_str}\"\n```", "```py\nfrom database.models import Expense, Revenue\nprint(generate_query_context(Expense, Revenue))\n```", "```py\nToday is Sunday 2024-04-21\nYou can access the following tables in database:\n - Expense: id = <int>, description = <str>, net_amount = <float>, gross_amount = <float>, tax_rate = <float>, date = <datetime>\n - Revenue: id = <int>, description = <str>, net_amount = <float>, gross_amount = <float>, tax_rate = <float>, date = <datetime>\n```", "```py\n# agents/routing.py\nfrom openai import OpenAI\nimport colorama\nfrom agents.task_agent import TaskAgent\nfrom agents.utils import parse_function_args\n\nSYSTEM_MESSAGE = \"\"\"You are a helpful assistant.\nRole: You are an AI Assistant designed to serve as the primary point of contact for users interacting through a chat interface. \nYour primary role is to understand users' requests related to database operations and route these requests to the appropriate tool.\n\nCapabilities: \nYou have access to a variety of tools designed for Create, Read operations on a set of predefined tables in a database. \n\nTables:\n{table_names}\n\"\"\"\n\nNOTES = \"\"\"Important Notes:\nAlways confirm the completion of the requested operation with the user.\nMaintain user privacy and data security throughout the interaction.\nIf a request is ambiguous or lacks specific details, ask follow-up questions to clarify the user's needs.\"\"\"\n\nclass RoutingAgent:\n\n    def __init__(\n            self,\n            tools: list[TaskAgent] = None,\n            client: OpenAI = OpenAI(),\n            system_message: str = SYSTEM_MESSAGE,\n            model_name: str = \"gpt-3.5-turbo-0125\",\n            max_steps: int = 5,\n            verbose: bool = True,\n            prompt_extra: dict = None,\n            examples: list[dict] = None,\n            context: str = None\n    ):\n        self.tools = tools or ROUTING_AGENTS\n        self.client = client\n        self.model_name = model_name\n        self.system_message = system_message\n        self.memory = []\n        self.step_history = []\n        self.max_steps = max_steps\n        self.verbose = verbose\n        self.prompt_extra = prompt_extra or PROMPT_EXTRA\n        self.examples = self.load_examples(examples)\n        self.context = context or \"\"\n\n    def load_examples(self, examples: list[dict] = None):\n        examples = examples or []\n        for agent in self.tools:\n            examples.extend(agent.routing_example)\n        return examples\n\n    def run(self, user_input: str, employee_id: int = None, **kwargs):\n        context = create_routing_agent_context(employee_id)\n        if context:\n            user_input_with_context = f\"{context}\\n---\\n\\nUser Message: {user_input}\"\n        else:\n            user_input_with_context = user_input\n\n        self.to_console(\"START\", f\"Starting Task Agent with Input:\\n'''{user_input_with_context}'''\")\n        partial_variables = {**self.prompt_extra, \"context\": context}\n        system_message = self.system_message.format(**partial_variables)\n\n        messages = [\n            {\"role\": \"system\", \"content\": system_message},\n            *self.examples,\n            {\"role\": \"user\", \"content\": user_input}\n        ]\n\n        tools = [tool.openai_tool_schema for tool in self.tools]\n\n        response = self.client.chat.completions.create(\n            model=self.model_name,\n            messages=messages,\n            tools=tools\n        )\n        self.step_history.append(response.choices[0].message)\n        self.to_console(\"RESPONSE\", response.choices[0].message.content, color=\"blue\")\n        tool_kwargs = parse_function_args(response)\n        tool_name = response.choices[0].message.tool_calls[0].function.name\n        self.to_console(\"Tool Name\", tool_name)\n        self.to_console(\"Tool Args\", tool_kwargs)\n\n        agent = self.prepare_agent(tool_name, tool_kwargs)\n        return agent.run(user_input)\n\n    def prepare_agent(self, tool_name, tool_kwargs):\n        for agent in self.tools:\n            if agent.name == tool_name:\n                input_kwargs = agent.arg_model.model_validate(tool_kwargs)\n                return agent.load_agent(**input_kwargs.dict())\n        raise ValueError(f\"Agent {tool_name} not found\")\n\n    def to_console(self, tag: str, message: str, color: str = \"green\"):\n        if self.verbose:\n            color_prefix = colorama.Fore.__dict__[color.upper()]\n            print(color_prefix + f\"{tag}: {message}{colorama.Style.RESET_ALL}\")\n```", "```py\nfrom typing import Type, Callable, Optional\n\nfrom agents.base import OpenAIAgent\nfrom tools.base import Tool\nfrom tools.report_tool import report_tool\nfrom pydantic import BaseModel, ConfigDict, Field\n\nfrom tools.utils import convert_to_openai_tool\n\nSYSTEM_MESSAGE = \"\"\"You are tasked with completing specific objectives and must report the outcomes. At your disposal, you have a variety of tools, each specialized in performing a distinct type of task.\n\nFor successful task completion:\nThought: Consider the task at hand and determine which tool is best suited based on its capabilities and the nature of the work. \nIf you can complete the task or answer a question, soley by the information provided you can use the report_tool directly.\n\nUse the report_tool with an instruction detailing the results of your work or to answer a user question.\nIf you encounter an issue and cannot complete the task:\n\nUse the report_tool to communicate the challenge or reason for the task's incompletion.\nYou will receive feedback based on the outcomes of each tool's task execution or explanations for any tasks that couldn't be completed. This feedback loop is crucial for addressing and resolving any issues by strategically deploying the available tools.\n\nOn error: If information are missing consider if you can deduce or calculate the missing information and repeat the tool call with more arguments.\n\nUse the information provided by the user to deduct the correct tool arguments.\nBefore using a tool think about the arguments and explain each input argument used in the tool. \nReturn only one tool call at a time! Explain your thoughts!\n{context}\n\"\"\"\n\nclass EmptyArgModel(BaseModel):\n    pass\n\nclass TaskAgent(BaseModel):\n    name: str\n    description: str\n    arg_model: Type[BaseModel] = EmptyArgModel\n\n    create_context: Callable = None\n    create_user_context: Callable = None\n    tool_loader: Callable = None\n\n    system_message: str = SYSTEM_MESSAGE\n    tools: list[Tool]\n    examples: list[dict] = None\n    routing_example: list[dict] = Field(default_factory=list)\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    def load_agent(self, **kwargs) -> OpenAIAgent:\n\n        input_kwargs = self.arg_model(**kwargs)\n        kwargs = input_kwargs.dict()\n\n        context = self.create_context(**kwargs) if self.create_context else None\n        user_context = self.create_user_context(**kwargs) if self.create_user_context else None\n\n        if self.tool_loader:\n            self.tools.extend(self.tool_loader(**kwargs))\n\n        if report_tool not in self.tools:\n            self.tools.append(report_tool)\n\n        return OpenAIAgent(\n            tools=self.tools,\n            context=context,\n            user_context=user_context,\n            system_message=self.system_message,\n            examples=self.examples,\n        )\n\n    @property\n    def openai_tool_schema(self):\n        return convert_to_openai_tool(self.arg_model, name=self.name, description=self.description)\n```", "```py\nfrom database.models import Expense, Revenue, Customer\nfrom agents.task import TaskAgent\nfrom utils import generate_query_context\n\nfrom tools.base import Tool\nfrom tools.query import query_data_tool\nfrom tools.add import add_entry_to_table\n\nquery_task_agent = TaskAgent(\n    name=\"query_agent\",\n    description=\"An agent that can perform queries on multiple data sources\",\n    create_user_context=lambda: generate_query_context(Expense, Revenue, Customer),\n    tools=[query_data_tool]\n)\n\nadd_expense_agent = TaskAgent(\n    name=\"add_expense_agent\",\n    description=\"An agent that can add an expense to the database\",\n    create_user_context=lambda: generate_query_context(Expense) + \"\\nRemarks: The tax rate is 0.19\\. The user provide the net amount you need to calculate the gross amount.\",\n    tools=[\n        Tool(\n            name=\"add_expense\",\n            description=\"Add an expense to the database\",\n            function=add_entry_to_table(Expense),\n            model=Expense\n        )\n    ]\n)\n\nadd_revenue_agent = TaskAgent(\n    name=\"add_revenue_agent\",\n    description=\"An agent that can add a revenue entry to the database\",\n    create_user_context=lambda: generate_query_context(Revenue) + \"\\nRemarks: The tax rate is 0.19\\. The user provide the gross_amount you should use the tax rate to calculate the net_amount.\",\n    tools=[\n        Tool(\n            name=\"add_revenue\",\n            description=\"Add a revenue entry to the database\",\n            function=add_entry_to_table(Revenue),\n            model=Revenue\n        )\n    ]\n)\n\nadd_customer_agent = TaskAgent(\n    name=\"add_customer_agent\",\n    description=\"An agent that can add a customer to the database\",\n    create_user_context=lambda: generate_query_context(Customer),\n    tools=[\n        Tool(\n            name=\"add_customer\",\n            description=\"Add a customer to the database\",\n            function=add_entry_to_table(Customer),\n            model=Customer\n        )\n    ]\n)\n```", "```py\nfrom agents.routing import RoutingAgent\n\nrouting_agent = RoutingAgent(\n    tools=[\n        query_task_agent,\n        add_expense_agent,\n        add_revenue_agent,\n        add_customer_agent\n    ]\n)\n\nrouting_agent.run(\"I have spent 5 € on a office stuff. Last Thursday\")\n```", "```py\nSTART: Starting Routing Agent with Input:\nI have spent 5 € on a office stuff. Last Thursday\n\nTool Name: add_expense_agent\nTool Args: {}\n\nSTART: Starting Task Agent with Input:\n\"\"\"Today is Sunday 2024-04-21\nYou can access the following tables in database:\n - expense: id = <int>, description = <str>, net_amount = <float>, gross_amount = <float>, tax_rate = <float>, date = <datetime>\n\nRemarks: The tax rate is 0.19\\. The user provide the net amount you need to calculate the gross amount.\n---\nUser Message: I have spent 5 € on a office stuff. Last Thursday\"\"\"\n\nTool Call: Name: add_expense\nArgs: {'description': 'office stuff', 'net_amount': 5, 'tax_rate': 0.19, 'date': '2024-04-18'}\nMessage: None\nerror: Missing values: gross_amount\n\nTool Call: Name: add_expense\nArgs: {'description': 'office stuff', 'net_amount': 5, 'tax_rate': 0.19, 'date': '2024-04-18', 'gross_amount': 5.95}\nMessage: None\ntool_result: Successfully added net_amount=5.0 id=2 gross_amount=5.95 description='office stuff' date=datetime.datetime(2024, 4, 18, 0, 0) tax_rate=0.19 to the table\n\nError: No tool calls were returned.\nMessage: I have successfully added the expense for office stuff with a net amount of 5€, calculated the gross amount, and recorded it in the database.\n\nTool Call: Name: report_tool\nArgs: {'report': 'Expense for office stuff with a net amount of 5€ has been successfully added. Gross amount calculated as 5.95€.'}\nMessage: None\n\nFinal Result: Expense for office stuff with a net amount of 5€ has been successfully added. Gross amount calculated as 5.95€.\n```", "```py\nrouting_agent.run(\"Two weeks ago on Saturday we had a revenue of 1000 € in the shop\")\n```", "```py\nSTART: Starting Routing Agent with Input:\nTwo weeks ago on Saturday we had a revenue of 1000 € in the shop\n\nTool Name: add_revenue_agent\nTool Args: {}\n\nSTART: Starting Task Agent with Input:\n\"\"\"Today is Sunday 2024-04-21\nYou can access the following tables in database:\n - revenue: id = <int>, description = <str>, net_amount = <float>, gross_amount = <float>, tax_rate = <float>, date = <datetime>\n\nRemarks: The tax rate is 0.19\\. The user provide the gross_amount you should use the tax rate to calculate the net_amount.\n---\nUser Message: Two weeks ago on Saturday we had a revenue of 1000 € in the shop\"\"\"\n\nTool Call: Name: add_revenue\nArgs: {'description': 'Revenue from the shop', 'gross_amount': 1000, 'tax_rate': 0.19, 'date': '2024-04-06'}\nMessage: None\nerror: Missing values: net_amount\n\nTool Call: Name: add_revenue\nArgs: {'description': 'Revenue from the shop', 'gross_amount': 1000, 'tax_rate': 0.19, 'date': '2024-04-06', 'net_amount': 840.34}\nMessage: None\ntool_result: Successfully added net_amount=840.34 gross_amount=1000.0 tax_rate=0.19 description='Revenue from the shop' id=1 date=datetime.datetime(2024, 4, 6, 0, 0) to the table\n\nError: No tool calls were returned.\nMessage: The revenue entry for the shop on April 6, 2024, with a gross amount of 1000€ has been successfully added to the database. The calculated net amount after applying the tax rate is 840.34€.\n\nTool Call: Name: report_tool\nArgs: {'report': 'completed'}\nMessage: None\n\nFinal Result: completed\n```", "```py\nrouting_agent.run(\"How much revenue did we made this month?\")\n```", "```py\nSTART: Starting Routing Agent with Input:\nHow much revenue did we made this month?\n\nTool Name: query_agent\nTool Args: {}\n\nSTART: Starting Agent with Input:\n\"\"\"Today is Sunday 2024-04-21\nYou can access the following tables in database:\n - expense: id = <int>, description = <str>, net_amount = <float>, gross_amount = <float>, tax_rate = <float>, date = <datetime>\n - revenue: id = <int>, description = <str>, net_amount = <float>, gross_amount = <float>, tax_rate = <float>, date = <datetime>\n - customer: id = <int>, company_name = <str>, first_name = <str>, last_name = <str>, phone = <str>, address = <str>, city = <str>, zip = <str>, country = <str>\n\n---\n\nUser Message: How much revenue did we made this month?\"\"\"\n\nTool Call: Name: query_data_tool\nArgs: {'table_name': 'revenue', 'select_columns': ['gross_amount'], 'where': [{'column': 'date', 'operator': 'gte', 'value': '2024-04-01'}, {'column': 'date', 'operator': 'lte', 'value': '2024-04-30'}]}\nMessage: None\ntool_result: content=\"Query results: ['1000.0']\" success=True\n\nError: No tool calls were returned.\nMessage: The revenue made this month is $1000.00.\n\nTool Call: Name: report_tool\nArgs: {'report': 'The revenue made this month is $1000.00.'}\nMessage: None\n\nFinal Result: The revenue made this month is $1000.00.\n```"]
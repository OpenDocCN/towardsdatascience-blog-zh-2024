<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Cyclic Partition: An Up to 1.5x Faster Partitioning Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Cyclic Partition: An Up to 1.5x Faster Partitioning Algorithm</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cyclic-partition-an-up-to-1-5x-faster-partitioning-algorithm-e38bf7948a5f?source=collection_archive---------4-----------------------#2024-10-10">https://towardsdatascience.com/cyclic-partition-an-up-to-1-5x-faster-partitioning-algorithm-e38bf7948a5f?source=collection_archive---------4-----------------------#2024-10-10</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="f9e3" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">A sequence partitioning algorithm that does minimal rearrangements of values</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Tigran Hayrapetyan" class="l ep by dd de cx" src="../Images/36efd337fef6ddc01a4261e301b9ac78.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*1wwgRMPMOk6ktF_j1_FiTQ.png"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@tigran.cs?source=post_page---byline--e38bf7948a5f--------------------------------" rel="noopener follow">Tigran Hayrapetyan</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--e38bf7948a5f--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">19 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Oct 10, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">2</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/aaca4bc60dbe61ce5228172e0852c4cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2F4sw1EN4eECdYynHHOyA.png"/></div></div></figure><p id="acde" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">1. Introduction</p><p id="2dd2" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Sequence partitioning is a basic and frequently used algorithm in computer programming. Given a sequence of numbers “<em class="nt">A</em>”, and some value ‘<em class="nt">p</em>’ called pivot value, the purpose of a partitioning algorithm is to rearrange numbers inside “<em class="nt">A</em>” in such a way, so that all numbers less than ‘<em class="nt">p</em>’ come first, followed by the rest of the numbers.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/6dd838ac6618329d70677b31f28cab20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJmOiPIqwI9mI4J_fMw-WA.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">An example of a sequence before and after partitioning by pivot value “p=20”. <br/>After the algorithm, all the values which are less than 20 (light green)<br/>appear before the other values (yellow).</em></figcaption></figure><p id="f7d5" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">There are different applications of partitioning, but the most popular are:</p><ul class=""><li id="38d3" class="mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns ob oc od bk">QuickSort — which is generally nothing more than a partitioning algorithm, called through recursion multiple times on different sub-arrays of given array, until it becomes sorted.</li><li id="55f8" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">Finding the median value of a given sequence — which makes use of partitioning in order to efficiently cut down the search range, and to ultimately find the median in expected linear time.</li></ul><p id="9537" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Sorting a sequence is an essential step to enable faster navigation over large amounts of data. Of the two common searching algorithms — linear search and binary search — the latter can only be used if the data in the array is sorted. Finding the median or k’th order statistic can be essential to understand the distribution of values in given unsorted data.</p><p id="c00d" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Currently there are different partitioning algorithms (also called — partition schemes), but the well-known ones are “Lomuto scheme” and “Hoare scheme”. Lomuto scheme is often intuitively easier to understand, while Hoare scheme does less rearrangements inside a given array, which is why it is often preferred in practice.</p><p id="ecc7" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">What I am going to suggest in this story is a new partition scheme called “cyclic partition”, which is similar to Hoare scheme, but does 1.5 times fewer rearrangements (value assignments) inside the array. Thus, as it will be shown later, the number of value assignments becomes almost equal to the number of the values which are initially “not at their place”, and should be somehow moved. That fact allows me to consider this new partition scheme as a nearly optimal one.</p><p id="d8ae" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">The next chapters are organized in the following way:</p><ul class=""><li id="e080" class="mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns ob oc od bk">In chapter 2 we will recall what is in-place partitioning (a property, which makes partitioning to be not a trivial task),</li><li id="4422" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">In chapter 3 we will recall the widely used Hoare partitioning scheme,</li><li id="df36" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">In chapter 4 I’ll present “cycles of assignments”, and we will see why some rearrangements of a sequence might require more value assignments, than other rearrangements of the same sequence,</li><li id="0dab" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">Chapter 5 will use some properties of “cycles of assignments”, and derive the new “cyclic partition” scheme, as an optimized variant of Hoare scheme,</li><li id="b474" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">And finally, chapter 6 will present an experimental comparison between the Hoare scheme and cyclic partition, for arrays of small and large data types.</li></ul><p id="5651" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">An implementation of Cyclic partition in the C++ language, as well as its benchmarking with the currently standard Hoare scheme, are present on GitHub, and are referenced at the end of this story [1].</p></div></div></div><div class="ab cb oj ok ol om" role="separator"><span class="on by bm oo op oq"/><span class="on by bm oo op oq"/><span class="on by bm oo op"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="f8a8" class="or os fq bf ot ou ov gq ow ox oy gt oz pa pb pc pd pe pf pg ph pi pj pk pl pm bk">2. Recalling in-place sequence partitioning</h1><p id="e8e0" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">Partitioning a sequence will not be a difficult task, if the input and output sequences would reside in computer memory in 2 different arrays. If that would be the case, then one of methods might be to:</p><ol class=""><li id="a412" class="mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns ps oc od bk">Calculate how many values in “<em class="nt">A</em>” are less than ‘<em class="nt">p</em>’ (this will give us final length of the left part of output sequence),</li><li id="aded" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ps oc od bk">Scan the input array “<em class="nt">A</em>” from left to right, and append every current value “<em class="nt">A</em>[<em class="nt">i</em>]” either to the left part or to the right part, depending on whether it is less than ‘<em class="nt">p</em>’ or not.</li></ol><p id="4b79" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Here are presented a few states of running such algorithm:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/bd9f17358955113e3434fc0f0d8b6782.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ono-le72len_2TIezMbtJA.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">During the first stage we calculate that there are only 7 values less than “p=20” (the light green ones), so we prepare to write the greater values into the output sequence, starting from index 7.</em></figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/f9e1b2e33ffe1606a940fc89c9fef97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7SkpVOEr1wbnLusr0j-kg.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">During the second stage, after scanning 5 values of the input sequence, <br/>we append 3 of them to the left part of output sequence, <br/>and the other 2 to its right part.</em></figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/c82de73a14465cf291d01b03bf0b71ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lIXYk45esW2wZPOmVn49kA.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Continuing the second stage, we have scanned now 9 values from input sequence, <br/>placing 5 of them in the left part of output sequence, and the other 4 to its right part.</em></figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/4d3eb3d4846edf6d520b0800ab1312d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0VfqbeNf_htkb_6YzFbh-g.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">The algorithm is completed. Both parts of the output sequence are now properly filled to the end. <br/>Note, the relative order of values in either left or right parts is preserved, <br/>upon how they were originally written in the input array.</em></figcaption></figure><p id="c7fe" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Other, shorter solutions also exist, such ones which have only one loop in the code.</p><p id="025a" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Now, the difficulty comes when we want to not use any extra memory, so the input sequence will be transformed into the partitioned output sequence just by moving values inside the only array. By the way, such kind of algorithms which don’t use extra memory are called in-place algorithms.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/68571922f3140f447f263db1e119e387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3FH-T2llHsEVrd9_a_hwPQ.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Partitioning the same input sequence “A” in-place, by the same pivot value “p=20”.<br/>Presented order of values corresponds to the input state of the sequence, and arrows for every value show <br/>if where to that value should be moved, in order for the entire sequence to become partitioned.</em></figcaption></figure><p id="d6ce" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Before introducing my partitioning scheme, let’s review the existing and commonly used solution of in-place partitioning.</p></div></div></div><div class="ab cb oj ok ol om" role="separator"><span class="on by bm oo op oq"/><span class="on by bm oo op oq"/><span class="on by bm oo op"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="fed9" class="or os fq bf ot ou ov gq ow ox oy gt oz pa pb pc pd pe pf pg ph pi pj pk pl pm bk">3. The currently used partitioning scheme</h1><p id="fbec" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">After observing a few implementations of sorting in standard libraries of various programming languages, it looks like the most widely used partitioning algorithm is the Hoare scheme. I found out that it is used for example in:</p><ul class=""><li id="1aa2" class="mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns ob oc od bk">“std::sort()” implementation in STL for C++,</li><li id="c739" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">“Arrays.sort()” implementation in JDK for Java, for primitive data types.</li></ul><p id="409b" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">In the partitioning based on the Hoare scheme, we scan the sequence simultaneously from both ends towards each other, searching in the left part such a value <em class="nt">A</em>[<em class="nt">i</em>] which is greater or equal to ‘<em class="nt">p</em>’, and searching in the right part such a value <em class="nt">A</em>[<em class="nt">j</em>] which is less than ‘<em class="nt">p</em>’. Once found, we know that those two values <em class="nt">A</em>[<em class="nt">i</em>] and <em class="nt">A</em>[<em class="nt">j</em>] are kind of “not at their proper places” (remember, the partitioned sequence should have the values less than ‘<em class="nt">p</em>’ coming first, and only then all the other values which are greater or equal to ‘<em class="nt">p</em>’), so we just swap <em class="nt">A</em>[<em class="nt">i</em>] and <em class="nt">A</em>[<em class="nt">j</em>]. After the swap, we continue the same way, simultaneously scanning array “<em class="nt">A</em>” with indexes <em class="nt">i</em> and <em class="nt">j</em>, until they become equal. Once they are, partitioning is completed.</p><p id="3a6d" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Let’s observe the Hoare scheme on another example:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/7dcd2b1d0e8f69d3f0dedf521d6dbb2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CIjFf2_knUB9b0bxD2pc7A.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">The input sequence “A” of length ’N’, that should be partitioned by pivot value “p=20”. <br/>Index i starts scanning from 0 upwards, and index j starts scanning from “N-1” downwards.</em></figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/66f4da72a6c895b44fd267f4334a48dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LJpR8UVVelNaE37vEo-sgA.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx">While increasing index i we meet value “A[2]=31” which is greater than ‘p’. Then, after decreasing index j <br/>we meet another value “A[10]=16” which is less than ‘p’. Those 2 are going to be swapped.</figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/79f91856628c0ee07c14e66ec980cf0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cGimM0p18HUb-vlSrEq47g.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">After swapping “A[2]” and “A[10]” we continue increasing i from 2 and decreasing j from 10. Index i will stop on value “A[4]=28” which is greater than ‘p’, and index j will stop on value “A[9]=5” which is less than ‘p’. Those 2 are also going to be swapped.</em></figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/524bca2c95f5430921fe6c0da6951fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Ec_64TPWu8psgkBDYhAaQ.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">The algorithm continues the same way, and the numbers “A[5]=48” and “A[7]=3” are also going to be swapped.</em></figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/3c4f00b7e95a7a7d27ff9ce5b00458a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gW0-CPWSzpgtrlLyU1UP7Q.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">After that, indexes ‘i’ and ‘j’ will become equal to each other. Partitioning is completed.</em></figcaption></figure><p id="7e68" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">If writing the pseudo-code of partitioning by the Hoare scheme, we will have the following:</p><pre class="mm mn mo mp mq pt pu pv bp pw bb bk"><span id="f202" class="px os fq pu b bg py pz l qa qb">// Partitions sequence A[0..N) with pivot value 'p' <br/>// upon Hoare scheme, and returns index of the first value <br/>// of the resulting right part.<br/>function partition_hoare( A[0..N) : Array of Integers, p: Integer ) : Integer<br/>    i := 0<br/>    j := N-1<br/>    while true<br/>        // Move left index 'i', as much as needed<br/>        while i &lt; j and A[i] &lt; p<br/>            i := i+1<br/>        // Move right index 'j', as much as needed<br/>        while i &lt; j and A[j] &gt;= p<br/>            j := j-1<br/>        // Check for completion<br/>        if i &gt;= j<br/>            if i == j and A[i] &lt; p<br/>                return i+1  // "A[i]" also refers to left part<br/>            else<br/>                return i  // "A[i]" refers to right part<br/>        // Swap "A[i]" and "A[j]"<br/>        tmp := A[i]<br/>        A[i] := A[j]<br/>        A[j] := tmp<br/>        // Advance by one both 'i' and 'j'<br/>        i := i+1<br/>        j := j-1</span></pre><blockquote class="qc qd qe"><p id="36bb" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Here in lines 5 and 6 we set up start indexes for the 2 scans.</p><p id="6c29" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Lines 8–10 search from left for such a value, which should belong to the right part, after partitioning.</p><p id="7c20" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Similarly, lines 11–13 search from right for such a value, which should belong to the left part.</p><p id="69c3" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Lines 15–19 check for completion of the scans. Once indexes ‘i’ and ‘j’ meet, there are 2 cases: either “A[i]” belongs to the left part or to the right part. Depending on that, we return either ‘i’ or ‘i+1’, as return value of the function should be the start index of the right part.</p><p id="c639" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Next, if the scans are not completed yet, lines 20–23 do swap those 2 values which are not at their proper places.</p><p id="21a9" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">And finally, lines 24–26 advance the both indexes, in order to not re-check the already swapped values.</p></blockquote><p id="9468" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">The time complexity of the algorithm is <em class="nt">O</em>(<em class="nt">N</em>), regardless of where the 2 scans will meet each other, as together they always scan <em class="nt">N</em> values.</p><p id="51b8" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">An important note here, if the array “<em class="nt">A</em>” has ‘<em class="nt">L</em>’ values which are “not at their places”, and should be swapped, then acting by Hoare scheme we will do “3*<em class="nt">L</em>/2” assignments, because swapping 2 values requires 3 assignments:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/7a689b04e744421351a03d3c693d8e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T3YWE_KUfGDnxZ5XX4Ydkw.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Swapping values of 2 variables ‘a’ and ‘b’ requires to do 3 assignments, with help of ‘tmp’ variable.</em></figcaption></figure><p id="1bcf" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Those assignments are:</p><pre class="mm mn mo mp mq pt pu pv bp pw bb bk"><span id="c85c" class="px os fq pu b bg py pz l qa qb">tmp := a<br/>a := b<br/>b := tmp</span></pre><p id="4610" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Let me also emphasize here that ‘<em class="nt">L</em>’ is always an even number. That is because for every value “<em class="nt">A</em>[<em class="nt">i</em>]&gt;=<em class="nt">p</em>” originally residing at the left area, there is another value “<em class="nt">A</em>[<em class="nt">j</em>]&lt;<em class="nt">p</em>” originally residing at the right area, the ones which are being swapped. So, every swap rearranges 2 such values, and all rearrangements in Hoare scheme are being done only through swaps. That’s why the ‘<em class="nt">L</em>’ — the total number of values to be rearranged, is always an even number.</p></div></div></div><div class="ab cb oj ok ol om" role="separator"><span class="on by bm oo op oq"/><span class="on by bm oo op oq"/><span class="on by bm oo op"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="4059" class="or os fq bf ot ou ov gq ow ox oy gt oz pa pb pc pd pe pf pg ph pi pj pk pl pm bk">4. Cycles of assignments</h1><p id="66f8" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">This chapter might look as a deviation from the agenda of the story, but actually it isn’t, as we will need the knowledge about cycles of assignments in the next chapter, when optimizing the Hoare partitioning scheme.</p><p id="9514" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Assume that we want to somehow rearrange the order of values in given sequence “<em class="nt">A</em>”. This should not necessarily be a partitioning, but any kind of rearrangement. Let me show that some rearrangements require more assignments than some others.</p><h2 id="8825" class="qf os fq bf ot qg qh qi ow qj qk ql oz ng qm qn qo nk qp qq qr no qs qt qu qv bk">Case #1: Cyclic left-shift of a sequence</h2><p id="d12e" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">How many assignments should be done if we want to cyclic left shift the sequence “<em class="nt">A</em>” by 1 position?</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/e553b939bc7c0ef82e6fe3a43c0d6926.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztfpq5VXRBPunh9CfYhRdA.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Example of cyclic left shift of sequence “A” of length N=12. <br/>We see that the number of assignments needed is N+1=13, as we need to: <br/>1) store “A[0]” in the temporary variable “tmp”, then<br/>2) “N-1” times assign the right adjacent value to the current one, and finally <br/>3) assign “tmp” to the last value of the sequence “A[N-1]”.</em></figcaption></figure><p id="596e" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">The needed operations to do that are:</p><pre class="mm mn mo mp mq pt pu pv bp pw bb bk"><span id="cc69" class="px os fq pu b bg py pz l qa qb">tmp := A[0]<br/>A[0] := A[1]<br/>A[1] := A[2]<br/>...<br/>A[9] := A[10]<br/>A[10] := A[11]<br/>A[11] := tmp</span></pre><p id="bcdf" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">… which results in 13 assignments.</p><h2 id="722c" class="qf os fq bf ot qg qh qi ow qj qk ql oz ng qm qn qo nk qp qq qr no qs qt qu qv bk">Case #2: Cyclic left-shift by 3 positions</h2><p id="43be" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">In the next example we still want to do a cyclic left shift of the same sequence, but now by 3 positions to the left:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/f689ead42e953ba64e25a9fbba4927eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xe8c5Ce85VwpMzCmZzot8g.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Example of cyclic left shift by 3 of the sequence “A”, having length N=12.<br/>We see that the values A[0], A[3], A[6] and A[9] are being exchanged between each other (blue arrows), <br/>as well as values A[1], A[4], A[7] and A[10] do (pink arrows),<br/>and as the values A[2], A[5], A[8] and A[11] do exchange only between each other (yellow arrows).<br/>The “tmp” variable is being assigned to and read from 3 times.</em></figcaption></figure><p id="ee34" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Here we have 3 independent chains / cycles of assignments, each of length 4.</p><p id="26b9" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">In order to properly exchange values between <em class="nt">A</em>[0], <em class="nt">A</em>[3], <em class="nt">A</em>[6] and <em class="nt">A</em>[9], the needed actions are:</p><pre class="mm mn mo mp mq pt pu pv bp pw bb bk"><span id="0d33" class="px os fq pu b bg py pz l qa qb">tmp := A[0]<br/>A[0] := A[3]<br/>A[3] := A[6]<br/>A[6] := A[9]<br/>A[9] := tmp</span></pre><p id="7cca" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">… which makes 5 assignments. Similarly, exchanging values inside groups (<em class="nt">A</em>[1], <em class="nt">A</em>[4], <em class="nt">A</em>[7], <em class="nt">A</em>[10]) and (<em class="nt">A</em>[2], <em class="nt">A</em>[5], <em class="nt">A</em>[8], <em class="nt">A</em>[11]) will require 5 assignments each. And adding all that together gives 5*3=15 assignments required to cyclic left shift by 3 the sequence “<em class="nt">A</em>”, having <em class="nt">N</em>=12 values.</p><h2 id="9b0b" class="qf os fq bf ot qg qh qi ow qj qk ql oz ng qm qn qo nk qp qq qr no qs qt qu qv bk"><em class="oa">Case #3: Reversing a sequence</em></h2><p id="9ea1" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">When reversing the sequence “<em class="nt">A</em>” of length ’<em class="nt">N</em>’, the actions performed are:</p><ul class=""><li id="c942" class="mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns ob oc od bk">swap its first value with the last one, then</li><li id="9371" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">swap the second value with the second one from right,</li><li id="bac5" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">swap the third value with the third one from right,</li><li id="f7b2" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">… and so on.</li></ul><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/3421a95524897208559180641f413088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-UOhLPiDZMkTr3HUKjx6dA.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Example of reversing array “A”, having N=12 values.<br/>We see that the values in pairs (A[0], A[11]), (A[1], A[10]), (A[2], A[9]), etc, are being swapped, independently from each other. The variable “tmp” is being assigned to and read from 6 times.</em></figcaption></figure><p id="e485" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">As every swap requires 3 assignments, and as for reversing entire sequence “<em class="nt">A</em>” we need to do ⌊<em class="nt">N</em>/2⌋ swaps, the total number of assignments results in:</p><blockquote class="qc qd qe"><p id="ec42" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">3*⌊N/2⌋ = 3*⌊12/2⌋ = 3*6 = 18</p></blockquote><p id="09a4" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">And the exact sequence of assignments needed to do the reverse of “<em class="nt">A</em>” is:</p><pre class="mm mn mo mp mq pt pu pv bp pw bb bk"><span id="81d0" class="px os fq pu b bg py pz l qa qb">tmp := A[0]    // Cycle 1<br/>A[0] := A[11]<br/>A[11] := tmp<br/>tmp := A[1]    // Cycle 2<br/>A[1] := A[10]<br/>A[10] := tmp<br/><br/>...<br/><br/>tmp := A[5]    // Cycle 6<br/>A[5] := A[6]<br/>A[6] := tmp</span></pre><h2 id="c289" class="qf os fq bf ot qg qh qi ow qj qk ql oz ng qm qn qo nk qp qq qr no qs qt qu qv bk">Summary</h2><p id="1aec" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">We have seen that rearranging values of the same sequence “<em class="nt">A</em>” might require different number of assignments, depending on how exactly the values are being rearranged.</p><p id="f3cf" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">In the presented 3 examples, the sequence always had length of <em class="nt">N</em>=12, but the number of required assignments was different:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qw"><img src="../Images/6ae43094e570ff03c8f9ab450f725761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7sCaN6Wz5QHRGIQN_KTvZA.png"/></div></div></figure><p id="070b" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">More precisely, the number of assignments is equal to <em class="nt">N</em>+<em class="nt">C</em>, where “<em class="nt">C</em>” is the number of cycles, which originate during the rearrangement. Here by saying “cycle” I mean such a subset of variables of “<em class="nt">A</em>”, values of which are being rotated among each other.</p><p id="a19e" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">In our case 1 (left shift by 1) we had only <em class="nt">C</em>=1 cycle of assignments, and all variables of “<em class="nt">A</em>” did participate in that cycle. That’s why overall number of assignments was:</p><blockquote class="qc qd qe"><p id="60bd" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">N+C = 12+1 = 13.</p></blockquote><p id="7b45" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">In the case 2 (left shift by 3) we had <em class="nt">C</em>=3 cycles of assignments, with:<br/> — first cycle within variables (<em class="nt">A</em>[0], <em class="nt">A</em>[3], <em class="nt">A</em>[6], <em class="nt">A</em>[9]), <br/> — second cycle applied to variables (<em class="nt">A</em>[1], <em class="nt">A</em>[4], <em class="nt">A</em>[7], <em class="nt">A</em>[10]) and <br/> — third cycle applied to variables (<em class="nt">A</em>[2], <em class="nt">A</em>[5], <em class="nt">A</em>[8], <em class="nt">A</em>[11]).</p><p id="bae8" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">That’s why the overall number of assignments was:</p><blockquote class="qc qd qe"><p id="1f5c" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">N+C = 12+3 = 15.</p></blockquote><p id="c6c8" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">And in our case 3 (reversing) we had ⌊<em class="nt">N</em>/2⌋ = 12/2 = 6 cycles. Those all were the shortest possible cycles, and were applied to pairs (<em class="nt">A</em>[0], <em class="nt">A</em>[11]), (<em class="nt">A</em>[1], <em class="nt">A</em>[10]), … and so on. That’s why the overall number of assignments was:</p><blockquote class="qc qd qe"><p id="853e" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">N+C = 12+6 = 18.</p></blockquote><p id="aaf9" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Surely, in the presented examples the absolute difference in number of assignments is very small, and it will not play any role when writing high-performance code. But that is because we were considering a very short array of length “<em class="nt">N</em>=12”. For longer arrays, those differences in numbers of assignments will grow proportionally to <em class="nt">N</em>.</p><p id="a614" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Concluding this chapter, let’s keep in mind that the number of assignments needed to rearrange a sequence grows together with number of cycles, introduced by such rearrangement. And if we want to have a faster rearrangement, we should try to do it by such a scheme, which has the smallest possible number of cycles of assignments.</p></div></div></div><div class="ab cb oj ok ol om" role="separator"><span class="on by bm oo op oq"/><span class="on by bm oo op oq"/><span class="on by bm oo op"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="3029" class="or os fq bf ot ou ov gq ow ox oy gt oz pa pb pc pd pe pf pg ph pi pj pk pl pm bk"><strong class="al">5. Optimizing the Hoare partitioning scheme</strong></h1><p id="dd2b" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">Now let’s observe the Hoare partitioning scheme once again, this time paying attention to how many cycles of assignments it introduces.</p><p id="48a2" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Let’s assume we have the same array “<em class="nt">A</em>” of length <em class="nt">N</em>, and a pivot value ‘<em class="nt">p</em>’ according to which the partitioning must be made. Also let’s assume that there are ‘<em class="nt">L</em>’ values in the array which should be somehow rearranged, in order to bring “<em class="nt">A</em>” into a partitioned state. It turns out that Hoare partitioning scheme rearranges those ‘<em class="nt">L</em>’ values in the slowest possible way, because it introduces the maximal possible number of cycles of assignments, with every cycle consisting of only 2 values.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/daecf43ab4e32d31447e30733c658d05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VUZQ6-qJr-2baLSS8s5CFw.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Given pivot value “p=20”, the “L=8” values which should be rearranged are the ones to which <br/>arrows are coming (or going from).<br/>Hoare partitioning scheme introduces “L/2=4” cycles of assignments, each acting on just 2 values.</em></figcaption></figure><p id="5a52" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Moving 2 values over a cycle of length 2, which is essentially swapping them, requires 3 assignments. So the overall number of values assignments is “3*<em class="nt">L</em>/2” for the Hoare partitioning scheme.</p><p id="2de9" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">The idea which lies beneath the optimization that I am going to describe, comes from the fact that after partitioning a sequence, we are generally not interested in relative order of the values “<em class="nt">A</em>[<em class="nt">i</em>]&lt;<em class="nt">p</em>”, which should finish at the left part of partitioned sequence, as well as we are not interested in the relative order of the ones, which should finish at the right part. The only thing that we are interested in, is for all values less than ‘<em class="nt">p</em>’ to come before the other ones. This fact allows us to alter the cycles of assignments in Hoare scheme, and to come up with only 1 cycle of assignments, containing all the ‘<em class="nt">L</em>’ values, which should somehow be rearranged.</p><p id="20d6" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Let me first describe the altered partitioning scheme with the help of the following illustration:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk nu"><img src="../Images/477f288a1d4e8beb24d2e2973a816044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8lkn4uR2R9y78rtK7S5wA.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">The altered partitioning scheme, applied to the same sequence “A”.<br/>As the pivot “p=20” is not changed, the “L=8” values which should be rearranged are also the same.<br/>All the arrows represent the only cycle of assignments in the new scheme. <br/>After moving all the ‘L’ values upon it, we will end up with an alternative partitioned sequence.</em></figcaption></figure><p id="ff89" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">So what are we doing here?</p><ul class=""><li id="071d" class="mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns ob oc od bk">As in the original Hoare scheme, at first we scan from the left and find such value “<em class="nt">A</em>[<em class="nt">i</em>]&gt;=<em class="nt">p</em>” which should go to the right part. But instead of swapping it with some other value, we just remember it: “<em class="nt">tmp </em>:= <em class="nt">A</em>[<em class="nt">i</em>]”.</li><li id="9404" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">Next we scan from right and find such value “<em class="nt">A</em>[<em class="nt">j</em>]&lt;<em class="nt">p</em>” which should go to the left part. And we just do the assignment “<em class="nt">A</em>[<em class="nt">i</em>] := <em class="nt">A</em>[<em class="nt">j</em>]”, without loosing the value of “<em class="nt">A</em>[<em class="nt">i</em>]”, as it is already stored in “<em class="nt">tmp</em>”.</li><li id="40ef" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">Next we continue the scan from left, and find such value “<em class="nt">A</em>[<em class="nt">i</em>]&gt;=<em class="nt">p</em>” which also should go to the right part. So we do the assignment “<em class="nt">A</em>[<em class="nt">j</em>] := <em class="nt">A</em>[<em class="nt">i</em>]”, without loosing value “<em class="nt">A</em>[<em class="nt">j</em>]”, as it is already assigned to the previous position of ‘<em class="nt">i</em>’.</li><li id="fd40" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">This pattern continues, and once indexes <em class="nt">i</em> and <em class="nt">j</em> meet each other, it remains to place some value greater than ‘<em class="nt">p</em>’ to “<em class="nt">A</em>[<em class="nt">j</em>]”, we just do “<em class="nt">A</em>[<em class="nt">j</em>] := <em class="nt">tmp</em>”, as initially the variable “<em class="nt">tmp</em>” was holding the first value from left, greater than ‘<em class="nt">p</em>’. The partitioning is completed.</li></ul><p id="ae74" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">As we see, here we have only 1 cycle of assignments which goes over all the ‘<em class="nt">L</em>’ values, and in order to properly rearrange them it requires just “<em class="nt">L</em>+1” value assignments, compared to the “3*<em class="nt">L</em>/2” assignments of Hoare scheme.</p><p id="855e" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">I prefer to call this new partitioning scheme a “Cyclic partition”, because all the ‘<em class="nt">L</em>’ values which should be somehow rearranged, now reside on a single cycle of assignments.</p><p id="2790" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Here is the pseudo-code of the Cyclic partition algorithm. Compared to the pseudo-code of Hoare scheme the changes are insignificant, but <strong class="mz fr">now we always do 1.5x fewer assignments</strong>.</p><pre class="mm mn mo mp mq pt pu pv bp pw bb bk"><span id="8e0d" class="px os fq pu b bg py pz l qa qb">// Partitions sequence A[0..N) with pivot value 'p' <br/>// by "cyclic partition" scheme, and returns index of <br/>// the first value of the resulting right part.<br/>function partition_cyclic( A[0..N) : Array of Integers, p: Integer ) : Integer<br/>    i := 0<br/>    j := N-1<br/>    // Find the first value from left, which is not on its place<br/>    while i &lt; N and A[i] &lt; p<br/>        i := i+1<br/>    if i == N<br/>        return N  // All N values go to the left part<br/>    // The cycle of assignments starts here<br/>    tmp := A[i]  // The only write to 'tmp' variable<br/>    while true<br/>        // Move right index 'j', as much as needed<br/>        while i &lt; j and A[j] &gt;= p<br/>            j := j-1<br/>        if i == j  // Check for completion of scans<br/>            break<br/>        // The next assignment in the cycle<br/>        A[i] := A[j]<br/>        i := i+1<br/>        // Move left index 'i', as much as needed<br/>        while i &lt; j and A[i] &lt; p<br/>            i := i+1<br/>        if i == j  // Check for completion of scans<br/>            break<br/>        // The next assignment in the cycle<br/>        A[j] := A[i]<br/>        j := j-1<br/>    // The scans have completed<br/>    A[j] := tmp  // The only read from 'tmp' variable<br/>    return j</span></pre><blockquote class="qc qd qe"><p id="4092" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Here lines 5 and 6 set up the start indexes for both scans (‘i’ — from left to right, and ‘j’ — from right to left).</p><p id="7d4e" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Lines 7–9 search from left for such a value “A[i]”, which should go to the right part. If it turns out that there is no such value, and all N items belong to the left part, lines 10 and 11 report that and finish the algorithm.</p><p id="d583" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Otherwise, if such value was found, at line 13 we remember it in the ‘tmp’ variable, thus opening a slot at index ‘i’ for placing another value there.</p><p id="4879" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Lines 15–19 search from right for such a value “A[j]” which should be moved to the left part. Once found, lines 20–22 place it into the empty slot at index ‘i’, after which the slot at index ‘j’ becomes empty, and waits for another value.</p><p id="2e68" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Similarly, lines 23–27 search from left for such a value “A[i]” which should be moved to the right part. Once found, lines 28–30 place it into the empty slot at index ‘j’, after which the slot at index ‘i’ again becomes empty, and waits for another value.</p><p id="3f0d" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">This pattern is continued in the main loop of the algorithm, at lines 14–30.</p><p id="438f" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Once indexes ‘i’ and ‘j’ meet each other, we have an empty slot there, and lines 31 and 32 assign the originally remembered value in ‘tmp’ variable there, so the index ‘j’ becomes the first one to hold such value which belongs to the right part.</p><p id="a25f" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">The last line returns that index.</p></blockquote><p id="c464" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">This way we can write 2 assignments of the cycle together in the loop’s body, because as it was proven in chapter 3, ‘<em class="nt">L</em>’ is always an even number.</p><p id="5575" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Time complexity of this algorithm is also <em class="nt">O</em>(<em class="nt">N</em>), as we still scan the sequence from both ends. It just does 1.5x less value assignments, so the speed-up is reflected only in the constant factor.</p><p id="05a6" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">An implementation of Cyclic partition in the C++ language is present on GitHub, and is referenced at the end of this story [1].</p><p id="4d1a" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">I also want to show that the value ‘<em class="nt">L</em>’ figuring in the Hoare scheme can’t be lowered, regardless of what partitioning scheme we use. Assume that after partitioning, the length of the left part will be “<em class="nt">left_n</em>”, and length of the right part will be “<em class="nt">right_n</em>”. Now, if looking at the left-aligned “<em class="nt">left_n</em>”-long area of the original unpartitioned array, we will find some ‘<em class="nt">t1</em>’ values there, which are not at their final places. So those are such values which are greater or equal to ‘<em class="nt">p</em>’, and should be moved to the right part anyway.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/d395148fb74f9a7086da0d3df7bba2ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VN7QfGukHgAyZQXKW8XKnw.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Illustration of the sequence before and after partitioning.<br/>Length of the left part is “left_n=7” and length of the right part is “right_n=5”.<br/>Among the first 7 values of the unpartitioned sequence there are “t1=3” of them <br/>which are greater than “p=20” (the yellow ones), and should be somehow moved to the right part.<br/>And among the last 5 values of the unpartitioned sequence there are “t2=3” of them <br/>which are less than ‘p’ (the light green ones), and should be somehow moved to the left part.</em></figcaption></figure><p id="705c" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Similarly, if looking at the right-aligned “<em class="nt">right_n</em>”-long area of the original unpartitioned array, we will find some ‘<em class="nt">t2</em>’ values there, which are also not at their final places. Those are such values which are less than ‘<em class="nt">p</em>’, and should be moved to the left part. We can’t move less than ‘<em class="nt">t1</em>’ values from left to right, as well as we can’t move less than ‘<em class="nt">t2</em>’ values from right to left.</p><p id="063a" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">In the Hoare partitioning scheme, the ‘<em class="nt">t1</em>’ and ‘<em class="nt">t2</em>’ values are the ones which are swapped between each other. So there we have:</p><blockquote class="qc qd qe"><p id="1323" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">t1 = t2 = L/2,</p></blockquote><p id="5f8f" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">or</p><blockquote class="qc qd qe"><p id="83ea" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">t1 + t2 = L.</p></blockquote><p id="6a8a" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Which means that ‘<em class="nt">L</em>’ is actually the minimal amount of values which should be somehow rearranged, in order for the sequence to become partitioned. And the Cyclic partition algorithm rearranges them doing just “<em class="nt">L</em>+1” assignments. That’s why I allow myself to call this new partitioning scheme as “nearly optimal”.</p></div></div></div><div class="ab cb oj ok ol om" role="separator"><span class="on by bm oo op oq"/><span class="on by bm oo op oq"/><span class="on by bm oo op"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="3f5c" class="or os fq bf ot ou ov gq ow ox oy gt oz pa pb pc pd pe pf pg ph pi pj pk pl pm bk">6. Experimental results</h1><p id="ed93" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">It is already proven that the new partitioning scheme is doing fewer assignments of values, so we can expect it to run faster. However, before publishing the algorithm I wanted to collect the results also in an experimental way.</p><p id="ef58" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">I have compared the running times when partitioning by the Hoare scheme and by Cyclic partition. All the experiments were performed on randomly shuffled arrays.</p><p id="08c1" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">The parameters by which the experiments were different are:</p><ul class=""><li id="bb5c" class="mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns ob oc od bk"><em class="nt">N</em> — length of the array,</li><li id="9b91" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">“left_part_percent” — percent of length of the left part (upon <em class="nt">N</em>), which results after partitioning,</li><li id="38b2" class="mx my fq mz b go oe nb nc gr of ne nf ng og ni nj nk oh nm nn no oi nq nr ns ob oc od bk">running on array of primitive data type variables (32-bit integers) <em class="nt">vs.</em> on array of some kind of large objects (256-long static arrays of 16-bit integers).</li></ul><p id="7f26" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">I want to clarify why I found it necessary to run partitioning both on arrays of primitive data types, and on arrays of large objects. Here, by saying “large object” I mean such values, which occupy much more memory, compared to primitive data types. When partitioning primitive data types, assigning one variable to another will work as fast as almost all other instructions used in both algorithms (like incrementing an index or checking condition of the loop). Meanwhile when partitioning large objects, assigning one such object to another will take significantly more time, compared to other used instructions, and that is when we are interested to reduce the overall number of value assignments as much as that is possible.</p><p id="ecd5" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">I’ll explain why I decided to run different experiments with different values of “left_part_percent” a bit later in this chapter.</p><p id="847d" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">The experiments were performed with Google Benchmark, under the following system:</p><blockquote class="qc qd qe"><p id="7f9a" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">CPU: Intel Core i7–11800H @ 2.30GHz<br/>RAM: 16.0 GB<br/>OS: Windows 11 Home, 64-bit<br/>Compiler: MSVC 2022 ( /O2 /Ob2 /MD /GR /Gd )</p></blockquote><h2 id="d984" class="qf os fq bf ot qg qh qi ow qj qk ql oz ng qm qn qo nk qp qq qr no qs qt qu qv bk"><em class="oa">Partitioning arrays of a primitive data type</em></h2><p id="3736" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">Here are the results of running partition algorithms on arrays of primitive data type — 32 bit integer:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qx"><img src="../Images/5dc5942fff1891d9586462a471299fdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bUgajHXkuTPGsbsvWfPfqg.png"/></div></div></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qy"><img src="../Images/3635c3e77ec7d8b6b9fdbfefe66f71ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yJ4fRvowipIH-ioloh5oww.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Running times of partitioning algorithms, on array of 32-bit integers, having length N=10'000.<br/>Blue bars correspond to partitioning by Hoare scheme, <br/>while red bars correspond to the Cyclic partition algorithm.<br/>Partitioning algorithms are run for 5 different cases, based on “left_part_percent” — percent of the left part of array (upon N), that will appear after partitioning. The time is presented in nanoseconds.</em></figcaption></figure><p id="2911" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">We see that there is no obvious correlation between value of “left_part_percent” and relative difference in running times of the 2 algorithms. This kind of behavior is expected.</p><h2 id="20dc" class="qf os fq bf ot qg qh qi ow qj qk ql oz ng qm qn qo nk qp qq qr no qs qt qu qv bk"><em class="oa">Partitioning arrays of “large objects”</em></h2><p id="b876" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">And here are the results of running the 2 partitioning algorithms on array of so called “large objects” — each of which is an 256-long static array of 16-bit random integers.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qz"><img src="../Images/c96678e7fda50c54f2b241541c080557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dhWplWJtrYUp3y0FkNyQ1A.png"/></div></div></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ra"><img src="../Images/f53f40b7b62dab8d72b720966896c573.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JtECAkK-k3EwxvA8Ngscg.png"/></div></div><figcaption class="nv nw nx mj mk ny nz bf b bg z dx"><em class="oa">Running times of partitioning algorithms, on array of large objects <br/>(256-long static arrays of random 16-bit integers), having length N=10'000.<br/>Blue bars correspond to partitioning by Hoare scheme, <br/>while red bars correspond to the Cyclic partition algorithm.<br/>Partitioning algorithms are run for 5 different cases, based on “left_part_percent” — percent of the left part of array (upon N), that will appear after partitioning. The time is presented in nanoseconds.</em></figcaption></figure><p id="0c90" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Now we see an obvious correlation: Cyclic partition outperforms the Hoare scheme as more, as the “left_part_percent” is closer to 50%. In other words, Cyclic partition works relatively faster when after partitioning the left and right parts of the array appear to have closer lengths. This is also an expected behavior.</p><h2 id="7fc3" class="qf os fq bf ot qg qh qi ow qj qk ql oz ng qm qn qo nk qp qq qr no qs qt qu qv bk">Explanation of the results</h2><p id="53a0" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk"><em class="nt">— Why does partitioning generally take longer, when “left_part_percent” is closer to 50%?</em></p><p id="185d" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Let’s imagine for a moment a corner case — when after partitioning almost all values appear in left (or right) part. This will mean that almost all values of the array were less (or greater) than the pivot value. And it will mean that during the scan, all those values were considered to be already at their final positions, and very few assignments of values were performed. If trying to imagine the other case — when after partitioning the left and right parts appear to have almost equal length, it will mean that a lot of value assignments were performed (as initially all the values were randomly shuffled in the array).</p><p id="8279" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk"><em class="nt">— When looking at partitioning of “large objects”, why does the difference in running time of the 2 algorithms become greater when “left_part_percent” gets closer to 50%?</em></p><p id="adb6" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">The previous explanation shows that when “left_part_percent” gets closer to 50%, there arises need to do more assignments of values in the array. In previous chapters we also have shown that Cyclic partition always makes 1.5x less value assignments, compared to Hoare scheme. So that difference of 1.5 times brings more impact on overall running time when we generally need to do more rearrangements of values in the array.</p><p id="a8ee" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk"><em class="nt">— Why is the absolute time (in nanoseconds) greater when partitioning “large objects”, rather than when partitioning 32-bit integers?</em></p><p id="a852" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">This one is simple — because assigning one “large object” to another takes much more time, than assigning one primitive data type to another.</p><p id="fe3c" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">I also run all the experiments on arrays with different lengths, but the overall picture didn’t change.</p></div></div></div><div class="ab cb oj ok ol om" role="separator"><span class="on by bm oo op oq"/><span class="on by bm oo op oq"/><span class="on by bm oo op"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="9a76" class="or os fq bf ot ou ov gq ow ox oy gt oz pa pb pc pd pe pf pg ph pi pj pk pl pm bk">7. Conclusion</h1><p id="c360" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">In this story I introduced an altered partitioning scheme, called “Cyclic partition”. It always makes 1.5 times fewer value assignments, compared to the currently used Hoare partitioning scheme.</p><p id="1ea8" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">Surely, when partitioning a sequence, value assignment is not the only type of operation performed. Besides it, partitioning algorithms check values of input sequence “<em class="nt">A</em>” for being less or greater than the pivot value ‘<em class="nt">p</em>’, as well as they do increments and decrements of indexes over “<em class="nt">A</em>”. The amounts of comparisons, increments and decrements are not affected by introducing “cyclic partition”, so we can’t just expect it to run 1.5x faster. However, when partitioning an array of complex data types, where value assignment is significantly more time-consuming than simply incrementing or decrementing an index, the overall algorithm can actually run up to 1.5 times faster.</p><p id="571d" class="pw-post-body-paragraph mx my fq mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">The partitioning procedure is the main routine of the QuickSort algorithm, as well as of the algorithm for finding the median of an unsorted array, or finding its <em class="nt">k</em>-th order statistic. So we can also expect for those algorithms to have a performance gain up to 1.5 times, when working on complex data types.</p></div></div></div><div class="ab cb oj ok ol om" role="separator"><span class="on by bm oo op oq"/><span class="on by bm oo op oq"/><span class="on by bm oo op"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><blockquote class="qc qd qe"><p id="a17b" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">My gratitudes to:<br/> — Roza Galstyan, for reviewing the draft of the story and suggesting useful enhancements,<br/> — David Ayrapetyan, for the spell check ( <a class="af rb" href="https://www.linkedin.com/in/davidayrapetyan/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/davidayrapetyan/</a> ),<br/> — Asya Papyan, for careful design of all used illustrations ( <a class="af rb" href="https://www.behance.net/asyapapyan" rel="noopener ugc nofollow" target="_blank">https://www.behance.net/asyapapyan</a> ).</p><p id="f71f" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">If you enjoyed this story, feel free to find and connect me on LinkedIn ( <a class="af rb" href="https://www.linkedin.com/in/tigran-hayrapetyan-cs/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/tigran-hayrapetyan-cs/</a> ).</p><p id="99d3" class="mx my nt mz b go na nb nc gr nd ne nf ng nh ni nj nk nl nm nn no np nq nr ns fj bk">All used images, unless otherwise noted, are designed by request of the author.</p></blockquote></div></div></div><div class="ab cb oj ok ol om" role="separator"><span class="on by bm oo op oq"/><span class="on by bm oo op oq"/><span class="on by bm oo op"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="fbac" class="or os fq bf ot ou ov gq ow ox oy gt oz pa pb pc pd pe pf pg ph pi pj pk pl pm bk">References:</h1><p id="fc18" class="pw-post-body-paragraph mx my fq mz b go pn nb nc gr po ne nf ng pp ni nj nk pq nm nn no pr nq nr ns fj bk">[1] — Implementation of Cyclic partition in C++ : <a class="af rb" href="https://github.com/tigranh/cyclic_partition" rel="noopener ugc nofollow" target="_blank">https://github.com/tigranh/cyclic_partition</a></p></div></div></div></div>    
</body>
</html>
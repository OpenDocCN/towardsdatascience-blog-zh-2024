<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Perform Outlier Detection More Effectively Using Subsets of Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Perform Outlier Detection More Effectively Using Subsets of Features</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/perform-outlier-detection-more-effectively-using-subsets-of-features-d984bde99981?source=collection_archive---------1-----------------------#2024-11-24">https://towardsdatascience.com/perform-outlier-detection-more-effectively-using-subsets-of-features-d984bde99981?source=collection_archive---------1-----------------------#2024-11-24</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="1ee6" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Identify relevant subspaces: subsets of features that allow you to most effectively perform outlier detection on tabular data</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@wkennedy934?source=post_page---byline--d984bde99981--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="W Brett Kennedy" class="l ep by dd de cx" src="../Images/b3ce55ffd028167326c117d47c64c467.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*v8pf2r3SPMLuHoSmF4IwlA.png"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--d984bde99981--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@wkennedy934?source=post_page---byline--d984bde99981--------------------------------" rel="noopener follow">W Brett Kennedy</a></p></div></div></div><div class="hz ia l"><div class="ab ib"><div class="ab"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewbox="0 0 16 16"><path fill="#437AFF" d="M15.163 8c0 .65-.459 1.144-.863 1.575-.232.244-.471.5-.563.719s-.086.543-.092.875c-.006.606-.018 1.3-.49 1.781-.47.481-1.15.494-1.744.5-.324.006-.655.013-.857.094s-.465.337-.704.575c-.422.412-.906.881-1.542.881-.637 0-1.12-.469-1.543-.881-.239-.238-.49-.482-.704-.575-.214-.094-.532-.088-.857-.094-.593-.006-1.273-.019-1.744-.5s-.484-1.175-.49-1.781c-.006-.332-.012-.669-.092-.875-.08-.207-.33-.475-.563-.719-.404-.431-.863-.925-.863-1.575s.46-1.144.863-1.575c.233-.244.472-.5.563-.719.092-.219.086-.544.092-.875.006-.606.019-1.3.49-1.781s1.15-.494 1.744-.5c.325-.006.655-.012.857-.094.202-.081.465-.337.704-.575C7.188 1.47 7.671 1 8.308 1s1.12.469 1.542.881c.239.238.49.481.704.575s.533.088.857.094c.594.006 1.273.019 1.745.5.47.481.483 1.175.49 1.781.005.331.011.669.091.875s.33.475.563.719c.404.431.863.925.863 1.575"/><path fill="#fff" d="M7.328 10.5c.195 0 .381.08.519.22.137.141.215.331.216.53 0 .066.026.13.072.177a.24.24 0 0 0 .346 0 .25.25 0 0 0 .071-.177c.001-.199.079-.389.216-.53a.73.73 0 0 1 .519-.22h1.959c.13 0 .254-.053.346-.146a.5.5 0 0 0 .143-.354V6a.5.5 0 0 0-.143-.354.49.49 0 0 0-.346-.146h-1.47c-.324 0-.635.132-.865.366-.23.235-.359.552-.359.884v2.5c0 .066-.025.13-.071.177a.24.24 0 0 1-.346 0 .25.25 0 0 1-.072-.177v-2.5c0-.332-.13-.65-.359-.884A1.21 1.21 0 0 0 6.84 5.5h-1.47a.49.49 0 0 0-.346.146A.5.5 0 0 0 4.88 6v4c0 .133.051.26.143.354a.49.49 0 0 0 .347.146z"/></svg></div></div></div><span class="ic id" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ie if ah ai aj ak al am an ao ap aq ar ig ih ii" disabled="">Follow</button></p></div></div></span></div></div><div class="l ij"><span class="bf b bg z dx"><div class="ab cn ik il im"><div class="in io ab"><div class="bf b bg z dx ab ip"><span class="iq l ij">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--d984bde99981--------------------------------" rel="noopener follow"><p class="bf b bg z ir is it iu iv iw ix iy bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="ic id" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">28 min read</span><div class="iz ja l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Nov 24, 2024</span></div></span></div></span></div></div></div><div class="ab cp jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq"><div class="h k w ea eb q"><div class="kg l"><div class="ab q kh ki"><div class="pw-multi-vote-icon ed iq kj kk kl"><div class=""><div class="km kn ko kp kq kr ks am kt ku kv kl"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kw kx ky kz la lb lc"><p class="bf b dy z dx"><span class="kn">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao km lf lg ab q ee lh li" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="le"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count ld le">8</span></p></button></div></div></div><div class="ab q jr js jt ju jv jw jx jy jz ka kb kc kd ke kf"><div class="lj k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lk an ao ap ig ll lm ln" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lo cn"><div class="l ae"><div class="ab cb"><div class="lp lq lr ls lt lu ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lk an ao ap ig lv lw li lx ly lz ma mb s mc md me mf mg mh mi u mj mk ml"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lk an ao ap ig lv lw li lx ly lz ma mb s mc md me mf mg mh mi u mj mk ml"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lk an ao ap ig lv lw li lx ly lz ma mb s mc md me mf mg mh mi u mj mk ml"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><p id="f958" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This article is part of a series related to the challenges, and the techniques that may be used, to best identify outliers in data, including articles related to using <a class="af ni" rel="noopener" target="_blank" href="/using-pca-for-outlier-detection-afecab4d2b78">PCA</a>, <a class="af ni" rel="noopener" target="_blank" href="/distance-metric-learning-for-outlier-detection-5b4840d01246">Distance Metric Learning</a>, <a class="af ni" rel="noopener" target="_blank" href="/shared-nearest-neighbors-a-more-robust-distance-metric-064d7f99ffb7">Shared Nearest Neighbors</a>, <a class="af ni" rel="noopener" target="_blank" href="/interpretable-outlier-detection-frequent-patterns-outlier-factor-fpof-0d9cbf51b17a">Frequent Patterns Outlier Factor</a>, <a class="af ni" rel="noopener" target="_blank" href="/counts-outlier-detector-interpretable-outlier-detection-ead0d469557a">Counts Outlier Detector</a> (a multi-dimensional histogram-based method), and <a class="af ni" href="https://medium.com/towards-data-science/doping-a-technique-to-test-outlier-detectors-3f6b847ab8d4" rel="noopener">doping</a>. This article also contains an excerpt from my book, <a class="af ni" href="https://www.manning.com/books/outlier-detection-in-python" rel="noopener ugc nofollow" target="_blank">Outlier Detection in Python</a>.</p><p id="12fd" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We look here at techniques to create, instead of a single outlier detector examining all features within a dataset, a series of smaller outlier detectors, each working with a subset of the features (referred to as <em class="nj">subspaces</em>).</p><h1 id="b996" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">Challenges with outlier detection</h1><p id="dcc9" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">When performing outlier detection on tabular data, we’re looking for the records in the data that are the most unusual — either relative to the other records in the same dataset, or relative to previous data.</p><p id="6f40" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">There are a number of challenges associated with finding the most meaningful outliers, particularly that there is no definition of <em class="nj">statistically unusual</em> that definitively specifies which anomalies in the data should be considered the strongest. As well, the outliers that are most <em class="nj">relevant</em> (and not necessarily the most statistically unusual) for your purposes will be specific to your project, and may evolve over time.</p><p id="414c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">There are also a number of technical challenges that appear in outlier detection. Among these are the difficulties that occur where data has many features. As covered in previous articles related to <a class="af ni" rel="noopener" target="_blank" href="/counts-outlier-detector-interpretable-outlier-detection-ead0d469557a">Counts Outlier Detector</a> and <a class="af ni" rel="noopener" target="_blank" href="/shared-nearest-neighbors-a-more-robust-distance-metric-064d7f99ffb7">Shared Nearest Neighbors</a>, where we have many features, we often face an issue known as the <em class="nj">curse of dimensionality</em>.</p><p id="119b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This has a number of implications for outlier detection, including that it makes distance metrics unreliable. Many outlier detection algorithms rely on calculating the distances between records — in order to identify as outliers the records that are similar to unusually few other records, and that are unusually different from most other records — that is, records that are <em class="nj">close to </em>few other records and <em class="nj">far from</em> most other records.</p><p id="15c0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">For example, if we have a table with 40 features, each record in the data may be viewed as a point in 40-dimensional space, and its outlierness can be evaluated by the distances from it to the other points in this space. This, then, requires a way to measure the distance between records. A variety of measures are used, with Euclidean distances being quite common (assuming the data is numeric, or is converted to numeric values). So, the outlierness of each record is often measured based on the Euclidean distance between it and the other records in the dataset.</p><p id="92cc" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">These distance calculations can, though, break down where we are working with many features and, in fact, issues with distance metrics may appear even with only ten or twenty features, and very often with about thirty or forty or more.</p><p id="6a0c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We should note though, issues dealing with large numbers of features do not appear with all outlier detectors. For example, they do not tend to be significant when working with univariate tests (tests such as z-score or interquartile range tests, that consider each feature one at a time, independently of the other features — described in more detail in <a class="af ni" href="https://medium.com/towards-data-science/a-simple-example-using-pca-for-outlier-detection-ab2773b98e4a" rel="noopener">A Simple Example Using PCA for Outlier Detection</a>) or when using categorical outlier detectors such as <a class="af ni" href="https://medium.com/towards-data-science/interpretable-outlier-detection-frequent-patterns-outlier-factor-fpof-0d9cbf51b17a" rel="noopener">FPOF</a>.</p><p id="bd12" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">However, the majority of outlier detectors commonly used are numeric multi-variate outlier detectors — detectors that assume all features are numeric, and that generally work on all features at once. For example, LOF (Local Outlier Factor) and KNN (k-Nearest Neighbors) are two the the most widely-used detectors and these both evaluate the outlierness of each record based on their distances (in the high-dimensional spaces the data points live in) to the other records.</p><h1 id="753b" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">An example of outliers based on their distances to other datapoints</h1><p id="7cfb" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">Consider the plots below. This presents a dataset with six features, shown in three 2d scatter plots. This includes two points that can reasonably be considered outliers, P1 and P2.</p><p id="2c6e" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Looking, for now, at P1, it is far from the other points, at least in feature A. That is, considering just feature A, P1 can easily be flagged as an outlier. However, most detectors will consider the distance of each point to the other points using all six dimensions, which, unfortunately, means P1 may not necessarily stand out as an outlier, due to the nature of distance calculations in high-dimensional spaces. P1 is fairly typical in the other five features, and so it’s distance to the other points, in 6d space, may be fairly normal.</p><p id="67fd" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Nevertheless, we can see that this general approach to outlier detection — where we examine the distances from each record to the other records — is quite reasonable: P1 and P2 are outliers because they are far (at least in some dimensions) from the other points.</p><figure class="oo op oq or os ot ol om paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="ol om on"><img src="../Images/61f3d772fbd9a9a7ef17de2d324cf2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSilYlAPKbKt3fJCB9SatA.png"/></div></div></figure><h1 id="4fe5" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">KNN and LOF algorithms</h1><p id="46c6" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">As KNN and LOF are very commonly used detectors, we’ll look at them a little closer here, and then look specifically at using subspaces with these algorithms.</p><p id="9e52" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">With the KNN outlier detector, we pick a value for k, which determines how many neighbors each record is compared to. Let’s say we pick 10 (in practice, this would be a fairly typical value).</p><p id="0bfe" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">For each record, we then measure the distance to its 10 nearest neighbors, which provides a good sense of how isolated and remote each point is. We then need to create a single outlier score (i.e., a single number) for each record based on these 10 distances. For this, we generally then take either the mean or the maximum of these distances.</p><p id="b1e0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Let’s assume we take the maximum (using the mean, median, or other function works similarly, though each have their nuances). If a record has an unusually large distance to its 10th nearest neighbor, this means there are at most 9 records that are reasonably close to it (and possibly less), and that it is otherwise unusually far from most other points, so can be considered an outlier.</p><p id="73fb" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">With the LOF outlier detector, we use a similar approach, though it works a bit differently. We also look at the distance of each point to its k nearest neighbors, but then compare this to the distances of these k neighbors to <em class="nj">their </em>k nearest neighbors. So LOF measures the outlierness of each point relative to the other points in their neighborhoods.</p><p id="8c4e" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">That is, while KNN uses a global standard to determine what are unusually large distances to their neighbors, LOF uses a local standard to determine what are unusually large distances.</p><p id="aae9" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The details of the LOF algorithm are actually a bit more involved, and the implications of the specific differences in these two algorithms (and the many variations of these algorithms) are covered in more detail in <a class="af ni" href="https://www.manning.com/books/outlier-detection-in-python" rel="noopener ugc nofollow" target="_blank">Outlier Detection in Python</a>.</p><p id="da0a" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">These are interesting considerations in themselves, but the main point for here is that KNN and LOF both evaluate records based on their distances to their closest neighbors. And that these distance metrics can work sub-optimally (or even completely breakdown) if using many features at once, which is reduced greatly by working with small numbers of features (subspaces) at a time.</p><p id="e649" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The idea of using subspaces is useful even where the detector used does not use distance metrics, but where detectors based on distance calculations are used, some of the benefits of using subspaces can be a bit more clear. And, using distances in ways similar to KNN and LOF is quite common among detectors. As well as KNN and LOF, for example, Radius, ODIN, INFLO, and LoOP detectors, as well as detectors based on sampling, and detectors based on clustering, all use distances.</p><p id="82ce" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">However, issues with the curse of dimensionality can occur with other detectors as well. For example, ABOD (Angle-based Outlier Detector) uses the angles between records to evaluate the outlierness of each record, as opposed to the distances. But, the idea is similar, and using subspaces can also be helpful when working with ABOD.</p><p id="9359" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As well, other benefits of subspaces I’ll go through below apply equally to many detectors, whether using distance calculations or not. Still, the curse of dimensionality is a serious concern in outlier detection: where detectors use distance calculations (or similar measures, such as angle calculations), and there are many features, these distance calculations can break down. In the plots above, P1 and P2 may be detected well considering only six dimensions, and quite possibly if using 10 or 20 features, but if there were, say, 100 dimensions, the distances between all points would actually end up about the same, and P1 and P2 would not stand out at all as unusual.</p><h1 id="7b92" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">Issues with moderate numbers of features</h1><p id="0d24" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">Outside of the issues related to working with very large numbers of features, our attempts to identify the most unusual records in a dataset can be undermined even when working with fairly small numbers of features.</p><p id="02a0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">While very large numbers of features can make the distances calculated between records meaningless, even moderate numbers of features can make records that are unusual in just one or two features more difficult to identify.</p><p id="c220" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Consider again the scatter plot shown earlier, repeated here. Point P1 is an outlier in feature A (thought not in the other five features). Point P2 is unusual in features C and D, but not in the other four features). However, when considering the Euclidean distances of these points to the other points in 6-dimensional space, they may not reliably stand out as outliers. The same would be true using Manhattan, and most other distance metrics as well.</p><figure class="oo op oq or os ot ol om paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="ol om on"><img src="../Images/61f3d772fbd9a9a7ef17de2d324cf2bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xSilYlAPKbKt3fJCB9SatA.png"/></div></div><figcaption class="oz pa pb ol om pc pd bf b bg z dx">The left pane shows point P1 in a 2D dataspace. The point is unusual considering feature A, but less so if using Euclidean distances in the full 6D dataspace, or even the 2D dataspace shown in this plot. This is an example where using additional features can be counterproductive. In the middle pane, we see another point, point P2, which is an outlier in the C–D subspace but not in the A-B or E–F subspaces. We need only features C and D to identify this outlier, and again including other features will simply make P2 more difficult to identify.</figcaption></figure><p id="78b5" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">P1, for example, even in the 2d space shown in the left-most plot, is not unusually far from most other points. It’s unusual that there are no other points near it (which KNN and LOF will detect), but the distance from P1 to the other points in this 2d space is not unusual: it’s similar to the distances between most other pairs of points.</p><p id="7767" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Using a KNN algorithm, we would likely be able to detect this, at least if k is set fairly low, for example, to 5 or 10 — most records have their 5th (and their 10th) nearest neighbors much closer than P1 does. Though, when including all six features in the calculations, this is much less clear than when viewing just feature A, or just the left-most plot, with just features A and B.</p><p id="f6d7" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Point P2 stands out well as an outlier when considering just features C and D. Using a KNN detector with a k value of, say, 5, we can identify its 5 nearest neighbors, and the distances to these would be larger than is typical for points in this dataset.</p><p id="29f3" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Using an LOF detector, again with a k value of, say, 5, we can compare the distances to P1’s or P2’s 5 nearest neighbors to the distances to their 5 nearest neighbors and here as well, the distance from P1 or P2 to their 5 nearest neighbors would be found to be unusually large.</p><p id="a9c8" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">At least this is straightforward when considering only Features A and B, or Features C and D, but again, when considering the full 6-d space, they become more difficult to identify as outliers.</p><p id="1906" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">While many outlier detectors may still be able to identify P1 and P2 even with six, or a small number more, dimensions, it is clearly easier and more reliable to use fewer features. To detect P1, we really only need to consider feature A; and to identify P2, we really only need to consider features C and D. Including other features in the process simply makes this more difficult.</p><p id="00ab" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This is actually a common theme with outlier detection. We often have many features in the datasets we work with, and each can be useful. For example, if we have a table with 50 features, it may be that all 50 features are relevant: either a rare value in any of these features would be interesting, or a rare combination of values in two or more features, for each of these 50 features, would be interesting. It would be, then, worth keeping all 50 features for analysis.</p><p id="ff45" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">But, to identify any one anomaly, we generally need only a small number of features. In fact, it’s very rare for a record to be unusual in all features. And it’s very rare for a record to have a anomaly based on a rare combination of many features (see <a class="af ni" href="https://medium.com/towards-data-science/counts-outlier-detector-interpretable-outlier-detection-ead0d469557a" rel="noopener">Counts Outlier Detector</a> for more explanation of this).</p><p id="ddfe" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Any given outlier will likely have a rare value in one or two features, or a rare combination of values in a pair, or a set of perhaps three or four features. Only these features are necessary to identify the anomalies in that row, even though the other features may be necessary to detect the anomalies in other rows.</p><h1 id="f380" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">Subspaces</h1><p id="c218" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">To address these issues, an important technique in outlier detection is using subspaces. The term <em class="nj">subspaces </em>simply refers to subsets of the features. In the example above, if we use the subspaces: A-B, C-D, E-F, A-E, B-C, B-D-F, and A-B-E, then we have seven subspaces (five 2d subspaces and two 3d subspaces). Creating these, we would run one (or more) detectors on each subspace, so would run at least seven detectors on each record.</p><p id="57f7" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Realistically, subspaces become more useful where we have many more features that six, and generally even the the subspaces themselves will have more than six features, and not just two or three, but viewing this simple case, for now, with a small number of small subspaces is fairly easy to understand.</p><p id="0a5f" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Using these subspaces, we can more reliably find P1 and P2 as outliers. P1 would likely be scored high by the detector running on features A-B, the detector running on features A-E, and the detector running on features A-B-E. P2 would likely be detected by the detector running on features C-D, and possibly the detector running on B-C.</p><p id="899d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">However, we have to be careful: using only these seven subspaces, as opposed to a single 6d space covering all features, would miss any rare combinations of, for example, A and D, or C and E. These may or may not be detected using a detector covering all six features, but definitely could not be detected using a suite of detectors that simply never examine these combinations of features.</p><p id="5425" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Using subspaces does have some large benefits, but does have some risk of missing relevant outliers. We’ll cover some techniques to generate subspaces below that mitigate this issue, but it can be useful to still run one or more outlier detectors on the full dataspace as well. In general, with outlier detection, we’re rarely able to find the full set of outliers we’re interested in unless we apply many techniques. As important as the use of subspaces can be, it is still often useful to use a variety of techniques, which may include running some detectors on the full data.</p><p id="be98" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Similarly, with each subspace, we may execute multiple detectors. For example, we may use both a KNN and LOF detector, as well as Radius, ABOD, and possibly a number of other detectors — again, using multiple techniques allows us to better cover the range of outliers we wish to detect.</p><h1 id="520b" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">Further Motivations for Subspaces</h1><p id="7117" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">We’ve seen, then, a couple motivations for working with subspaces: we can mitigate the curse of dimensionality, and we can reduce where anomalies are not identified reliably where they are based on small numbers of features that are lost among many features.</p><p id="94d3" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As well as handling situations like this, there are a number of other advantages to using subspaces with outlier detection. These include:</p><ul class=""><li id="360d" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh pe pf pg bk"><strong class="mo fr">Accuracy due to the effects of using ensembles </strong>— Using multiple subspaces allows us to create ensembles (collections of outlier detectors), which allows us to combine the results of many detectors. In general, using ensembles of detectors provides greater accuracy than using a single detector. This is similar (though with some real differences too) to the way ensembles of predictors tend to be stronger for classification and regression problems than a single predictor. Here, using subspaces, each record is examined multiple times, which provides a more stable evaluation of each record than any single detector would.</li><li id="27d8" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk"><strong class="mo fr">Interpretability </strong>— The results can be more interpretable, and interpretability is often a key concern in outlier detection. Very often in outlier detection, we’re flagging unusual records with the idea that they may be a concern, or a point of interest, in some way, and often they will be manually examined. Knowing why they are unusual is necessary to be able to do this efficiently and effectively. Manually assessing outliers that are flagged by detectors that examined many features can be especially difficult; on the other hand, outliers flagged by detectors using only a small number of features can be much more manageable to asses.</li><li id="5d7e" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk"><strong class="mo fr">Faster systems</strong> — Using fewer features allows us to create faster (and less memory-intensive) detectors. This can speed up both fitting and inference, particularly when working with detectors whose execution time is non-linear in the number of features (many detectors are, for example, quadratic in execution time based on the number of features). Depending on the detectors, using, say, 20 detectors, each covering 8 features, may actually execute faster than a single detector covering 100 features.</li><li id="bf91" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk"><strong class="mo fr">Execution in parallel </strong>— Given that we use many small detectors instead of one large detector, it’s possible to execute both the fitting and the predicting steps in parallel, allowing for faster execution where there are the hardware resources to support this.</li><li id="817a" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk"><strong class="mo fr">Ease of tuning over time</strong> — Using many simple detectors creates a system that’s easier to tune over time. Very often with outlier detection, we’re simply evaluating a single dataset and wish just to identify the outliers in this. But it’s also very common to execute outlier detection systems on a long-running basis, for example, monitoring industrial processes, website activity, financial transactions, the data being input to machine learning systems or other software applications, the output of these systems, and so on. In these cases, we generally wish to improve the outlier detection system over time, allowing us to focus better on the more relevant outliers. Having a suite of simple detectors, each based on a small number of features, makes this much more manageable. It allows us to, over time, increase the weight of the more useful detectors and decrease the weight of the less useful detectors.</li></ul><h1 id="4561" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">Choosing the subspaces</h1><p id="a5fd" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">As indicated, we will need, for each dataset evaluated, to determine the appropriate subspaces. It can, though, be difficult to find the relevant set of subspaces, or at least to find the optimal set of subspaces. That is, assuming we are interested in finding any unusual combinations of values, it can be difficult to know which sets of features will contain the most relevant of the unusual combinations.</p><p id="1dc6" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As an example, if a dataset has 100 features, we may train 10 models, each covering 10 features. We may use, say, the first 10 features for the first detector, the second set of 10 features for the second, and so on, If the first two features have some rows with anomalous combinations of values, we will detect this. But if there are anomalous combinations related to the first feature and any of the 90 features not covered by the same model, we will miss these.</p><p id="0122" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We can improve the odds of putting relevant features together by using many more subspaces, but it can be difficult to ensure all sets of features that should be together are actually together at least once, particularly where there are relevant outliers in the data that are based on three, four, or more features — which must appear together in at least one subspace to be detected. For example, in a table of staff expenses, you may wish to identify expenses for rare combinations of Department, Expense Type, and Amount. If so, these three features must appear together in at least one subspace.</p><p id="3a30" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">So, we have the questions of how many features should be in each subspace, which features should go together, and how many subspaces to create.</p><p id="ebb0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">There are a very large number of combinations to consider. If there are 20 features, there are ²²⁰ possible subspaces, which is just over a million. If there are 30 features, there over a billion. If we decide ahead of time how many features will be in each subspace, the numbers of combinations decreases, but is still very large. If there are 20 features and we wish to use subspaces with 8 features each, there are 20 chose 8, or 125,970 combinations. If there are 30 features and we wish for subspaces with 7 features each, there are 30 chose 7, or 2,035,800 combinations.</p><p id="4b4b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">One approach we may wish to take is to keep the subspaces small, which allows for greater interpretability. The most interpretable option, using two features per subspace, also allows for simple visualization. However, if we have d features, we will need d*(d-1)/2 models to cover all combinations, which can be intractable. With 100 features, we would require 4,950 detectors. We usually need to use at least several features per detector, though not necessarily a large number.</p><p id="cf09" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We wish to use enough detectors, and enough features per detector, that each pair of features appears together ideally at least once, and few enough features per detector that the detectors have largely different features from each other. For example, if each detector used 90 out of the 100 features, we’d cover all combinations of features well, but the subspaces would still be quite large (undoing much of the benefit of using subspaces), and all the subspaces will be quite similar to each other (undoing much of the benefit of creating ensembles).</p><p id="914f" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">While the number of features per subspace requires balancing these concerns, the number of subspaces created is a bit more straightforward: in terms of accuracy, using more subspaces is strictly better, but is computationally more expensive.</p><p id="b5b0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">There are a few broad approaches to finding useful subspaces. I list these here quickly, then look at some in more detail below.</p><ul class=""><li id="9a60" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh pe pf pg bk"><strong class="mo fr">Based on domain knowledge </strong>— Here we consider which sets of features could potentially have combinations of values we would consider noteworthy.</li><li id="d880" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk"><strong class="mo fr">Based on associations </strong>— Unusual combinations of values are only possible if a set of features are associated in some way. In prediction problems, we often wish to minimize the correlations between features, but with outlier detection, these are the features that are most useful to consider together. The features with the strongest associations will have the most meaningful outliers if there are exceptions to the normal patterns.</li><li id="899b" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk"><strong class="mo fr">Based on finding very sparse regions </strong>— Records are typically considered as outliers if they are unlike most other records in the data, which implies they are located in sparse regions of the data. Therefore, useful subspaces can be found as those that contain large, nearly-empty regions.</li><li id="06a2" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk"><strong class="mo fr">Randomly</strong> — This is the method used by a technique shown later called <em class="nj">FeatureBagging</em> and, while it can be suboptimal, it avoids the expensive searches for associations and sparse regions, and can work reasonably well where many subspaces are used.</li><li id="22d0" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk"><strong class="mo fr">Exhaustive searches</strong> — This is the method employed by <a class="af ni" href="https://medium.com/towards-data-science/counts-outlier-detector-interpretable-outlier-detection-ead0d469557a" rel="noopener">Counts Outlier Detector</a>. This is limited to subspaces with small numbers of features, but the results are highly interpretable. It also avoids any computation, or biases, associated with selecting only a subset of the possible subspaces.</li><li id="3000" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk"><strong class="mo fr">Using the features related to any known outliers </strong>— If we have a set of known outliers, can identify why they are outliers (the relevant features), and are in a situation where we do not wish to identify unknown outliers (only these specific outliers), then we can take advantage of this and identify the sets of features relevant for each known outlier, and construct models for the various sets of features required.</li></ul><p id="a116" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We’ll look at a few of these next in a little more detail.</p><h2 id="d2cd" class="pm nl fq bf nm pn po pp np pq pr ps ns mv pt pu pv mz pw px py nd pz qa qb qc bk"><strong class="al">Domain knowledge</strong></h2><p id="9bcf" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">Let’s take the example of a dataset, specifically an expenses table, shown below. If examining this table, we may be able to determine the types of outliers we would and would not be interested in. Unusual combinations of Account and Amount, as well as unusual combinations of Department and Account, may be of interest; whereas Date of Expense and Time would likely not be a useful combination. We can continue in this way, creating a small number of subspaces, each with likely two, three, or four features, which can allow for very efficient and interpretable outlier detection, flagging the most relevant outliers.</p><figure class="oo op oq or os ot ol om paragraph-image"><div class="ol om qd"><img src="../Images/b937a9fb973ad691e3cc5eec0b4e1cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*-Ip-Cr5ERpp4Ds-ZecVa5Q.png"/></div><figcaption class="oz pa pb ol om pc pd bf b bg z dx">Expenses table</figcaption></figure><p id="6028" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This can miss cases where we have an association in the data, though the association is not obvious. So, as well as taking advantage of domain knowledge, it may be worth searching the data for associations. We can discover relationships among the features, for example, testing where features can be predicted accurately from the other features using simple predictive models. Where we find such associations, these can be worth investigating.</p><p id="3853" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Discovering these associations, though, may be useful for some purposes, but may or may not be useful for the outlier detection process. If there is, for example, a relationship between accounts and the time of the day, this may simply be due to the process people happen to typically use to submit their expenses, and it may be that deviations from this are of interest, but more likely they are not.</p><h2 id="55fc" class="pm nl fq bf nm pn po pp np pq pr ps ns mv pt pu pv mz pw px py nd pz qa qb qc bk">Random feature subspaces</h2><p id="6d5a" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">Creating subspaces randomly can be effective if there is no domain knowledge to draw on. This is fast and can create a set of subspaces that will tend to catch the strongest outliers, though it can miss some important outliers too.</p><p id="dce4" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The code below provides an example of one method to create a set of random subspaces. This example uses a set of eight features, named A through H, and creates a set of subspaces of these.</p><p id="5f77" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Each subspace starts by selecting the feature that is so far the least-used (if there is a tie, one is selected randomly). It uses a variable called <em class="nj">ft_used_counts</em> to track this. It then adds features to this subspace one at a time, each step selecting the feature that has appeared in other subspaces the least often with the features so far in the subspace. It uses a feature called <em class="nj">ft_pair_mtx </em>to track how many subspaces each pair of features have appeared in together so far. Doing this, we create a set of subspaces that matches each pair of features roughly equally often.</p><pre class="oo op oq or os qe qf qg bp qh bb bk"><span id="1770" class="qi nl fq qf b bg qj qk l ql qm">import pandas as pd<br/>import numpy as np<br/><br/>def get_random_subspaces(features_arr, num_base_detectors,<br/>                         num_feats_per_detector):<br/>    num_feats = len(features_arr)<br/>    feat_sets_arr = []<br/>    ft_used_counts = np.zeros(num_feats) <br/>    ft_pair_mtx = np.zeros((num_feats, num_feats))  <br/><br/>    # Each loop generates one subspace, which is one set of features<br/>    for _ in range(num_base_detectors):  <br/>        # Get the set of features with the minimum count      <br/>        min_count = ft_used_counts.min() <br/>        idxs = np.where(ft_used_counts == min_count)[0]    <br/><br/>        # Pick one of these randomly and add to the current set<br/>        feat_set = [np.random.choice(idxs)]   <br/><br/>        # Find the remaining set of features<br/>        while len(feat_set) &lt; num_feats_per_detector: <br/>            mtx_with_set = ft_pair_mtx[:, feat_set]<br/>            sums = mtx_with_set.sum(axis=1)<br/>            min_sum = sums.min()<br/>            min_idxs = np.where(sums==min_sum)[0]<br/>            new_feat = np.random.choice(min_idxs)<br/>            feat_set.append(new_feat)<br/>            feat_set = list(set(feat_set))<br/>            <br/>            # Updates ft_pair_mtx<br/>            for c in feat_set: <br/>                ft_pair_mtx[c][new_feat] += 1<br/>                ft_pair_mtx[new_feat][c] += 1<br/>            <br/>        # Updates ft_used_counts<br/>        for c in feat_set: <br/>            ft_used_counts[c] += 1<br/><br/>        feat_sets_arr.append(feat_set)<br/><br/>    return feat_sets_arr<br/><br/>np.random.seed(0)<br/>features_arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] <br/>num_base_detectors = 4<br/>num_feats_per_detector = 5<br/><br/>feat_sets_arr = get_random_subspaces(features_arr, <br/>                                     num_base_detectors, <br/>                                     num_feats_per_detector)<br/>for feat_set in feat_sets_arr:    <br/>    print([features_arr[x] for x in feat_set])</span></pre><p id="2c3d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Normally we would create many more base detectors (each subspace often corresponds to one base detector, though we can also run multiple base detectors on each subspace) than we do in this example, but this uses just four to keep things simple. This will output the following subspaces:</p><pre class="oo op oq or os qe qf qg bp qh bb bk"><span id="7c1c" class="qi nl fq qf b bg qj qk l ql qm">['A', 'E', 'F', 'G', 'H']<br/>['B', 'C', 'D', 'F', 'H']<br/>['A', 'B', 'C', 'D', 'E']<br/>['B', 'D', 'E', 'F', 'G']</span></pre><p id="2cb3" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The code here will create the subspaces such that all have the same number of features. There is also an advantage in having the subspaces cover different numbers of features, as this can introduce some more diversity (which is important when creating ensembles), but there is strong diversity in any case from using different features (so long as each uses a relatively small number of features, such that the subspaces are largely different features).</p><p id="35b7" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Having the same number of features has a couple benefits. It simplifies tuning the models, as many parameters used by outlier detectors depend on the number of features. If all subspaces have the same number of features, they can also use the same parameters.</p><p id="7ec4" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">It also simplifies combining the scores, as the detectors will be more comparable to each other. If using different numbers of features, this can produce scores that are on different scales, and not easily comparable. For example, with k-Nearest Neighbors (KNN), we expect greater distances between neighbors if there are more features.</p><h2 id="d909" class="pm nl fq bf nm pn po pp np pq pr ps ns mv pt pu pv mz pw px py nd pz qa qb qc bk">Feature subspaces based on correlations</h2><p id="ff8d" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">Everything else equal, in creating the subspaces, it’s useful to keep associated features together as much as possible. In the code below, we provide an example of code to select subspaces based on correlations.</p><p id="64ae" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">There are several ways to test for associations. We can create predictive models to attempt to predict each feature from each other single feature (this will capture even relatively complex relationships between features). With numeric features, the simplest method is likely to check for Spearman correlations, which will miss nonmonotonic relationships, but will detect most strong relationships. This is what is used in the code example below.</p><p id="25c5" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">To execute the code, we first specify the number of subspaces desired and the number of features in each.</p><p id="a3d2" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This executes by first finding all pairwise correlations between the features and storing this in a matrix. We then create the first subspace, starting by finding the largest correlation in the correlation matrix (this adds two features to this subspace) and then looping over the number of other features to be added to this subspace. For each, we take the largest correlation in the correlation matrix for any pair of features, such that one feature is currently in the subspace and one is not. Once this subspace has a sufficient number of features, we create the next subspace, taking the largest correlation remaining in the correlation matrix, and so on.</p><p id="01d9" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">For this example, we use a real dataset, the <a class="af ni" href="https://www.openml.org/search?type=data&amp;sort=version&amp;status=any&amp;order=asc&amp;exact_name=baseball&amp;id=185" rel="noopener ugc nofollow" target="_blank">baseball </a>dataset from OpenML (available with a public license). The dataset turns out to contain some large correlations. The correlation, for example, between At bats and Runs is 0.94, indicating that any values that deviate significantly from this pattern would likely be outliers.</p><pre class="oo op oq or os qe qf qg bp qh bb bk"><span id="2171" class="qi nl fq qf b bg qj qk l ql qm">import pandas as pd<br/>import numpy as np<br/>from sklearn.datasets import fetch_openml<br/><br/># Function to find the pair of features remaining in the matrix with the <br/># highest correlation<br/>def get_highest_corr(): <br/>    return np.unravel_index(<br/>        np.argmax(corr_matrix.values, axis=None), <br/>        corr_matrix.shape)<br/><br/>def get_correlated_subspaces(corr_matrix, num_base_detectors, <br/>                                num_feats_per_detector):<br/>    sets = []<br/><br/>    # Loop through each subspace to be created<br/>    for _ in range(num_base_detectors): <br/>        m1, m2 = get_highest_corr()<br/><br/>        # Start each subspace as the two remaining features with <br/>        # the highest correlation<br/>        curr_set = [m1, m2] <br/>        for _ in range(2, num_feats_per_detector):<br/>            # Get the other remaining correlations<br/>            m = np.unravel_index(np.argsort(corr_matrix.values, axis=None), <br/>                                 corr_matrix.shape) <br/>            m0 = m[0][::-1]<br/>            m1 = m[1][::-1]<br/>            for i in range(len(m0)):<br/>                d0 = m0[i]<br/>                d1 = m1[i]<br/>                # Add the pair if either feature is already in the subset<br/>                if (d0 in curr_set) or (d1 in curr_set): <br/>                    curr_set.append(d0)<br/>                    curr_set = list(set(curr_set))<br/>                    if len(curr_set) &lt; num_feats_per_detector:<br/>                        curr_set.append(d1)<br/>                        # Remove duplicates<br/>                        curr_set = list(set(curr_set)) <br/>                if len(curr_set) &gt;= num_feats_per_detector:<br/>                    break<br/><br/>            # Update the correlation matrix, removing the features now used <br/>            # in the current subspace<br/>            for i in curr_set: <br/>                i_idx = corr_matrix.index[i]<br/>                for j in curr_set:<br/>                    j_idx = corr_matrix.columns[j]<br/>                    corr_matrix.loc[i_idx, j_idx] = 0<br/>            if len(curr_set) &gt;= num_feats_per_detector:<br/>                break<br/><br/>        sets.append(curr_set)<br/>    return sets<br/><br/>data = fetch_openml('baseball', version=1)<br/>df = pd.DataFrame(data.data, columns=data.feature_names)<br/><br/>corr_matrix = abs(df.corr(method='spearman'))<br/>corr_matrix = corr_matrix.where(<br/>    np.triu(np.ones(corr_matrix.shape), k=1).astype(np.bool))<br/>corr_matrix = corr_matrix.fillna(0)<br/><br/>feat_sets_arr = get_correlated_subspaces(corr_matrix, num_base_detectors=5, <br/>                                         num_feats_per_detector=4)<br/>for feat_set in feat_sets_arr:    <br/>    print([df.columns[x] for x in feat_set])<br/></span></pre><p id="c84c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This produces:</p><pre class="oo op oq or os qe qf qg bp qh bb bk"><span id="29a5" class="qi nl fq qf b bg qj qk l ql qm">['Games_played', 'At_bats', 'Runs', 'Hits']<br/>['RBIs', 'At_bats', 'Hits', 'Doubles']<br/>['RBIs', 'Games_played', 'Runs', 'Doubles']<br/>['Walks', 'Runs', 'Games_played', 'Triples']<br/>['RBIs', 'Strikeouts', 'Slugging_pct', 'Home_runs']</span></pre><h1 id="7331" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">PyOD</h1><p id="3c58" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk"><a class="af ni" href="https://github.com/yzhao062/pyod" rel="noopener ugc nofollow" target="_blank">PyOD</a> is likely the most comprehensive and well-used tool for outlier detection on numeric tabular data available in Python today. It includes a large number of detectors, ranging from very simple to very complex — including several deep learning-based methods.</p><p id="4601" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Now that we have an idea of how subspaces work with outlier detection, we’ll look at two tools provided by PyOD that work with subspaces, called SOD and FeatureBagging. Both of these tools identify a set of subspaces, execute a detector on each subspace, and combine the results for a single score for each record.</p><p id="ca3d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Whether using subspaces or not, it’s necessary to determine what base detectors to use. If not using subspaces, we would select one or more detectors and run these on the full dataset. And, if we are using subspaces, we again select one or more detectors, here running these on each subspace. As indicated above, LOF and KNN can be reasonable choices, but PyOD provides a number of others as well that can work well if executed on each subspace, including, for example, Angle-based Outlier Detector (ABOD), models based on Gaussian Mixture Models (GMMs), Kernel Density Estimations (KDE), and several others. Other detectors, provided outside PyOD can work very effectively as well.</p><h1 id="c09a" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">SOD (Subspace Outlier Detection)</h1><p id="033e" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">SOD was designed specifically to handle situations such as shown in the scatter plots above. SOD works, similar to KNN and LOF, by identifying a neighborhood of k neighbors for each point, known as the <em class="nj">reference set</em>. The reference set is found in a different way, though, using a method called shared nearest neighbors (SNN).</p><p id="8a93" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Shared nearest neighbors are described thoroughly in <a class="af ni" rel="noopener" target="_blank" href="/shared-nearest-neighbors-a-more-robust-distance-metric-064d7f99ffb7">this article</a>, but the general idea is that if two points are generated by the same mechanism, they will tend to not only be close, but also to have many of the same neighbors. And so, the similarity of any two records can be measured by the number of shared neighbors they have. Given this, neighborhoods can be identified by using not only the sets of points with the smallest Euclidean distances between them (as KNN and LOF do), but the points with the most shared neighbors. This tends to be robust even in high dimensions and even where there are many irrelevant features: the rank order of neighbors tends to remain meaningful even in these cases, and so the set of nearest neighbors can be reliably found even where specific distances cannot.</p><p id="3504" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Once we have the reference set, we use this to determine the subspace, which here is the set of features that explain the greatest amount of variance for the reference set. Once we identify these subspaces, SOD examines the distances of each point to the data center.</p><p id="8827" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">I provide a quick example using SOD below. This assumes pyod has been installed, which requires running:</p><pre class="oo op oq or os qe qf qg bp qh bb bk"><span id="af37" class="qi nl fq qf b bg qj qk l ql qm">pip install pyod</span></pre><p id="3609" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We’ll use, as an example, a synthetic dataset, which allows us to experiment with the data and model hyperparameters to get a better sense of the strengths and limitations of each detector. The code here provides an example of working with 35 features, where two features (features 8 and 9) are correlated and the other features are irrelevant. A single outlier is created as an unusual combination of the two correlated features.</p><p id="e0d7" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">SOD is able to identify the one known outlier as the top outlier. I set the contamination rate to 0.01 to specify to return (given there are 100 records) only a single outlier. Testing this beyond 35 features, though, SOD scores this point much lower. This example specifies the size of the reference set to be 3; different results may be seen with different values.</p><pre class="oo op oq or os qe qf qg bp qh bb bk"><span id="13b1" class="qi nl fq qf b bg qj qk l ql qm">import pandas as pd<br/>import numpy as np<br/>from pyod.models.sod import SOD<br/><br/>np.random.seed(0)<br/>d = np.random.randn(100, 35)<br/>d = pd.DataFrame(d)<br/><br/>#A Ensure features 8 and 9 are correlated, while all others are irrelevant<br/>d[9] = d[9] + d[8] <br/><br/># Insert a single outlier<br/>d.loc[99, 8] = 3.5 <br/>d.loc[99, 9] = -3.8<br/><br/>#C Execute SOD, flagging only 1 outlier<br/>clf = SOD(ref_set=3, contamination=0.01) <br/>d['SOD Scores'] = clf.fit (d)<br/>d['SOD Scores'] = clf.labels_</span></pre><p id="b873" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We display four scatterplots below, showing four pairs of the 35 features. The known outlier is shown as a star in each of these. We can see features 8 and 9 (the two relevant features) in the second pane, and we can see the point is a clear outlier, though it is typical in all other dimensions.</p><figure class="oo op oq or os ot ol om paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="ol om qn"><img src="../Images/5a3159315c07d883e72c50cda17ea3e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSgg3uGxzNOlHXEZmfcIyA.png"/></div></div><figcaption class="oz pa pb ol om pc pd bf b bg z dx">Testing SOD with 35-dimensional data. One outlier was inserted into the data and can be seen clearly in the second pane for features 8 and 9. Although the point is typical otherwise, it is flagged as the top outlier by SOD. The third pane also includes feature 9, and we can see the point is somewhat unusual here, though no more so than many other points in other dimensions. The relationship in features 8 and 9 is the most relevant, and SOD appears to detect this</figcaption></figure><h1 id="2031" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">FeatureBagging</h1><p id="78ac" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">FeatureBagging was designed to solve the same problem as SOD, though takes a different approach to determining the subspaces. It creates the subspaces completely randomly (so slightly differently than the example above, which keeps a record of how often each pair of features are placed in a subspace together and attempts to balance this). It also subsamples the rows for each base detector, which provides a little more diversity between the detectors.</p><p id="df6b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">A specified number of base detectors are used (10 by default, though it is preferable to use more), each of which selects a random set of rows and features. For each, the maximum number of features that may be selected is specified as a parameter, defaulting to all. So, for each base detector, FeatureBagging:</p><ul class=""><li id="d586" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh pe pf pg bk">Determines the number of features to use, up to the specified maximum.</li><li id="f203" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk">Chooses this many features randomly.</li><li id="4f51" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk">Chooses a set of rows randomly. This is a bootstrap sample of the same size as the number of rows.</li><li id="45b7" class="mm mn fq mo b go ph mq mr gr pi mt mu mv pj mx my mz pk nb nc nd pl nf ng nh pe pf pg bk">Creates an LOF detector (by default; other base detectors may be used) to evaluate the subspace.</li></ul><p id="f6fc" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Once this is complete, each row will have been scored by each base detector and the scores must then be combined into a single, final score for each row. PyOD’s FeatureBagging provides two options for this: using the maximum score and using the mean score.</p><p id="9f3f" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As we saw in the scatter plots above, points can be strong outliers in some subspaces and not in others, and averaging in their scores from the subspaces where they are typical can water down their scores and defeat the benefit of using subspaces. In other forms of ensembling with outlier detection, using the mean can work well, but when working with multiple subspaces, using the maximum will typically be the better of the two options. Doing that, we give each record a score based on the subspace where it was most unusual. This isn’t perfect either, and there can be better options, but using the maximum is simple and is almost always preferable to the mean.</p><p id="8722" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Any detector can be used within the subspaces. PyOD uses LOF by default, as did the original paper describing FeatureBagging. LOF is a strong detector and a sensible choice, though you may find better results with other base detectors.</p><p id="ebda" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In the original paper, subspaces are created randomly, each using between d/2 and d — 1 features, where d is the total number of features. Some researchers have pointed out that the number of features used in the original paper is likely much larger than is appropriate.</p><p id="874d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">If the full number of features is large, using over half the features at once will allow the curse of dimensionality to take effect. And using many features in each detector will result in the detectors being correlated with each other (for example, if all base detectors use 90% of the features, they will use roughly the same features and tend to score each record roughly the same), which can also remove much of the benefit of creating ensembles.</p><p id="33b5" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">PyOD allows setting the number of features used in each subspace, and it should be typically set fairly low, with a large number of base estimators created.</p><h1 id="69f2" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">Using other detectors</h1><p id="5237" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">In this article we’ve looked at subspaces as a way to improve outlier detection in a number of ways, including reducing the curse of dimensionality, increasing interpretability, allowing parallel execution, allowing easier tuning over time, and so on. Each of these are important considerations, and using subspaces is often very helpful.</p><p id="caee" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">There are, though, often other approaches as well that can be used for these purposes, sometimes as alternatives, and sometimes in combination of with the use of subspaces. For example, to improve interpretability, its important to, as much as possible, select model types that are inherently interpretable (for example univariate tests such as z-score tests, Counts Outlier Detector, or a detector provided by PyOD called ECOD).</p><p id="bb56" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Where the main interest is in reducing the curse of dimensionality, here again, it can be useful to look at model types that scale to many features well, for instance Isolation Forest or Counts Outlier Detector. It can also be useful to look at executing univariate tests, or applying <a class="af ni" href="https://medium.com/towards-data-science/a-simple-example-using-pca-for-outlier-detection-ab2773b98e4a" rel="noopener">PCA</a>.</p><h1 id="dc61" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">Ongoing outlier detection projects</h1><p id="2948" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">One thing to be aware of when constructing subspaces, if they are formed based on correlations, or on sparse regions, is that the relevant subspaces may change over time as the data changes. New associations may emerge between features and new sparse regions may form that will be useful for identifying outliers, though these will be missed if the subspaces are not recalculated from time to time. Finding the relevant subspaces in these ways can be quite effective, but they may need to to be updated on some schedule, or where the data is known to have changed.</p><h1 id="2279" class="nk nl fq bf nm nn no gq np nq nr gt ns nt nu nv nw nx ny nz oa ob oc od oe of bk">Conclusions</h1><p id="a7d9" class="pw-post-body-paragraph mm mn fq mo b go og mq mr gr oh mt mu mv oi mx my mz oj nb nc nd ok nf ng nh fj bk">It’s common with outlier detection projects on tabular data for it to be worth looking at using subspaces, particularly where we have many features. Using subspaces is a relatively straightforward technique with a number of noteworthy advantages.</p><p id="c9d0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Where you face issues related to large data volumes, execution times, or memory limits, using <a class="af ni" href="https://medium.com/towards-data-science/a-simple-example-using-pca-for-outlier-detection-ab2773b98e4a" rel="noopener">PCA </a>may also be a useful technique, and may work better in some cases than creating sub-spaces, though working with sub-spaces (and so, working with the original features, and not the components created by PCA) can be substantially more interpretable, and interpretability is often quite important with outlier detection.</p><p id="baca" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Subspaces can be used in combination with other techniques to improve outlier detection. As an example, using subspaces can be combined with other ways to create ensembles: it’s possible to create larger ensembles using both subspaces (where different detectors in the ensemble use different features) as well as different model types, different training rows, different pre-processing, and so on. This can provide some further benefits, though with some increase in computation as well.</p><p id="e223" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">All images by author</p></div></div></div></div>    
</body>
</html>
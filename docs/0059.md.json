["```py\nimport numpy as np\n\ndef simple_dft(signal):\n    # Get the number of samples in the signal\n    N = len(signal)\n\n    # Initialize an empty list to store the result (DFT coefficients)\n    res = []\n\n    # Iterate over each frequency bin (k)\n    for k in range(N):\n        # Initialize the current DFT coefficient for the given frequency bin\n        cur_value = 0\n\n        # Iterate over each sample in the signal (j)\n        for j in range(N):\n            # Calculate the complex exponential term and accumulate\n            cur_value += signal[j] * np.exp(-2 * np.pi * 1j * j * k / N)\n\n        # Append the result for the current frequency bin to the list\n        res.append(np.round(cur_value, 5))\n\n    # Return the list of DFT coefficients\n    return res\n\nsimple_dft([1, 2, 0, 5, 9, 2, 0, 4])\n# Output: [(23+0j), (-8.70711-0.70711j), (10+5j), (-7.29289-0.70711j), \n# (-3-0j), (-7.29289+0.70711j), (10-5j), (-8.70711+0.70711j)]\n```", "```py\n# Compute the FFT using NumPy's fft function\na = np.fft.fft([1, 2, 0, 5, 9, 2, 0, 4])\n\n# Compute the DFT using our simple_dft function\nb = simple_dft([1, 2, 0, 5, 9, 2, 0, 4])\n\n# Check if the results are element-wise close within a tolerance\nprint(np.allclose(a, b))\n# Output: True\n```", "```py\nimport numpy as np\n\ndef nice_fft(signal):\n    # Get the number of samples in the signal\n    N = len(signal)\n\n    # Base case: if the signal has only 1 samples, use simple_dft\n    if N == 1:\n        return simple_dft(signal)\n    else:\n        # Initialize an empty list to store the result (DFT coefficients)\n        res = []\n\n        # Separate the signal into even and odd terms\n        even_terms = signal[::2]\n        odd_terms = signal[1::2]\n\n        # Recursively compute FFT for even and odd terms\n        f1 = nice_fft(even_terms)\n        f2 = nice_fft(odd_terms)\n\n        # Combine the results using the Cooley-Tukey FFT algorithm\n        for k in range(N):\n            # Calculate the complex exponential term\n            mult = np.exp(-2 * np.pi * 1j * k / N)\n            # Determine the index for the even and odd terms\n            INDEX = (k % int(N / 2))\n            # Combine the results for the current frequency bin\n            dft_value = f1[INDEX] + mult * f2[INDEX]\n            # Append the result for the current frequency bin to the list\n            res.append(np.round(dft_value, 5))\n\n        # Return the list of DFT coefficients\n        return res\n\nnice_fft([1, 2, 0, 5, 9, 2, 0, 4])\n# Output: [(23+0j), (-8.70711-0.70711j), (10+5j), (-7.29289-0.70711j), \n# (-3-0j), (-7.29289+0.70711j), (10-5j), (-8.70711+0.70711j)]\n```", "```py\nimport timeit\n\n# Generate a random array of size 2^14 (16384)\nrandom_array = np.random.rand(2**14)\n\n# Measure the execution time for simple_dft\ntime_simple_dft = timeit.timeit(lambda: simple_dft(random_array), number=1)\n\n# Measure the execution time for nice_fft\ntime_nice_fft = timeit.timeit(lambda: nice_fft(random_array), number=1)\n\n# Print the results\nprint(f\"Time taken for simple_dft: {time_simple_dft:.5f} seconds\")\n# Output: Time taken for simple_dft: 149.81244 secondss\nprint(f\"Time taken for nice_fft: {time_nice_fft:.5f} seconds\")\n# Output: Time taken for nice_fft: 1.28395 seconds\n```", "```py\n# Define array sizes to test\narray_sizes = [2**n for n in range(5, 14)]  # Sizes from 2^5 to 2^14\n\n# Measure execution time for each array size\ntime_simple_dft = []\ntime_nice_fft = []\n\nfor size in array_sizes:\n    random_array = np.random.rand(size)\n    time_simple_dft.append(timeit.timeit(lambda: simple_dft(random_array), number=1))\n    time_nice_fft.append(timeit.timeit(lambda: nice_fft(random_array), number=1))\n\n# Plotting\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(10, 6))\nplt.plot(array_sizes, time_simple_dft, label='simple_dft')\nplt.plot(array_sizes, time_nice_fft, label='nice_fft')\nplt.xlabel('Array Size')\nplt.ylabel('Time (seconds)')\nplt.title('Execution Time for simple_dft and nice_fft')\nplt.legend()\nplt.show()\n```"]
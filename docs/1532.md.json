["```py\nEXPR = number\n       | EXPR + EXPR\n       | EXPR - EXPR\n       | EXPR * EXPR\n       | EXPR / EXPR\n       | (EXPR)\n```", "```py\ngrammar EmojiLang;\n\nprogram: '🏃‍♂️🏃‍♂️🏃‍♂️' expr '🛑🛑🛑' EOF;\n\nexpr: '(' (ID\n         | atom\n         | ifCond\n         | anonFunctionDefn\n         | funApplication\n         | varAssignment\n         | READ_FLOAT\n         | READ_STRING\n         | printExpr\n         | sequentialOp\n         | baseComputation) ')';\n\natom: NUMBER | BOOLEAN | STRING;\nifCond: '🤔' cond=expr '❓' ontrue=expr ':' onfalse=expr;\nanonFunctionDefn: '🧑‍🏭' arg=ID '⚒️' body=expr;\nfunApplication: '🏭' fun=expr arg=expr;\nvarAssignment: '📦' var=ID '🔜' val=expr;\nprintExpr: '🖨️' expr;\nsequentialOp: '📋' first=expr second=expr;\nbaseComputation: left=expr op=('➕' | '➖' | '✖️' | '➗' | '🟰' | '≤') right=expr;\n\nID: [a-zA-Z_][a-zA-Z0-9_]*;\nNUMBER: [0-9]+ ('.' [0-9]+)?;\nBOOLEAN: '👍' | '👎';\nSTRING: '\"' ~[\\r\\n\"]* '\"';\nREAD_FLOAT: '🔢';\nREAD_STRING: '🔤';\n\nWHITESPACE: [ \\t\\r\\n]+ -> skip;\nCOMMENT: '😴' .*? '⏰' -> skip;\nLINE_COMMENT: '🥱' ~[\\r\\n]* -> skip;\n```", "```py\nimport emoji\nimport sys\n\ndef demojify_file(input_file, output_file):\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        input_text = f.read()\n\n    input_text = emoji.demojize(input_text)\n\n    with open(output_file, \"w\", encoding=\"utf-8\") as f:\n        f.write(input_text)\n\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    output_file = sys.argv[2]\n    demojify_file(input_file, output_file)\n```", "```py\nfrom antlr4 import *\nfrom EmojiLangLexer import EmojiLangLexer\nfrom EmojiLangParser import EmojiLangParser\nfrom EmojiLangListener import EmojiLangListener\nimport emoji\n\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        input_text = f.read()\n\n    input_text = emoji.demojize(input_text)\n    input_stream = InputStream(input_text)\n    lexer = EmojiLangLexer(input_stream)\n    token_stream = CommonTokenStream(lexer)\n    parser = EmojiLangParser(token_stream)\n    tree = parser.program()\n\n    if parser.getNumberOfSyntaxErrors() > 0:\n        exit(1)\n```", "```py\nclass Value:\n    def __init__(self, value):\n        self.value = value\n\n    def __str__(self) -> str:\n        return str(self.value)\n\nclass NumValue(Value):\n    def __init__(self, value: float):\n        super().__init__(value)\n\nclass StringValue(Value):\n    def __init__(self, value: str):\n        super().__init__(value)\n\nclass BoolValue(Value):\n    def __init__(self, value: bool):\n        super().__init__(value) \n```", "```py\nclass EnvLookupException(Exception):\n    pass\n\nclass Environment:\n    def __init__(self):\n        self.vars = {}\n\n    def set_var(self, name, addr: int):\n        self.vars[name] = addr\n\n    def get_var(self, name):\n        if name not in self.vars:\n            raise EnvLookupException(f\"Variable {name} not found in environment\")\n        return self.vars[name]\n\n    def copy(self):\n        new_env = Environment()\n        new_env.vars = self.vars.copy()\n        return new_env\n\nclass Store:\n    def __init__(self):\n        self.store = []\n\n    def alloc(self, value: Value):\n        self.store.append(value)\n        return len(self.store) - 1\n\n    def get(self, addr: int):\n        if addr >= len(self.store):\n            raise EnvLookupException(f\"Address {addr} not found in store\")\n        return self.store[addr]\n\n    def set(self, addr: int, value: Value):\n        if addr >= len(self.store):\n            raise EnvLookupException(f\"Address {addr} not found in store\")\n        self.store[addr] = value\n```", "```py\nclass ClosureValue(Value):\n    # Body should be an antlr4 tree\n    def __init__(self, param: str, body: object, env: 'Environment'):\n        super().__init__(None)\n        self.param = param\n        self.body = body\n        self.env = env\n\n    def __str__(self) -> str:\n        return f\"<function>\"\n```", "```py\nclass FunctionValue(Value):\n    # Body should be an antlr4 tree\n    def __init__(self, param: str, body: object):\n        super().__init__(None)\n        self.param = param\n        self.body = body\n\n    def __str__(self) -> str:\n        return f\"<function>\"\n```", "```py\n# ----------------\n# ENV MUST PERSIST\n# ----------------\ndef f(x):\n  def g(y):\n    return x + y\n  return g(x)\n\nprint((f(4))(5)) # 9\n\n# ----------------\n# ENV MUST CLEAR\n# ----------------\ndef f2(x):\n  return x + y\n\ndef g2(y):\n  return f(5)\n\nprint(f(4)) # Should crash\n```", "```py\nclass EmojiLangException(Exception):\n    pass\n\nTOP_ENV = Environment()\n\nclass Interpreter(EmojiLangListener):\n    def __init__(self):\n        self.store = Store()\n```", "```py\ndef interp(self, prog, env: Environment) -> Value:\n      if prog.ID():\n          return self.interp_id(prog.ID())\n      elif prog.atom():\n          return self.interp_atom(prog.atom())\n      elif prog.anonFunctionDefn():\n          return self.interp_function_defn(prog.anonFunctionDefn())\n      elif prog.READ_FLOAT():\n          return self.interp_read_float()\n      elif prog.READ_STRING():\n          return self.interp_read_string()\n      elif prog.printExpr():\n          return self.interp_print_expr()\n      elif prog.ifCond():\n          return self.interp_if(prog.ifCond(), env)\n      elif prog.sequentialOp():\n          return self.interp_sequential_op(prog.sequentialOp(), env)\n      elif prog.baseComputation():\n          return self.interp_base_computation(prog.baseComputation(), env)\n      elif prog.varAssignment():\n          return self.interp_var_assignment(prog.varAssignment(), env)\n      elif prog.funApplication():\n          return self.interp_fun_application(prog.funApplication(), env)\n```", "```py\ndef interp(self, prog, env: Environment) -> Value:\n    if prog.ID():\n        return self.store.get(env.get_var(prog.ID().getText()))\n    elif prog.atom():\n        return self.interp_atom(prog.atom())\n    elif prog.anonFunctionDefn():\n        return ClosureValue(prog.anonFunctionDefn().arg.text, prog.anonFunctionDefn().body, env)\n    elif prog.READ_FLOAT():\n        try:\n            return NumValue(float(input(\"> \")))\n        except ValueError:\n            raise EmojiLangException(\"Expected float input\")\n    elif prog.READ_STRING():\n        return StringValue(input(\"> \"))\n    elif prog.printExpr():\n        value = self.interp(prog.printExpr().expr(), env)\n        if isinstance(value, StringValue):\n            # print without quotes\n            print(str(value)[1:-1])\n        else:\n            print(value)\n        return value\n    # ...\n\ndef interp_atom(self, atm):\n    if atm.NUMBER():\n        return NumValue(float(atm.NUMBER().getText()))\n    elif atm.BOOLEAN():\n        return BoolValue(atm.BOOLEAN().getText() == \":thumbs_up:\")\n    elif atm.STRING():\n        return StringValue(atm.STRING().getText())\n    # THIS SHOULD NEVER HAPPEN\n    raise EmojiLangException(f\"Unknown atom {atm.getText()}\")\n```", "```py\ndef interp_if(self, if_cond, env: Environment):\n    cond = self.interp(if_cond.cond, env)\n    if not isinstance(cond, BoolValue):\n        raise EmojiLangException(f\"Expected boolean when evaluating if condition, got {cond}\")\n    return self.interp(if_cond.ontrue if cond.value else if_cond.onfalse, env)\n```", "```py\ndef interp(self, prog, env: Environment) -> Value:\n  # ...\n  elif prog.sequentialOp():\n    self.interp(prog.sequentialOp().first, env)\n    return self.interp(prog.sequentialOp().second, env)\n  # ...\n```", "```py\ndef interp_base_computation(self, base_computation, env: Environment):\n    left, right = self.interp(base_computation.left, env), self.interp(base_computation.right, env)\n    if base_computation.op.text == \":plus:\":\n        if isinstance(left, NumValue) and isinstance(right, NumValue):\n            return NumValue(left.value + right.value)\n        elif isinstance(left, StringValue) and isinstance(right, StringValue):\n            return StringValue(left.value + right.value)\n        raise EmojiLangException(f\"Cannot add {left} and {right}\")\n    if base_computation.op.text == \":heavy_equals_sign:\":\n        if type(left) != type(right):\n            return BoolValue(False)\n        if isinstance(left, ClosureValue):\n            raise EmojiLangException(\"Cannot compare functions\")\n        return BoolValue(left.value == right.value)\n\n    # NUMBERS ONLY COMPUTATIONS\n    if not isinstance(left, NumValue) or not isinstance(right, NumValue):\n        raise EmojiLangException(f\"Expected numbers when evaluating base computation, got {left} and {right}\")\n    if base_computation.op.text == \":minus:\":\n        return NumValue(left.value - right.value)\n    elif base_computation.op.text == \":multiply:\":\n        return NumValue(left.value * right.value)\n    elif base_computation.op.text == \":divide:\":\n        if right.value == 0:\n            raise EmojiLangException(\"Division by zero\")\n        return NumValue(left.value / right.value)\n    elif base_computation.op.text == \"≤\":\n        return BoolValue(left.value <= right.value) \n```", "```py\ndef interp_var_assignment(self, var_assign, env: Environment):\n    value = self.interp(var_assign.val, env)\n    addr = env.get_var(var_assign.var.text)\n    self.store.store[addr] = value\n    return value\n```", "```py\ndef interp_fun_application(self, fun_app, env: Environment):\n    closure = self.interp(fun_app.fun, env)\n    if not isinstance(closure, ClosureValue):\n        raise EmojiLangException(f\"Expected function when evaluating function application, got {closure}\")\n    arg = self.interp(fun_app.arg, env)\n    new_env = closure.env.copy()\n    new_env.set_var(closure.param, self.store.alloc(arg))\n    return self.interp(closure.body, new_env)\n```", "```py\nif __name__ == \"__main__\":\n    input_file = sys.argv[1]\n    with open(input_file, \"r\", encoding=\"utf-8\") as f:\n        input_text = f.read()\n\n    # Preprocess input to replace emojis with demojized names\n    input_text = emoji.demojize(input_text)\n\n    input_stream = InputStream(input_text)\n    lexer = EmojiLangLexer(input_stream)\n    token_stream = CommonTokenStream(lexer)\n    parser = EmojiLangParser(token_stream)\n    tree = parser.program()\n\n    if parser.getNumberOfSyntaxErrors() > 0:\n        exit(1)\n\n    interpreter = Interpreter()\n    interpreter.interp(tree.expr(), TOP_ENV)\n```", "```py\n🏃‍♂️🏃‍♂️🏃‍♂️\n    (🖨️ (\"Hello World!\"))\n🛑🛑🛑\n```", "```py\n> python emoji_lang.py helloworld.eml\nHello World!\n```", "```py\ndef f(x, y):\n  return x + y\n\nprint(f(3, 4))\n```", "```py\ndef f(x):\n  def g(y):\n    return x + y\n  return g\n\nprint((f(3))(4))\n```", "```py\n🏃‍♂️🏃‍♂️🏃‍♂️\n    (📋\n        (🖨️ (\"Enter two numbers to compute their sum.\"))\n        (🖨️\n            (🏭\n                (🏭 \n                    (🧑‍🏭 x ⚒️ \n                        (🧑‍🏭 y ⚒️\n                            ((x) ➕ (y))\n                        )\n                    )\n                (🔢))\n            (🔢))\n        )\n    )\n🛑🛑🛑\n```", "```py\nprint(\"Enter two numbers to compute their sum.\")\nprint(((lambda x: (lambda y: x + y)))(float(input()))(float(input())))\n```", "```py\nprint(\"Enter two numbers to compute their sum.\")\n\ndef f(x):\n  def g(y):\n    return x + y\n  return g\n\nx = float(input())\ny = float(input())\n\nprint(f(x)(y))\n```", "```py\n> python emoji_lang.py currying.eml\nEnter two numbers to compute their sum\n> 4\n> 5\n9.0\n```", "```py\nn = int(input())\nwhile n > 0:\n  print(n)\n  n -= 1\n```", "```py\ndef while_loop(condition, body):\n  \"\"\"\n  A recursive implementation of a while loop.\n\n  Arguments\n  -------------\n  - condition: Some function of zero arguments that returns a boolean value\n  - body: Some function of zero arguments to run while the condition returns true\n  \"\"\"\n  if condition():\n    body()\n    while_loop(condition, body)\n  else:\n    return False\n\nclass Box:\n    def __init__(self, n):\n        self.n = n\n\n    def set_n(self, n):\n        self.n = n\n\n    def get_n(self):\n        return self.n\n\nn = Box(int(input()))\n\ndef body():\n    print(n.get_n())\n    n.set_n(n.get_n() - 1)\n\nwhile_loop(lambda: n.get_n() > 0, body)\n```", "```py\ndef while_loop(self, condition, body):\n  if condition():\n    body()\n    self(self, condition, body)\n  else:\n    return False\n\n# ...\n# (define n as a box)\n# ...\n\ndef body():\n    print(n.get_n())\n    n.set_n(n.get_n() - 1)\n\ndef call_while(loop_func, condition, body):\n    loop_func(loop_func, condition, body)\n\ncall_while(while_loop, lambda: n.get_n() > 0, body)\n```", "```py\n(((lambda while_loop: \n    lambda n: \n        while_loop(while_loop)\n                  (lambda bogus: n.get_n() > 0)\n                  (lambda bogus: print(n.get_n()) or n.set_n(n.get_n() - 1)))\n(lambda self:\n    lambda cond:\n        lambda body:\n            (body(\"BOGUS\") or self(self)(cond)(body)) if cond(\"BOGUS\") else False))\n(Box(int(input()))))\n```", "```py\n🏃‍♂️🏃‍♂️🏃‍♂️\n    (🏭\n        (🏭\n            (🧑‍🏭 while ⚒️\n                (🧑‍🏭 n ⚒️\n                    (🏭 (🏭 (🏭 (while) (while))\n                        (🧑‍🏭 bogus ⚒️ (🤔 ((n) ≤ (0)) ❓ (👎) : (👍))))\n                        (🧑‍🏭 bogus ⚒️ (📋\n                            (🖨️ (n))\n                            (📦 n 🔜 ((n) ➖ (1)))\n                        )))\n                ))\n            😴\n                Below is our while function. Note that it takes\n                itself as an argument - this allows for recursion\n                (there are other ways to do this, but recursion via self\n                passing is fairly simple)\n\n                ARGS: \n                1\\. self(itself)\n                2\\. condition_func (function of zero arguments that returns a boolean)\n                3\\. body (function of zero arguments that returns nothing to run while true)\n\n                RETURNS:\n                false when finished\n            ⏰\n            (🧑‍🏭 self ⚒️\n                (🧑‍🏭 condition_func ⚒️\n                    (🧑‍🏭 body ⚒️\n                        (\n                            🤔 (🏭 (condition_func) (\"BOGUS\")) ❓ \n                                (📋 \n                                    (🏭 (body) (\"BOGUS\")) \n                                    (🏭 (🏭 (🏭 (self) (self))\n                                            (condition_func))\n                                            (body))) : \n                                (👎)\n                        ))))\n        )\n    (🔢))       \n🛑🛑🛑\n```", "```py\n> python emoji_lang.py while_loop.eml\n> 4\n4.0\n3.0\n2.0\n1.0\n```", "```py\nY = lambda g: (lambda f: g(lambda arg: f(f)(arg))) (lambda f: g(lambda arg: f(f)(arg)))\n```", "```py\n🏃‍♂️🏃‍♂️🏃‍♂️\n    (🏭\n        (🏭\n            (🏭\n                (🧑‍🏭 y_combinator ⚒️\n                    (🧑‍🏭 while ⚒️\n                        (🧑‍🏭 n ⚒️\n                            (📋\n                                🥱y-combinate our while\n                                (📦 while 🔜 (🏭 (y_combinator) (while)))\n                                (🏭 (🏭 (while)\n                                        (🧑‍🏭 bogus ⚒️ (🤔 ((n) ≤ (0)) ❓ (👎) : (👍))))\n                                        (🧑‍🏭 bogus ⚒️ (📋\n                                                (🖨️ (n))\n                                                (📦 n 🔜 ((n) ➖ (1)))\n                                        ))\n                                )\n                            )\n                        )\n                    )\n                )\n                😴\n                    Our y combinator function - this allows for recursion without e.g. self passing\n                    by effectively currying the function and passing it to itself.\n                ⏰\n                (🧑‍🏭 fn_nr ⚒️\n                    (🏭\n                       (🧑‍🏭 cc ⚒️\n                            (🏭 (fn_nr) \n                                (🧑‍🏭 x ⚒️ (🏭 (🏭 (cc) (cc)) (x)))\n                            )\n                       )\n                       (🧑‍🏭 cc ⚒️\n                            (🏭 (fn_nr) \n                                (🧑‍🏭 x ⚒️ (🏭 (🏭 (cc) (cc)) (x)))\n                            )\n                       )\n                    )\n                )\n            )\n            (🧑‍🏭 while ⚒️\n                    (🧑‍🏭 condition_func ⚒️\n                        (🧑‍🏭 body ⚒️\n                            (\n                                🤔 (🏭 (condition_func) (\"BOGUS\")) ❓ \n                                    (📋 \n                                        (🏭 (body) (\"BOGUS\")) \n                                        (🏭 (🏭 (while)\n                                                (condition_func))\n                                                (body))) : \n                                    (👎)\n                            ))))\n        )  \n    (🔢))    \n🛑🛑🛑\n```", "```py\n> python emoji_lang.py y_comb_while.eml\n> 4\n4.0\n3.0\n2.0\n1.0\n```", "```py\nEXPR = number\n       | EXPR + EXPR\n       | EXPR - EXPR\n       | EXPR * EXPR\n       | EXPR / EXPR\n       | (EXPR)\n```", "```py\nprogram = (FUNDEF | EXPR)* // one or more function definitions or expressions\n\n// NOTE: <something> implies that something is a string\n// also, feel free to ignore whitespace or add semicolons or parenthesize\n// expressions/fundefs if you please\n\nEXPR = number\n     | functionApplication\n     | computation\n\nFUNDEF = 'def' <name> '(' <args>* '):' EXPR\n\nfunctionApplication = <name> '(' EXPR* ')' // e.g. f(1, 2+2, g(3))\ncomputation = EXPR + EXPR\n             | EXPR - EXPR\n             | EXPR * EXPR\n             | EXPR / EXPR\n             | (EXPR)\n```", "```py\n# ...\ndef get_body_and_cond(inp):\n    n = inp\n    condition = lambda: n > 0\n\n    def body():\n        print(n)\n        n -= 1\n    return condition, body\n\nc, b = get_body_and_cond(float(input()))\n\nwhile_loop(c, b)\n```"]
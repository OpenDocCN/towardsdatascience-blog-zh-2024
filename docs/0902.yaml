- en: 3 Popular Methods for Spatial Interpolation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/3-best-methods-for-spatial-interpolation-912cab7aee47?source=collection_archive---------4-----------------------#2024-04-09](https://towardsdatascience.com/3-best-methods-for-spatial-interpolation-912cab7aee47?source=collection_archive---------4-----------------------#2024-04-09)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From scratch, in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@alexroz?source=post_page---byline--912cab7aee47--------------------------------)[![Aleksei
    Rozanov](../Images/748b69bfaccf39c9aa568a9e6f41eec3.png)](https://medium.com/@alexroz?source=post_page---byline--912cab7aee47--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--912cab7aee47--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--912cab7aee47--------------------------------)
    [Aleksei Rozanov](https://medium.com/@alexroz?source=post_page---byline--912cab7aee47--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--912cab7aee47--------------------------------)
    ·10 min read·Apr 9, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/001778775344af81b306237ca482d2f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation is a quite common mathematical concept, which is used not only
    by data scientists, but also people from a vast range of fields. However, when
    dealing with geospatial data, interpolation gets more complicated, since you need
    to create a representative grid based on several often sparse observations.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into geospatial part, let’s have a brief recap on linear interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: As always, to follow up the tutorial, you can download and run the notebook
    [here](https://github.com/alexxxroz/Medium/blob/main/SpatialInterpolation.ipynb).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For the purpose of demonstration I’ll use a regular polynomial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/cf8d98b5a651c1aa5f0a1d3acbbc0385.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can randomly sample several points [-4.2, 0, 2.5] and connect them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e8719b75ecd4d6a0fc7f3f0127f7eac7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: This is called linear interpolation, since the function is approximated by a
    straight line at each interval, and now, knowing function’s values only at 3 points,
    we can find the values inside the interval [-4.2;2.5].
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other methods, which have higher accuracy, but the idea behind
    them is the same: find the functions values between at least two known points.'
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to get to geospatial part. In this tutorial, our goal will be
    to perform spatial interpolation of daily average air temperature measured at
    meteorological sites across Switzerland provided by [NOAA](https://www.ncdc.noaa.gov/cdo-web/datatools/selectlocation).
    The expected result is a grid of temperatures with cells of 0.1° resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to acquire an administrative boundary of Switzerland and visualize
    it using geopandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5e55dea85838eb0bcc54cd63a1bb2fe8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, looks like it’s Switzerland, wow =)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s plot our temperature observations and overlay them with the country
    shape. To do that, let’s load meteorological data to regular pandas dataframe
    and then convert it to a geopandas one with coordinates transformed to the *shapely*
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After doing that we can easily overlay the two dataframes using *matplotlib*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f4faf1e5e8b63083eefa2d94851ca8a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize our task let’s create the grid for interpolation and overlay it
    with the map above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e4607c90b750b50ae111a917e734562d.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: So the goal is to produce interpolation on the regular grid illustrated above
    having 8 temperature observations.
  prefs: []
  type: TYPE_NORMAL
- en: I. Nearest Neighbor (NN)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first super intuitive and simple method is called Nearest Neighbor (NN).
    As you can guess from its name, the algorithm assigns the value of the nearest
    observation to each grid node.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement it we will need only two functions. The first function is called
    Euclidean, and it calculates the distance between two points using the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0d1d55d8a5f799b2ed5b785c283e1d97.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one is the NN method itself. After creating an empty array to store
    the values we iterate over all latitudes and longitudes, calculate distances from
    each point to the current grid node and assign the value of the closest observation
    to that grid node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole idea is here, in this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Variable data is our pandas dataframe with meteo sites (each row represents
    one site). So in the *for* loop we calculate the distance and find the index of
    the site with the minimum distance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s run the algorithm and wrap the results into xarray dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can plot the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/467e205cd93ce8b723cd2532c76ca361.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: 'Looks nice, but let’s enhance our plot by creating a Switzerland mask using
    regionmask library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e7f7730e717c2319598913a194acc95f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see this method might be applied only to categorical data. Since
    we are dealing with temperature, which is continuous variable, meaning it can
    take any value in a certain range, this interpolation is misleading. In real life
    there always gradients and randomness.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s have a look at more advanced algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: II. Inverse Distance Weighting (IDW)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basically, Inverse Distance Weighting (IDW) is an enhanced version of NN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, instead of assigning the value of the closest known point, here
    we calculate weights. To do that the aforementioned Euclidean distanced is used
    as well, but this time we raise each distance to the **-**β-th power (β is an
    arbitrary value). These weights are basically the contribution of each ground
    point to a certain grid node. The greater the distance, the less this point influence
    the node value.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the weights we calculate the weighted average.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e1e8c71eaf2d24be507f660bc5ad8a9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a8c951cc303dfcb26d32ae11e115651a.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s plot it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/92f3b15ccad15743feffd844cd4c00ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, now results are much more realistic and smooth!
  prefs: []
  type: TYPE_NORMAL
- en: III. Kriging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last method for today is Kriging. Among these three, this one is most complex,
    and we will only touch upon it. In case you want to use it consciously and effectively,
    consider having look at the literature!
  prefs: []
  type: TYPE_NORMAL
- en: So the main idea of the method is the usage of variogram (or semivariogram).
    In essence, a variogram quantifies how the variability of some parameter changes
    with distance and direction. This exactly what we need when dealing with air temperature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the Kriging algorithms we will need two types of variograms: **experimental**
    and **theoretical**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is really easy to calculate. It’s defined as **gamma γ**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4abd2abbed6ff877bef3b09fb87691a7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: where h — geographical distance between two points, z — temperature function.
    So in a nutshell it’s an average of temperature differences at known points.
  prefs: []
  type: TYPE_NORMAL
- en: 'The theoretical variogram is a little bit more complicated. Firstly, there
    are many of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2ee04146f677148333add1dd78b6b9ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: where p — is partial sill, d — distance (we used *h* before), n — nugget, r
    — range.
  prefs: []
  type: TYPE_NORMAL
- en: I found a really good visual explanation of these parameters at [CDT Columbia](https://iri.columbia.edu/~rijaf/CDTUserGuide/html/interpolation_methods.html).
    I adopted an image, which illustrates the dependence between **γ** and distance,
    from their material. As you can see now it’s clear what sill, partial sill, nugget
    and range are.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8565dd27b5eed2585089effddec4cff4.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: So the whole idea of the algorithm is to adjust the parameters of the parameters
    of theoretical variogram so it would fit to the experimental one and then predict
    the values of nodes using it.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the method we’ll need several extra libraries and to create a class
    called OrdinaryKriging.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s consider each function separately.
  prefs: []
  type: TYPE_NORMAL
- en: The **__init__** function besides initializing coordinates and values consists
    of three lists comprising possible values of nugget, sill and range. All three
    are mixed together in all possible combinations and stored in the parameter_combinations
    variable. We will need it later for searching the optimal ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function, **theoretical_variogram**, is simply a python implementation
    of one of the aforementioned formulas. In our case, it’s the *exponential* one
    (but you can write code for another one and compare the results):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The third class method **Euclidean**. It’s an altered version of the function
    we created for NN and IDW. This time we return a matrix (n,n) where each row represents
    distances between a point and all other points (one of the values in each row
    is 0, since the distance between a point and itself is 0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The fourth function performs the **fitting**. Here it obtains experimental variogram
    values and Euclidean distances. Then, iterating over our combinations of sill,
    range and nugget it calculates the theoretical variogram values with the following
    estimation of Mean Squared Error, or MSE, between theoretical and experimental
    values (but you can use other metrics). Then we save the optimal parameters to
    the class variable optimal_pars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And the last, but not least function is **predict**. Getting a point (lat;lon)
    as input, it estimates the distance between the point and other known values.
    Then it calls the theoretical_variogram function passing the optimal parameters
    we obtained earlier and getting weights as output. Then a weighted mean is calculated
    and returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can collect all the predictions and visualize the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1349a0969a19bd1bac7ea47919a97413.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the result is quite different from what we get from IDW. For
    Kriging the most important parameter is the kind of theoretical variogram you
    pick, since it basically defines the relationship between the predicted values
    and distance. In case you don’t want to play around with the code I provide here
    or your own, you can explore [PyKrige](https://geostat-framework.readthedocs.io/projects/pykrige/en/stable/#license)
    library which has implementations of many variogram models.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully this article was informative and insightful for you!
  prefs: []
  type: TYPE_NORMAL
- en: ===========================================
  prefs: []
  type: TYPE_NORMAL
- en: '***All my publications on Medium are free and open-access, that’s why I’d really
    appreciate if you followed me here!***'
  prefs: []
  type: TYPE_NORMAL
- en: P.s. I’m extremely passionate about (Geo)Data Science, ML/AI and Climate Change.
    So if you want to work together on some project pls contact me in [LinkedIn](https://www.linkedin.com/in/alexxxroz/).
  prefs: []
  type: TYPE_NORMAL
- en: 🛰️Follow for more🛰️
  prefs: []
  type: TYPE_NORMAL

["```py\nimport numpy as np\nimport pandas as pd\nimport scipy.stats as stats\n\ndef create_experiment_data(n_mice, mu, sigma, seed):\n      lower, upper = 0, np.inf\n      initial_weights = stats.truncnorm(\n          (lower - mu) / sigma,\n          (upper - mu) / sigma,\n          loc=mu,\n          scale=sigma\n      ).rvs(size=n_mice, random_state=seed)\n      return pd.DataFrame({\n          'mice': list(range(1, n_mice+1)),\n          'initial_weight': initial_weights,\n      })\n\ntumor_data = create_experiment_data(n_mice=20, mu=200, sigma=300, seed=123)\nprint(tumor_data.head())\n```", "```py\n>    mice  initial_weight\n0     1      424.736888\n1     2      174.691035\n2     3      141.016478\n3     4      327.518749\n4     5      442.239789\n```", "```py\nmean = tumor_data['initial_weight'].mean()\nstd = tumor_data['initial_weight'].std()\n\ntumor_data['norm_initial_weight'] = (tumor_data['initial_weight'] - mean) / std\n```", "```py\nfrom ortools.linear_solver import pywraplp\nfrom typing import Union\n\nclass SingleFeatureOptimizationModel:\n    \"\"\"\n    Implements the discrete optimization model proposed by Bertsimas et al. (2015) in \"The Power of \n    Optimization Over Randomization in Designing Experiments Involving Small Samples\". \n    See: https://doi.org/10.1287/opre.2015.1361.\n    \"\"\"\n\n    def __init__(self, data: pd.DataFrame, n_groups: int, units_per_group: int, metric: str, unit: str):\n        self.data = data.reset_index(drop=True)\n        self.parameters = {\n            'rho': 0.5,\n            'groups': range(n_groups),\n            'units': range(len(self.data)),\n            'unit_list': self.data[unit].tolist(),\n            'metric_list': self.data[metric].tolist(),\n            'units_per_group': units_per_group,\n        }\n        self._create_solver()\n        self._add_vars()\n        self._add_constraints()\n        self._set_objective()\n\n    def _create_solver(self):\n        self.model = pywraplp.Solver.CreateSolver(\"SCIP\")\n        if self.model is None:\n            raise Exception(\"Failed to create SCIP solver\")\n\n    def _add_vars(self):\n        self.d = self.model.NumVar(0, self.model.infinity(), \"d\")\n        self.x = {}\n        for i in self.parameters['units']:\n            for p in self.parameters['groups']:\n                self.x[i, p] = self.model.IntVar(0, 1, \"\")\n\n    def _set_objective(self):\n        self.model.Minimize(self.d)\n\n    def _add_constraints(self):\n        self._add_constraints_d_bounding()\n        self._add_constraint_group_size()\n        self._add_constraint_all_units_assigned()\n\n    def _add_constraints_d_bounding(self):\n        rho = self.parameters['rho']\n        for p in self.parameters['groups']:\n            for q in self.parameters['groups']:\n                if p < q:\n                    self.model.Add(self.d >= self._mu(p) - self._mu(q) + rho * self._var(p) - rho * self._var(q))\n                    self.model.Add(self.d >= self._mu(p) - self._mu(q) + rho * self._var(q) - rho * self._var(p))\n                    self.model.Add(self.d >= self._mu(q) - self._mu(p) + rho * self._var(p) - rho * self._var(q))\n                    self.model.Add(self.d >= self._mu(q) - self._mu(p) + rho * self._var(q) - rho * self._var(p))\n\n    def _add_constraint_group_size(self):\n        for p in self.parameters['groups']:\n            self.model.Add(\n                self.model.Sum([\n                    self.x[i,p] for i in self.parameters['units']\n                ]) == self.parameters['units_per_group']\n                )\n\n    def _add_constraint_all_units_assigned(self):\n        for i in self.parameters['units']:\n            self.model.Add(\n                self.model.Sum([\n                    self.x[i,p] for p in self.parameters['groups']\n                ]) == 1\n                )\n\n    def _add_contraint_symmetry(self):\n        for i in self.parameters['units']:\n            for p in self.parameters['units']: \n                if i < p:\n                    self.model.Add(\n                        self.x[i,p] == 0 \n                        )\n\n    def _mu(self, p):\n        mu = self.model.Sum([\n            (self.x[i,p] * self.parameters['metric_list'][i]) / self.parameters['units_per_group']\n            for i in self.parameters['units']\n            ])\n        return mu\n\n    def _var(self, p):\n        var = self.model.Sum([\n            (self.x[i,p]*(self.parameters['metric_list'][i])**2) / self.parameters['units_per_group']\n            for i in self.parameters['units']\n            ])\n        return var\n\n    def optimize(\n            self,\n            max_run_time: int = 60,\n            max_solution_gap: float = 0.05,\n            max_solutions: Union[int, None] = None,\n            num_threads: int = -1,\n            verbose: bool = False\n    ):\n        \"\"\"\n        Runs the optimization model.\n\n        Args:\n            max_run_time: int\n                Maximum run time in minutes.\n            max_solution_gap: float\n                Maximum gap with the LP relaxation solution.\n            max_solutions: int\n                Maximum number of solutions until stop.\n            num_threads: int\n                Number of threads to use in solver.\n            verbose: bool\n                Whether to set the solver output.\n\n        Returns: str\n            The status of the solution.\n        \"\"\"\n        self.model.SetTimeLimit(max_run_time * 60 * 1000)\n        self.model.SetNumThreads(num_threads)\n\n        if verbose:\n            self.model.EnableOutput()\n\n        self.model.SetSolverSpecificParametersAsString(f\"limits/gap = {max_solution_gap}\")\n        self.model.SetSolverSpecificParametersAsString(f\"limits/time = {max_run_time * 60}\")\n\n        if max_solutions:\n            self.model.SetSolverSpecificParametersAsString(f\"limits/solutions = {max_solutions}\")\n\n        status = self.model.Solve()\n\n        if verbose:\n            if status == pywraplp.Solver.OPTIMAL:\n                print(\"Optimal Solution Found.\")\n            elif status == pywraplp.Solver.FEASIBLE:\n                print(\"Feasible Solution Found.\")\n            else:\n                print(\"Problem infeasible or unbounded.\")\n\n        self._extract_solution()\n        return status\n\n    def _extract_solution(self):\n        tol = 0.01\n        self.assignment = {}\n        for i in self.parameters['units']:\n            for p in self.parameters['groups']:\n                if self.x[i,p].solution_value() > tol:\n                    self.assignment.setdefault(p, []).append(self.parameters['unit_list'][i])\n\n    def get_groups_list(self):\n        return list(self.assignment.values())\n```", "```py\nmodel = SingleFeatureOptimizationModel(\n    data = tumor_data,\n    n_groups = 2,\n    units_per_group = 10,\n    unit = 'mice',\n    metric = 'norm_initial_weight',\n\n)\n\nstatus = model.optimize()\noptimized_groups = model.get_groups_list()\nprint(f\"The optimized mice groups are: {optimized_groups}\")\n```", "```py\n> The optimized mice groups are: [\n   [1, 4, 5, 6, 8, 12, 14, 16, 17, 18], \n   [2, 3, 7, 9, 10, 11, 13, 15, 19, 20]\n  ]\n```", "```py\nimport random\n\ndef random_shuffle_groups(group_list, seed):\n  random.seed(seed)\n  random.shuffle(group_list)\n  return group_list\n\nrandomized_groups = random_shuffle_groups(optimized_groups, seed=123)\ntreatment_labels = [\"Placebo\", \"Treatment\"]\ntreatment_dict = {treatment_labels[i]: randomized_groups[i] for i in range(len(randomized_groups))}\nprint(f\"The treatment assignment is: {treatment_dict}\")\n```", "```py\n> The treatment assignment is: {\n   'Placebo': [2, 3, 7, 9, 10, 11, 13, 15, 19, 20], \n   'Treatment': [1, 4, 5, 6, 8, 12, 14, 16, 17, 18]\n}\n```", "```py\nmice_assignment_dict = {inx: gp for gp, indices in treatment_dict.items() for inx in indices}\ntumor_data['treatment'] = tumor_data['mice'].map(mice_assignment_dict)\n\nprint(tumor_data.groupby('treatment').agg(\n    avg_initial_weight = ('initial_weight', 'mean'),\n    std_initial_weight = ('initial_weight', 'std'),\n).round(2))\n```", "```py\n>          avg_initial_weight  std_initial_weight\ntreatment                                        \nPlacebo                302.79              202.54\nTreatment              303.61              162.12\n```", "```py\nimport numpy as np\nfrom scipy.integrate import odeint\n\n# Gompertz model parameters\na = 1 \nb = 5\n\n# Critical weight\nwc = 400\n\ndef gompex_growth(w, t):\n    \"\"\"\n    Gomp-ex differential equation model based on the initial weight.\n    \"\"\"\n    growth_rate = a + max(0, b * np.log(wc / w))\n    return w * growth_rate\n\ndef simulate_growth(w_initial, t_span):\n    \"\"\"\n    Simulate the tumor growth using the Gomp-ex model.\n    \"\"\"\n    return odeint(gompex_growth, w_initial, t_span).flatten()\n\ndef simulate_tumor_growth(data: pd.DataFrame, initial_weight: str, treatment_col: str, treatment_value: str, treatment_effect: float):\n    \"\"\"\n    Simulate the tumor growth experiment and return the dataset.\n    \"\"\"\n    t_span = np.linspace(0, 1, 2)\n    final_weights = np.array([simulate_growth(w, t_span)[-1] for w in data[initial_weight]])\n\n    experiment_data = data.copy()\n    mask_treatment = data[treatment_col] == treatment_value\n    experiment_data['final_weight'] = np.where(mask_treatment, final_weights + treatment_effect, final_weights)\n\n    return experiment_data.round(2)\n\nexperiment_data = simulate_tumor_growth(\n    data = tumor_data, \n    initial_weight = 'initial_weight', \n    treatment_col = 'treatment', \n    treatment_value = 'Treatment', \n    treatment_effect = -250\n)\n\nprint(experiment_data.head())\n```", "```py\n>   mice  initial_weight  norm_initial_weight  treatment  final_weight\n0     1          424.74                 0.68  Treatment        904.55\n1     2          174.69                -0.72    Placebo        783.65\n2     3          141.02                -0.91    Placebo        754.56\n3     4          327.52                 0.14  Treatment        696.60\n4     5          442.24                 0.78  Treatment        952.13\n```", "```py\nmask_tr = experiment_data.group == 'Treatment'\nmean_tr = experiment_data[mask_tr]['final_weight'].mean()\nmean_co = experiment_data[~mask_tr]['final_weight'].mean()\nprint(f\"Mean difference between treatment and control: {round(mean_tr - mean_co)} mg\")\n```", "```py\n> Mean difference between treatment and control: -260 mg\n```", "```py\nfrom tqdm import tqdm\nfrom typing import Any, List\n\ndef inference(data: pd.DataFrame, unit: str, outcome: str, treatment: str, treatment_value: Any = 1, n_bootstrap: int = 1000) -> pd.DataFrame:\n    \"\"\"\n    Estimates the p-value using bootstrap for two groups.\n\n    Parameters\n    -----------\n    data (pd.DataFrame): The experimental dataset with the observed outcome.\n    unit (str): The experimental unit column.\n    outcome (str): The outcome metric column.\n    treatment (str): The treatment column.\n    treatment_value (Any): The value referencing the treatment (other will be considered as control).\n    n_bootstrap (int): The number of random draws with replacement to use.\n\n    Returns\n    -----------\n    pd.DataFrame: The dataset with the results.\n\n    Raise\n    ------------\n    ValueException: if there are more than two treatment values.\n    \"\"\"\n    responses = data[outcome].values\n    mask_tr = (data[treatment] == treatment_value).values\n    delta_obs = _compute_delta(responses[mask_tr], responses[~mask_tr])\n    deltas_B = _run_bootstrap(data, unit, outcome, n_bootstrap)\n    pvalue = _compute_pvalue(delta_obs, deltas_B)\n    output_data = pd.DataFrame({\n        'delta': [delta_obs],\n        'pvalue': [pvalue],\n        'n_bootstrap': [n_bootstrap],\n        'avg_delta_bootstrap': [np.round(np.mean(deltas_B), 2)],\n        'std_delta_bootstrap': [np.round(np.std(deltas_B), 2)]\n    })\n    return output_data\n\ndef _run_bootstrap(data: pd.DataFrame, unit: str, outcome: str, B: int = 1000) -> List[float]:\n    \"\"\"\n    Runs the bootstrap method and returns the bootstrapped deltas.\n\n    Parameters\n    -----------\n    data (pd.DataFrame): The dataframe from which sample with replacement.\n    outcome (str): The outcome metric observed in the experiment.\n    B (int): The number of random draws with replacement to perfrom.\n\n    Returns\n    -----------\n    List[float]: The list of bootstrap deltas.\n    \"\"\"\n    deltas_bootstrap = []\n    for i in tqdm(range(B), desc=\"Bootstrap Progress\"):\n        sample_b = _random_draw_with_replacement(data, unit)\n        responses_b, mask_tr_b = _optimal_treatment_control_split(sample_b, unit, outcome, seed=i)\n        delta_b = _compute_delta(responses_b[mask_tr_b], responses_b[~mask_tr_b])\n        deltas_bootstrap.append(delta_b)\n\n    return deltas_bootstrap\n\ndef _compute_delta(response_tr, responses_co):\n    delta = np.mean(response_tr) - np.mean(responses_co)\n    return delta\n\ndef _compute_pvalue(obs_delta, bootstrap_deltas):\n    count_extreme = sum(1 for delta_b in bootstrap_deltas if abs(delta_b) >= abs(obs_delta))\n    p_value = (1 + count_extreme) / (1 + len(bootstrap_deltas))\n    return p_value\n\ndef _random_draw_with_replacement(data: pd.DataFrame, unit: str):\n    sample = data.sample(frac=1, replace=True)\n    sample[unit] = range(1, len(sample) + 1)\n    return sample\n\ndef _optimal_treatment_control_split(data: pd.DataFrame, unit: str, outcome: str, seed: int):\n    result = _sample(\n        data = data, \n        unit = unit,\n        normalized_feature = 'norm_initial_weight',\n        seed = seed\n    )\n    treatment_dict = {inx: gp for gp, indices in result.items() for inx in indices}\n    treatment = data[unit].map(treatment_dict)\n    mask_tr = (treatment == 'Treatment').values\n    responses = data[outcome].values\n    return responses, mask_tr\n\ndef _sample(data: pd.DataFrame, unit: str, normalized_feature: str, seed: int):\n    model = SingleFeatureOptimizationModel(\n        data, \n        n_groups = 2, \n        units_per_group = 10, \n        unit = unit, \n        metric = normalized_feature,\n    )\n    status = model.optimize()\n    optimized_groups = model.get_groups_list()\n    randomized_groups = random_shuffle_groups(optimized_groups, seed=seed)\n    treatment_labels = [\"Placebo\", \"Treatment\"]\n    return {treatment_labels[i]: randomized_groups[i] for i in range(len(randomized_groups))}\n```", "```py\ninfer_result = inference(\n    data = experiment_data, \n    unit = 'mice',\n    outcome = 'final_weight',\n    treatment = 'group',\n    treatment_value = 'Treatment',\n    n_bootstrap = 1000\n)\n\nprint(infer_result)\n```", "```py\n>     delta    pvalue  n_bootstrap  avg_delta_bootstrap  std_delta_bootstrap\n0 -260.183  0.001998         1000                 2.02               112.61\n```"]
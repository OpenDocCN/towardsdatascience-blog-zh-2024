["```py\n# Read women's data\nw_data = (\n    spark.read.option(\"header\", True)\n    .option(\"inferSchema\", True)\n    .csv(f\"Files/WNCAATourneyDetailedResults.csv\")\n    .cache()\n)\n```", "```py\n# Read women's data\n...\n\n# Read men's data\nm_data = (\n    spark.read.option(\"header\", True)\n    .option(\"inferSchema\", True)\n    .csv(f\"Files/MNCAATourneyDetailedResults.csv\")\n    .cache()\n)\n\n# Combine (union) the DataFrames\ncombined_results = m_data.unionByName(w_data)\n```", "```py\n# Selecting a single column\nw_scores = w_data.select(\"WScore\")\n\n# Selecting multiple columns\nteamid_w_scores = w_data.select(\"WTeamID\", \"WScore\")\n```", "```py\n+------+\n|Season|\n+------+\n|  2010|\n|  2010|\n|  2010|\n|  2010|\n|  2010|\n+------+\nonly showing top 5 rows\n```", "```py\nwinners = w_data.select(\n    w_data.WTeamID.alias(\"TeamID\"),\n    w_data.WScore.alias(\"Score\")\n)\n```", "```py\n# Grouping and aggregating\nwinners_average_scores = winners.groupBy(\"TeamID\").avg(\"Score\")\n```", "```py\n+------+-----------------+\n|TeamID|       avg(Score)|\n+------+-----------------+\n|  3125|             68.5|\n|  3345|             74.2|\n|  3346|79.66666666666667|\n|  3376|73.58333333333333|\n|  3107|             61.0|\n+------+-----------------+\n```", "```py\n# Joining on Season and TeamID\nfinal_df = matches_df.join(stats_df, on=['Season', 'TeamID'], how='left')\n```", "```py\nfrom pyspark.sql import functions as F\n\nw_data = w_data.withColumn(\"HighScore\", F.when(F.col(\"Score\") > 80, \"Yes\").otherwise(\"No\"))\n```", "```py\n# Columns that we'll want to get statistics from\nboxscore_cols = [\n    'T1_FGM', 'T1_FGA', 'T1_FGM3', 'T1_FGA3', 'T1_OR', 'T1_DR', 'T1_Ast', 'T1_Stl', 'T1_PF', \n    'T2_FGM', 'T2_FGA', 'T2_FGM3', 'T2_FGA3', 'T2_OR', 'T2_DR', 'T2_Ast', 'T2_Stl', 'T2_PF'\n]\n```", "```py\nfrom pyspark.sql import functions as F\nfrom pyspark.sql.functions import col  # select a column\n\nagg_exprs = {col: F.mean(col).alias(col + 'mean') for col in boxscore_cols}\n```", "```py\nseason_statistics = regular_data.groupBy([\"Season\", \"T1_TeamID\"]).agg(*agg_exprs.values())\n```", "```py\n# Rename columns for T1\nfor col in boxscore_cols:\n    season_statistics = season_statistics.withColumnRenamed(col + 'mean', 'T1_' + col[3:] + 'mean') if 'T1_' in col \\\n        else season_statistics.withColumnRenamed(col + 'mean', 'T1_opponent_' + col[3:] + 'mean')\n```", "```py\nseason_statistics_T2 = season_statistics.select(\n    *[F.col(col).alias(col.replace('T1_opponent_', 'T2_opponent_').replace('T1_', 'T2_')) if col not in ['Season'] else F.col(col) for col in season_statistics.columns]\n)\n```", "```py\ntourney_df = tourney_df.join(season_statistics, on=['Season', 'T1_TeamID'], how='left')\ntourney_df = tourney_df.join(season_statistics_T2, on=['Season', 'T2_TeamID'], how='left')\n```", "```py\n# Function to calculate expected score\ndef expected_score(ra, rb):\n    # ra = rating (Elo) team A\n    # rb = rating (Elo) team B\n    # Elo function\n    return 1 / (1 + 10 ** ((rb - ra) / 400))\n```", "```py\n# Function to update Elo ratings, keeping T1 and T2 terminology\ndef update_elo(t1_elo, t2_elo, location, T1_Score, T2_Score):\n    expected_t1 = expected_score(t1_elo, t2_elo)\n    expected_t2 = expected_score(t2_elo, t1_elo)\n\n    actual_t1 = 1 if T1_Score > T2_Score else 0\n    actual_t2 = 1 - actual_t1\n\n    # Determine K based on game location\n    # The larger the K, the bigger the impact\n    # team1 winning at home (location=1) less impressive than winning away (location = -1)\n    if actual_t1 == 1:  # team1 won\n        if location == 1:\n            k = 20\n        elif location == 0:\n            k = 30\n        else:  # location = -1\n            k = 40\n    else:  # team2 won\n        if location == 1:\n            k = 40\n        elif location == 0:\n            k = 30\n        else:  # location = -1\n            k = 20\n\n    new_t1_elo = t1_elo + k * (actual_t1 - expected_t1)\n    new_t2_elo = t2_elo + k * (actual_t2 - expected_t2)\n\n    return new_t1_elo, new_t2_elo\n```", "```py\ndef calculate_elo_through_seasons(regular_data):\n\n    # For this feature, using Pandas\n    regular_data = regular_data.toPandas()\n\n    # Set value of initial elo\n    initial_elo = 1500\n\n    # DataFrame to collect final Elo ratings\n    final_elo_list = []\n\n    for season in sorted(regular_data['Season'].unique()):\n        print(f\"Season: {season}\")\n        # Initialize elo ratings dictionary\n        elo_ratings = {}\n\n        print(f\"Processing Season: {season}\")\n        # Get the teams that played in the season\n        season_teams = set(regular_data[regular_data['Season'] == season]['T1_TeamID']).union(set(regular_data[regular_data['Season'] == season]['T2_TeamID']))\n\n        # Initialize season teams' Elo ratings\n        for team in season_teams:\n            if (season, team) not in elo_ratings:\n                elo_ratings[(season, team)] = initial_elo\n\n        # Update Elo ratings per game\n        season_games = regular_data[regular_data['Season'] == season]\n        for _, row in season_games.iterrows():\n            t1_elo = elo_ratings[(season, row['T1_TeamID'])]\n            t2_elo = elo_ratings[(season, row['T2_TeamID'])]\n\n            new_t1_elo, new_t2_elo = update_elo(t1_elo, t2_elo, row['location'], row['T1_Score'], row['T2_Score'])\n\n            # Only keep the last season rating\n            elo_ratings[(season, row['T1_TeamID'])] = new_t1_elo\n            elo_ratings[(season, row['T2_TeamID'])] = new_t2_elo\n\n        # Collect final Elo ratings for the season\n        for team in season_teams:\n            final_elo_list.append({'Season': season, 'TeamID': team, 'Elo': elo_ratings[(season, team)]})\n\n    # Convert list to DataFrame\n    final_elo_df = pd.DataFrame(final_elo_list)\n\n    # Separate DataFrames for T1 and T2\n    final_elo_t1_df = final_elo_df.copy().rename(columns={'TeamID': 'T1_TeamID', 'Elo': 'T1_Elo'})\n    final_elo_t2_df = final_elo_df.copy().rename(columns={'TeamID': 'T2_TeamID', 'Elo': 'T2_Elo'})\n\n    # Convert the pandas DataFrames back to Spark DataFrames\n    final_elo_t1_df = spark.createDataFrame(final_elo_t1_df)\n    final_elo_t2_df = spark.createDataFrame(final_elo_t2_df)\n\n    return final_elo_t1_df, final_elo_t2_df\n```"]
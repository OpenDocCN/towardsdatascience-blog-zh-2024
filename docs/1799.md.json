["```py\n#used to label and construct each feature dataframe.\ndef gen_df(category, series):\n    gen_ser = fred.get_series(series, frequency='q')\n    return pd.DataFrame({'Date': gen_ser.index, category + ' : Billions of dollars': gen_ser.values})\n#used to merge every constructed dataframe.\ndef merge_dataframes(dataframes, on_column):\n    merged_df = dataframes[0]\n    for df in dataframes[1:]:\n        merged_df = pd.merge(merged_df, df, on=on_column)\n    return merged_df\n#list of features to be used \ndataframes_list = [\n    gen_df('GDP', 'GDP'),\n    gen_df('PCE', 'PCE'),\n    gen_df('GPDI', 'GPDI'),\n    gen_df('NETEXP', 'NETEXP'),\n    gen_df('GovTotExp', 'W068RCQ027SBEA')\n]\n#defining and displaying dataset\ndata = merge_dataframes(dataframes_list,'Date')\ndata\n```", "```py\n#separating date column from feature columns\ndate_column = 'Date'\nfeature_columns = data.columns.difference([date_column])\n#set the plot \nfig, ax = plt.subplots(figsize=(10, 6))\nfig.suptitle('Features vs Time', y=1.02)\n#graphing features onto plot\nfor i, feature in enumerate(feature_columns):\n    ax.plot(data[date_column], data[feature], label=feature, color=plt.cm.viridis(i / len(feature_columns)))\n#label axis\nax.set_xlabel('Date')\nax.set_ylabel('Billions of Dollars')\nax.legend(loc='upper left', bbox_to_anchor=(1, 1))\n#display the plot \nplt.show()\n```", "```py\nfrom statsmodels.tsa.stattools import adfuller\n#iterating through each feature\nfor column in data.columns:\n    if column != 'Date':\n        result = adfuller(data[column])\n        print(f\"ADF Statistic for {column}: {result[0]}\")\n        print(f\"P-value for {column}: {result[1]}\")\n        print(\"Critical Values:\")\n        for key, value in result[4].items():\n            print(f\"  {key}: {value}\")\n#creating separation line between each feature\n        print(\"\\n\" + \"=\" * 40 + \"\\n\")\n```", "```py\n#differencing and storing original dataset \ndata_diff = data.drop('Date', axis=1).diff().dropna()\n#printing ADF test for new dataset\nfor column in data_diff.columns:\n    result = adfuller(data_diff[column])\n    print(f\"ADF Statistic for {column}: {result[0]}\")\n    print(f\"P-value for {column}: {result[1]}\")\n    print(\"Critical Values:\")\n    for key, value in result[4].items():\n        print(f\"  {key}: {value}\")\n\n    print(\"\\n\" + \"=\" * 40 + \"\\n\") \n```", "```py\nfrom statsmodels.tsa.stattools import grangercausalitytests\ncolumns = ['PCE : Billions of dollars', 'GPDI : Billions of dollars', 'NETEXP : Billions of dollars', 'GovTotExp : Billions of dollars']\nlags = [6, 9, 1, 1] #determined from individually testing each combination\n\nfor column, lag in zip(columns, lags):\n    df_new = data_diff[['GDP : Billions of dollars', column]]\n    print(f'For: {column}')\n    gc_res = grangercausalitytests(df_new, lag)\n    print(\"\\n\" + \"=\" * 40 + \"\\n\")\n```", "```py\n#90-10 data split\nsplit_index = int(len(data_diff) * 0.90)\ntrain_data = data_diff.iloc[:split_index]\ntest_data = data_diff.iloc[split_index:]\n#Assigning GDP column to target variable \nX_train = train_data.drop('GDP : Billions of dollars', axis=1)\ny_train = train_data['GDP : Billions of dollars']\nX_test = test_data.drop('GDP : Billions of dollars', axis=1)\ny_test = test_data['GDP : Billions of dollars']\n```", "```py\nfrom sklearn.ensemble import RandomForestRegressor\n#fitting model \nrf_model = RandomForestRegressor(n_estimators=100, random_state=42)\nrf_model.fit(X_train, y_train)\n\ny_pred = rf_model.predict(X_test)\n#plotting results\nprintevals(y_test,y_pred)\nplotresults('Actual vs Forecasted GDP using Random Forest')\n```", "```py\nfrom sklearn.neighbors import KNeighborsRegressor\n#iterate over all k=1 to k=10\nfor i in range (1,10):\n    knn_model = KNeighborsRegressor(n_neighbors=i)\n    knn_model.fit(X_train, y_train)\n\n    y_pred = knn_model.predict(X_test)\n#print evaluation for each k\n    print(f'for k = {i} ')\n    printevals(y_test,y_pred)\n    print(\"\\n\" + \"=\" * 40 + \"\\n\")\n```", "```py\n#applying model with optimal k value\nknn_model = KNeighborsRegressor(n_neighbors=2)\nknn_model.fit(X_train, y_train)\n\ny_pred = knn_model.predict(X_test)\n\nprintevals(y_test,y_pred)\n\nplotresults('Actual vs Forecasted GDP using KNN')\n```"]
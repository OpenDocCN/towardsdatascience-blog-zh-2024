["```py\nimport pandas as pd\nimport gpxpy\n\n# read file\nwith open('juan.gpx', 'r') as gpx_file:\n    juan_gpx = gpxpy.parse(gpx_file)\n\n# Convert JuanÂ´s gpx to dataframe\njuan_route_info = []\n\nfor track in juan_gpx.tracks:\n    for segment in track.segments:\n        for point in segment.points:\n            juan_route_info.append({\n                'latitude': point.latitude,\n                'longitude': point.longitude,\n                'elevation': point.elevation,\n                'date_time': point.time\n            })\n\njuan_df =  pd.DataFrame(juan_route_info)\njuan_df\n```", "```py\n# First Calculate elevation diff\njuan_df['elevation_diff'] = juan_df['elevation'].diff()\n\n# Calculate the difference in seconds between datapoints\njuan_df['seconds_diff'] = juan_df['date_time'].diff()\n```", "```py\nimport haversine as hs\n\n# Function to calculate haversine distances\ndef haversine_distance(lat1, lon1, lat2, lon2) -> float:\n    distance = hs.haversine(\n        point1=(lat1, lon1),\n        point2=(lat2, lon2),\n        unit=hs.Unit.METERS\n    )\n\n    # Returns the distance between the first point and the second point\n    return np.round(distance, 2)\n\n#calculate the distances between all data points\ndistances = [np.nan]\n\nfor i in range(len(track_df)):\n    if i == 0:\n        continue\n    else:\n        distances.append(haversine_distance(\n            lat1=juan_df.iloc[i - 1]['latitude'],\n            lon1=juan_df.iloc[i - 1]['longitude'],\n            lat2=juan_df.iloc[i]['latitude'],\n            lon2=juan_df.iloc[i]['longitude']\n        ))\n\njuan_df['distance_diff'] = distances\n```", "```py\n# Calculate the cumulative sum of the distance\njuan_df['distance_cum'] = juan_df['distance_diff'].cumsum()\n```", "```py\n## Function: **interpolate_value**()\n\n**Input**: \n    - *start*: The starting value.\n    - *end*: The ending value.\n    - *fraction*: A value between 0 and 1 that represents the position between \n      the start and end values where the interpolation should occur.\n**Return**:\n    - The interpolated value that lies between the *start* and *end* values \n      at the specified *fraction*.\n```", "```py\ndef interpolate_value(start, end, fraction):\n    return start + (end - start) * fraction\n```", "```py\n## Function: **interpolate_laps()**\n\n**Input**: \n    - track_df: dataframe with track data.\n    - lap_distance: metres per lap (default 1000)\n**Return**:\n    - track_laps: dataframe with lap metrics. As many rows as laps identified.\n```", "```py\ndef interpolate_laps(track_df , lap_distance = 1000):\n  #### 1\\. Initialise track_laps with the first row of track_df \n  track_laps = track_df.loc[0][['latitude','longitude','elevation','date_time','distance_cum']].copy()\n\n  # Set distance_cum = 0\n  track_laps[['distance_cum']] = 0\n\n  # Transpose dataframe\n  track_laps = pd.DataFrame(track_laps)\n  track_laps = track_laps.transpose()\n\n  #### 2\\. Calculate number_of_laps = Total Distance / lap_distance\n  number_of_laps = track_df['distance_cum'].max()//lap_distance\n\n  #### 3\\. For each lap i from 1 to number_of_laps:\n  for i in range(1,int(number_of_laps+1),1):\n\n    # a. Calculate target_distance = i * lap_distance\n    target_distance = i*lap_distance\n\n    # b. Find first_crossing_index where track_df['distance_cum'] > target_distance\n    first_crossing_index = (track_df['distance_cum'] > target_distance).idxmax()\n\n    # c. If match is exactly the lap distance, copy that row\n    if (track_df.loc[first_crossing_index]['distance_cum'] == target_distance):\n      new_row = track_df.loc[first_crossing_index][['latitude','longitude','elevation','date_time','distance_cum']]\n\n    # Else: Create new_row with interpolated values, copy that row.\n    else: \n\n      fraction = (target_distance - track_df.loc[first_crossing_index-1, 'distance_cum']) / (track_df.loc[first_crossing_index, 'distance_cum'] - track_df.loc[first_crossing_index-1, 'distance_cum'])\n\n      # Create the new row\n      new_row = pd.Series({\n          'latitude': interpolate_value(track_df.loc[first_crossing_index-1, 'latitude'], track_df.loc[first_crossing_index, 'latitude'], fraction),\n          'longitude': interpolate_value(track_df.loc[first_crossing_index-1, 'longitude'], track_df.loc[first_crossing_index, 'longitude'], fraction),\n          'elevation': interpolate_value(track_df.loc[first_crossing_index-1, 'elevation'], track_df.loc[first_crossing_index, 'elevation'], fraction),\n          'date_time': track_df.loc[first_crossing_index-1, 'date_time'] + (track_df.loc[first_crossing_index, 'date_time'] - track_df.loc[first_crossing_index-1, 'date_time']) * fraction,\n          'distance_cum': target_distance\n      }, name=f'lap_{i}')\n\n    # d. Add the new row to the dataframe that stores the laps\n    new_row_df = pd.DataFrame(new_row)\n    new_row_df = new_row_df.transpose()\n\n    track_laps = pd.concat([track_laps,new_row_df])\n\n  #### 4\\. Convert date_time to datetime format and remove timezone\n  track_laps['date_time'] = pd.to_datetime(track_laps['date_time'], format='%Y-%m-%d %H:%M:%S.%f%z')\n  track_laps['date_time'] = track_laps['date_time'].dt.tz_localize(None)\n\n  #### 5\\. Calculate seconds_diff between consecutive rows in track_laps\n  track_laps['seconds_diff'] = track_laps['date_time'].diff()\n\n  return track_laps\n```", "```py\njuan_laps = interpolate_laps(juan_df , lap_distance=1000)\n```", "```py\n## Helper Functions:\n- **get_seconds**(): Convert timedelta to total seconds\n- **format_timedelta**(): Format timedelta as a string (e.g., \"+01:23\" or \"-00:45\")\n```", "```py\n# Convert timedelta to total seconds\ndef get_seconds(td):\n    # Convert to total seconds\n    total_seconds = td.total_seconds()    \n\n    return total_seconds\n\n# Format timedelta as a string (e.g., \"+01:23\" or \"-00:45\")\ndef format_timedelta(td):\n    # Convert to total seconds\n    total_seconds = td.total_seconds()\n\n    # Determine sign\n    sign = '+' if total_seconds >= 0 else '-'\n\n    # Take absolute value for calculation\n    total_seconds = abs(total_seconds)\n\n    # Calculate minutes and remaining seconds\n    minutes = int(total_seconds // 60)\n    seconds = int(total_seconds % 60)\n\n    # Format the string\n    return f\"{sign}{minutes:02d}:{seconds:02d}\"\n```", "```py\n## Function: **gap_to_reference**()\n\n**Input**: \n    - laps_dict: dictionary containing the df_laps for all the runnners' names\n    - df_dict: dictionary containing the track_df for all the runnners' names\n    - reference_name: name of the reference\n**Return**:\n    - matches: processed data with time differences.\n```", "```py\n def gap_to_reference(laps_dict, df_dict, reference_name):\n  #### 1\\. Get the reference's lap data from laps_dict\n  matches = laps_dict[reference_name][['latitude','longitude','date_time','distance_cum']]\n\n  #### 2\\. For each racer (name) and their data (df) in df_dict:\n  for name, df in df_dict.items():\n\n    # If racer is the reference: \n    if name == reference_name:\n\n      # Set time difference to zero for all laps\n      for lap, row  in matches.iterrows():\n        matches.loc[lap,f'seconds_to_reference_{reference_name}'] = 0\n\n    # If racer is not the reference:\n    if name != reference_name:\n\n      # a. For each lap find the nearest point in racer's data based on lat, lon.\n      for lap, row  in matches.iterrows():\n\n        # Step 1: set the position and lap distance from the reference\n        target_coordinates = matches.loc[lap][['latitude', 'longitude']].values\n        target_distance = matches.loc[lap]['distance_cum']\n\n        # Step 2: find the datapoint that will be in the centre of the window\n        first_crossing_index = (df_dict[name]['distance_cum'] > target_distance).idxmax()\n\n        # Step 3: select the 20 candidate datapoints to look for the match\n        window_size = 20\n        window_sample = df_dict[name].loc[first_crossing_index-(window_size//2):first_crossing_index+(window_size//2)]\n        candidates = window_sample[['latitude', 'longitude']].values\n\n        # Step 4: get the nearest match using the coordinates\n        nn = NearestNeighbors(n_neighbors=1, metric='euclidean')\n        nn.fit(candidates)\n        distance, indice = nn.kneighbors([target_coordinates])\n\n        nearest_timestamp = window_sample.iloc[indice.flatten()]['date_time'].values\n        nearest_distance_cum = window_sample.iloc[indice.flatten()]['distance_cum'].values\n        euclidean_distance = distance\n\n        matches.loc[lap,f'nearest_timestamp_{name}'] = nearest_timestamp[0]\n        matches.loc[lap,f'nearest_distance_cum_{name}'] = nearest_distance_cum[0]\n        matches.loc[lap,f'euclidean_distance_{name}'] = euclidean_distance\n\n      # b. Calculate time difference between racer and reference at this point\n      matches[f'time_to_ref_{name}'] = matches[f'nearest_timestamp_{name}'] - matches['date_time']\n\n      # c. Store time difference and other relevant data\n      matches[f'time_to_ref_diff_{name}'] = matches[f'time_to_ref_{name}'].diff()\n      matches[f'time_to_ref_diff_{name}'] = matches[f'time_to_ref_diff_{name}'].fillna(pd.Timedelta(seconds=0))\n\n      # d. Format data using helper functions\n      matches[f'lap_difference_seconds_{name}'] = matches[f'time_to_ref_diff_{name}'].apply(get_seconds)\n      matches[f'lap_difference_formatted_{name}'] = matches[f'time_to_ref_diff_{name}'].apply(format_timedelta)\n\n      matches[f'seconds_to_reference_{name}'] = matches[f'time_to_ref_{name}'].apply(get_seconds)\n      matches[f'time_to_reference_formatted_{name}'] = matches[f'time_to_ref_{name}'].apply(format_timedelta)\n\n#### 3\\. Return processed data with time differences\n  return matches\n```", "```py\n# Lap distance\nlap_distance = 1000\n\n# Store the DataFrames in a dictionary\ndf_dict = {\n    'jimena': jimena_df,\n    'juan': juan_df,\n    'pedro': pedro_df,\n}\n\n# Store the Lap DataFrames in a dictionary\nlaps_dict = {\n    'jimena': interpolate_laps(jimena_df , lap_distance),\n    'juan': interpolate_laps(juan_df , lap_distance),\n    'pedro': interpolate_laps(pedro_df , lap_distance)\n}\n\n# Calculate gaps to reference\nreference_name = 'juan'\nmatches_gap_to_reference  = gap_to_reference(laps_dict, df_dict, reference_name) \n```"]
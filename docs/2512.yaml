- en: 'lintsampler: a new way to quickly get random samples from any distribution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/lintsampler-a-new-way-to-quickly-get-random-samples-from-any-distribution-d07f73a70f5c?source=collection_archive---------8-----------------------#2024-10-14](https://towardsdatascience.com/lintsampler-a-new-way-to-quickly-get-random-samples-from-any-distribution-d07f73a70f5c?source=collection_archive---------8-----------------------#2024-10-14)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[](https://medium.com/@aneesh92?source=post_page---byline--d07f73a70f5c--------------------------------)[![Aneesh
    Naik](../Images/65aff47941ac2013ccbbbc15423e03a8.png)](https://medium.com/@aneesh92?source=post_page---byline--d07f73a70f5c--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--d07f73a70f5c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--d07f73a70f5c--------------------------------)
    [Aneesh Naik](https://medium.com/@aneesh92?source=post_page---byline--d07f73a70f5c--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--d07f73a70f5c--------------------------------)
    ·4 min read·Oct 14, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '`lintsampler` is a pure Python package that can easily and efficiently generate
    random samples from any probability distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Full disclosure: I am one of the authors of `lintsampler`.'
  prefs: []
  type: TYPE_NORMAL
- en: Why you need lintsampler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We often find ourselves in situations where we have a probability distribution
    (PDF) and we need to draw random samples it. For example, we might want to estimate
    some summary statistics or to create a population of particles for a simulation.
  prefs: []
  type: TYPE_NORMAL
- en: If the probability distribution is a standard one, such as a uniform distribution
    or a Gaussian (normal) distribution, then the `numpy`/`scipy` ecosystem provides
    us with some easy ways to draw these samples, via the `numpy.random` or `scipy.stats`
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, out in the wild, we often encounter probability distributions that
    are not Gaussian. Sometimes, they are *very* not Gaussian. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a816e849fa2d0c53df5dd8cde36582eb.png)'
  prefs: []
  type: TYPE_IMG
- en: A very non-Gaussian PDF. Contour lines are lines of equal density, separated
    by equal intervals in log-space. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: How would we draw samples from this distribution?
  prefs: []
  type: TYPE_NORMAL
- en: There are a few widely-used techniques to draw samples from arbitrary distributions
    like this, such as [rejection sampling](https://en.wikipedia.org/wiki/Rejection_sampling)
    or [Markov chain Monte Carlo (MCMC)](https://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo).
    These are excellent and reliable methods, with some handy Python implementations.
    For example, [emcee](https://emcee.readthedocs.io/en/stable/) is an MCMC sampler
    widely used in scientific applications.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with these existing techniques is that they require a fair amount
    of setup and tuning. With rejection sampling, one has to choose a proposal distribution,
    and a poor choice can make the procedure very inefficient. With MCMC one has to
    worry about whether the samples are converged, which typically requires some post-hoc
    testing to gauge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `lintsampler`. It’s as easy as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, we constructed 1D arrays along each of the two dimensions,
    then we fed them to the `LintSampler` object (imported from the `lintsampler`
    package) along with a `pdf` function representing the probability distribution
    we want to draw samples from. We didn’t spell out the `pdf` function in this snippet,
    but there are some fully self-contained examples in the [docs](https://lintsampler.readthedocs.io/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `pts` is an array containing 100000 samples from the PDF. Here they are
    in a scatter plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d79dcd41533335c64d581654d00cf3ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Scatter plot of points sampled from the weird PDF above (the latter is represented
    by the contour lines). Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of this example was to demonstrate how easy it is to set up and use
    `lintsampler`. In certain cases, it is also much faster and more efficient than
    MCMC and/or rejection sampling. If you’re interested to find out how `lintsampler`
    works under the hood, read on. Otherwise, visit the [docs](https://lintsampler.readthedocs.io/en/latest/),
    where there are instructions describing [how to install](https://lintsampler.readthedocs.io/en/latest/installation.html)
    and use `lintsampler`, including example notebooks with [1D](https://lintsampler.readthedocs.io/en/latest/example_notebooks/1_gmm.html),
    [2D](https://lintsampler.readthedocs.io/en/latest/example_notebooks/2_doughnuts.html),
    and [3D](https://lintsampler.readthedocs.io/en/latest/example_notebooks/3_dark_matter.html)
    use cases, as well as descriptions of some of lintsampler’s additional features:
    [quasi Monte Carlo sampling](https://lintsampler.readthedocs.io/en/latest/example_notebooks/4_qmc.html)
    (a.k.a. low discrepancy sequencing), and sampling on an [adaptive tree structure](https://lintsampler.readthedocs.io/en/latest/densitytree.html).
    There is also a [paper](https://joss.theoj.org/papers/10.21105/joss.06906) published
    in the Journal of Open Source Software (JOSS) describing `lintsampler`.'
  prefs: []
  type: TYPE_NORMAL
- en: How lintsampler works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Underlying `lintsampler` is an algorithm we call *linear interpolant sampling*.
    The [theory](https://lintsampler.readthedocs.io/en/latest/theory/preamble.html)
    section of the docs gives a more detailed and more mathematical description of
    how the algorithm works, but here it is in short.
  prefs: []
  type: TYPE_NORMAL
- en: The example below illustrates what happens under the hood in `lintsampler` when
    you feed a PDF and a grid to the `LintSampler` class. We’ll take an easy example
    of a 2D Gaussian, but this methodology applies in any number of dimensions, and
    with much less friendly PDFs.
  prefs: []
  type: TYPE_NORMAL
- en: First, the PDF gets evaluated on the grid. In the example below, the grid has
    uneven spacings, just for fun.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/3ea73a9e43dfcf1f8357735edfbacb2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Left: 2D Gaussian PDF. Right: PDF evaluated on (uneven) grid. Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: Having evaluated the PDF on the grid in this way, we can estimate the total
    probability of each grid cell according to the trapezium rule (i.e., volume of
    the cell multiplied by the average of its corner densities).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within each grid cell, we can approximate the PDF with the [bilinear interpolant](https://en.wikipedia.org/wiki/Bilinear_interpolation)
    between the cell corners:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/d349e131a17ba10837746ab5363527d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Gridded PDF filled in with (bi)linear interpolation. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: This linear approximation to the PDF can then be sampled very efficiently. Drawing
    a single sample is a two step process, illustrated in the figure below. First,
    choose a random cell from the probability-weighted list of cells (left-hand panel).
    Next, sample a point within the cell via [inverse transform sampling](https://en.wikipedia.org/wiki/Inverse_transform_sampling)
    (right-hand panel).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/abf2821331ada9ab62cafcd622eb73e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Left: same as previous figure, with randomly chosen cell highlighted. Right:
    Zoom-in of highlighted cell, with sampled point illustrated. Image by author.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth understanding that the key step here is the linear approximation:
    we describe this, as well as more details of the inverse transform sampling process,
    in the `lintsampler` docs. Approximating the PDF to a linear function within grid
    each cell means it has a closed, analytic form for its [quantile function](https://en.wikipedia.org/wiki/Quantile_function)
    (i.e., its inverse CDF), which means doing inverse transform sampling essentially
    boils down to drawing uniform samples and applying an algebraic function to them.'
  prefs: []
  type: TYPE_NORMAL
- en: The main thing the user needs to worry about is getting a decent grid resolution,
    so that the linear approximation is sufficient. What a good resolution is will
    vary from use case to use case, as demonstrated in some of the example notebooks
    in the `lintsampler` docs.
  prefs: []
  type: TYPE_NORMAL
- en: Happy sampling!
  prefs: []
  type: TYPE_NORMAL

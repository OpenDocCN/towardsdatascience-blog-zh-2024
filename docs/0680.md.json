["```py\n def potential_to_action(potential):\n\n    if abs(potential-0) < 0.5:\n        return 0\n\n    elif abs(potential-0) < 1:\n        return 2\n\n    elif potential < 0:\n        return 1\n\n    else:\n        return 3\n```", "```py\nlast_gen = [F]\n\nfor i in range(GENS):\n    next_gen = []\n\n    for policy in last_gen:\n        batch = cull(mutants(policy))\n\n        for policy in batch:\n            next_gen.append(policy) \n\n    last_gen = next_gen\n```", "```py\nlast_gen.sort(key=lambda x: x['score'])\n\nfinal_cull = last_gen [-30:]\n\nfor policy in final_cull:\n\n    policy['score'] = score_policy(policy,ep=7)\n\nfinal_cull.sort(key=lambda x: x['score'])\n\nprint('Final Popluation #:',len(last_gen))\n\nfor policy in final_cull:\n    print(policy['AP'])\n    print(policy['score'])\n    print('-'*20)\n\nenv.close()\n```", "```py\nBIN_OPS = ['mult','add','sub', 'div']\nUN_OPS = ['abs','exp','log','sqrt','sin','cos']\nOPNDS = ['x','y','dx','dy','angle','dangle','L','R']\n```", "```py\nF = {'AP': ['add', \n                ['mult','x','y'],\n                ['mult','dx','dy']],\n        'score': 0\n        }\n```", "```py\ndef mutants(policy, sample=1):\n    children = [policy]\n    mutation_target = policy\n\n    for i in range(REPL):\n        new_policy = copy.deepcopy(policy)\n        new_policy['AP'] = mutate_recursive(new_policy['AP'])\n        children.append(new_policy)\n\n    return children\n```", "```py\ndef mutate_recursive(target, probability=MUTATE_P):\n\n    # Recursive case\n    if isinstance(target, list):\n      random_element = random.choice(range(len(target)))\n      target[random_element] = mutate_recursive(target[random_element])\n      return target\n\n    # Base cases\n    elif(target in BIN_OPS):\n      new = random.choice(BIN_OPS)\n      return new\n\n    elif(target in UN_OPS):\n      new = random.choice(UN_OPS)\n      return new\n\n    elif(target in OPNDS):\n      new = random.choice(OPNDS)\n      return new\n```", "```py\n +----------+\n                | x + dy^2 |\n                +----------+\n                     |\n          +----------+----------+\n          |                     |\n     +----v----+           +----v----+\n     | y + dy^2|           | x / dy^2|\n     +---------+           +---------+\n          |                      |\n     +----+----+            +----+-----+\n     |         |            |          |\n +---v--+-+ +--v---+-+   +--v-----+ +--v-----+\n |y - dy^2| |y - dy^2|   |x / dx^2| |y - dy^3|\n +--------+ +--------+   +--------+ +--------+\n```", "```py\ndef cull(batch):\n\n    for policy in batch[1:]:\n        policy['score'] = score_policy(policy)\n\n    batch.sort(key=lambda x: x['score'], reverse=True)\n\n    return batch[:CULL]\n```", "```py\ndef score_policy(policy, ep=10, render=False):\n    observation = env.reset()[0]  # Reset the environment to start a new episode\n    total_reward = 0\n    sample = 0\n\n    for episode in range(ep):\n\n        while True:\n            if render:\n                env.render()\n\n            values = list(observation)\n            values =    {'x': values[0],\n            'y': values[1],\n            'dx': values[2],\n            'dy': values[3],\n            'angle': values[4],\n            'dangle': values[5],\n            'L': values[6],\n            'R': values[7]\n            }\n\n            potential = policy_compute(policy['AP'], values)\n            action = potential_to_action(potential)\n\n            sample += 1\n\n            observation, reward, done, info = env.step(action)[:4]\n            total_reward += reward\n\n            if done:  # If the episode is finished\n                break\n\n    return total_reward/EPISODES\n```", "```py\ndef policy_compute(policy, values):\n\n    if isinstance(policy, str):\n        if policy in values:\n            return values[policy]\n        else:\n            print('ERROR')\n\n    elif isinstance(policy, list):\n        operation = policy[0]\n        branches = policy[1:]\n\n        if operation in BIN_OPS:\n\n            if len(branches) != 2:\n                raise ValueError(f\"At {policy}, Operation {operation} expects 2 operands, got {len(branches)}\")\n\n            operands = [operand for operand in branches]\n\n            left = policy_compute(operands[0], values)\n            right = policy_compute(operands[1], values)\n\n            if operation == 'add':\n                return left + right\n            elif operation == 'sub':\n                return left - right\n            elif operation == 'mult':\n                if left is None or right is None:\n                    print('ERROR: left:',left,'right:',right)\n                return left * right\n            elif operation == 'div':\n                if right == 0:\n                    return 0\n                return left / right\n\n        elif operation in UN_OPS:\n            if len(branches) != 1:\n                raise ValueError(f\"Operation {operation} expects 1 operand, got {len(branches)}\")\n\n            operand_value = policy_compute(next(iter(branches)), values)\n\n            if operation == 'abs':\n                return abs(operand_value)\n            elif operation == 'exp':\n                return math.exp(operand_value)\n            elif operation == 'logabs':\n                return math.log(abs(operand_value))\n            elif operation == 'sin':\n                return math.sin(operand_value)\n            elif operation == 'cos':\n                return math.cos(operand_value)\n            elif operation == 'sqrtabs':\n                return math.sqrt(abs(operand_value))\n\n        else:\n            raise ValueError(f\"Unknown operation: {operation}\")\n\n    else:\n        print('ERROR')\n        return 0\n```"]
- en: Building a simple Agent with Tools and Toolkits in LangChain
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/building-a-simple-agent-with-tools-and-toolkits-in-langchain-77e0f9bd1fa5?source=collection_archive---------1-----------------------#2024-04-10](https://towardsdatascience.com/building-a-simple-agent-with-tools-and-toolkits-in-langchain-77e0f9bd1fa5?source=collection_archive---------1-----------------------#2024-04-10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Get familiar with the building blocks of Agents in LangChain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@ssmaameri?source=post_page---byline--77e0f9bd1fa5--------------------------------)[![Sami
    Maameri](../Images/9e9892fe7d3cc53ad1c4d165145878ef.png)](https://medium.com/@ssmaameri?source=post_page---byline--77e0f9bd1fa5--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--77e0f9bd1fa5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--77e0f9bd1fa5--------------------------------)
    [Sami Maameri](https://medium.com/@ssmaameri?source=post_page---byline--77e0f9bd1fa5--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--77e0f9bd1fa5--------------------------------)
    ·13 min read·Apr 10, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c890aaf761bb571b28a0b60b25e8fda6.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Dan LeFebvre](https://unsplash.com/@danlefeb?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build a simple agent in LangChain to help us understand some of the foundational
    concepts and building blocks for how agents work there.
  prefs: []
  type: TYPE_NORMAL
- en: By keeping it simple we can get a better grasp of the foundational ideas behind
    these agents, allowing us to build more complex agents in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Want to get notified about my future posts? [*Subscribe here*](https://medium.com/@ssmaameri/subscribe)
  prefs: []
  type: TYPE_NORMAL
- en: What are Agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LangChain documentation actually has a pretty [good page](https://python.langchain.com/docs/modules/agents/)
    on the high level concepts around its agents. It’s a short easy read, and definitely
    worth skimming through before getting started.
  prefs: []
  type: TYPE_NORMAL
- en: If you lookup the definition of AI Agents, you get something along the lines
    of “An entity that is able to perceive its environment, act on its environment,
    and make intelligent decisions about how to reach a goal it has been given, as
    well as the ability to learn as it goes”
  prefs: []
  type: TYPE_NORMAL
- en: That fits the definition of LangChain agents pretty well I would say. What makes
    all this possible in software is the reasoning abilities of Large Language Model’s
    (LLM’s). The brains of a LangChain agent are an LLM. It is the LLM that is used
    to reason about the best way to carry out the ask requested by a user.
  prefs: []
  type: TYPE_NORMAL
- en: In order to carry out its task, and operate on things and retrieve information,
    the agent has what are called Tool’s in LangChain, at its disposal. It is through
    these tools that it is able to interact with its environment.
  prefs: []
  type: TYPE_NORMAL
- en: The tools are basically just methods/classes the agent has access to that can
    do things like interact with a Stock Market index over an API, update a Google
    Calendar event, or run a query against a database. We can build out tools as needed,
    depending on the nature of tasks we are trying to carry out with the agent to
    fulfil.
  prefs: []
  type: TYPE_NORMAL
- en: A collection of Tools in LangChain are called a Toolkit. Implementation wise,
    this is literally just an array of the Tools that are available for the agent.
    As such, the high level overview of an agent in LangChain looks something like
    this
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/34df972c8faa9ba0de48bb3d01d91eb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: So, at a basic level, an agent needs
  prefs: []
  type: TYPE_NORMAL
- en: an LLM to act as its brain, and to give it its reasoning abilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tools so that it can interact with the environment around it and achieve its
    goals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make some of these concepts more concrete, let’s build a simple agent.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a Mathematics Agent that can perform a few simple mathematical
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Environment setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First lets setup our environment and script
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can also clone the code used here [from GitHub](https://github.com/smaameri/simple-math-agent)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: or check out the code inside a [Google Colab](https://colab.research.google.com/drive/1dHG7d4Iq0yuDEOWK1UaMZ7ADeTo0uAFT?usp=sharing)
    also.
  prefs: []
  type: TYPE_NORMAL
- en: The Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest place to start will be to fist define the tools for our Maths agent.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s give it “add”, “multiply” and “square” tools, so that it can perform those
    operations on questions we pass to it. By keeping our tools simple we can focus
    on the core concepts, and build the tools ourselves, instead of relying on an
    existing and more complex tools like the WikipediaTool, that acts as a wrapper
    around the Wikipedia API, and requires us to import it from the LangChain library.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we are not trying to do anything fancy here, just keeping it simple and
    putting the main building blocks of an agent together so we can understand how
    they work, and get our first agent up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the “add” tool. The bottom up way to create a Tool in LangChain
    would be to extend the **BaseTool** class, set the **name** and **description**
    fields on the class, and implement the **_run** method. That would look like this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we need to implement the **_run** method to show what our tool does
    with the parameters that are passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also how it requires a pydantic model for the **args_schema**. We will
    define that here
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, LangChain does give us an easier way to define tools, then by needing to
    extend the **BaseTool** class each time. We can do this with the help of the **@too**l
    decorator. Defining the “add” tool in LangChain using the @tool decorator will
    look like this
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Much simpler right. Behind the scenes, the decorator magically uses the method
    provided to extend the BaseTool class, just as we did earlier. Some thing to note:'
  prefs: []
  type: TYPE_NORMAL
- en: the method name also becomes the tool name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the method params define the input parameters for the tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the docstring gets converted into the tools description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access these properties on the tool also
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the description of a tool is very important as this is what the LLM
    uses to decide whether or not it is the right tool for the job. A bad description
    may lead to the not tool getting used when it should be, or getting used at the
    wrong times.
  prefs: []
  type: TYPE_NORMAL
- en: With the **add** tool done, let’s move on to the definitions for our **multiply**
    and **square** tools.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And that is it, simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: So we have defined our own three [custom tools](https://python.langchain.com/docs/modules/tools/custom_tools/).
    A more common use case might be to use some of the already provided and existing
    tools in LangChain, which you can see [here](https://python.langchain.com/docs/integrations/tools/).
    However, at the source code level, they would all be built and defined using a
    similar methods as described above.
  prefs: []
  type: TYPE_NORMAL
- en: And that is it as far as our Tools our concerned. Now time to combine our tools
    into a Toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: The Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Toolkits sound fancy, but they are actually very simple. They are **literally**
    just a a list of tools. We can define our toolkit as an array of tools like so
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it. Really straightforward, and nothing to get confused over.
  prefs: []
  type: TYPE_NORMAL
- en: Usually Toolkits are groups of tools that are useful together, and would be
    helpful for agents trying to carry out certain kinds of tasks. For example an
    SQLToolkit might contain a tool for generating an SQL query, validating an SQL
    query, and executing an SQL query.
  prefs: []
  type: TYPE_NORMAL
- en: The [Integrations Toolkit](https://python.langchain.com/docs/integrations/toolkits/)
    page on the LangChain docs has a large list of toolkits developed by the community
    that might be useful for you.
  prefs: []
  type: TYPE_NORMAL
- en: The LLM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned above, an LLM is the brains of an agent. It decides which tools
    to call based on the question passed to it, what are the best next steps to take
    based on a tools description. It also decides when it has reached its final answer,
    and is ready to return that to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s setup the LLM here
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Prompt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly we need a prompt to pass into our agent, so it has a general idea bout
    what kind of agent it is, and what sorts of tasks it should solve.
  prefs: []
  type: TYPE_NORMAL
- en: Our agent requires a ChatPromptTemplate to work (more on that later). This is
    what a barebones ChatPromptTemplate looks like. The main part we care about is
    the system prompt, and the rest are just the default settings we are required
    to pass in.
  prefs: []
  type: TYPE_NORMAL
- en: In our prompt we have included a sample answer, showing the agent how we want
    it to return the answer only, and not any descriptive text along with the answer
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That is it. We have setup our Tools and Toolkit, which our agent will need as
    part of its setup, so its knows what are the types of actions and capabilities
    it has at its disposal. And we have also setup the LLM and system prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the fun part. Setting up our Agent!
  prefs: []
  type: TYPE_NORMAL
- en: The Agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LangChain has a [number of different agents types](https://python.langchain.com/docs/modules/agents/agent_types/)
    that can be created, with different reasoning powers and abilities. We will be
    using the most capable and powerful agent currently available, the [OpenAI Tools](https://python.langchain.com/docs/modules/agents/agent_types/openai_tools/)
    agent. As per the docs on the the OpenAI Tools agent, which uses newer OpenAI
    models also,
  prefs: []
  type: TYPE_NORMAL
- en: Newer OpenAI models have been fine-tuned to detect when one or more function(s)
    should be called and respond with the inputs that should be passed to the function(s).
    In an API call, you can describe functions and have the model intelligently choose
    to output a JSON object containing arguments to call these functions. The goal
    of the OpenAI tools APIs is to more reliably return valid and useful function
    calls than what can be done using a generic text completion or chat API.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In other words this agents is good at generating the correct structure for calling
    functions, and is able to understand if more than one function (tool) might be
    needed for our task also. This agent also has the ability to call functions (tools)
    with multiple input parameters, just like ours do. Some agents can only work with
    functions that have a single input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with [OpenAI’s Function](https://platform.openai.com/docs/guides/function-calling)
    calling feature, where we can use the OpenAI LLM to generate the correct parameters
    to call a function with, the OpenAI Tools agent we are using here is leveraging
    some of that power in order to be able to call the correct tool, with the correct
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In order to setup an agent in LangChain, we need to use one of the factory methods
    provided for creating the agent of our choice.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method for creating an OpenAI tools agent is **create_openai_tools_agent()**.
    And it requires passing in the llm, tools and prompt we setup above. So let’s
    initialise our agent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in order to run agents in LangChain, we cannot just call a “*run*”
    type method on them directly. They need to be run via an AgentExecutor.
  prefs: []
  type: TYPE_NORMAL
- en: Am bringing up the Agent Executor only here at the end as I don’t think it’s
    a critical concept for understanding how the agents work, and bring it up at the
    start with everything else would just the whole thing seem more complicated than
    it needs to be, as well as distract from understanding some of the other more
    fundamental concepts.
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we are introducing it, an AgentExecutor acts as the runtime for
    agents in LangChain, and allow an agent to keep running until it is ready to return
    its final response to the user. In pseudo-code, the AgentExecutor’s are doing
    something along the lines of (pulled directly from [the LangChain docs](https://python.langchain.com/docs/modules/agents/concepts/#agentexecutor))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So they are basically a while loop that keep’s calling the next action methods
    on the agent, until the agent has returned its final response.
  prefs: []
  type: TYPE_NORMAL
- en: So, let us setup our agent inside the agent executor. We pass it the agent,
    and must also pass it the toolkit. And we are setting verbose to True so we can
    get an idea of what the agent is doing as it is processing our request
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And that is it. We are now ready to pass commands to our agent
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let run our script, and see the agent’s output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/38082f690ae8ca1409e8cac5d2270f77.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Since we have set **verbose=True** on the AgentExecutor, we can see the lines
    of Action our agent has taken. It has identified we should call the “**add**”
    tool, called the “**add**” tool with the required parameters, and returned us
    our result.
  prefs: []
  type: TYPE_NORMAL
- en: This is what the full source code looks like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Testing our agent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s shoot a few questions at our agent to see how it performs.
  prefs: []
  type: TYPE_NORMAL
- en: '**what is 5 squared?**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again we get the correct result, and see that it does use our **square** tool
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4da75f6cccd073be0ccf10095da58268.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: what is 5 to the power of 6?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It takes an interesting course of action. It first uses the **square** tool.
    And then, using the result of that, tries to use the **multiply** tool a few times
    to get the final answer. Admittedly, the final answer, 3125, is wrong, and needs
    to be multiplied by 5 one more time to get the correct answer. But it is interesting
    to see how the agent tried to use different tools, and multiple steps to try and
    get to the final answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/06605974f62a317700216b36626a3a9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '**what is 1 minus 3?**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don’t have a minus tool. But it is smart enough to use our add tool, but
    set the second value to -3\. Its funny and somewhat amazing sometimes how they
    are smart and creative like that.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1c4add21cd9408cce4be6aeaa9abdd53.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '**what is the square root of 64**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a final test, what if we ask it to carry out a mathematical operation that
    is not part of our tool set? Since we have no tools for square rooting, it does
    not attempt to call a tool, and instead calculates the value directly using just
    the LLM.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/670b50b68a2de3c16cf3636692a5838c.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Our system prompt did tell it to answer that it “does not know” if it does not
    have the correct tool for the job, and it did do that sometimes during testing.
    An improved initial system prompt could probably help resolve that, at least to
    some extent
  prefs: []
  type: TYPE_NORMAL
- en: Observations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on using the agent a bit, I noticed the following
  prefs: []
  type: TYPE_NORMAL
- en: when asking it direct questions which it had the tools to answer with, it was
    pretty consistent at using the correct tools for the job, and returning the correct
    answer. So, pretty reliable in that sense.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if the question is a little complicated, for example our “5 to the power of
    6” question, it does not always return the correct results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it can sometimes use just the pure power of the LLM to answer our question,
    without invoking our tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Agents, and programs that can reason from themselves, are a new paradigm in
    programming, and I think they are going to become a much more mainstream part
    of how lots of things are built. Obviously the non-deterministic (i.e not wholly
    predictable) nature of LLM’s means that agents results will also suffer from this,
    questioning how much we can rely on them for tasks where we need to be sure of
    the answers we have.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps as the technology matures, their results can be more and more predictable,
    and we may develop some work arounds for this.
  prefs: []
  type: TYPE_NORMAL
- en: I can also see agent type libraries and packages starting to become a thing.
    Similar to how we install third party libraries and packages into software, for
    example via the pip package manager for python, or Docker Hub for docker images,
    I wonder if we may start to see a library and package manager of agents start
    being developed, with agents developed that become very good at their specific
    tasks, which we can then also install as packages into out application.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed LangChain’s [library of Toolkits](https://python.langchain.com/docs/integrations/toolkits/)
    for agents to use, listed on their Integrations page, are sets of Tools built
    by the community for people to use, which could be an early example of agent type
    libraries built by the community.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hope this was a useful introduction into getting you started building with agents
    in LangChain.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, agents are basically just a brain (the LLM), and a bunch of tools,
    which they can use to get stuff done in the world around us.
  prefs: []
  type: TYPE_NORMAL
- en: Happy hacking!
  prefs: []
  type: TYPE_NORMAL
- en: '*If you enjoyed the article, and would like to stay up to date on future articles
    I release about building things with LangChain and AI tools, do* [*subscribe here*](https://medium.com/@ssmaameri/subscribe)
    *to be notified by email when they come out*'
  prefs: []
  type: TYPE_NORMAL

["```py\nGRAPHRAG_LLM_MODEL=gpt-4o-mini\n```", "```py\nGRAPHRAG_ENTITY_EXTRACTION_ENTITY_TYPES=organization,person,event,geo\n```", "```py\nGRAPHRAG_ENTITY_EXTRACTION_MAX_GLEANINGS=1\n```", "```py\nGRAPHRAG_CLAIM_EXTRACTION_ENABLED=False\nGRAPHRAG_CLAIM_EXTRACTION_MAX_GLEANINGS=1\n```", "```py\nNEO4J_URI=\"bolt://localhost\"\nNEO4J_USERNAME=\"neo4j\"\nNEO4J_PASSWORD=\"password\"\n\ndriver = GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USERNAME, NEO4J_PASSWORD))\n\ndef db_query(cypher: str, params: Dict[str, Any] = {}) -> pd.DataFrame:\n    \"\"\"Executes a Cypher statement and returns a DataFrame\"\"\"\n    return driver.execute_query(\n        cypher, parameters_=params, result_transformer_=Result.to_df\n    )\n```", "```py\ndb_query(\n  \"MATCH (n:__Chunk__) RETURN n.n_tokens as token_count, count(*) AS count\"\n)\n# token_count count\n# 300         230\n# 155         1\n```", "```py\ndb_query(\n  \"MATCH (n:__Entity__) RETURN n.name AS name, n.description AS description LIMIT 1\"\n)\n```", "```py\ndb_query(\n  \"MATCH ()-[n:RELATED]->() RETURN n.description AS description LIMIT 5\"\n)\n```", "```py\ndb_query(\"\"\"\n  MATCH (n:__Community__) \n  RETURN n.title AS title, n.summary AS summary, n.full_content AS full_content LIMIT 1\n\"\"\")\n```", "```py\n[Data: Entities (11, 177); Relationships (25, 159, 20, 29, +more)]\n```", "```py\nentity_df = db_query(\n    \"\"\"\nMATCH (d:__Chunk__)\nRETURN count {(d)-[:HAS_ENTITY]->()} AS entity_count\n\"\"\"\n)\n# Plot distribution\nplt.figure(figsize=(10, 6))\nsns.histplot(entity_df['entity_count'], kde=True, bins=15, color='skyblue')\nplt.axvline(entity_df['entity_count'].mean(), color='red', linestyle='dashed', linewidth=1)\nplt.axvline(entity_df['entity_count'].median(), color='green', linestyle='dashed', linewidth=1)\nplt.xlabel('Entity Count', fontsize=12)\nplt.ylabel('Frequency', fontsize=12)\nplt.title('Distribution of Entity Count', fontsize=15)\nplt.legend({'Mean': entity_df['entity_count'].mean(), 'Median': entity_df['entity_count'].median()})\nplt.show()\n```", "```py\ndegree_dist_df = db_query(\n    \"\"\"\nMATCH (e:__Entity__)\nRETURN count {(e)-[:RELATED]-()} AS node_degree\n\"\"\"\n)\n# Calculate mean and median\nmean_degree = np.mean(degree_dist_df['node_degree'])\npercentiles = np.percentile(degree_dist_df['node_degree'], [25, 50, 75, 90])\n# Create a histogram with a logarithmic scale\nplt.figure(figsize=(12, 6))\nsns.histplot(degree_dist_df['node_degree'], bins=50, kde=False, color='blue')\n# Use a logarithmic scale for the x-axis\nplt.yscale('log')\n# Adding labels and title\nplt.xlabel('Node Degree')\nplt.ylabel('Count (log scale)')\nplt.title('Node Degree Distribution')\n# Add mean, median, and percentile lines\nplt.axvline(mean_degree, color='red', linestyle='dashed', linewidth=1, label=f'Mean: {mean_degree:.2f}')\nplt.axvline(percentiles[0], color='purple', linestyle='dashed', linewidth=1, label=f'25th Percentile: {percentiles[0]:.2f}')\nplt.axvline(percentiles[1], color='orange', linestyle='dashed', linewidth=1, label=f'50th Percentile: {percentiles[1]:.2f}')\nplt.axvline(percentiles[2], color='yellow', linestyle='dashed', linewidth=1, label=f'75th Percentile: {percentiles[2]:.2f}')\nplt.axvline(percentiles[3], color='brown', linestyle='dashed', linewidth=1, label=f'90th Percentile: {percentiles[3]:.2f}')\n# Add legend\nplt.legend()\n# Show the plot\nplt.show()\n```", "```py\ndb_query(\"\"\"\n  MATCH (n:__Entity__) \n  RETURN n.name AS name, count{(n)-[:RELATED]-()} AS degree\n  ORDER BY degree DESC LIMIT 5\"\"\")\n```", "```py\ncommunity_data = db_query(\"\"\"\n  MATCH (n:__Community__)\n  RETURN n.level AS level, count{(n)-[:IN_COMMUNITY]-()} AS members\n\"\"\")\n\nstats = community_data.groupby('level').agg(\n    min_members=('members', 'min'),\n    max_members=('members', 'max'),\n    median_members=('members', 'median'),\n    avg_members=('members', 'mean'),\n    num_communities=('members', 'count'),\n    total_members=('members', 'sum')\n).reset_index()\n\n# Create box plot\nplt.figure(figsize=(10, 6))\nsns.boxplot(x='level', y='members', data=community_data, palette='viridis')\nplt.xlabel('Level')\nplt.ylabel('Members')\n\n# Add statistical annotations\nfor i in range(stats.shape[0]):\n    level = stats['level'][i]\n    max_val = stats['max_members'][i]\n    text = (f\"num: {stats['num_communities'][i]}\\n\"\n            f\"all_members: {stats['total_members'][i]}\\n\"\n            f\"min: {stats['min_members'][i]}\\n\"\n            f\"max: {stats['max_members'][i]}\\n\"\n            f\"med: {stats['median_members'][i]}\\n\"\n            f\"avg: {stats['avg_members'][i]:.2f}\")\n    plt.text(level, 85, text, horizontalalignment='center', fontsize=9)\n\nplt.show()\n```", "```py\nindex_name = \"entity\"\n\ndb_query(\n    \"\"\"\nCREATE VECTOR INDEX \"\"\"\n    + index_name\n    + \"\"\" IF NOT EXISTS FOR (e:__Entity__) ON e.description_embedding\nOPTIONS {indexConfig: {\n `vector.dimensions`: 1536,\n `vector.similarity_function`: 'cosine'\n}}\n\"\"\"\n)\n```", "```py\ndb_query(\n    \"\"\"\nMATCH (n:`__Community__`)<-[:IN_COMMUNITY]-()<-[:HAS_ENTITY]-(c)\nWITH n, count(distinct c) AS chunkCount\nSET n.weight = chunkCount\"\"\"\n)\n```", "```py\ntopChunks = 3\ntopCommunities = 3\ntopOutsideRels = 10\ntopInsideRels = 10\ntopEntities = 10\n```", "```py\nlc_retrieval_query = \"\"\"\nWITH collect(node) as nodes\n// Entity - Text Unit Mapping\nWITH\ncollect {\n    UNWIND nodes as n\n    MATCH (n)<-[:HAS_ENTITY]->(c:__Chunk__)\n    WITH c, count(distinct n) as freq\n    RETURN c.text AS chunkText\n    ORDER BY freq DESC\n    LIMIT $topChunks\n} AS text_mapping,\n// Entity - Report Mapping\ncollect {\n    UNWIND nodes as n\n    MATCH (n)-[:IN_COMMUNITY]->(c:__Community__)\n    WITH c, c.rank as rank, c.weight AS weight\n    RETURN c.summary \n    ORDER BY rank, weight DESC\n    LIMIT $topCommunities\n} AS report_mapping,\n// Outside Relationships \ncollect {\n    UNWIND nodes as n\n    MATCH (n)-[r:RELATED]-(m) \n    WHERE NOT m IN nodes\n    RETURN r.description AS descriptionText\n    ORDER BY r.rank, r.weight DESC \n    LIMIT $topOutsideRels\n} as outsideRels,\n// Inside Relationships \ncollect {\n    UNWIND nodes as n\n    MATCH (n)-[r:RELATED]-(m) \n    WHERE m IN nodes\n    RETURN r.description AS descriptionText\n    ORDER BY r.rank, r.weight DESC \n    LIMIT $topInsideRels\n} as insideRels,\n// Entities description\ncollect {\n    UNWIND nodes as n\n    RETURN n.description AS descriptionText\n} as entities\n// We don't have covariates or claims here\nRETURN {Chunks: text_mapping, Reports: report_mapping, \n       Relationships: outsideRels + insideRels, \n       Entities: entities} AS text, 1.0 AS score, {} AS metadata\n\"\"\"\n\nlc_vector = Neo4jVector.from_existing_index(\n    OpenAIEmbeddings(model=\"text-embedding-3-small\"),\n    url=NEO4J_URI,\n    username=NEO4J_USERNAME,\n    password=NEO4J_PASSWORD,\n    index_name=index_name,\n    retrieval_query=lc_retrieval_query\n)\n```", "```py\ndocs = lc_vector.similarity_search(\n    \"What do you know about Cratchitt family?\",\n    k=topEntities,\n    params={\n        \"topChunks\": topChunks,\n        \"topCommunities\": topCommunities,\n        \"topOutsideRels\": topOutsideRels,\n        \"topInsideRels\": topInsideRels,\n    },\n)\n# print(docs[0].page_content)\n```", "```py\n# https://github.com/run-llama/llama_index/blob/main/llama-index-core/llama_index/core/vector_stores/utils.py#L32\nfrom llama_index.core.schema import TextNode\nfrom llama_index.core.vector_stores.utils import node_to_metadata_dict\n\ncontent = node_to_metadata_dict(TextNode(), remove_text=True, flat_metadata=False)\n\ndb_query(\n    \"\"\"\n  MATCH (e:__Entity__)\n  SET e += $content\"\"\",\n    {\"content\": content},\n)\n```", "```py\nretrieval_query = f\"\"\"\nWITH collect(node) as nodes\n// Entity - Text Unit Mapping\nWITH\nnodes,\ncollect {{\n    UNWIND nodes as n\n    MATCH (n)<-[:HAS_ENTITY]->(c:__Chunk__)\n    WITH c, count(distinct n) as freq\n    RETURN c.text AS chunkText\n    ORDER BY freq DESC\n    LIMIT {topChunks}\n}} AS text_mapping,\n// Entity - Report Mapping\ncollect {{\n    UNWIND nodes as n\n    MATCH (n)-[:IN_COMMUNITY]->(c:__Community__)\n    WITH c, c.rank as rank, c.weight AS weight\n    RETURN c.summary \n    ORDER BY rank, weight DESC\n    LIMIT {topCommunities}\n}} AS report_mapping,\n// Outside Relationships \ncollect {{\n    UNWIND nodes as n\n    MATCH (n)-[r:RELATED]-(m) \n    WHERE NOT m IN nodes\n    RETURN r.description AS descriptionText\n    ORDER BY r.rank, r.weight DESC \n    LIMIT {topOutsideRels}\n}} as outsideRels,\n// Inside Relationships \ncollect {{\n    UNWIND nodes as n\n    MATCH (n)-[r:RELATED]-(m) \n    WHERE m IN nodes\n    RETURN r.description AS descriptionText\n    ORDER BY r.rank, r.weight DESC \n    LIMIT {topInsideRels}\n}} as insideRels,\n// Entities description\ncollect {{\n    UNWIND nodes as n\n    RETURN n.description AS descriptionText\n}} as entities\n// We don't have covariates or claims here\nRETURN \"Chunks:\" + apoc.text.join(text_mapping, '|') + \"\\nReports: \" + apoc.text.join(report_mapping,'|') +  \n       \"\\nRelationships: \" + apoc.text.join(outsideRels + insideRels, '|') + \n       \"\\nEntities: \" + apoc.text.join(entities, \"|\") AS text, 1.0 AS score, nodes[0].id AS id, {{_node_type:nodes[0]._node_type, _node_content:nodes[0]._node_content}} AS metadata\n\"\"\"\n```", "```py\nneo4j_vector = Neo4jVectorStore(\n    NEO4J_USERNAME,\n    NEO4J_PASSWORD,\n    NEO4J_URI,\n    embed_dim,\n    index_name=index_name,\n    retrieval_query=retrieval_query,\n)\nloaded_index = VectorStoreIndex.from_vector_store(neo4j_vector).as_query_engine(\n    similarity_top_k=topEntities, embed_model=OpenAIEmbedding(model=\"text-embedding-3-large\")\n)\n```", "```py\nresponse = loaded_index.query(\"What do you know about Scrooge?\")\nprint(response.response)\n#print(response.source_nodes[0].text)\n# Scrooge is an employee who is impacted by the generosity and festive spirit \n# of the Fezziwig family, particularly Mr. and Mrs. Fezziwig. He is involved \n# in the memorable Domestic Ball hosted by the Fezziwigs, which significantly \n# influences his life and contributes to the broader narrative of kindness \n# and community spirit.\n```", "```py\ndef global_retriever(query: str, level: int, response_type: str = response_type) -> str:\n    community_data = graph.query(\n        \"\"\"\n    MATCH (c:__Community__)\n    WHERE c.level = $level\n    RETURN c.full_content AS output\n    \"\"\",\n        params={\"level\": level},\n    )\n    intermediate_results = []\n    for community in tqdm(community_data, desc=\"Processing communities\"):\n        intermediate_response = map_chain.invoke(\n            {\"question\": query, \"context_data\": community[\"output\"]}\n        )\n        intermediate_results.append(intermediate_response)\n    final_response = reduce_chain.invoke(\n        {\n            \"report_data\": intermediate_results,\n            \"question\": query,\n            \"response_type\": response_type,\n        }\n    )\n    return final_response\n```", "```py\nprint(global_retriever(\"What is the story about?\", 2))\n```"]
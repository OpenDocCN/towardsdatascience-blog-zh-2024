- en: 'Cypher Generation: The Good, The Bad and The Messy'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cypher ç”Ÿæˆï¼šå¥½ã€åä¸æ··ä¹±
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/cypher-generation-the-good-the-bad-and-the-messy-4ec119dd72ea?source=collection_archive---------6-----------------------#2024-01-29](https://towardsdatascience.com/cypher-generation-the-good-the-bad-and-the-messy-4ec119dd72ea?source=collection_archive---------6-----------------------#2024-01-29)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/cypher-generation-the-good-the-bad-and-the-messy-4ec119dd72ea?source=collection_archive---------6-----------------------#2024-01-29](https://towardsdatascience.com/cypher-generation-the-good-the-bad-and-the-messy-4ec119dd72ea?source=collection_archive---------6-----------------------#2024-01-29)
- en: '*Methods for creating fine-tuning datasets for text-to-Cypher generation.*'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*åˆ›å»ºç”¨äºæ–‡æœ¬åˆ° Cypher ç”Ÿæˆçš„å¾®è°ƒæ•°æ®é›†çš„æ–¹æ³•ã€‚*'
- en: '[](https://medium.com/@silviaonofrei?source=post_page---byline--4ec119dd72ea--------------------------------)[![Silvia
    Onofrei](../Images/198b04b2063b4269eaff52402dc5f8d5.png)](https://medium.com/@silviaonofrei?source=post_page---byline--4ec119dd72ea--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--4ec119dd72ea--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--4ec119dd72ea--------------------------------)
    [Silvia Onofrei](https://medium.com/@silviaonofrei?source=post_page---byline--4ec119dd72ea--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@silviaonofrei?source=post_page---byline--4ec119dd72ea--------------------------------)[![Silvia
    Onofrei](../Images/198b04b2063b4269eaff52402dc5f8d5.png)](https://medium.com/@silviaonofrei?source=post_page---byline--4ec119dd72ea--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--4ec119dd72ea--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--4ec119dd72ea--------------------------------)
    [Silvia Onofrei](https://medium.com/@silviaonofrei?source=post_page---byline--4ec119dd72ea--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--4ec119dd72ea--------------------------------)
    Â·13 min readÂ·Jan 29, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘å¸ƒäº [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--4ec119dd72ea--------------------------------)
    Â·13åˆ†é’Ÿé˜…è¯»Â·2024å¹´1æœˆ29æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/ad8b418ba27894f9c93e3debc77b318b.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ad8b418ba27894f9c93e3debc77b318b.png)'
- en: Created with ChatGPT-DALLE
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ç”± ChatGPT-DALLE åˆ›å»º
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¼•è¨€
- en: Cypher is Neo4jâ€™s graph query language. It was inspired and bears similarities
    with SQL, enabling data retrieval from knowledge graphs. Given the rise of generative
    AI and the widespread availability of large language models (LLMs), it is natural
    to ask which LLMs are capable of generating Cypher queries or how we can finetune
    our own model to generate Cypher from the text.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Cypher æ˜¯ Neo4j çš„å›¾æŸ¥è¯¢è¯­è¨€ã€‚å®ƒçš„çµæ„Ÿæ¥æºäº SQLï¼Œå¹¶ä¸”ä¸ SQL æœ‰è®¸å¤šç›¸ä¼¼ä¹‹å¤„ï¼Œèƒ½å¤Ÿä»çŸ¥è¯†å›¾è°±ä¸­æ£€ç´¢æ•°æ®ã€‚éšç€ç”Ÿæˆå¼ AI çš„å…´èµ·ä»¥åŠå¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰çš„å¹¿æ³›åº”ç”¨ï¼Œè‡ªç„¶è€Œç„¶åœ°ä¼šæœ‰äººé—®ï¼Œå“ªäº›
    LLM èƒ½ç”Ÿæˆ Cypher æŸ¥è¯¢ï¼Œæˆ–è€…æˆ‘ä»¬å¦‚ä½•å¾®è°ƒè‡ªå·±çš„æ¨¡å‹ä»æ–‡æœ¬ç”Ÿæˆ Cypher æŸ¥è¯¢ã€‚
- en: The issue presents considerable challenges, primarily due to the scarcity of
    fine-tuning datasets and, in my opinion, because such a dataset would significantly
    rely on the specific graph schema.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªé—®é¢˜æå‡ºäº†ç›¸å½“å¤§çš„æŒ‘æˆ˜ï¼Œä¸»è¦æ˜¯ç”±äºå¾®è°ƒæ•°æ®é›†çš„ç¨€ç¼ºï¼Œå¹¶ä¸”åœ¨æˆ‘çœ‹æ¥ï¼Œè¿™æ ·çš„æ•°æ®é›†å°†æå¤§åœ°ä¾èµ–äºç‰¹å®šçš„å›¾è°±æ¨¡å¼ã€‚
- en: In this blog post, I will discuss several approaches for creating a fine-tuning
    dataset aimed at generating Cypher queries from text. The initial approach is
    grounded in Large Language Models (LLMs) and utilizes a predefined graph schema.
    The second strategy, rooted entirely in Python, offers a versatile means to produce
    a vast array of questions and Cypher queries, adaptable to any graph schema. For
    experimentation I created a knowledge graph that is based on a subset of the ArXiv
    dataset.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç¯‡åšå®¢æ–‡ç« ä¸­ï¼Œæˆ‘å°†è®¨è®ºå‡ ç§åˆ›å»ºå¾®è°ƒæ•°æ®é›†çš„æ–¹æ³•ï¼Œæ—¨åœ¨ä»æ–‡æœ¬ä¸­ç”Ÿæˆ Cypher æŸ¥è¯¢ã€‚ç¬¬ä¸€ç§æ–¹æ³•åŸºäºå¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰ï¼Œå¹¶ä½¿ç”¨é¢„å®šä¹‰çš„å›¾è°±æ¨¡å¼ã€‚ç¬¬äºŒç§æ–¹æ³•å®Œå…¨åŸºäº
    Pythonï¼Œæä¾›äº†ä¸€ç§çµæ´»çš„æ–¹å¼ï¼Œå¯ä»¥ç”Ÿæˆå„ç§å„æ ·çš„é—®é¢˜å’Œ Cypher æŸ¥è¯¢ï¼Œé€‚ç”¨äºä»»ä½•å›¾è°±æ¨¡å¼ã€‚åœ¨å®éªŒä¸­ï¼Œæˆ‘åˆ›å»ºäº†ä¸€ä¸ªåŸºäº ArXiv æ•°æ®é›†å­é›†çš„çŸ¥è¯†å›¾è°±ã€‚
- en: As I was finalizing this blogpost, Tomaz Bratanic launched an [initiative project](https://medium.com/@bratanic-tomaz/crowdsourcing-text2cypher-dataset-e65ba51916d4)
    aimed at developing a comprehensive fine-tuning dataset that encompasses various
    graph schemas and integrates a human-in-the-loop approach to generate and validate
    Cypher statements. I hope that the insights discussed here will also be advantageous
    to the project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: å½“æˆ‘å®Œæˆè¿™ç¯‡åšå®¢æ—¶ï¼ŒTomaz Bratanic å¯åŠ¨äº†ä¸€ä¸ª [å€¡è®®é¡¹ç›®](https://medium.com/@bratanic-tomaz/crowdsourcing-text2cypher-dataset-e65ba51916d4)ï¼Œæ—¨åœ¨å¼€å‘ä¸€ä¸ªå…¨é¢çš„å¾®è°ƒæ•°æ®é›†ï¼Œæ¶µç›–å„ç§å›¾è°±æ¨¡å¼ï¼Œå¹¶ç»“åˆäººå·¥æ™ºèƒ½å‚ä¸çš„æ–¹æ³•æ¥ç”Ÿæˆå’ŒéªŒè¯
    Cypher è¯­å¥ã€‚æˆ‘å¸Œæœ›è¿™é‡Œè®¨è®ºçš„è§è§£ä¹Ÿèƒ½å¯¹è¯¥é¡¹ç›®æœ‰æ‰€å¸®åŠ©ã€‚
- en: Knowledge Graph Model
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: çŸ¥è¯†å›¾è°±æ¨¡å‹
- en: I like working with the ArXiv dataset of scientific articles because of its
    clean, easy-to-integrate format for a knowledge graph. Utilizing techniques from
    my recent [Medium blogpost](https://medium.com/towards-data-science/leverage-keybert-hdbscan-and-zephyr-7b-beta-to-build-a-knowledge-graph-33d7534ee01b),
    I enhanced this dataset with additional keywords and clusters. Since my primary
    focus is on building a fine-tuning dataset, Iâ€™ll omit the specifics of constructing
    this graph. For those interested, details can be found in this [Github repository.](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å–œæ¬¢ä½¿ç”¨ArXivç§‘å­¦æ–‡ç« æ•°æ®é›†ï¼Œå› ä¸ºå®ƒå…·æœ‰å¹²å‡€ä¸”æ˜“äºé›†æˆåˆ°çŸ¥è¯†å›¾è°±ä¸­çš„æ ¼å¼ã€‚åˆ©ç”¨æˆ‘æœ€è¿‘çš„[Mediumåšå®¢æ–‡ç« ](https://medium.com/towards-data-science/leverage-keybert-hdbscan-and-zephyr-7b-beta-to-build-a-knowledge-graph-33d7534ee01b)ä¸­çš„æŠ€æœ¯ï¼Œæˆ‘é€šè¿‡æ·»åŠ å…³é”®è¯å’Œèšç±»å¢å¼ºäº†è¿™ä¸ªæ•°æ®é›†ã€‚ç”±äºæˆ‘çš„ä¸»è¦å…³æ³¨ç‚¹æ˜¯æ„å»ºä¸€ä¸ªå¾®è°ƒæ•°æ®é›†ï¼Œæˆ‘å°†çœç•¥æ„å»ºè¯¥å›¾è°±çš„å…·ä½“ç»†èŠ‚ã€‚å¯¹äºæ„Ÿå…´è¶£çš„è¯»è€…ï¼Œè¯¦ç»†ä¿¡æ¯å¯ä»¥åœ¨è¿™ä¸ª[Githubä»“åº“](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator)ä¸­æ‰¾åˆ°ã€‚
- en: 'The graph is of a reasonable size, featuring over 38K nodes and almost 96K
    relationships, with 9 node labels and 8 relationship types. Its schema is illustrated
    in the following image:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: è¯¥å›¾è°±çš„è§„æ¨¡åˆç†ï¼ŒåŒ…å«è¶…è¿‡38Kä¸ªèŠ‚ç‚¹å’Œè¿‘96Kä¸ªå…³ç³»ï¼Œæ‹¥æœ‰9ç§èŠ‚ç‚¹æ ‡ç­¾å’Œ8ç§å…³ç³»ç±»å‹ã€‚å…¶æ¶æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
- en: '![](../Images/9d2e0017b08013546e0efeae020a78c9.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9d2e0017b08013546e0efeae020a78c9.png)'
- en: Image by the Author
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…
- en: While this knowledge graph isnâ€™t fully optimized and could be improved, it serves
    the purposes of this blogpost quite effectively. If you prefer to just test queries
    without building the graph, I uploaded the dump file in this [Github repository](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: è™½ç„¶è¿™ä¸ªçŸ¥è¯†å›¾è°±å°šæœªå®Œå…¨ä¼˜åŒ–ï¼Œè¿˜å¯ä»¥è¿›ä¸€æ­¥æ”¹è¿›ï¼Œä½†å®ƒåœ¨è¿™ç¯‡åšå®¢æ–‡ç« ä¸­èƒ½å¤Ÿæœ‰æ•ˆåœ°å®ç°ç›®çš„ã€‚å¦‚æœä½ æ›´å€¾å‘äºç›´æ¥æµ‹è¯•æŸ¥è¯¢è€Œä¸æ„å»ºå›¾è°±ï¼Œæˆ‘å·²å°†æ•°æ®è½¬å‚¨æ–‡ä»¶ä¸Šä¼ è‡³è¿™ä¸ª[Githubä»“åº“](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator)ã€‚
- en: Generating Training Pairs with LLM
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä½¿ç”¨LLMç”Ÿæˆè®­ç»ƒå¯¹
- en: The first approach I implemented was inspired by Tomaz Bratanicâ€™s blogposts
    on [building a knowledge graph chatbot](https://medium.com/neo4j/knowledge-graph-based-chatbot-with-gpt-3-and-neo4j-c4ebbd325ed)
    and [finetuning a LLM with H2O Studio](/fine-tuning-an-llm-model-with-h2o-llm-studio-to-generate-cypher-statements-3f34822ad5).
    Initially, a selection of sample queries was provided in the prompt. However,
    some of the recent models have enhanced capability to generate Cypher queries
    directly from the graph schema. Therefore, in addition to GPT-4 or GPT-4-turbo,
    there are now accessible open source alternatives such as Mixtral-8x7B I anticipate
    could effectively generate decent quality training data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å®ç°çš„ç¬¬ä¸€ç§æ–¹æ³•çµæ„Ÿæ¥è‡ªTomaz Bratanicçš„åšå®¢æ–‡ç« ï¼Œå…³äº[æ„å»ºçŸ¥è¯†å›¾è°±èŠå¤©æœºå™¨äºº](https://medium.com/neo4j/knowledge-graph-based-chatbot-with-gpt-3-and-neo4j-c4ebbd325ed)å’Œ[ä½¿ç”¨H2O
    Studioå¾®è°ƒLLMæ¨¡å‹](/fine-tuning-an-llm-model-with-h2o-llm-studio-to-generate-cypher-statements-3f34822ad5)ã€‚æœ€åˆï¼Œåœ¨æç¤ºä¸­æä¾›äº†ä¸€äº›ç¤ºä¾‹æŸ¥è¯¢ã€‚ç„¶è€Œï¼Œæœ€è¿‘çš„ä¸€äº›æ¨¡å‹å¢å¼ºäº†ç›´æ¥ä»å›¾è°±æ¶æ„ç”ŸæˆCypheræŸ¥è¯¢çš„èƒ½åŠ›ã€‚å› æ­¤ï¼Œé™¤äº†GPT-4æˆ–GPT-4-turboä¹‹å¤–ï¼Œç°åœ¨è¿˜æœ‰å¯è®¿é—®çš„å¼€æºæ›¿ä»£æ–¹æ¡ˆï¼Œå¦‚Mixtral-8x7Bï¼Œæˆ‘é¢„æœŸå®ƒèƒ½å¤Ÿæœ‰æ•ˆç”Ÿæˆé«˜è´¨é‡çš„è®­ç»ƒæ•°æ®ã€‚
- en: In this project, I experimented with two models. For the sake of convenience,
    I decided to use GPT-4-turbo in conjunction with ChatGPT, see this [Colab Notebook](https://github.com/SolanaO/Blogs_Content/blob/master/cypher_generator/4_ArXiv_KG_Synthetic_Data_OpenAI.ipynb).
    However, in this [notebook](https://github.com/SolanaO/Blogs_Content/blob/master/cypher_generator/5_ArXiv_KG_Synthetic_Data_Mixtral.ipynb)
    I performed a few tests with Mixtral-7x2B-GPTQ, a quantized model that is small
    enough to run on Google Colab, and which delivers satisfactory results.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ï¼Œæˆ‘å°è¯•äº†ä¸¤ç§æ¨¡å‹ã€‚ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œæˆ‘å†³å®šå°†GPT-4-turboä¸ChatGPTç»“åˆä½¿ç”¨ï¼Œè¯¦æƒ…è¯·è§è¿™ä¸ª[Colabç¬”è®°æœ¬](https://github.com/SolanaO/Blogs_Content/blob/master/cypher_generator/4_ArXiv_KG_Synthetic_Data_OpenAI.ipynb)ã€‚ç„¶è€Œï¼Œåœ¨è¿™ä¸ª[ç¬”è®°æœ¬](https://github.com/SolanaO/Blogs_Content/blob/master/cypher_generator/5_ArXiv_KG_Synthetic_Data_Mixtral.ipynb)ä¸­ï¼Œæˆ‘å¯¹Mixtral-7x2B-GPTQæ¨¡å‹è¿›è¡Œäº†ä¸€äº›æµ‹è¯•ï¼Œå®ƒæ˜¯ä¸€ä¸ªè¶³å¤Ÿå°çš„é‡åŒ–æ¨¡å‹ï¼Œå¯ä»¥åœ¨Google
    Colabä¸Šè¿è¡Œï¼Œå¹¶ä¸”èƒ½å¤Ÿæä¾›ä»¤äººæ»¡æ„çš„ç»“æœã€‚
- en: 'To maintain data diversity and effectively monitor the generated questions,
    Cypher statements pairs, I have adopted a two steps approach:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†ä¿æŒæ•°æ®çš„å¤šæ ·æ€§å¹¶æœ‰æ•ˆç›‘æ§ç”Ÿæˆçš„æé—®å’ŒCypherè¯­å¥å¯¹ï¼Œæˆ‘é‡‡ç”¨äº†ä¸€ä¸ªä¸¤æ­¥æ³•ï¼š
- en: 'Step 1: provide the full schema to the LLM and request it to generate 10â€“15
    different categories of potential questions related to the graph, along with their
    descriptions,'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¬¬1æ­¥ï¼šæä¾›å®Œæ•´çš„æ¶æ„ç»™LLMï¼Œå¹¶è¯·æ±‚å…¶ç”Ÿæˆ10â€“15ç§ä¸åŒç±»åˆ«çš„ä¸å›¾è°±ç›¸å…³çš„æ½œåœ¨é—®é¢˜åŠå…¶æè¿°ã€‚
- en: 'Step 2: provide schema information and instruct the LLM to create a specific
    number N of training pairs for each identified category.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç¬¬2æ­¥ï¼šæä¾›æ¶æ„ä¿¡æ¯å¹¶æŒ‡ç¤ºLLMä¸ºæ¯ä¸ªè¯†åˆ«çš„ç±»åˆ«åˆ›å»ºç‰¹å®šæ•°é‡Nçš„è®­ç»ƒå¯¹ã€‚
- en: 'Extract the categories of samples:'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æå–æ ·æœ¬ç±»åˆ«ï¼š
- en: For this step I used ChatGPT Pro version, although I did iterate through the
    prompt several times, combined and enhanced the outputs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€æ­¥ï¼Œæˆ‘ä½¿ç”¨äº† ChatGPT Pro ç‰ˆæœ¬ï¼Œå°½ç®¡æˆ‘ç¡®å®å¤šæ¬¡è°ƒæ•´æç¤ºï¼Œç»“åˆå¹¶å¢å¼ºäº†è¾“å‡ºç»“æœã€‚
- en: Extract a schema of the graph as a string (more about this in the next section).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°†å›¾çš„æ¨¡å¼æå–ä¸ºå­—ç¬¦ä¸²ï¼ˆæœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è§ä¸‹ä¸€éƒ¨åˆ†ï¼‰ã€‚
- en: 'Build a prompt to generate the categories:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ„å»ºä¸€ä¸ªæç¤ºæ¥ç”Ÿæˆç±»åˆ«ï¼š
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Ask the LLM to generate the categories.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¯· LLM ç”Ÿæˆç±»åˆ«ã€‚
- en: 'Review, make corrections and enhance the categories as needed. Here is a sample:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®¡æŸ¥ã€ä¿®æ­£å¹¶æ ¹æ®éœ€è¦å¢å¼ºç±»åˆ«ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ğŸ’¡**Tips**ğŸ’¡
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡**æç¤º**ğŸ’¡
- en: '*If the graph schema is very large, split it into overlapping subgraphs (this
    depends on the graph topology also) and repeat the abov*e process for each subgraph.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*å¦‚æœå›¾çš„æ¨¡å¼éå¸¸å¤§ï¼Œæ‹†åˆ†ä¸ºé‡å çš„å­å›¾ï¼ˆè¿™ä¹Ÿå–å†³äºå›¾çš„æ‹“æ‰‘ç»“æ„ï¼‰ï¼Œå¹¶å¯¹æ¯ä¸ªå­å›¾é‡å¤ä¸Šè¿°è¿‡ç¨‹ã€‚*'
- en: '*When working with open source models, choose the best model you can fit on
    your computational resources.* [*TheBloke*](https://huggingface.co/TheBloke) *has
    posted an extensive list of quantized models,* [*Neo4j GenAI*](https://neo4j.com/emil/introducing-genai-stack-developers/)
    *provides tools to work on your own hardware and* [*LightningAI Studio*](https://lightning.ai/onboarding)
    *is a recently released platform which gives you access to a multitude of LLMs.*'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*åœ¨ä½¿ç”¨å¼€æºæ¨¡å‹æ—¶ï¼Œé€‰æ‹©æœ€é€‚åˆä½ è®¡ç®—èµ„æºçš„æ¨¡å‹ã€‚* [*TheBloke*](https://huggingface.co/TheBloke) *å‘å¸ƒäº†ä¸€ä¸ªè¯¦å°½çš„é‡åŒ–æ¨¡å‹æ¸…å•ï¼Œ*
    [*Neo4j GenAI*](https://neo4j.com/emil/introducing-genai-stack-developers/) *æä¾›äº†åœ¨ä½ è‡ªå·±çš„ç¡¬ä»¶ä¸Šå·¥ä½œçš„å·¥å…·ï¼Œ*
    [*LightningAI Studio*](https://lightning.ai/onboarding) *æ˜¯ä¸€ä¸ªæœ€è¿‘å‘å¸ƒçš„å¹³å°ï¼Œæä¾›å¯¹å¤šç§ LLMs
    çš„è®¿é—®ã€‚*'
- en: 'Generate the training pairs:'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç”Ÿæˆè®­ç»ƒå¯¹ï¼š
- en: 'This step was performed with OpenAI API, working with GPT-4-turbo which also
    has the option to output JSON format. Again the schema of the graph is provided
    with the prompt:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸€æ­¥æ˜¯é€šè¿‡ OpenAI API æ‰§è¡Œçš„ï¼Œä½¿ç”¨ GPT-4-turboï¼Œå®ƒä¹Ÿæœ‰è¾“å‡º JSON æ ¼å¼çš„é€‰é¡¹ã€‚åŒæ ·ï¼Œå›¾çš„æ¨¡å¼é€šè¿‡æç¤ºæä¾›ï¼š
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Build the function which will prompt the model and will retrieve the output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: æ„å»ºä¸€ä¸ªå‡½æ•°æ¥æç¤ºæ¨¡å‹å¹¶æ£€ç´¢è¾“å‡ºï¼š
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Loop through the categories and collect the outputs in a list:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: éå†ç±»åˆ«å¹¶å°†è¾“å‡ºæ”¶é›†åˆ°ä¸€ä¸ªåˆ—è¡¨ä¸­ï¼š
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point in the project I collected almost 500 pairs of questions, Cypher
    statements. Here is a sample:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨é¡¹ç›®çš„è¿™ä¸€é˜¶æ®µï¼Œæˆ‘æ”¶é›†äº†è¿‘ 500 å¯¹é—®é¢˜å’Œ Cypher è¯­å¥ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªç¤ºä¾‹ï¼š
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The data requires significant cleaning and wrangling. While not overly complex,
    the process is both time-consuming and tedious. Here are several of the challenges
    I encountered:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: æ•°æ®éœ€è¦å¤§é‡æ¸…ç†å’Œæ•´ç†ã€‚è™½ç„¶å¹¶ä¸å¤æ‚ï¼Œä½†è¿‡ç¨‹æ—¢è€—æ—¶åˆç¹çã€‚ä»¥ä¸‹æ˜¯æˆ‘é‡åˆ°çš„ä¸€äº›æŒ‘æˆ˜ï¼š
- en: non-JSON entries due to incomplete Cypher statements;
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ç”±äº Cypher è¯­å¥ä¸å®Œæ•´ï¼Œå­˜åœ¨é JSON æ¡ç›®ï¼›
- en: 'the expected format is {â€™questionâ€™: â€˜some questionâ€™, â€˜cypherâ€™:â€™some cypherâ€™},
    but deviations are frequent and need to be standardized;'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'æœŸæœ›çš„æ ¼å¼æ˜¯ {â€™questionâ€™: â€˜æŸä¸ªé—®é¢˜â€™, â€˜cypherâ€™:â€™æŸä¸ª cypherâ€™}ï¼Œä½†åå·®å¾ˆå¸¸è§ï¼Œéœ€è¦è¿›è¡Œæ ‡å‡†åŒ–ï¼›'
- en: instances where the questions and the Cypher statements are clustered together,
    necessiting their separation and organization.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åœ¨é—®é¢˜å’Œ Cypher è¯­å¥èšé›†åœ¨ä¸€èµ·çš„æƒ…å†µä¸‹ï¼Œéœ€è¦å°†å®ƒä»¬åˆ†å¼€å¹¶è¿›è¡Œç»„ç»‡ã€‚
- en: ğŸ’¡**Tip**ğŸ’¡
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡**æç¤º**ğŸ’¡
- en: '*It is better to iterate through variations of the prompt than trying to find
    the best prompt format from the beginning. In my experience, even with diligent
    adjustments, generating a large volume of data like this inevitably leads to some
    deviations.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä¸å…¶ä»ä¸€å¼€å§‹å°±è¯•å›¾æ‰¾åˆ°æœ€å¥½çš„æç¤ºæ ¼å¼ï¼Œä¸å¦‚å¤šæ¬¡è¿­ä»£æç¤ºçš„å˜ä½“ã€‚æ ¹æ®æˆ‘çš„ç»éªŒï¼Œå³ä½¿ç»è¿‡ä»”ç»†è°ƒæ•´ï¼Œåƒè¿™æ ·çš„å¤§é‡æ•°æ®ç”Ÿæˆä¸å¯é¿å…åœ°ä¼šå‡ºç°ä¸€äº›åå·®ã€‚*'
- en: Now regarding the content. GPT-4-turbo is quite capable to generate good questions
    about the graph, however not all the Cypher statements are valid (working Cypher)
    and correct (extract the intended information). When fine-tuning in a production
    environment, I would either rectify or eliminate these erroneous statements.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨è¯´è¯´å†…å®¹æ–¹é¢ã€‚GPT-4-turbo å¾ˆæœ‰èƒ½åŠ›ç”Ÿæˆå…³äºå›¾çš„å¥½é—®é¢˜ï¼Œä½†å¹¶éæ‰€æœ‰çš„ Cypher è¯­å¥éƒ½æ˜¯æœ‰æ•ˆçš„ï¼ˆå·¥ä½œ Cypherï¼‰å’Œæ­£ç¡®çš„ï¼ˆæå–é¢„æœŸä¿¡æ¯ï¼‰ã€‚åœ¨ç”Ÿäº§ç¯å¢ƒä¸­è¿›è¡Œå¾®è°ƒæ—¶ï¼Œæˆ‘ä¼šçº æ­£æˆ–åˆ é™¤è¿™äº›é”™è¯¯çš„è¯­å¥ã€‚
- en: I created a function `execute_cypher_queries()` that sends the queries to the
    Neo4j graph database . It either records a message in case of an error or retrieves
    the output from the database. This function is available in this [Google Colab
    notebook](https://github.com/SolanaO/Blogs_Content/blob/master/cypher_generator/4_ArXiv_KG_Synthetic_Data_OpenAI.ipynb).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘åˆ›å»ºäº†ä¸€ä¸ªå‡½æ•° `execute_cypher_queries()`ï¼Œå®ƒå°†æŸ¥è¯¢å‘é€åˆ° Neo4j å›¾æ•°æ®åº“ã€‚å¦‚æœå‡ºç°é”™è¯¯ï¼Œå®ƒä¼šè®°å½•ä¸€æ¡æ¶ˆæ¯ï¼Œæˆ–è€…ä»æ•°æ®åº“ä¸­æ£€ç´¢è¾“å‡ºã€‚æ­¤å‡½æ•°å¯ä»¥åœ¨æ­¤
    [Google Colab ç¬”è®°æœ¬](https://github.com/SolanaO/Blogs_Content/blob/master/cypher_generator/4_ArXiv_KG_Synthetic_Data_OpenAI.ipynb)
    ä¸­æ‰¾åˆ°ã€‚
- en: 'From the prompt, you may notice that I instructed the LLM to generate mock
    data to populate the attributes values. While this approach is simpler, it results
    in numerous empty outputs from the graph. And it demands extra effort to identify
    those statements involving hallucinatins, such as made-up attributes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ä»æç¤ºä¸­ï¼Œä½ å¯èƒ½ä¼šæ³¨æ„åˆ°æˆ‘æŒ‡ç¤º LLM ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®ä»¥å¡«å……å±æ€§å€¼ã€‚è™½ç„¶è¿™ç§æ–¹æ³•æ›´ç®€å•ï¼Œä½†å®ƒå¯¼è‡´å›¾ä¸­çš„è®¸å¤šç©ºè¾“å‡ºã€‚è€Œä¸”ï¼Œè¿™éœ€è¦é¢å¤–çš„åŠªåŠ›æ¥è¯†åˆ«æ¶‰åŠå¹»è§‰çš„è¯­å¥ï¼Œå¦‚è™šæ„çš„å±æ€§ï¼š
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Article` node has no `creation_date` attribute in the ArXiv graph!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Article` èŠ‚ç‚¹åœ¨ ArXiv å›¾ä¸­æ²¡æœ‰ `creation_date` å±æ€§ï¼'
- en: ğŸ’¡**Tip**ğŸ’¡
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡**æç¤º**ğŸ’¡
- en: '*To minimize the empty outputs, we could instead extract instances directly
    from the graph. These instances can then be incorporated into the prompt, and
    instruct the LLM to use this information to enrich the Cypher statements.*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä¸ºäº†å‡å°‘ç©ºè¾“å‡ºï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä»å›¾ä¸­æå–å®ä¾‹ã€‚è¿™äº›å®ä¾‹å¯ä»¥è¢«çº³å…¥æç¤ºä¸­ï¼Œå¹¶æŒ‡ç¤º LLM ä½¿ç”¨è¿™äº›ä¿¡æ¯æ¥ä¸°å¯Œ Cypher è¯­å¥ã€‚*'
- en: Building Functional Queries
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ„å»ºåŠŸèƒ½æŸ¥è¯¢
- en: This method allows to create anywhere from hundreds to hundreds of thousands
    of correct Cypher queries, depending on the graphâ€™s size and complexity. However,
    it is crucial to strike a balance bewteen the quantity and the diversity of these
    queries. Despite being correct and applicable to any graph, these queries can
    occasionally appear formulaic or rigid.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•å¯ä»¥ç”Ÿæˆä»æ•°ç™¾åˆ°æ•°åä¸‡æ¡æ­£ç¡®çš„ Cypher æŸ¥è¯¢ï¼Œå…·ä½“å–å†³äºå›¾çš„å¤§å°å’Œå¤æ‚æ€§ã€‚ç„¶è€Œï¼Œè‡³å…³é‡è¦çš„æ˜¯è¦åœ¨æŸ¥è¯¢çš„æ•°é‡å’Œå¤šæ ·æ€§ä¹‹é—´æ‰¾åˆ°å¹³è¡¡ã€‚å°½ç®¡è¿™äº›æŸ¥è¯¢åœ¨ä»»ä½•å›¾ä¸­éƒ½æ˜¯æ­£ç¡®ä¸”é€‚ç”¨çš„ï¼Œä½†å®ƒä»¬æœ‰æ—¶ä¼šæ˜¾å¾—å…¬å¼åŒ–æˆ–åƒµåŒ–ã€‚
- en: Extract Information About the Graph Structure
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æå–æœ‰å…³å›¾ç»“æ„çš„ä¿¡æ¯
- en: For this process we need to start with some data extraction and preparation.
    I use the Cypher queries and the some of the code from the [neo4j_graph.py](https://github.com/langchain-ai/langchain/blob/master/libs/community/langchain_community/graphs/neo4j_graph.py)
    module in Langchain.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºè¿™ä¸ªè¿‡ç¨‹ï¼Œæˆ‘ä»¬éœ€è¦ä»ä¸€äº›æ•°æ®æå–å’Œå‡†å¤‡å¼€å§‹ã€‚æˆ‘ä½¿ç”¨äº† Cypher æŸ¥è¯¢å’Œæ¥è‡ª [neo4j_graph.py](https://github.com/langchain-ai/langchain/blob/master/libs/community/langchain_community/graphs/neo4j_graph.py)
    æ¨¡å—çš„ä¸€äº›ä»£ç ã€‚
- en: Connect to an existing Neo4j graph database.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿æ¥åˆ°ç°æœ‰çš„ Neo4j å›¾å½¢æ•°æ®åº“ã€‚
- en: Extract the schema in JSON format.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æå– JSON æ ¼å¼çš„æ¨¡å¼ã€‚
- en: Extract several node and relationship instances from the graph, i.e. data from
    the graph to use as samples to populate the queries.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä»å›¾ä¸­æå–å‡ ä¸ªèŠ‚ç‚¹å’Œå…³ç³»å®ä¾‹ï¼Œå³ä»å›¾ä¸­æå–æ•°æ®ä½œä¸ºæ ·æœ¬ï¼Œç”¨äºå¡«å……æŸ¥è¯¢ã€‚
- en: 'I created a Python class that perfoms these steps, it is available at `utils/neo4j_schema.py`
    in the [Github repository](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator).
    With all these in place, extracting the relevant data about the graph necessitates
    a few lines of code only:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘åˆ›å»ºäº†ä¸€ä¸ªæ‰§è¡Œè¿™äº›æ­¥éª¤çš„ Python ç±»ï¼Œå®ƒå¯ä»¥åœ¨ [Github ä»“åº“](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator)ä¸­çš„
    `utils/neo4j_schema.py` æ‰¾åˆ°ã€‚æœ‰äº†è¿™äº›ï¼Œåªéœ€å‡ è¡Œä»£ç å³å¯æå–å›¾çš„ç›¸å…³æ•°æ®ï¼š
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Extract Data From the Graph
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä»å›¾ä¸­æå–æ•°æ®
- en: This data will provide authentic values to populate our Cypher queries with.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›æ•°æ®å°†ä¸ºæˆ‘ä»¬å¡«å…… Cypher æŸ¥è¯¢æä¾›çœŸå®çš„å€¼ã€‚
- en: 'First, we extract several node instances, this will retrieve all the data for
    nodes in the graph, including labels, attributes and their values :'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œæˆ‘ä»¬æå–å‡ ä¸ªèŠ‚ç‚¹å®ä¾‹ï¼Œè¿™å°†æ£€ç´¢å›¾ä¸­æ‰€æœ‰èŠ‚ç‚¹çš„æ•°æ®ï¼ŒåŒ…æ‹¬æ ‡ç­¾ã€å±æ€§åŠå…¶å€¼ï¼š
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, extract relationship instances, this includes all the data on the start
    node, the relationship with its type and properties, and the end node information:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ï¼Œæå–å…³ç³»å®ä¾‹ï¼ŒåŒ…æ‹¬èµ·å§‹èŠ‚ç‚¹ã€å…³ç³»çš„ç±»å‹å’Œå±æ€§ä»¥åŠç»ˆæ­¢èŠ‚ç‚¹ä¿¡æ¯ï¼š
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ğŸ’¡**Tips**ğŸ’¡
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡**æç¤º**ğŸ’¡
- en: '*Both of the above methods work for the full lists of nodes, relationships
    or sublists of them.*'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ä¸Šè¿°ä¸¤ç§æ–¹æ³•é€‚ç”¨äºå®Œæ•´çš„èŠ‚ç‚¹åˆ—è¡¨ã€å…³ç³»æˆ–å®ƒä»¬çš„å­åˆ—è¡¨ã€‚*'
- en: '*If the graph contains instances that lack records for some attributes, it
    is advisable to collect more instances to ensure all possible scenarios are covered.*'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*å¦‚æœå›¾ä¸­åŒ…å«ç¼ºå°‘æŸäº›å±æ€§è®°å½•çš„å®ä¾‹ï¼Œå»ºè®®æ”¶é›†æ›´å¤šå®ä¾‹ï¼Œä»¥ç¡®ä¿è¦†ç›–æ‰€æœ‰å¯èƒ½çš„åœºæ™¯ã€‚*'
- en: The next step is to serialize the data, by replacing the Neo4j.time values with
    strings and save it to files.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€æ­¥æ˜¯åºåˆ—åŒ–æ•°æ®ï¼Œé€šè¿‡å°† Neo4j.time çš„å€¼æ›¿æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œå¹¶å°†å…¶ä¿å­˜åˆ°æ–‡ä»¶ä¸­ã€‚
- en: Parse the Extracted Data
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: è§£ææå–çš„æ•°æ®
- en: I refer to this phase as Python gymnastics. Here, we handle the data obtained
    in the previous step, which consists of the graph schema, node instances, and
    relationship instances. We reformat this data to make it easily accessible for
    the functions we are developing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æŠŠè¿™ä¸ªé˜¶æ®µç§°ä¸º Python ä½“æ“ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¤„ç†å‰ä¸€æ­¥è·å¾—çš„æ•°æ®ï¼ŒåŒ…æ‹¬å›¾æ¨¡å¼ã€èŠ‚ç‚¹å®ä¾‹å’Œå…³ç³»å®ä¾‹ã€‚æˆ‘ä»¬é‡æ–°æ ¼å¼åŒ–è¿™äº›æ•°æ®ï¼Œä»¥ä½¿å…¶æ›´æ˜“äºè®¿é—®æˆ‘ä»¬æ­£åœ¨å¼€å‘çš„å‡½æ•°ã€‚
- en: 'We first identify all the datatypes in the graph with:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬é¦–å…ˆä½¿ç”¨ä»¥ä¸‹æ–¹æ³•è¯†åˆ«å›¾ä¸­çš„æ‰€æœ‰æ•°æ®ç±»å‹ï¼š
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For each datatype we extract the attributes (and the corresponding nodes) that
    have that dataype.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¯¹äºæ¯ç§æ•°æ®ç±»å‹ï¼Œæˆ‘ä»¬æå–å…·æœ‰è¯¥æ•°æ®ç±»å‹çš„å±æ€§ï¼ˆåŠç›¸åº”çš„èŠ‚ç‚¹ï¼‰ã€‚
- en: We parse instances of each datatype.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è§£ææ¯ç§æ•°æ®ç±»å‹çš„å®ä¾‹ã€‚
- en: We also process and filter the relationships so that the start and the end nodes
    have attributes of specifid data types.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬è¿˜ä¼šå¤„ç†å’Œç­›é€‰å…³ç³»ï¼Œä½¿å¾—èµ·å§‹èŠ‚ç‚¹å’Œç»“æŸèŠ‚ç‚¹å…·æœ‰ç‰¹å®šæ•°æ®ç±»å‹çš„å±æ€§ã€‚
- en: All the code is available in the [Github repository](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator).
    The reasons of doing all these will become transparent in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€æœ‰ä»£ç éƒ½å¯ä»¥åœ¨[Github ä»“åº“](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator)ä¸­æ‰¾åˆ°ã€‚è¿™æ ·åšçš„åŸå› å°†åœ¨ä¸‹ä¸€èŠ‚ä¸­é€æ˜åŒ–ã€‚
- en: How to Build One or One Thousand Cypher Statements
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¦‚ä½•æ„å»ºä¸€ä¸ªæˆ–ä¸€åƒä¸ª Cypher è¯­å¥
- en: 'Being a mathematician, I often perceive statements in terms of the underlying
    functions. Letâ€™s consider the following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œä¸ºä¸€ä¸ªæ•°å­¦å®¶ï¼Œæˆ‘é€šå¸¸é€šè¿‡æ½œåœ¨çš„å‡½æ•°æ¥ç†è§£é™ˆè¿°ã€‚è®©æˆ‘ä»¬è€ƒè™‘ä»¥ä¸‹ç¤ºä¾‹ï¼š
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The above can be regarded as functions of several variables `f(x, y, z)` and
    `g(x. y, z)` where
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸Šè¿°å†…å®¹å¯ä»¥è§†ä¸ºå¤šä¸ªå˜é‡`f(x, y, z)`å’Œ`g(x, y, z)`çš„å‡½æ•°ï¼Œå…¶ä¸­
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How many queries of this type can we build? To simplify the argument letâ€™s assume
    that there are `N` node labels, each having in average `n` properties that have
    `STRING` datatype. So at least `Nxn` queries are available for us to build, not
    taking into account the options for the string choices `z`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬èƒ½æ„å»ºå¤šå°‘è¿™ç§ç±»å‹çš„æŸ¥è¯¢ï¼Ÿä¸ºäº†ç®€åŒ–è®ºè¯ï¼Œå‡è®¾æœ‰`N`ä¸ªèŠ‚ç‚¹æ ‡ç­¾ï¼Œæ¯ä¸ªæ ‡ç­¾å¹³å‡æœ‰`n`ä¸ªå±æ€§ï¼Œè¿™äº›å±æ€§çš„æ•°æ®ç±»å‹ä¸º`STRING`ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è‡³å°‘å¯ä»¥æ„å»º`Nxn`ä¸ªæŸ¥è¯¢ï¼Œä¸è€ƒè™‘å­—ç¬¦ä¸²é€‰æ‹©`z`çš„é€‰é¡¹ã€‚
- en: ğŸ’¡**Tip**ğŸ’¡
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡**æç¤º**ğŸ’¡
- en: '*Just because we are able to construct all these queries using a single line
    of code doesnâ€™t imply that we should incorporate the entire set of examples into
    our fine-tuning dataset.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä»…ä»…å› ä¸ºæˆ‘ä»¬èƒ½å¤Ÿé€šè¿‡ä¸€è¡Œä»£ç æ„å»ºæ‰€æœ‰è¿™äº›æŸ¥è¯¢ï¼Œå¹¶ä¸æ„å‘³ç€æˆ‘ä»¬åº”è¯¥å°†æ•´ä¸ªæŸ¥è¯¢ç¤ºä¾‹é›†çº³å…¥æˆ‘ä»¬çš„å¾®è°ƒæ•°æ®é›†ä¸­ã€‚*'
- en: Develop a Process and a Template
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åˆ¶å®šä¸€ä¸ªæµç¨‹å’Œæ¨¡æ¿
- en: The main challenge lies in creating a sufficiently varied list of queries that
    covers a wide range of aspects related to the graph. With both proprietary and
    open-source LLMs capable of generating basic Cypher syntax, our focus can shift
    to generating queries about the nodes and relationships within the graph, while
    omitting syntax-specific queries. To gather query examples for conversion into
    functional form, one could refer to any Cypher language book or explore the [Neo4j
    Cypher documentation site](https://neo4j.com/docs/cypher-manual/current/introduction/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸»è¦æŒ‘æˆ˜åœ¨äºåˆ›å»ºä¸€ä¸ªè¶³å¤Ÿå¤šæ ·åŒ–çš„æŸ¥è¯¢åˆ—è¡¨ï¼Œè¦†ç›–ä¸å›¾è°±ç›¸å…³çš„å¹¿æ³›æ–¹é¢ã€‚ç”±äºä¸“æœ‰å’Œå¼€æºçš„å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰èƒ½å¤Ÿç”ŸæˆåŸºæœ¬çš„ Cypher è¯­æ³•ï¼Œæˆ‘ä»¬çš„é‡ç‚¹å¯ä»¥è½¬å‘ç”Ÿæˆæœ‰å…³å›¾è°±ä¸­èŠ‚ç‚¹å’Œå…³ç³»çš„æŸ¥è¯¢ï¼Œè€Œå¿½ç•¥ç‰¹å®šè¯­æ³•çš„æŸ¥è¯¢ã€‚ä¸ºäº†æ”¶é›†æŸ¥è¯¢ç¤ºä¾‹å¹¶å°†å…¶è½¬æ¢ä¸ºåŠŸèƒ½å½¢å¼ï¼Œå¯ä»¥å‚è€ƒä»»ä½•
    Cypher è¯­è¨€ä¹¦ç±æˆ–è®¿é—®[Neo4j Cypher æ–‡æ¡£ç½‘ç«™](https://neo4j.com/docs/cypher-manual/current/introduction/)ã€‚
- en: In the [GitHub repository](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator),
    there are about 60 types of these queries that are then applied to the ArXiv knowledge
    graph. They are versatile and applicable to any graph schema.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[GitHub ä»“åº“](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator)ä¸­ï¼Œæœ‰å¤§çº¦60ç§æ­¤ç±»æŸ¥è¯¢ï¼Œå®ƒä»¬è¢«åº”ç”¨äº
    ArXiv çŸ¥è¯†å›¾è°±ã€‚è¿™äº›æŸ¥è¯¢å…·æœ‰å¤šåŠŸèƒ½æ€§ï¼Œé€‚ç”¨äºä»»ä½•å›¾è°±æ¨¡å¼ã€‚
- en: 'Below is the complete Python function for creating one set of similar queries
    and incorporate it in the fine-tuning dataset:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ä»¥ä¸‹æ˜¯åˆ›å»ºä¸€ç»„ç›¸ä¼¼æŸ¥è¯¢å¹¶å°†å…¶çº³å…¥å¾®è°ƒæ•°æ®é›†çš„å®Œæ•´ Python å‡½æ•°ï¼š
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'the function find_nodes_connected_to_node_via_relation() takes the generating
    prompter and evaluates it for all the elements in all_rels which is the collection
    of extracted and processed relationship instances, whose entries are of the form:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å‡½æ•°find_nodes_connected_to_node_via_relation()æ¥å—ç”Ÿæˆçš„æç¤ºå¹¶å¯¹all_relsä¸­çš„æ‰€æœ‰å…ƒç´ è¿›è¡Œè¯„ä¼°ï¼Œall_relsæ˜¯æå–å’Œå¤„ç†åçš„å…³ç³»å®ä¾‹é›†åˆï¼Œæ¡ç›®çš„å½¢å¼ä¸ºï¼š
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: the prompter inputs are two nodes denoted `label_1` and `label_2` , the property
    `prop_1` for `label_1` and the relationship `rel_1` ,
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æç¤ºè¾“å…¥ä¸ºä¸¤ä¸ªèŠ‚ç‚¹ï¼Œåˆ†åˆ«è¡¨ç¤ºä¸º`label_1`å’Œ`label_2`ï¼Œå±æ€§`prop_1`é’ˆå¯¹`label_1`ï¼Œå…³ç³»`rel_1`ï¼Œ
- en: the `message` contains the components of the prompt for the corresponding entry
    in the fine-tuning dataset,
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`åŒ…å«äº†ç›¸åº”æ¡ç›®åœ¨å¾®è°ƒæ•°æ®é›†ä¸­çš„æç¤ºç»„ä»¶ï¼Œ'
- en: 'the `subschema` extracts first neighbors for the two nodes denoted `label_1`
    and `label_2` , this means: the two nodes listed, all the nodes related to them
    (distance one in the graph), the relationships and all the corresponding attributes.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subschema`æå–è¡¨ç¤º`label_1`å’Œ`label_2`çš„ä¸¤ä¸ªèŠ‚ç‚¹çš„ç¬¬ä¸€é‚»å±…ï¼Œè¿™æ„å‘³ç€ï¼šåˆ—å‡ºçš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œå®ƒä»¬æ‰€æœ‰ç›¸å…³çš„èŠ‚ç‚¹ï¼ˆå›¾ä¸­çš„è·ç¦»ä¸º1ï¼‰ï¼Œä»¥åŠå…³ç³»å’Œæ‰€æœ‰å¯¹åº”çš„å±æ€§ã€‚'
- en: ğŸ’¡**Tip**ğŸ’¡
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ğŸ’¡**æç¤º**ğŸ’¡
- en: '*Including the* `*subschema*` *in the finetuning dataset is not essential,
    although the more closely the prompt aligns with the fine-tuning data, the better
    the generated output tends to be. From my perspective, incorporating the subschema
    in the fine-tuning data still offers advantages.*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*å°†* `*subschema*` *åŒ…æ‹¬åœ¨å¾®è°ƒæ•°æ®é›†ä¸­å¹¶éå¿…è¦ï¼Œå°½ç®¡æç¤ºä¸å¾®è°ƒæ•°æ®çš„å¯¹é½ç¨‹åº¦è¶Šé«˜ï¼Œç”Ÿæˆçš„è¾“å‡ºå¾€å¾€è¶Šå¥½ã€‚ä»æˆ‘çš„è§’åº¦æ¥çœ‹ï¼Œå°† subschema
    çº³å…¥å¾®è°ƒæ•°æ®ä»ç„¶å…·æœ‰ä¼˜åŠ¿ã€‚*'
- en: Concluding Remarks
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: 'To summarize, post has explored various methods for building a fine-tuning
    dataset for generating Cypher queries from text. Here is a breakdown of these
    techniques, along with their advantages and disadvantages:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ç»“æ¥è¯´ï¼Œæœ¬æ–‡æ¢ç´¢äº†å¤šç§æ„å»ºå¾®è°ƒæ•°æ®é›†ä»¥ä»æ–‡æœ¬ç”Ÿæˆ Cypher æŸ¥è¯¢çš„æ–¹æ³•ã€‚ä»¥ä¸‹æ˜¯è¿™äº›æŠ€æœ¯çš„æ¦‚è¿°ï¼ŒåŒ…æ‹¬å®ƒä»¬çš„ä¼˜ç¼ºç‚¹ï¼š
- en: '**LLM generated question and Cypher statements pairs**:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**LLM ç”Ÿæˆçš„é—®é¢˜å’Œ Cypher è¯­å¥å¯¹**ï¼š'
- en: The method may seem straightforward in terms of data collection, yet it often
    demands excessive data cleaning.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•åœ¨æ•°æ®æ”¶é›†æ–¹é¢çœ‹ä¼¼ç›´æ¥ï¼Œä½†å®ƒé€šå¸¸éœ€è¦è¿‡å¤šçš„æ•°æ®æ¸…ç†ã€‚
- en: While certain proprietary LLMs yield good outcomes, many open source LLMs still
    lack the proficiency of generating a wide range of accurate Cypher statements.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è™½ç„¶æŸäº›ä¸“æœ‰çš„ LLM äº§ç”Ÿäº†è¾ƒå¥½çš„ç»“æœï¼Œä½†è®¸å¤šå¼€æºçš„ LLM ä»ç„¶ç¼ºä¹ç”Ÿæˆå¤šç§å‡†ç¡® Cypher è¯­å¥çš„èƒ½åŠ›ã€‚
- en: This technique becomes burdensome when the graph schema is complex.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å½“å›¾æ¨¡å¼å¤æ‚æ—¶ï¼Œè¿™ç§æŠ€æœ¯ä¼šå˜å¾—ç¹çã€‚
- en: '**Functional approach or parametric query generation:**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**åŠŸèƒ½æ€§æ–¹æ³•æˆ–å‚æ•°æŸ¥è¯¢ç”Ÿæˆï¼š**'
- en: This method is adaptable across various graphs schemas and allows for easy scaling
    of the sample size. However, it is important to ensure that the data doesnâ€™t become
    overly repetitive and maintains diversity.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: è¿™ç§æ–¹æ³•å¯ä»¥é€‚åº”ä¸åŒçš„å›¾æ¨¡å¼ï¼Œå¹¶å…è®¸è½»æ¾æ‰©å±•æ ·æœ¬å¤§å°ã€‚ç„¶è€Œï¼Œé‡è¦çš„æ˜¯ç¡®ä¿æ•°æ®ä¸ä¼šå˜å¾—è¿‡äºé‡å¤ï¼Œå¹¶ä¿æŒå¤šæ ·æ€§ã€‚
- en: It requires a significant amount of Python programming. The queries generated
    can often seem mechanial and may lack a conversational tone.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å®ƒéœ€è¦å¤§é‡çš„ Python ç¼–ç¨‹ã€‚ç”Ÿæˆçš„æŸ¥è¯¢å¸¸å¸¸æ˜¾å¾—æœºæ¢°ï¼Œç¼ºä¹å¯¹è¯çš„è¯­æ°”ã€‚
- en: 'To expand beyond these approaches:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: è¦æ‰©å±•è¿™äº›æ–¹æ³•ä¹‹å¤–ï¼š
- en: 'The graph schema can be seamlessley incorporated into the framework for creating
    the functional queries. Consider the following question, Cypher statement pair:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å›¾æ¨¡å¼å¯ä»¥æ— ç¼åœ°èå…¥åˆ›å»ºåŠŸèƒ½æŸ¥è¯¢çš„æ¡†æ¶ä¸­ã€‚è€ƒè™‘ä»¥ä¸‹é—®é¢˜å’Œ Cypher è¯­å¥å¯¹ï¼š
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instead of using a direct parametrization, we could incorporate basic parsing
    (such as replacing WRITTEN_BY with written by), enhancing the naturalness of the
    generated question.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥é€šè¿‡åŸºæœ¬çš„è§£æï¼ˆä¾‹å¦‚å°† WRITTEN_BY æ›¿æ¢ä¸º written byï¼‰ï¼Œè€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨å‚æ•°åŒ–ï¼Œæ¥å¢å¼ºç”Ÿæˆé—®é¢˜çš„è‡ªç„¶æ€§ã€‚
- en: This highligts the significance of the graph schemaâ€™s design and the labelling
    of graphâ€™s entities in the construction of the fine-tuning pars. Adhering to general
    norms like using nouns for node labels and suggestive verbs for the relationships
    proves beneficial and can create a more organically conversational link between
    the elements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™çªæ˜¾äº†å›¾å½¢æ¨¡å¼è®¾è®¡å’Œå›¾å½¢å®ä½“æ ‡æ³¨åœ¨å¾®è°ƒè§£ææ„å»ºä¸­çš„é‡è¦æ€§ã€‚éµå¾ªä¸€èˆ¬è§„èŒƒï¼Œæ¯”å¦‚ä½¿ç”¨åè¯ä½œä¸ºèŠ‚ç‚¹æ ‡ç­¾ï¼Œä½¿ç”¨å¯Œæœ‰æç¤ºæ€§çš„åŠ¨è¯ä½œä¸ºå…³ç³»ï¼Œè¯æ˜æ˜¯æœ‰ç›Šçš„ï¼Œå¹¶ä¸”èƒ½å¤Ÿåœ¨å…ƒç´ ä¹‹é—´åˆ›å»ºæ›´è‡ªç„¶çš„å¯¹è¯å¼è”ç³»ã€‚
- en: Finally, it is crucial not to overlook the value of collecting actual user generated
    queries from graph interactions. When available, parametrizing these queries or
    enhancing them through other methods can be very useful. Ultimately, the effectiveness
    of this method depends on the specific objectives for which the graph has been
    designed.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: æœ€åï¼Œè‡³å…³é‡è¦çš„æ˜¯ä¸è¦å¿½è§†ä»å›¾å½¢äº¤äº’ä¸­æ”¶é›†å®é™…ç”¨æˆ·ç”ŸæˆæŸ¥è¯¢çš„ä»·å€¼ã€‚è‹¥æœ‰å¯èƒ½ï¼Œé€šè¿‡å‚æ•°åŒ–è¿™äº›æŸ¥è¯¢æˆ–é€šè¿‡å…¶ä»–æ–¹æ³•å¢å¼ºå®ƒä»¬ä¼šéå¸¸æœ‰ç”¨ã€‚æœ€ç»ˆï¼Œè¿™ç§æ–¹æ³•çš„æœ‰æ•ˆæ€§å–å†³äºå›¾å½¢è®¾è®¡çš„å…·ä½“ç›®æ ‡ã€‚
- en: To this end, it is important to mention that my focus was on simpler Cypher
    queries. I did not address creating or modifying data within the graph, or the
    graph schema, nor I did include APOC queries.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºæ­¤ï¼Œé‡è¦çš„æ˜¯è¦æåˆ°ï¼Œæˆ‘çš„é‡ç‚¹æ˜¯åœ¨è¾ƒç®€å•çš„ Cypher æŸ¥è¯¢ä¸Šã€‚æˆ‘æ²¡æœ‰æ¶‰åŠåˆ›å»ºæˆ–ä¿®æ”¹å›¾ä¸­çš„æ•°æ®ï¼Œä¹Ÿæ²¡æœ‰æ¶‰åŠå›¾æ¨¡å¼ï¼Œä¸”æ²¡æœ‰åŒ…æ‹¬ APOC æŸ¥è¯¢ã€‚
- en: '*Are there any other methods or ideas you might suggest for generating such
    fine-tuning question and Cypher statement pairs?*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä½ æ˜¯å¦èƒ½æå‡ºå…¶ä»–æ–¹æ³•æˆ–æƒ³æ³•ï¼Œç”¨äºç”Ÿæˆè¿™æ ·çš„å¾®è°ƒé—®é¢˜å’Œ Cypher è¯­å¥å¯¹ï¼Ÿ*'
- en: Resources
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: èµ„æº
- en: '**Code**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä»£ç **'
- en: '[Github Repository: Knowledge_Graphs_Assortment](https://www.notion.so/GraphRAG-Unleashing-the-Power-of-KG-with-LLM-51cf4430ea3349ff9320b3375fe47fe5?pvs=21)
    â€” for building the ArXiv knowledge graph'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[Github ä»“åº“ï¼šKnowledge_Graphs_Assortment](https://www.notion.so/GraphRAG-Unleashing-the-Power-of-KG-with-LLM-51cf4430ea3349ff9320b3375fe47fe5?pvs=21)
    â€” ç”¨äºæ„å»º ArXiv çŸ¥è¯†å›¾è°±'
- en: '[Github Repository: Cypher_Generator](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator)
    â€” for all the code related to this blogpost'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[Github ä»“åº“ï¼šCypher_Generator](https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator)
    â€” åŒ…å«ä¸æœ¬æ–‡ç›¸å…³çš„æ‰€æœ‰ä»£ç '
- en: '**Data**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ•°æ®**'
- en: 'â€¢ Repository of scholary articles: [arXiv Dataset](https://www.kaggle.com/datasets/Cornell-University/arxiv)
    that has [CC0: Public Domain](https://creativecommons.org/publicdomain/zero/1.0/)
    license.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'â€¢ å­¦æœ¯æ–‡ç« ä»“åº“ï¼š[arXiv æ•°æ®é›†](https://www.kaggle.com/datasets/Cornell-University/arxiv)ï¼Œè¯¥æ•°æ®é›†æ‹¥æœ‰[CC0:
    å…¬å…±é¢†åŸŸ](https://creativecommons.org/publicdomain/zero/1.0/)è®¸å¯è¯ã€‚'

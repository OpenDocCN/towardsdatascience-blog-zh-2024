- en: Diving Deeper with Structured Outputs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ·±å…¥æ¢ç´¢ç»“æ„åŒ–è¾“å‡º
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/diving-deeper-with-structured-outputs-b4a5d280c208?source=collection_archive---------1-----------------------#2024-09-03](https://towardsdatascience.com/diving-deeper-with-structured-outputs-b4a5d280c208?source=collection_archive---------1-----------------------#2024-09-03)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/diving-deeper-with-structured-outputs-b4a5d280c208?source=collection_archive---------1-----------------------#2024-09-03](https://towardsdatascience.com/diving-deeper-with-structured-outputs-b4a5d280c208?source=collection_archive---------1-----------------------#2024-09-03)
- en: Helping enhance your understanding and optimal usage of structured outputs and
    LLMs
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¸®åŠ©å¢å¼ºæ‚¨å¯¹ç»“æ„åŒ–è¾“å‡ºå’ŒLLMçš„ç†è§£ä¸æœ€ä½³ä½¿ç”¨
- en: '[](https://medium.com/@armin.catovic?source=post_page---byline--b4a5d280c208--------------------------------)[![Armin
    Catovic](../Images/046042098f3fec885e756f7f8ee94e6a.png)](https://medium.com/@armin.catovic?source=post_page---byline--b4a5d280c208--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--b4a5d280c208--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--b4a5d280c208--------------------------------)
    [Armin Catovic](https://medium.com/@armin.catovic?source=post_page---byline--b4a5d280c208--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@armin.catovic?source=post_page---byline--b4a5d280c208--------------------------------)[![Armin
    Catovic](../Images/046042098f3fec885e756f7f8ee94e6a.png)](https://medium.com/@armin.catovic?source=post_page---byline--b4a5d280c208--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--b4a5d280c208--------------------------------)[![æ•°æ®ç§‘å­¦å‰æ²¿](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--b4a5d280c208--------------------------------)
    [Armin Catovic](https://medium.com/@armin.catovic?source=post_page---byline--b4a5d280c208--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--b4a5d280c208--------------------------------)
    Â·8 min readÂ·Sep 3, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘å¸ƒäº[æ•°æ®ç§‘å­¦å‰æ²¿](https://towardsdatascience.com/?source=post_page---byline--b4a5d280c208--------------------------------)
    Â·é˜…è¯»æ—¶é•¿8åˆ†é’ŸÂ·2024å¹´9æœˆ3æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/2d1b5f51320c152d86373c947974ac13.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2d1b5f51320c152d86373c947974ac13.png)'
- en: Figure 1 â€” steps that are executed both explicitly, as well as implicitly, from
    the userâ€™s perspective, when applying structured outputs; image by the author
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾1 â€” ä»ç”¨æˆ·çš„è§’åº¦ï¼Œåœ¨åº”ç”¨ç»“æ„åŒ–è¾“å‡ºæ—¶ï¼Œæ˜¾å¼å’Œéšå¼æ‰§è¡Œçš„æ­¥éª¤ï¼›å›¾ç‰‡æ¥è‡ªä½œè€…
- en: In the [previous article](https://medium.com/towards-data-science/structured-outputs-and-how-to-use-them-40bd86881d39),
    we were introduced to **structured outputs** using OpenAI. Since the general availability
    release in ChatCompletions API ([v1.40.0](https://github.com/openai/openai-python/releases/tag/v1.40.0)),
    structured outputs have been applied across dozens of use cases, and spawned numerous
    threads on [OpenAI forums](https://community.openai.com/).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨[ä¸Šä¸€ç¯‡æ–‡ç« ](https://medium.com/towards-data-science/structured-outputs-and-how-to-use-them-40bd86881d39)ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†å¦‚ä½•ä½¿ç”¨OpenAIçš„**ç»“æ„åŒ–è¾“å‡º**ã€‚è‡ªä»ChatCompletions
    APIï¼ˆ[v1.40.0](https://github.com/openai/openai-python/releases/tag/v1.40.0)ï¼‰çš„æ­£å¼å‘å¸ƒä»¥æ¥ï¼Œç»“æ„åŒ–è¾“å‡ºå·²è¢«åº”ç”¨äºæ•°åç§ä½¿ç”¨åœºæ™¯ï¼Œå¹¶åœ¨[OpenAIè®ºå›](https://community.openai.com/)ä¸­å¼•å‘äº†å¤§é‡è®¨è®ºã€‚
- en: In this article, our aim is to provide you with an even deeper understanding,
    dispel some misconceptions, and give you some tips on how to apply them in the
    most optimal manner possible, across different scenarios.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬çš„ç›®æ ‡æ˜¯ä¸ºæ‚¨æä¾›æ›´æ·±å…¥çš„ç†è§£ï¼Œæ¶ˆé™¤ä¸€äº›è¯¯è§£ï¼Œå¹¶ä¸ºæ‚¨æä¾›ä¸€äº›å…³äºå¦‚ä½•åœ¨ä¸åŒåœºæ™¯ä¸­ä»¥æœ€ä¼˜åŒ–çš„æ–¹å¼åº”ç”¨å®ƒä»¬çš„å»ºè®®ã€‚
- en: Structured outputs overview
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“æ„åŒ–è¾“å‡ºæ¦‚è¿°
- en: Structured outputs are a way of enforcing the output of an LLM to follow a pre-defined
    schema â€” usually a JSON schema. This works by transforming the schema into a [context
    free grammar (CFG)](https://en.wikipedia.org/wiki/Context-free_grammar), which
    during the token sampling step, is used together with the previously generated
    tokens, to inform which subsequent tokens are valid. Itâ€™s helpful to think of
    it as creating a [regex](https://en.wikipedia.org/wiki/Regular_expression) for
    token generation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ç»“æ„åŒ–è¾“å‡ºæ˜¯ä¸€ç§å¼ºåˆ¶LLMè¾“å‡ºéµå¾ªé¢„å®šä¹‰æ¨¡å¼çš„æ–¹å¼â€”â€”é€šå¸¸æ˜¯JSONæ¨¡å¼ã€‚è¿™æ˜¯é€šè¿‡å°†æ¨¡å¼è½¬æ¢ä¸º[ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• (CFG)](https://en.wikipedia.org/wiki/Context-free_grammar)ï¼Œåœ¨æ ‡è®°é‡‡æ ·æ­¥éª¤ä¸­ä¸ä¹‹å‰ç”Ÿæˆçš„æ ‡è®°ä¸€èµ·ä½¿ç”¨ï¼Œä»¥ç¡®å®šå“ªäº›åç»­æ ‡è®°æ˜¯æœ‰æ•ˆçš„ã€‚å¯ä»¥å°†å…¶ç†è§£ä¸ºä¸ºæ ‡è®°ç”Ÿæˆåˆ›å»ºä¸€ä¸ª[æ­£åˆ™è¡¨è¾¾å¼](https://en.wikipedia.org/wiki/Regular_expression)ã€‚
- en: OpenAI API implementation actually tracks a limited subset of JSON schema features.
    With more general structured output solutions, such as [Outlines](https://github.com/outlines-dev/outlines),
    it is possible to use a somewhat larger subset of the JSON schema, and even define
    completely custom non-JSON schemas â€” as long as one has access to an open weight
    model. For the purpose of this article, we will assume the OpenAI API implementation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI API å®ç°å®é™…ä¸Šä»…è·Ÿè¸ª JSON schema ç‰¹æ€§çš„ä¸€ä¸ªæœ‰é™å­é›†ã€‚å¯¹äºæ›´ä¸€èˆ¬çš„ç»“æ„åŒ–è¾“å‡ºè§£å†³æ–¹æ¡ˆï¼Œæ¯”å¦‚ [Outlines](https://github.com/outlines-dev/outlines)ï¼Œå¯ä»¥ä½¿ç”¨ç¨å¤§ä¸€äº›çš„
    JSON schema å­é›†ï¼Œç”šè‡³å¯ä»¥å®šä¹‰å®Œå…¨è‡ªå®šä¹‰çš„é JSON schema â€”â€” åªè¦ä½ èƒ½è®¿é—®åˆ°å¼€æ”¾æƒé‡æ¨¡å‹ã€‚æœ¬æ–‡å°†å‡è®¾ä½¿ç”¨ OpenAI API å®ç°ã€‚
- en: JSON Schema and Pydantic
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Schema å’Œ Pydantic
- en: According to [JSON Schema Core Specification](https://json-schema.org/draft/2020-12/json-schema-core),
    *â€œJSON Schema asserts what a JSON document must look like, ways to extract information
    from it, and how to interact with itâ€*. JSON schema defines six primitive types
    â€” null, boolean, object, array, number and string. It also defines certain keywords,
    annotations, and specific behaviours. For example, we can specify in our schema
    that we expect an `array` and add an annotation that `minItems` shall be `5` .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æ ¹æ® [JSON Schema æ ¸å¿ƒè§„èŒƒ](https://json-schema.org/draft/2020-12/json-schema-core)ï¼Œ*â€œJSON
    Schema ç¡®å®šäº†ä¸€ä¸ª JSON æ–‡æ¡£å¿…é¡»æ˜¯ä»€ä¹ˆæ ·å­ï¼Œå¦‚ä½•ä»ä¸­æå–ä¿¡æ¯ï¼Œä»¥åŠå¦‚ä½•ä¸ä¹‹äº’åŠ¨â€*ã€‚JSON schema å®šä¹‰äº†å…­ç§åŸå§‹ç±»å‹ â€”â€” nullã€booleanã€objectã€arrayã€number
    å’Œ stringã€‚å®ƒè¿˜å®šä¹‰äº†ä¸€äº›å…³é”®å­—ã€æ³¨è§£å’Œç‰¹å®šçš„è¡Œä¸ºã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ schema ä¸­æŒ‡å®šæˆ‘ä»¬æœŸæœ›çš„æ˜¯ä¸€ä¸ª `array`ï¼Œå¹¶æ·»åŠ ä¸€ä¸ªæ³¨è§£ï¼Œè¦æ±‚ `minItems`
    ä¸º `5`ã€‚
- en: 'Pydantic is a Python library that implements the JSON schema specification.
    We use Pydantic to build robust and maintainable software in Python. Since Python
    is a dynamically typed language, data scientists do not necessarily think in terms
    of **variable types** â€” these are often **implied** in their code. For example,
    a fruit would be specified as:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic æ˜¯ä¸€ä¸ªå®ç° JSON schema è§„èŒƒçš„ Python åº“ã€‚æˆ‘ä»¬ä½¿ç”¨ Pydantic åœ¨ Python ä¸­æ„å»ºç¨³å¥ä¸”å¯ç»´æŠ¤çš„è½¯ä»¶ã€‚ç”±äº
    Python æ˜¯ä¸€ç§åŠ¨æ€ç±»å‹è¯­è¨€ï¼Œæ•°æ®ç§‘å­¦å®¶é€šå¸¸ä¸ä¼šä»¥ **å˜é‡ç±»å‹** ä¸ºä¸­å¿ƒæ€è€ƒ â€”â€” è¿™äº›é€šå¸¸æ˜¯ **éšå«** åœ¨ä»–ä»¬çš„ä»£ç ä¸­çš„ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªæ°´æœå¯èƒ½ä¼šè¢«æŒ‡å®šä¸ºï¼š
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'â€¦while a function declaration that returns â€œfruitâ€ from some piece of data
    would often be specified as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: â€¦è€Œä¸€ä¸ªè¿”å›â€œæ°´æœâ€çš„å‡½æ•°å£°æ˜ï¼Œé€šå¸¸ä¼šè¢«æŒ‡å®šä¸ºï¼š
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pydantic on the other hand allows us to generate a JSON-schema compliant class,
    with properly annotated variables and **type hints**, making our code more readable/maintainable
    and in general more robust, i.e.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€æ–¹é¢ï¼ŒPydantic å…è®¸æˆ‘ä»¬ç”Ÿæˆä¸€ä¸ªç¬¦åˆ JSON schema è§„èŒƒçš„ç±»ï¼Œå…·æœ‰æ­£ç¡®æ³¨è§£çš„å˜é‡å’Œ **ç±»å‹æç¤º**ï¼Œä½¿å¾—æˆ‘ä»¬çš„ä»£ç æ›´å…·å¯è¯»æ€§/å¯ç»´æŠ¤æ€§ï¼Œå¹¶ä¸”é€šå¸¸æ›´åŠ ç¨³å¥ï¼Œå³ï¼š
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: OpenAI actually [strongly recommends](https://platform.openai.com/docs/guides/structured-outputs/avoid-json-schema-divergence)
    the use of Pydantic for specifying schemas, as opposed to specifying the â€œrawâ€
    JSON schema directly. There are several reasons for this. Firstly, Pydantic is
    guaranteed to adhere to the JSON schema specification, so it saves you extra pre-validation
    steps. Secondly, for larger schemas, it is less verbose, allowing you to write
    cleaner code, faster. Finally, the `openai` Python package actually does some
    housekeeping, like setting `additionalProperties` to `False` for you, whereas
    when defining your schema â€œby-handâ€ using JSON, you would need to [set these manually](https://platform.openai.com/docs/guides/structured-outputs/additionalproperties-false-must-always-be-set-in-objects),
    for every object in your schema (failing to do so results in a rather annoying
    API error).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAI å®é™…ä¸Š [å¼ºçƒˆæ¨è](https://platform.openai.com/docs/guides/structured-outputs/avoid-json-schema-divergence)
    ä½¿ç”¨ Pydantic æ¥æŒ‡å®š schemaï¼Œè€Œä¸æ˜¯ç›´æ¥æŒ‡å®šâ€œåŸå§‹â€ JSON schemaã€‚è¿™æ ·åšæœ‰å‡ ä¸ªåŸå› ã€‚é¦–å…ˆï¼ŒPydantic ä¿è¯éµå¾ª JSON
    schema è§„èŒƒï¼Œå› æ­¤å®ƒå¯ä»¥ä¸ºä½ çœå»é¢å¤–çš„é¢„éªŒè¯æ­¥éª¤ã€‚å…¶æ¬¡ï¼Œå¯¹äºè¾ƒå¤§çš„ schemaï¼Œå®ƒæ›´åŠ ç®€æ´ï¼Œè®©ä½ å¯ä»¥å†™å‡ºæ›´æ¸…æ™°ã€æ›´å¿«é€Ÿçš„ä»£ç ã€‚æœ€åï¼Œ`openai`
    Python åŒ…å®é™…ä¸Šä¼šåšä¸€äº›â€œå®¶åŠ¡å·¥ä½œâ€ï¼Œæ¯”å¦‚å¸®ä½ å°† `additionalProperties` è®¾ç½®ä¸º `False`ï¼Œè€Œå½“ä½ ä½¿ç”¨ JSON æ‰‹åŠ¨å®šä¹‰
    schema æ—¶ï¼Œä½ éœ€è¦ä¸º schema ä¸­çš„æ¯ä¸ªå¯¹è±¡ [æ‰‹åŠ¨è®¾ç½®è¿™äº›](https://platform.openai.com/docs/guides/structured-outputs/additionalproperties-false-must-always-be-set-in-objects)ï¼Œå¦‚æœä¸è®¾ç½®ï¼Œå°†ä¼šå¯¼è‡´ç›¸å½“çƒ¦äººçš„
    API é”™è¯¯ã€‚
- en: Limitations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: é™åˆ¶
- en: As we alluded to previously, the ChatCompletions API provides a limited subset
    of the full JSON schema specification. There are numerous [keywords that are not
    yet supported](https://platform.openai.com/docs/guides/structured-outputs/some-type-specific-keywords-are-not-yet-supported),
    such as `minimum` and `maximum` for numbers, and `minItems` and `maxItems` for
    arrays â€” annotations that would be otherwise very useful in reducing hallucinations,
    or constraining the output size.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚æˆ‘ä»¬ä¹‹å‰æåˆ°çš„ï¼ŒChatCompletions APIæä¾›äº†ä¸€ä¸ªæœ‰é™çš„å®Œæ•´JSONæ¨¡å¼è§„èŒƒå­é›†ã€‚æœ‰è®¸å¤š[å½“å‰ä¸æ”¯æŒçš„å…³é”®å­—](https://platform.openai.com/docs/guides/structured-outputs/some-type-specific-keywords-are-not-yet-supported)ï¼Œä¾‹å¦‚ç”¨äºæ•°å­—çš„`minimum`å’Œ`maximum`ï¼Œä»¥åŠç”¨äºæ•°ç»„çš„`minItems`å’Œ`maxItems`â€”â€”è¿™äº›æ³¨è§£æœ¬æ¥ä¼šåœ¨å‡å°‘å¹»è§‰æˆ–é™åˆ¶è¾“å‡ºå¤§å°æ—¶éå¸¸æœ‰ç”¨ã€‚
- en: 'Certain formatting features are also unavailable. For example, the following
    Pydantic schema would result in API error when passed to `response_format` in
    ChatCompletions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: æŸäº›æ ¼å¼åŒ–ç‰¹æ€§ä¹Ÿä¸å¯ç”¨ã€‚ä¾‹å¦‚ï¼Œä»¥ä¸‹Pydanticæ¨¡å¼åœ¨ä¼ é€’ç»™ChatCompletionsä¸­çš„`response_format`æ—¶ä¼šå¯¼è‡´APIé”™è¯¯ï¼š
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It would fail because `openai` package has no format handling for `datetime`
    , so instead you would need to set `date_published` as a `str` and perform format
    validation (e.g. ISO 8601 compliance) post-hoc.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: å®ƒä¼šå¤±è´¥ï¼Œå› ä¸º`openai`åŒ…æ²¡æœ‰å¤„ç†`datetime`æ ¼å¼çš„åŠŸèƒ½ï¼Œå› æ­¤ä½ éœ€è¦å°†`date_published`è®¾ç½®ä¸º`str`ç±»å‹ï¼Œå¹¶åœ¨åæœŸè¿›è¡Œæ ¼å¼éªŒè¯ï¼ˆä¾‹å¦‚ï¼ŒISO
    8601åˆè§„æ€§ï¼‰ã€‚
- en: 'Other key limitations include the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä»–å…³é”®é™åˆ¶åŒ…æ‹¬ï¼š
- en: '**Hallucinations are still possible** â€” for example, when extracting product
    IDs, you would define in your response schema the following: `product_ids: List[str]`
    ; while the output is guaranteed to produce a list of strings (product IDs), the
    strings themselves may be hallucinated, so in this use case, you may want to validate
    the output against some pre-defined set of product IDs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ä»ç„¶å¯èƒ½å‡ºç°å¹»è§‰**â€”â€”ä¾‹å¦‚ï¼Œåœ¨æå–äº§å“IDæ—¶ï¼Œä½ éœ€è¦åœ¨å“åº”æ¨¡å¼ä¸­å®šä¹‰ä»¥ä¸‹å†…å®¹ï¼š`product_ids: List[str]`ï¼›è™½ç„¶è¾“å‡ºä¿è¯ä¼šç”Ÿæˆä¸€ä¸ªå­—ç¬¦ä¸²åˆ—è¡¨ï¼ˆäº§å“IDï¼‰ï¼Œä½†è¿™äº›å­—ç¬¦ä¸²æœ¬èº«å¯èƒ½æ˜¯å¹»è§‰ï¼Œå› æ­¤åœ¨è¿™ç§ä½¿ç”¨åœºæ™¯ä¸‹ï¼Œä½ å¯èƒ½éœ€è¦å°†è¾“å‡ºä¸ä¸€äº›é¢„å®šä¹‰çš„äº§å“IDé›†åˆè¿›è¡ŒéªŒè¯ã€‚'
- en: '**The output is capped** at 16,384 tokens (**NOTE:** thanks Peter Edmonds for
    the correction!), or the lesser number you set within the `max_tokens` parameter
    â€” so even though the schema will be followed precisely, if the output is too large,
    it will be truncated and produce an invalid JSON â€” especially annoying on very
    large [Batch API](https://platform.openai.com/docs/guides/batch) jobs!'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è¾“å‡ºæœ‰ä¸Šé™**ï¼Œæœ€å¤šä¸º16,384ä¸ªä»¤ç‰Œï¼ˆ**æ³¨æ„ï¼š**æ„Ÿè°¢Peter Edmondsçš„çº æ­£ï¼ï¼‰ï¼Œæˆ–è€…ä½ åœ¨`max_tokens`å‚æ•°ä¸­è®¾ç½®çš„è¾ƒå°å€¼â€”â€”å› æ­¤ï¼Œå°½ç®¡æ¨¡å¼ä¼šè¢«ç²¾ç¡®éµå¾ªï¼Œä½†å¦‚æœè¾“å‡ºè¿‡å¤§ï¼Œå®ƒå°†è¢«æˆªæ–­å¹¶äº§ç”Ÿæ— æ•ˆçš„JSONâ€”â€”åœ¨éå¸¸å¤§çš„[æ‰¹é‡API](https://platform.openai.com/docs/guides/batch)ä»»åŠ¡ä¸­å°¤å…¶ä»¤äººçƒ¦æ¼ï¼'
- en: '**Deeply nested schemas with many object properties** may yield API errors
    â€” there is a [limitation on the depth and breadth](https://platform.openai.com/docs/guides/structured-outputs/objects-have-limitations-on-nesting-depth-and-size)
    of your schema, but in general it is best to stick to flat and simple structuresâ€”
    not just to avoid API errors but also to squeeze out as much performance from
    the LLMs as possible (LLMs in general have trouble attending to deeply nested
    structures).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ·±åº¦åµŒå¥—çš„æ¨¡å¼åŠå…¶å¤šä¸ªå¯¹è±¡å±æ€§**å¯èƒ½ä¼šå¯¼è‡´APIé”™è¯¯â€”â€”ä½ çš„æ¨¡å¼æœ‰[æ·±åº¦å’Œå®½åº¦çš„é™åˆ¶](https://platform.openai.com/docs/guides/structured-outputs/objects-have-limitations-on-nesting-depth-and-size)ï¼Œä½†é€šå¸¸æœ€å¥½åšæŒä½¿ç”¨æ‰å¹³å’Œç®€å•çš„ç»“æ„â€”â€”ä¸ä»…æ˜¯ä¸ºäº†é¿å…APIé”™è¯¯ï¼Œè¿˜ä¸ºäº†ä»LLMä¸­å°½å¯èƒ½åœ°æå–æ›´å¤šæ€§èƒ½ï¼ˆé€šå¸¸LLMéš¾ä»¥å¤„ç†æ·±åº¦åµŒå¥—çš„ç»“æ„ï¼‰ã€‚'
- en: '**Highly dynamic or arbitrary schemas are not possible** â€” even though [recursion
    is supported](https://platform.openai.com/docs/guides/structured-outputs/recursive-schemas-are-supported),
    it is not possible to create a highly dynamic schema of letâ€™s say, a list of arbitrary
    key-value objects, i.e. `[{"key1": "val1"}, {"key2": "val2"}, ..., {"keyN": "valN"}]`
    , since the â€œkeysâ€ in this case **must** be pre-defined; in such a scenario, the
    best option is not to use structured outputs at all, but instead opt for standard
    JSON mode, and provide the instructions on the output structure within the system
    prompt.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**é«˜åº¦åŠ¨æ€æˆ–ä»»æ„æ¨¡å¼ä¸å¯è¡Œ**â€”â€”å°½ç®¡[æ”¯æŒé€’å½’](https://platform.openai.com/docs/guides/structured-outputs/recursive-schemas-are-supported)ï¼Œä½†æ— æ³•åˆ›å»ºä¸€ä¸ªé«˜åº¦åŠ¨æ€çš„æ¨¡å¼ï¼Œä¾‹å¦‚ä¸€ç»„ä»»æ„çš„é”®å€¼å¯¹å¯¹è±¡åˆ—è¡¨ï¼Œå³`[{"key1":
    "val1"}, {"key2": "val2"}, ..., {"keyN": "valN"}]`ï¼Œå› ä¸ºåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œâ€œé”®â€**å¿…é¡»**æ˜¯é¢„å®šä¹‰çš„ï¼›åœ¨è¿™ç§åœºæ™¯ä¸‹ï¼Œæœ€ä½³é€‰æ‹©æ˜¯æ ¹æœ¬ä¸ä½¿ç”¨ç»“æ„åŒ–è¾“å‡ºï¼Œè€Œæ˜¯é€‰æ‹©æ ‡å‡†çš„JSONæ¨¡å¼ï¼Œå¹¶åœ¨ç³»ç»Ÿæç¤ºä¸­æä¾›è¾“å‡ºç»“æ„çš„è¯´æ˜ã€‚'
- en: Tips and tricks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æŠ€å·§å’Œçªé—¨
- en: With all this in mind, we can now go through a couple of use cases with tips
    and tricks on how to enhance the performance when using structured outputs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: è€ƒè™‘åˆ°è¿™ä¸€åˆ‡ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥é€šè¿‡å‡ ä¸ªä½¿ç”¨æ¡ˆä¾‹æ¥æ¢è®¨å¦‚ä½•åœ¨ä½¿ç”¨ç»“æ„åŒ–è¾“å‡ºæ—¶æå‡æ€§èƒ½çš„æŠ€å·§å’Œçªé—¨ã€‚
- en: Creating flexibility using optional parameters
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä½¿ç”¨å¯é€‰å‚æ•°åˆ›å»ºçµæ´»æ€§
- en: 'Letâ€™s say we are building a web scraping application where our goal is to collect
    specific components from the web pages. For each web page, we supply the raw HTML
    in the user prompt, give specific scraping instructions in the system prompt,
    and define the following Pydantic model:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: å‡è®¾æˆ‘ä»¬æ­£åœ¨æ„å»ºä¸€ä¸ªç½‘é¡µæŠ“å–åº”ç”¨ç¨‹åºï¼Œç›®æ ‡æ˜¯ä»ç½‘é¡µä¸­æ”¶é›†ç‰¹å®šç»„ä»¶ã€‚å¯¹äºæ¯ä¸ªç½‘é¡µï¼Œæˆ‘ä»¬åœ¨ç”¨æˆ·æç¤ºä¸­æä¾›åŸå§‹ HTMLï¼Œåœ¨ç³»ç»Ÿæç¤ºä¸­ç»™å‡ºå…·ä½“çš„æŠ“å–æŒ‡ä»¤ï¼Œå¹¶å®šä¹‰ä»¥ä¸‹
    Pydantic æ¨¡å‹ï¼š
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We would then call the API as followsâ€¦
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åæˆ‘ä»¬ä¼šæŒ‰å¦‚ä¸‹æ–¹å¼è°ƒç”¨ APIâ€¦â€¦
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'â€¦with the following response:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: â€¦ä»¥åŠä»¥ä¸‹å“åº”ï¼š
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Response schema supplied to the API using structured outputs **must** return
    all the specified fields. However, we can â€œemulateâ€ optional fields and add more
    flexibility using the `Optional` type annotation. We could actually also use `Union[List[str],
    None]` â€” they are syntactically exactly the same. In both cases, we get a conversion
    to `anyOf` keyword as per the JSON schema spec. In the example above, since there
    are no `<a></a>` tags present on the web page, the API still returns the `links`
    field, but it is set to `None` .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: æä¾›ç»™ API çš„å“åº”æ¶æ„ä½¿ç”¨ç»“æ„åŒ–è¾“å‡ºæ—¶ï¼Œ**å¿…é¡»**è¿”å›æ‰€æœ‰æŒ‡å®šçš„å­—æ®µã€‚ç„¶è€Œï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä½¿ç”¨`Optional`ç±»å‹æ³¨è§£æ¥â€œæ¨¡æ‹Ÿâ€å¯é€‰å­—æ®µï¼Œå¹¶å¢åŠ æ›´å¤šçš„çµæ´»æ€§ã€‚æˆ‘ä»¬å®é™…ä¸Šè¿˜å¯ä»¥ä½¿ç”¨`Union[List[str],
    None]`â€”â€”å®ƒä»¬åœ¨è¯­æ³•ä¸Šæ˜¯å®Œå…¨ç›¸åŒçš„ã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼ŒæŒ‰ç…§ JSON æ¶æ„è§„èŒƒï¼Œæˆ‘ä»¬éƒ½ä¼šå¾—åˆ°è½¬æ¢ä¸º`anyOf`å…³é”®å­—ã€‚åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œç”±äºç½‘é¡µä¸Šæ²¡æœ‰`<a></a>`æ ‡ç­¾ï¼ŒAPIä»ç„¶è¿”å›äº†`links`å­—æ®µï¼Œä½†å®ƒè¢«è®¾ç½®ä¸º`None`ã€‚
- en: Reducing hallucinations using enums and a two-phased approach
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä½¿ç”¨æšä¸¾å’Œä¸¤é˜¶æ®µæ–¹æ³•å‡å°‘è™šæ„å†…å®¹
- en: We mentioned previously that even if the LLM is guaranteed to follow the provided
    response schema, it may still hallucinate the actual values. Adding to this, a
    [recent paper](https://arxiv.org/pdf/2408.02442v1) found that enforcing a fixed
    schema on the outputs, actually causes the LLM to hallucinate, or degrade in terms
    of its reasoning capabilities (interestingly enough, classification performance
    improves ğŸ¤”).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹‹å‰æåˆ°è¿‡ï¼Œå³ä½¿ LLM è¢«ä¿è¯éµå¾ªæä¾›çš„å“åº”æ¶æ„ï¼Œå®ƒä»ç„¶å¯èƒ½ä¼šè™šæ„å®é™…çš„å€¼ã€‚å¯¹æ­¤ï¼Œæœ€è¿‘çš„ä¸€ç¯‡[è®ºæ–‡](https://arxiv.org/pdf/2408.02442v1)å‘ç°ï¼Œå¼ºåˆ¶å¯¹è¾“å‡ºæ–½åŠ å›ºå®šæ¶æ„ï¼Œå®é™…ä¸Šä¼šå¯¼è‡´
    LLM å‡ºç°è™šæ„å†…å®¹æˆ–åœ¨æ¨ç†èƒ½åŠ›æ–¹é¢é€€åŒ–ï¼ˆæœ‰è¶£çš„æ˜¯ï¼Œåˆ†ç±»æ€§èƒ½å´æœ‰æ‰€æé«˜ ğŸ¤”ï¼‰ã€‚
- en: One way to overcome these limitations, is to try and utilize enums as much as
    possible. Enums constrain the output to a very specific set of tokens, placing
    a probability of zero on everything else. For example, letâ€™s assume you are trying
    to re-rank product similarity results between a **target product** that contains
    a `description` and a unique `product_id` , and **top-5 products** that were obtained
    using some vector similarity search (e.g. using a cosine distance metric). Each
    one of those top-5 products also contain the corresponding textual description
    and a unique ID. In your response you simply wish to obtain the re-ranking 1â€“5
    as a list (e.g. `[1, 4, 3, 5, 2]` ), instead of getting a list of re-ranked product
    ID strings, which may be hallucinated or invalid. We setup our Pydantic model
    as followsâ€¦
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: å…‹æœè¿™äº›é™åˆ¶çš„ä¸€ç§æ–¹æ³•æ˜¯å°½å¯èƒ½å¤šåœ°åˆ©ç”¨æšä¸¾ç±»å‹ï¼ˆenumsï¼‰ã€‚æšä¸¾å°†è¾“å‡ºé™åˆ¶ä¸ºéå¸¸ç‰¹å®šçš„ä¸€ç»„æ ‡è®°ï¼Œå¯¹å…¶ä»–ä»»ä½•ä¸œè¥¿çš„æ¦‚ç‡è®¾ä¸ºé›¶ã€‚ä¾‹å¦‚ï¼Œå‡è®¾ä½ æ­£åœ¨å°è¯•å¯¹ä¸€ä¸ª**ç›®æ ‡äº§å“**ï¼ˆåŒ…å«`description`å’Œå”¯ä¸€çš„`product_id`ï¼‰ä¸é€šè¿‡æŸç§å‘é‡ç›¸ä¼¼æ€§æœç´¢ï¼ˆä¾‹å¦‚ä½¿ç”¨ä½™å¼¦è·ç¦»åº¦é‡ï¼‰è·å¾—çš„**å‰äº”åäº§å“**ä¹‹é—´çš„äº§å“ç›¸ä¼¼åº¦è¿›è¡Œé‡æ–°æ’åºã€‚æ¯ä¸€ä¸ªå‰äº”åäº§å“ä¹ŸåŒ…å«ç›¸åº”çš„æ–‡æœ¬æè¿°å’Œå”¯ä¸€çš„
    IDã€‚åœ¨ä½ çš„å“åº”ä¸­ï¼Œä½ åªå¸Œæœ›è·å–é‡æ–°æ’åºåçš„ 1-5 åˆ—è¡¨ï¼ˆä¾‹å¦‚`[1, 4, 3, 5, 2]`ï¼‰ï¼Œè€Œä¸æ˜¯è·å–å¯èƒ½æ˜¯è™šæ„æˆ–æ— æ•ˆçš„é‡æ–°æ’åºçš„äº§å“ ID å­—ç¬¦ä¸²ã€‚æˆ‘ä»¬å°†æˆ‘ä»¬çš„
    Pydantic æ¨¡å‹è®¾ç½®å¦‚ä¸‹â€¦â€¦
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'â€¦and run the API like so:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: â€¦å¹¶åƒè¿™æ ·è¿è¡Œ APIï¼š
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The final result is simply:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: æœ€ç»ˆç»“æœå°±æ˜¯ï¼š
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So the LLM ranked the Sony LED TV (i.e. item number â€œ3â€ in the list), and the
    BenQ PC Monitor (i.e. item number â€œ5â€), as the two most similar product candidates,
    i.e. the first two elements of the `ordered_ranking` list!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ LLM æ’åäº† Sony LED TVï¼ˆå³åˆ—è¡¨ä¸­çš„ç¬¬â€œ3â€é¡¹ï¼‰å’Œ BenQ PC æ˜¾ç¤ºå™¨ï¼ˆå³åˆ—è¡¨ä¸­çš„ç¬¬â€œ5â€é¡¹ï¼‰ï¼Œä½œä¸ºæœ€ç›¸ä¼¼çš„ä¸¤ä¸ªäº§å“å€™é€‰ï¼Œå³`ordered_ranking`åˆ—è¡¨ä¸­çš„å‰ä¸¤ä¸ªå…ƒç´ ï¼
- en: In theory, enums should completely eliminate hallucinations across those specific
    fields, since only the tokens specified in the enum set will pass through the
    token mask, i.e. all other tokens will have a probability of zero. However, users
    have also [reported seeing hallucinations even across enums](https://community.openai.com/t/structured-outputs-deep-dive/930169/18),
    particularly on the â€œminiâ€ models.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ç†è®ºä¸Šï¼Œæšä¸¾åº”è¯¥å®Œå…¨æ¶ˆé™¤è¿™äº›ç‰¹å®šå­—æ®µä¸­çš„è™šæ„å†…å®¹ï¼Œå› ä¸ºåªæœ‰æšä¸¾é›†ä¸­çš„æ ‡è®°ä¼šé€šè¿‡æ ‡è®°æ©ç ï¼Œå³æ‰€æœ‰å…¶ä»–æ ‡è®°çš„æ¦‚ç‡ä¸ºé›¶ã€‚ç„¶è€Œï¼Œç”¨æˆ·ä¹Ÿ[æŠ¥å‘Šè¿‡å³ä½¿åœ¨æšä¸¾ä¸­ä¹Ÿä¼šçœ‹åˆ°è™šæ„å†…å®¹](https://community.openai.com/t/structured-outputs-deep-dive/930169/18)ï¼Œç‰¹åˆ«æ˜¯åœ¨â€œè¿·ä½ â€æ¨¡å‹ä¸­ã€‚
- en: 'So another approach is a **two-phased approach**, which is in line with the
    findings of the [aforementioned paper](https://arxiv.org/pdf/2408.02442v1):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: å¦ä¸€ç§æ–¹æ³•æ˜¯**ä¸¤é˜¶æ®µæ–¹æ³•**ï¼Œè¿™ä¸[å‰è¿°è®ºæ–‡](https://arxiv.org/pdf/2408.02442v1)çš„ç ”ç©¶ç»“æœä¸€è‡´ï¼š
- en: Send a reasoning/extraction task to the mini model **without** enforcing structure,
    i.e. the response will be a flat string.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: å‘è¿·ä½ æ¨¡å‹å‘é€æ¨ç†/æå–ä»»åŠ¡**ä¸**å¼ºåˆ¶æ‰§è¡Œç»“æ„ï¼Œå³å“åº”å°†æ˜¯ä¸€ä¸ªç®€å•çš„å­—ç¬¦ä¸²ã€‚
- en: Create a 2nd request to the mini model, this time sending the output of the
    previous step, together with the response schema
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: åˆ›å»ºç¬¬äºŒä¸ªè¯·æ±‚å‘é€ç»™è¿·ä½ æ¨¡å‹ï¼Œè¿™æ¬¡å‘é€ä¸Šä¸€æ­¥çš„è¾“å‡ºä»¥åŠå“åº”æ¨¡å¼
- en: Using this approach we separate out the task into a reasoning step, and a structuring
    step.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡è¿™ç§æ–¹æ³•ï¼Œæˆ‘ä»¬å°†ä»»åŠ¡åˆ†ä¸ºæ¨ç†æ­¥éª¤å’Œç»“æ„åŒ–æ­¥éª¤ã€‚
- en: Conclusion
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: 'In this article we gave a thorough deep-dive into structured outputs. We introduced
    the JSON schema and Pydantic models, and connected these to OpenAIâ€™s ChatCompletions
    API. We walked through a number of examples and showcased some optimal ways of
    resolving those using structured outputs. To summarize some key takeaways:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ·±å…¥æ¢è®¨äº†ç»“æ„åŒ–è¾“å‡ºã€‚æˆ‘ä»¬ä»‹ç»äº†JSONæ¨¡å¼å’ŒPydanticæ¨¡å‹ï¼Œå¹¶å°†å®ƒä»¬ä¸OpenAIçš„ChatCompletions APIè¿æ¥ã€‚æˆ‘ä»¬é€šè¿‡å¤šä¸ªç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ç»“æ„åŒ–è¾“å‡ºè§£å†³è¿™äº›é—®é¢˜ã€‚æ€»ç»“ä¸€äº›å…³é”®è¦ç‚¹ï¼š
- en: Structured outputs as supported by OpenAI API, and other 3rd party frameworks,
    implement only a **subset of the JSON schema specification** â€” getting better
    informed in terms of its features and limitations will help you make the right
    design decisions.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenAI APIåŠå…¶ä»–ç¬¬ä¸‰æ–¹æ¡†æ¶æ‰€æ”¯æŒçš„ç»“æ„åŒ–è¾“å‡ºï¼Œä»…å®ç°**JSONæ¨¡å¼è§„èŒƒçš„å­é›†**â€”â€”äº†è§£å…¶ç‰¹æ€§å’Œå±€é™æ€§å°†å¸®åŠ©ä½ åšå‡ºæ­£ç¡®çš„è®¾è®¡å†³ç­–ã€‚
- en: Using **Pydantic** or similar frameworks that track JSON schema specification
    faithfully, is highly recommended, as it allows you to create valid and cleaner
    code.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å¼ºçƒˆæ¨èä½¿ç”¨**Pydantic**æˆ–ç±»ä¼¼çš„æ¡†æ¶ï¼Œè¿™äº›æ¡†æ¶èƒ½å¤Ÿå¿ å®åœ°è·Ÿè¸ªJSONæ¨¡å¼è§„èŒƒï¼Œå› ä¸ºå®ƒä»¬ä½¿ä½ èƒ½å¤Ÿåˆ›å»ºæœ‰æ•ˆä¸”æ›´æ¸…æ™°çš„ä»£ç ã€‚
- en: Whilst hallucinations are still expected, there are different ways of mitigating
    those, either by a choice of response schema design; for example, by **utilizing
    enums** where appropriate; or by creating a **two-phased approach** where we send
    two API requests â€” one for reasoning, and the 2nd one simply for output re-structuring.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: å°½ç®¡ä»ç„¶ä¼šå‡ºç°å¹»è§‰é—®é¢˜ï¼Œä½†æœ‰å¤šç§æ–¹æ³•å¯ä»¥ç¼“è§£è¿™äº›é—®é¢˜ï¼Œæ–¹æ³•ä¹‹ä¸€æ˜¯é€‰æ‹©å“åº”æ¨¡å¼è®¾è®¡ï¼›ä¾‹å¦‚ï¼Œåœ¨é€‚å½“çš„åœ°æ–¹**ä½¿ç”¨æšä¸¾ç±»å‹**ï¼›æˆ–è€…é‡‡ç”¨**ä¸¤é˜¶æ®µæ–¹æ³•**ï¼Œå³æˆ‘ä»¬å‘é€ä¸¤ä¸ªAPIè¯·æ±‚â€”â€”ä¸€ä¸ªç”¨äºæ¨ç†ï¼Œç¬¬äºŒä¸ªä»…ç”¨äºè¾“å‡ºé‡æ„ã€‚
- en: About the Author
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å…³äºä½œè€…
- en: '[**Armin Catovic**](https://medium.com/@armin.catovic) is a Secretary of the
    Board at [Stockholm AI](https://www.stockholm.ai/), and a Vice President and a
    Senior ML/AI Engineer at the [EQT Group](https://eqtgroup.com/), with 18 years
    of engineering experience across Australia, South-East Asia, Europe and the US,
    and a number of patents and top-tier peer-reviewed AI publications.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[**Armin Catovic**](https://medium.com/@armin.catovic)æ˜¯[æ–¯å¾·å“¥å°”æ‘©AI](https://www.stockholm.ai/)çš„è‘£äº‹ä¼šç§˜ä¹¦ï¼ŒåŒæ—¶ä¹Ÿæ˜¯[EQTé›†å›¢](https://eqtgroup.com/)çš„å‰¯æ€»è£å’Œé«˜çº§ML/AIå·¥ç¨‹å¸ˆï¼Œæ‹¥æœ‰18å¹´çš„å·¥ç¨‹ç»éªŒï¼Œå·¥ä½œéåŠæ¾³å¤§åˆ©äºšã€ä¸œå—äºšã€æ¬§æ´²å’Œç¾å›½ï¼Œå¹¶æ‹¥æœ‰å¤šé¡¹ä¸“åˆ©å’Œé¡¶çº§åŒè¡Œè¯„å®¡çš„AIå‡ºç‰ˆç‰©ã€‚'

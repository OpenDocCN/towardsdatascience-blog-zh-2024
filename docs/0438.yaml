- en: Particle Swarm Optimization (PSO) from scratch. Simplest explanation in python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/what-the-hell-is-particle-swarm-optimization-pso-simplest-explanation-in-python-be296fc3b1ab?source=collection_archive---------3-----------------------#2024-02-16](https://towardsdatascience.com/what-the-hell-is-particle-swarm-optimization-pso-simplest-explanation-in-python-be296fc3b1ab?source=collection_archive---------3-----------------------#2024-02-16)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to implement PSO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@alexroz?source=post_page---byline--be296fc3b1ab--------------------------------)[![Aleksei
    Rozanov](../Images/748b69bfaccf39c9aa568a9e6f41eec3.png)](https://medium.com/@alexroz?source=post_page---byline--be296fc3b1ab--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--be296fc3b1ab--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--be296fc3b1ab--------------------------------)
    [Aleksei Rozanov](https://medium.com/@alexroz?source=post_page---byline--be296fc3b1ab--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--be296fc3b1ab--------------------------------)
    ¬∑7 min read¬∑Feb 16, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d042439b9fca217c92cc9f23072a8af7.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [James Wainscoat](https://unsplash.com/@tumbao1949?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Before talking about *swarms* and *particles*, let‚Äôs briefly discuss **optimization**
    itself. Basically, optimization is the process of finding the minima or maxima
    of some function. For instance, when you need to get to your office ASAP and think
    about which way is the fastest, you‚Äôre optimizing your route (in this case it‚Äôs
    a function). In math, there are literally hundreds of ways of optimization, and
    among them a sub-group called nature-inspired exists.
  prefs: []
  type: TYPE_NORMAL
- en: '**Nature-inspired algorithms** are based on phenomena which draw inspiration
    from natural phenomena or processes. Among the most popular ones are Genetic Algorithm,
    Cuckoo Search, Ant Colony and **Particle Swarm Optimization** [**[1]**](https://www.marksmannet.com/RobertMarks/Classes/ENGR5358/Papers/pso_bySHI.pdf)
    **or PSO**.'
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial is implemented in python using only *numpy* and *matplotlib*.
    To follow up you can use [this notebook](https://github.com/alexxxroz/Medium/blob/main/PSO_explained.ipynb).
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs start with creating a function which we‚Äôll be optimizing using PSO.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If someone asks me to think about functions, the first thing that comes to my
    mind (it almost reflexiveüòÇ) is parabola. So let‚Äôs plot it firstly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/fcbfbeae100b6d28c0d7595cb7ac626e.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of this function, y=x¬≤, the goal of optimization is to find the point
    x=0, so y has the lowest value possible ‚Äî 0\. But it‚Äôs too easy. Let‚Äôs overcomplicate
    everything, but stay in **2D** space. I decided to use the following system of
    equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9e910a9f11cfc5b39085024fa10206c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: 'Or in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/085120e0e4cf19b81720c0551f3ce42e.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see I intentionally made two minima: global (left) and local (right).
    Often when optimizing a function, we need to find the lowest (greatest) value
    possible, i.e. global minimum (maximum), so I wanted the PSO algorithm to face
    the challenge of two extrema.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let‚Äôs discuss the algorithm itself.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The underlying idea is based on two terms: **population** and **swarm**. Swarm
    consists of populations which comprise particles.'
  prefs: []
  type: TYPE_NORMAL
- en: particle ‚Äî ‚Äî ‚Äî > population ‚Äî ‚Äî ‚Üí swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a particle in this case then? A particle is a possible solution. Imagine
    that you‚Äôre investigating a crime and a bunch of suspects are standing in front
    of you. All of them are ‚Äúcandidates‚Äù to be convicted. But in the case of particles,
    the candidates are cooperating and have social influence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The particles themselves has two features ‚Äî **position** and **velocity** (or
    speed; our particles are flying, right?). So these particles iteratively, one
    step at a time, change their positions. Their velocity is defined by the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/910a6732701e5d166f2e8af3748177f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are three components. The first is **inertia**. This is
    the velocity of the particle from the previous iteration multiplied by an arbitrary
    weight **w**. So it basically defines how much the previous speed of the particle
    affects the current one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one is **personal influence**. It has its own coefficients: an arbitrary
    weight *c*‚ÇÅ and random number *r*‚ÇÅ. In the brackets we have a difference between
    the **best position** of a particle in a **population** and the position of the
    current particle (**p**).'
  prefs: []
  type: TYPE_NORMAL
- en: The third part is **social influence**. It has similar arbitrary weight *c*‚ÇÇ
    and random number *r*‚ÇÇ, as well as the difference between the **best position**
    of a particle in a **swarm** and the position of the current particle (**p**).
  prefs: []
  type: TYPE_NORMAL
- en: 'After calculating the velocity we update the current positions of the particle
    simply by summation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b370df6126ccd1c67f4a480a3fd3e703.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: '*By now there is one big question left:* ***what are these best position in
    the swarm and population?***'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To calculate them we need a gain/reward function indicating which solution is
    closer to the minimum (maximum). In our example, this gain function is the function
    we plotted. So the particles are Xs, and by substituting each X to the function,
    we can figure out which X gives the lowest (greatest) value of Y.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the best position in a population is X, which gives the lowest (greatest)
    Y on **the current iteration**. And the best position in a swarm is X which gives
    the lowest (greatest) Y across all **the previous iterations.**
  prefs: []
  type: TYPE_NORMAL
- en: '*So simplifying everything, we can say that the idea of the algorithm is the
    following:*'
  prefs: []
  type: TYPE_NORMAL
- en: '*A bunch of particles, each having a certain position and velocity, are flying
    together in a search of the global minimum (maximum), forming a population. Populations
    appear iteratively and live during only one iteration, but they exchange information
    with each other, so each following population is closer to finding the solution
    than the previous one.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Now let‚Äôs get back to coding and implement in python what we‚Äôve discussed.**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let‚Äôs define our hypoparameters. Like in many other metaheuristic
    algorithms, these variables should be adjusted on the way, and there is no versatile
    set of values. But let‚Äôs stick to these ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let‚Äôs create a function which would generate a random population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we visualize it, we‚Äôll get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/dd8f28abbe9d431893d272b348e1ed37.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: Here you can see that I randomly initialized a population of 50 particles, some
    of which are already close to the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Now let‚Äôs implement the PSO algorithm itself. I commented each row in the code,
    but if you have any questions, feel free to ask in the comments below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After 30 iteration we‚Äôve got this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d82a4138cb2889322b10be822de4a443.png)'
  prefs: []
  type: TYPE_IMG
- en: PSO (w=0.2, c1=1, c2=2). Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see the algorithm fell into the local minimum, which is not what
    we wanted. That‚Äôs why we need to tune our hypoparameters and start again. This
    time I decided to set inertia weight **w=0.8**, thus, now the previous velocity
    has a greater impact on the current state.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1d43dcf5b6fa3f9f4e3a55a0be1bcb2f.png)'
  prefs: []
  type: TYPE_IMG
- en: PSO (w=0.9, c1=1, c2=2). Image by [author](https://medium.com/@alexroz).
  prefs: []
  type: TYPE_NORMAL
- en: And voila, we reached the global minimum of the function. I strongly encourage
    you to play around with POP_SIZE, c‚ÇÅ and c‚ÇÇ. It‚Äôll allow you to gain a better
    understanding of the code and the idea behind PSO. If you‚Äôre interested you can
    complicate the task and optimize some 3D function and make a nice visualization.
  prefs: []
  type: TYPE_NORMAL
- en: ===========================================
  prefs: []
  type: TYPE_NORMAL
- en: '[1]Shi Y. Particle swarm optimization //IEEE connections. ‚Äî 2004\. ‚Äî –¢. 2\.
    ‚Äî ‚Ññ. 1\. ‚Äî –°. 8‚Äì13.'
  prefs: []
  type: TYPE_NORMAL
- en: ===========================================
  prefs: []
  type: TYPE_NORMAL
- en: '***All my articles on Medium are free and open-access, that‚Äôs why I‚Äôd really
    appreciate if you followed me here!***'
  prefs: []
  type: TYPE_NORMAL
- en: P.s. I‚Äôm extremely passionate about (Geo)Data Science, ML/AI and Climate Change.
    So if you want to work together on some project pls contact me in [LinkedIn](https://www.linkedin.com/in/alexxxroz/).
  prefs: []
  type: TYPE_NORMAL
- en: üõ∞Ô∏èFollow for moreüõ∞Ô∏è
  prefs: []
  type: TYPE_NORMAL

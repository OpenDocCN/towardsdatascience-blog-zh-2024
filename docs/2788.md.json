["```py\nimport pandera as pa\n\nclass UserModel(pa.DataFrameModel):\n    id: int\n    username: str\n    email: str\n    is_active: bool\n    membership: str\n    creation_date: pd.DatetimeTZDtype\n```", "```py\n# Use\ndf = pd.DataFrame(...)\nUserModel.validate(df) # <- If invalidad raises SchemaError\n```", "```py\nclass UserModel(pa.DataFrameModel):\n    id: int  = pa.Field(unique=True, ge=0)\n    username: str = pa.Field(str_matches=r\"^[a-zA-Z0-9_]+$\")\n    email: str = pa.Field(str_matches=r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\")\n    is_active: bool\n    membership: str = pa.Field(isin=[\"premium\", \"free\"])\n    creation_date: pd.DatetimeTZDtype = pa.Field(dtype_kwargs={\"unit\": \"ns\", \"tz\": \"UTC\"})\n```", "```py\nimport pandera as pa\nfrom pandera.typing import Series\n\nclass UserModel(pa.DataFrameModel):\n    id: int = pa.Field(unique=True, ge=0)\n    username: str = pa.Field(str_matches=r\"^[a-zA-Z0-9_]+$\")\n    email: str = pa.Field(\n        str_matches=r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    )\n    is_active: bool\n    membership: str = pa.Field(isin=[\"premium\", \"free\"])\n    creation_date: Annotated[pd.DatetimeTZDtype, \"ns\", \"UTC\"]\n\n    # column/index checks\n    @pa.check(\"username\", name=\"username_length\")\n    def username_length(cls, x: Series[str]) -> Series[bool]:\n        \"\"\"\n        Check username length is between 1 and 20 characters\n        \"\"\"\n        return x.str.len().between(1, 20)\n\n    @pa.check(\"creation_date\", name=\"min_creation_date\")\n    def min_creation_date(cls, x: Series[pd.DatetimeTZDtype]) -> Series[bool]:\n        \"\"\"\n        Check creation date is after 2000-01-01\n        \"\"\"\n        return x >= dt.datetime(2000, 1, 1, tzinfo=dt.timezone.utc)\n\n    # dataframe check\n    @pa.dataframe_check\n    def membership_is_valid(\n        cls, df: pd.DataFrame, name=\"membership_is_valid\"\n    ) -> Series[bool]:\n        \"\"\"\n        Check account age for free memebers is <= 30 days\n        \"\"\"\n        current_time = dt.datetime.now(dt.timezone.utc)\n        thirty_days = dt.timedelta(days=30)\n\n        return (df[\"membership\"] == \"premium\") | (\n            (df[\"membership\"] == \"free\")\n            & ((current_time - df[\"creation_date\"]) <= thirty_days)\n        )\n```", "```py\nclass MyModel(pa.DataFrameModel):\n    alias_column: int = pa.Field(..., alias=\"Alias Column\")\n    ...\n```", "```py\nclass MyModel(pa.DataFrameModel):\n    ...\n\n    class Config:\n        strict = True # defaul: False\n        coerce = True # default: False\n```", "```py\ndf = pd.DataFrame(...)\nMymodel.validate(df, lazy_validation=True)\n```", "```py\n# pipeline.py\n\nclass MLPipeline:\n    \"\"\"General ML Pipeline\"\"\"\n    def __init__(self, model_id: str):\n        self.model_id = model_id\n\n    def load_model(self) -> None:\n        ...\n\n    def transform_data(self, df: pd.DataFrame) -> pd.DataFrame:\n        ...   # <- Potential invalid data error\n        return df_transform\n\n    def predict(self, df: pd.DataFrame) -> pd.DataFrame:\n        self.load_model()\n        df_transform = self.transform(df)\n        df['score'] = self.model.predict(df_transform)  # <- Potential invalid data error\n        return df\n```", "```py\n# models.py\nimport pandera as pa\n\nclass InputModel(pa.DataFrameModel):\n    ...\n\nclass PredictorModel(pa.DataFrameModel):\n    ...\n\n# OutputModel inherits all InputModel validation fields\n# and also includes the score\nclass OutputModel(InputModel):\n    score: float = pa.Field(ge=0, le=1) # assuming model returns probab.\n```", "```py\n# pipeline.py\nimport pandera as pa\nfrom .models import InputModel, PredictorModel, OutputModel\n\nclass MLPipeline:\n    \"\"\"General ML Pipeline\"\"\"\n    def __init__(self, model_id: str):\n        self.model_id = model_id\n\n    def load_model(self) -> None:\n        ...\n\n    @pa.check_io(df=InputModel.to_schema(), out=PredictorModel.to_schema(), lazy=True)\n    def transform_data(self, df: pd.DataFrame) -> pd.DataFrame:\n        ...\n        return df_transform\n\n    @pa.check_output(OutputModel.to_schema(), lazy=True)\n    def predict(self, df: pd.DataFrame) -> pd.DataFrame:\n        self.load_model()\n        df_transform = self.transform(df)  \n        df['score'] = self.model.predict(df_transform)\n        return df\n```", "```py\nclass MyModel(pa.DataFrameModel):\n    ...\n\n    class Config:\n        drop_invalid_rows = True\n```", "```py\nfrom typing import Tuple\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef log_pandera_errors(exc: pa.errors.SchemaErrors) -> None:\n    \"\"\"\n    Logs all errors from a SchemaErrors exception.\n    \"\"\"\n    for err_type, categories in exc.message.items():\n        for _, errors in categories.items():\n            for err in errors:\n                logger.error(f\"{err_type} ERROR: {err['column']}. {err['error']}\")\n\ndef handle_invalid(\n    df: pd.DataFrame, exc: pa.errors.SchemaErrors\n) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"\n    Handles invalid data in a DataFrame based on a SchemaErrors exception.\n    \"\"\"\n    log_pandera_errors(exc)\n\n    df_failure = exc.failure_cases\n\n    # Check for errors that cannot be resolved\n    # i.e. they aren't associated with a specific row index\n    nan_indices = df_failure[\"index\"].isna()\n    if nan_indices.any():\n        error_msg = \"\\n\".join(\n            f\"    - Column: {row['column']}, check: {row['check']}, \"\n            f\"failure_case: {row['failure_case']}\"\n            for row in df_failure[nan_indices].to_dict(\"records\")\n        )\n        raise ValueError(\n            f\"Schema validation failed with no possibility of continuing:\\n{error_msg}\\n\"\n            \"The pipeline cannot continue ðŸ˜¢. Resolve before rerunning\"\n        )\n\n    invalid_idcs = df.index.isin(df_failure[\"index\"].unique())\n    df_invalid = format_invalid_df(df.loc[invalid_idcs, :], exc)\n    df_valid = df.iloc[~invalid_idcs]\n\n    return df_valid, df_invalid\n\ndef validate(\n    df: pd.DataFrame, model: pa.DataFrameModel\n) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    \"\"\"\n    Validates a DataFrame against a DataFrameModel and handles errors.\n    \"\"\"\n    try:\n        return model.validate(df, lazy=True), pd.DataFrame()\n    except pa.errors.SchemaErrors as ex:\n        return handle_invalid(df, ex)\n```", "```py\n# Error output\nERROR:__main__:SCHEMA ERROR: UserModel. column 'id' not in dataframe. Columns in dataframe: ['username', 'email', 'membership', 'is_active', 'creation_date']\nERROR:__main__:DATA ERROR: username. Column 'username' failed element-wise validator number 0: str_matches('^[a-zA-Z0-9_]+$') failure cases: b%09\nERROR:__main__:DATA ERROR: email. Column 'email' failed element-wise validator number 0: str_matches('^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$') failure cases: ef.com\nERROR:__main__:DATA ERROR: UserModel. DataFrameSchema 'UserModel' failed element-wise validator number 0: <Check membership_is_valid> failure cases: c, ef.com, free, True, 2000-12-31 00:00:00+00:00\n\nValueError: Schema validation failed with no possibility of continuing:\n    - Column: UserModel, check: column_in_dataframe, failure_case: id\nThe pipeline cannot continue ðŸ˜¢. Resolve before rerunning\n```", "```py\nclass UserModel(pa.DataFrameModel):\n    ...\n\n    def sample(size: int = 10) -> pd.DataFrame:\n        \"\"\"Added method to generate valid test data manually\"\"\"\n        current_time = dt.datetime.now(dt.timezone.utc)\n        return pd.DataFrame(\n            {\n                \"id\": range(size),\n                \"username\": [f\"user_{i}\" for i in range(size)],\n                \"email\": [f\"user_{i}@example.com\" for i in range(size)],\n                \"is_active\": [True] * size,\n                \"membership\": [\"premium\"] * size,  # All premium to pass checks\n                \"creation_date\": [current_time] * size,\n            }\n        )\n```", "```py\nimport pandas as pd\nimport pandera as pa\nfrom pandera.typing import Series\nfrom typing import Annotated\nimport datetime as dt\n\nclass UserModel(pa.DataFrameModel):\n    id: int = pa.Field(unique=True, ge=0, coerce=False)\n    username: str = pa.Field(str_matches=r\"^[a-zA-Z0-9_]+$\")\n    email: str = pa.Field(\n        str_matches=r\"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$\"\n    )\n    is_active: bool\n    membership: str = pa.Field(isin=[\"premium\", \"free\"])\n    creation_date: Annotated[pd.DatetimeTZDtype, \"ns\", \"UTC\"]\n\n    @pa.check(\"username\", name=\"username_length\")\n    def username_length(cls, x: Series[str]) -> Series[bool]:\n        \"\"\"\n        Check username length is between 1 and 20 characters\n        \"\"\"\n        return x.str.len().between(1, 20)\n\n    @pa.check(\"creation_date\", name=\"min_creation_date\")\n    def min_creation_date(cls, x: Series[pd.DatetimeTZDtype]) -> Series[bool]:\n        \"\"\"\n        Check creation date is after 2000-01-01\n        \"\"\"\n        return x >= dt.datetime(2000, 1, 1, tzinfo=dt.timezone.utc)\n\n    @pa.dataframe_check\n    def membership_is_valid(\n        cls, df: pd.DataFrame, name=\"membership_is_valid\"\n    ) -> Series[bool]:\n        \"\"\"\n        Check account age for free memebers is <= 30 days\n        \"\"\"\n        current_time = dt.datetime.now(dt.timezone.utc)\n        thirty_days = dt.timedelta(days=30)\n\n        return (df[\"membership\"] == \"premium\") | (\n            (df[\"membership\"] == \"free\")\n            & ((current_time - df[\"creation_date\"]) <= thirty_days)\n        )\n\n    class Config:\n        strict = True\n        coerce = True\n\n    def sample(size: int = 10) -> pd.DataFrame:\n        \"\"\"Added method to generate valid test data manually\"\"\"\n        current_time = dt.datetime.now(dt.timezone.utc)\n        return pd.DataFrame(\n            {\n                \"id\": range(size),\n                \"username\": [f\"user_{i}\" for i in range(size)],\n                \"email\": [f\"user_{i}@example.com\" for i in range(size)],\n                \"is_active\": [True] * size,\n                \"membership\": [\"premium\"]\n                * size,  # All premium to avoid date restrictions\n                \"creation_date\": [current_time] * size,\n            }\n        )\n```"]
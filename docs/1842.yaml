- en: Stable and fast randomization using hash spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/stable-and-fast-randomization-using-hash-spaces-19000b9f27d3?source=collection_archive---------14-----------------------#2024-07-29](https://towardsdatascience.com/stable-and-fast-randomization-using-hash-spaces-19000b9f27d3?source=collection_archive---------14-----------------------#2024-07-29)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Generate consistent assignments on the fly across different implementation environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@davidclarance?source=post_page---byline--19000b9f27d3--------------------------------)[![David
    Clarance](../Images/02cf7cdde9576cdf3af30a79da4db747.png)](https://medium.com/@davidclarance?source=post_page---byline--19000b9f27d3--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--19000b9f27d3--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--19000b9f27d3--------------------------------)
    [David Clarance](https://medium.com/@davidclarance?source=post_page---byline--19000b9f27d3--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--19000b9f27d3--------------------------------)
    ·8 min read·Jul 29, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fb459aab4c75749b21394c14a2ecbd26.png)'
  prefs: []
  type: TYPE_IMG
- en: A bird’s eye view
  prefs: []
  type: TYPE_NORMAL
- en: 'A core part of running an experiment is to assign an experimental unit (for
    instance a customer) to a specific treatment (payment button variant, marketing
    push notification framing). Often this assignment needs to meet the following
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to be random.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It needs to be stable. If the customer comes back to the screen, they need to
    be exposed to the same payment button variant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It needs to be retrieved or generated very quickly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It needs to be available after the actual assignment so it can be used in downstream
    analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When organizations first start their experimentation journey, a common pattern
    is to pre-generate assignments, store it in a database and then retrieve it at
    the time of assignment. This is a perfectly valid method to use and works great
    when you’re starting off. However, as you start to scale in customer and experiment
    volumes, this method becomes harder and harder to maintain and use reliably. You’ve
    got to (a) manage the complexity of storage, (b) ensure that assignments are actually
    random *within* and *across* experiments, and (c) retrieve the assignment reliably.
    All of these are hard at scale.
  prefs: []
  type: TYPE_NORMAL
- en: Using *hash spaces* helps solve some of these problems. It’s a simple solution
    but isn’t as widely known as it probably should be. This blog is an attempt to
    explain the technique. There are links to code in different languages at the end.
    However, if you’d like, you can also directly [jump to code here](https://gist.github.com/davidclarance/daeafad5fc3e28e019950a12b0da01f5).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re running an experiment to test which variant of a progress bar on our
    customer app drives the most engagement. There are three variants: Control (the
    default experience), Variant A and Variant B.'
  prefs: []
  type: TYPE_NORMAL
- en: We have 10 million customers that use our app every week and we want to ensure
    that these 10 million customers get randomly assigned to one of the three variants.
    Each time the customer comes back to the app they should see the same variant.
    We want control to be assigned with a 50% probability, Variant 1 to be assigned
    with a 30% probability and Variant 2 to be assigned with a 20% probability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make things simpler, we’ll start with 4 customers. These customers have
    IDs that we use to refer to them. These IDs are generally either GUIDs (something
    like `"b7be65e3-c616-4a56-b90a-e546728a6640"`) or integers (like 1019222, 1028333).
    Any of these ID types would work but to make things easier to follow we’ll simply
    assume that these IDs are: “Customer1”, “Customer2”, “Customer3”, “Customer4”.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2c3e1b8d1a9749e82665f0b85b625077.png)'
  prefs: []
  type: TYPE_IMG
- en: Our goal is to map these 4 customers to the three possible variants.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing customer IDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method primarily relies on using hash algorithms that come with some very
    desirable properties. Hashing algorithms take a string of arbitrary length and
    map it to a ‘hash’ of a fixed length. The easiest way to understand this is through
    some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'A hash function, takes a string and maps it to a constant hash space. In the
    example below, a hash function (in this case [md5](https://en.wikipedia.org/wiki/MD5))
    takes the words: “Hello”, “World”, “Hello World” and “Hello WorLd” (note the capital
    L) and maps it to an alphanumeric string of 32 characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/00d92d992fb4fc78be549a1e6584b213.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A few important things to note:'
  prefs: []
  type: TYPE_NORMAL
- en: The hashes are all of the same length.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A minor difference in the input (capital L instead of small L) changes the hash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashes are a hexadecimal string. That is, they comprise of the numbers 0 to
    9 and the first six alphabets (a, b, c, d, e and f).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use this same logic and get hashes for our four customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/ef410f40b4ade02a5f145ea2809b19e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Hexadecimal strings are just representations of numbers in base 16\. We can
    [convert them to integers in base 10](https://g.co/gemini/share/83e1757e48f9).
  prefs: []
  type: TYPE_NORMAL
- en: '⚠️ One important note here: We rarely need to use the full hash. In practice
    (for instance in the linked code) we use a much smaller part of the hash (first
    10 characters). Here we use the full hash to make explanations a bit easier.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0cb07f18fec04b5226a7cda3b7113521.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two important properties of these integers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'These integers are **stable**: Given a fixed input (“Customer1”), the hashing
    algorithm will always give the same output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These integers are **uniformly distributed**: This one hasn’t been explained
    yet and mostly applies to cryptographic hash functions (such as md5). Uniformity
    is a design requirement for these hash functions. If they were not uniformly distributed,
    the chances of collisions (getting the same output for different inputs) would
    be higher and weaken the security of the hash. There are some [explorations](https://www.rolando.cl/blog/2018/12/how_uniform_is_md5.html)
    of the [uniformity](https://stackoverflow.com/a/9346575/4583536) property.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have an integer representation of each ID that’s stable (always
    has the same value) and [uniformly distributed](https://en.wikipedia.org/wiki/Hash_function#Uniformity),
    we can use it to get to an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: From integer representations to assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Going back to our probability assignments, we want to assign customers to variants
    with the following distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If we had 100 slots, we can divide them into 3 buckets where the number of slots
    represents the probability we want to assign to that bucket. For instance, in
    our example, we divide the integer range 0–99 (100 units), into 0–49 (50 units),
    50–79 (30 units) and 80–99 (20 units).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/47916521fbf40c2ba86ba2655962d4b7.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we assign a customer to one of the 100 slots randomly, the resultant
    distribution should then be equal to our intended distribution. Another way to
    think about this is, if we choose a number randomly between 0 and 99, there’s
    a 50% chance it’ll be between 0 and 49, 30% chance it’ll be between 50 and 79
    and 20% chance it’ll be between 80 and 99.
  prefs: []
  type: TYPE_NORMAL
- en: The only remaining step is to map the customer integers we generated to one
    of these hundred slots. We do this by extracting the last two digits of the integer
    generated and using that as the assignment. For instance, the last two digits
    for customer 1 are 97 (you can check the diagram below). This falls in the third
    bucket (Variant 2) and hence the customer is assigned to Variant 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We repeat this process iteratively for each customer. When we’re done with
    all our customers, we should find that the end distribution will be what we’d
    expect: 50% of customers are in control, 30% in variant 1, 20% in variant 2.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The [linked gist](https://gist.github.com/davidclarance/daeafad5fc3e28e019950a12b0da01f5?permalink_comment_id=5136729#gistcomment-5136729)
    has a replication of the above for 1,000,000 customers where we can observe that
    customers are distributed in the expected proportions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Practical considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding ‘salt’ to an experiment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In practice, when you’re running multiple experiments across different parts
    of your product, it’s common practice to add in a “salt” to the IDs before you
    hash them. This salt can be anything: the experiment name, an experiment id, the
    name of the feature etc. This ensures that the customer to bucket mapping is always
    different across experiments given that the salt is different. This is really
    helpful to ensure that customer aren’t always falling in the same buckets. For
    instance, you don’t want specific customers to always fall into the control treatment
    if it just happens that the control is allocated the first 50 buckets in all your
    experiments. This is straightforward to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Increasing the partitioned space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we used a space that consisted of 100 possible slots (or partitions).
    If you wanted to assign probabilities that were one or more decimal places, you’d
    just take the last n digits of the integer generated.
  prefs: []
  type: TYPE_NORMAL
- en: So for instance if you wanted to assign probabilities that were up to two decimal
    places, you could take the last 4 digits of the integer generated. That is, the
    value of `place_value` below would be 10000.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Cross environment availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, one reason this method is so powerful and attractive in practice is
    that you can replicate the process identically across different implementation
    environments. The core hashing algorithm will always give you the same hash in
    any environment as long as the input is the same. All you need is the `CustomerId`,
    `SaltId`and the intended probability distribution. You can find different implementations
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Python](https://gist.github.com/davidclarance/daeafad5fc3e28e019950a12b0da01f5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DuckDB](https://gist.github.com/davidclarance/b69559191e6628d32d8f2adf271e067f)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[TSQL](https://gist.github.com/davidclarance/99a22cc90bd7172fc2a2d00745b62c0e)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to generate random, fast and stable assignments across different
    implementation environments, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a cryptographic hashing function (such as md5) to generate a hash from a
    unique ID + some ‘salt’.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert this into an integer in base 10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the last two digits. You can extract more if you have more fine grained
    requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use these digits to assign the ID to one of a set of pre-defined experimental
    buckets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/fb459aab4c75749b21394c14a2ecbd26.png)'
  prefs: []
  type: TYPE_IMG
- en: An overview of mapping a customer to a bucket
  prefs: []
  type: TYPE_NORMAL
- en: Thanks for following along and hope you’ve found this useful. All images in
    the article are mine. Feel free to use them!
  prefs: []
  type: TYPE_NORMAL
- en: Massive thanks to *Deniss Zenkovs* for introducing me to the idea and suggesting
    interesting extensions.
  prefs: []
  type: TYPE_NORMAL

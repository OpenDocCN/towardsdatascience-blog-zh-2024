["```py\nimport numpy as np\n\ndef nms_cpu(boxes, scores, max_output_size, threshold=0.1):\n    epsilon = 1e-5\n\n    # Convert bounding boxes and scores to numpy\n    boxes = np.array(boxes)\n    scores = np.array(scores)\n\n    # coordinates of bounding boxes\n    start_x = boxes[:, 0]\n    start_y = boxes[:, 1]\n    end_x = boxes[:, 2]\n    end_y = boxes[:, 3]\n\n    # Compute areas of bounding boxes\n    areas = (end_x - start_x) * (end_y - start_y)\n\n    # Sort by confidence score of bounding boxes\n    order = np.argsort(scores)\n\n    # Picked bounding boxes\n    picked_boxes = []\n\n    # Iterate over bounding boxes\n    while order.size > 0 and len(picked_boxes) < max_output_size:\n\n        # The index of the remaining box with the highest score\n        index = order[-1]\n\n        # Pick the bounding box with largest confidence score\n        picked_boxes.append(index.item())\n\n        # Compute coordinates of intersection\n        x1 = np.maximum(start_x[index], start_x[order[:-1]])\n        x2 = np.minimum(end_x[index], end_x[order[:-1]])\n        y1 = np.maximum(start_y[index], start_y[order[:-1]])\n        y2 = np.minimum(end_y[index], end_y[order[:-1]])\n\n        # Compute areas of intersection and union\n        w = np.maximum(x2 - x1, 0.0)\n        h = np.maximum(y2 - y1, 0.0)\n\n        intersection = w * h\n        union = areas[index] + areas[order[:-1]] - intersection\n\n        # Compute the ratio between intersection and union\n        ratio = intersection / np.clip(union, min=epsilon)\n\n        # discard boxes above overlap threshold\n        keep = np.where(ratio < threshold)\n        order = order[keep]\n\n    return picked_boxes\n```", "```py\nimport jax\nfrom jax import random\nimport jax.numpy as jnp\n\ndef generate_random_boxes(run_on_cpu = False):\n    if run_on_cpu:\n        jax.config.update('jax_default_device', jax.devices('cpu')[0])\n    else:\n        jax.config.update('jax_default_device', jax.devices('tpu')[0])\n\n    n_boxes = 1024\n    img_size = 1024\n\n    k1, k2, k3 = random.split(random.key(0), 3)\n\n    # Randomly generate box sizes and positions\n    box_sizes = random.randint(k1,\n                               shape=(n_boxes, 2),\n                               minval=1,\n                               maxval=img_size)\n    top_left = random.randint(k2,\n                              shape=(n_boxes, 2),\n                              minval=0,\n                              maxval=img_size - 1)\n    bottom_right = jnp.clip(top_left + box_sizes, 0, img_size - 1)\n\n    # Concatenate top-left and bottom-right coordinates\n    rand_boxes = jnp.concatenate((top_left, bottom_right),\n                                 axis=1).astype(jnp.bfloat16)\n    rand_scores = jax.random.uniform(k3, \n                                     shape=(n_boxes,),\n                                     minval=0.0,\n                                     maxval=1.0)\n\n    return rand_boxes, rand_scores\n\nrand_boxes, rand_scores = generate_random_boxes(run_on_cpu=True)\n\ntime = benchmark(nms_cpu)(rand_boxes, rand_scores, max_output_size=128)\nprint(f'nms_cpu: {time}')\n```", "```py\nimport functools\n\n# Given N boxes, calculates mask_threshold an NxN boolean mask\n# where the (i,j) entry indicates whether the IOU of boxes i and j\n# exceed the threshold. Returns mask_threshold, mask_threshold2\n# which is equivalent to mask_threshold with zero diagonal and\n# the scores modified so that all values are greater than 0\ndef init_tensors(boxes, scores, threshold=0.1):\n    epsilon = 1e-5\n\n    # Extract left, top, right, bottom coordinates\n    left = boxes[:, 0]\n    top = boxes[:, 1]\n    right = boxes[:, 2]\n    bottom = boxes[:, 3]\n\n    # Compute areas of boxes\n    areas = (right - left) * (bottom - top)\n\n    # Calculate intersection points\n    inter_l = jnp.maximum(left[None, :], left[:, None])\n    inter_t = jnp.maximum(top[None, :], top[:, None])\n    inter_r = jnp.minimum(right[None, :], right[:, None])\n    inter_b = jnp.minimum(bottom[None, :], bottom[:, None])\n\n    # Width, height, and area of the intersection\n    inter_w = jnp.clip(inter_r - inter_l, 0)\n    inter_h = jnp.clip(inter_b - inter_t, 0)\n    inter_area = inter_w * inter_h\n\n    # Union of the areas\n    union = areas[None, :] + areas[:, None] - inter_area\n\n    # IoU calculation\n    iou = inter_area / jnp.clip(union, epsilon)\n\n    # Shift scores to be greater than zero\n    out_scores = scores - jnp.min(scores) + epsilon\n\n    # Create mask based on IoU threshold\n    mask_threshold = iou > threshold\n\n    # Create mask excluding diagonal (i.e., self IoU is ignored)\n    mask_threshold2 = mask_threshold * (1-jnp.eye(mask_threshold.shape[0],\n                                                  dtype=mask_threshold.dtype))\n\n    return mask_threshold, mask_threshold2, out_scores\n\n@functools.partial(jax.jit, static_argnames=['max_output_size', 'threshold'])\ndef nms_jax(boxes, scores, max_output_size, threshold=0.1):\n    # initialize mask and score tensors\n    mask_threshold, mask_threshold2, out_scores = init_tensors(boxes,\n                                                           scores,\n                                                           threshold)\n\n    # The out_scores tensor will retain the scores of the chosen boxes\n    # and zero the scores of the eliminated ones\n    # remaining_scores will maintain non-zero scores for boxes that\n    # have not been chosen or eliminated\n    remaining_scores = out_scores.copy()\n\n    def choose_box(state):\n        i, remaining_scores, out_scores = state\n        # choose index of box with highest score from remaining scores\n        index = jnp.argmax(remaining_scores)\n        # check validity of chosen box\n        valid = remaining_scores[index] > 0\n        # If valid, zero all scores with IOU greater than threshold\n        # (including the chosen index)\n        remaining_scores = jnp.where(mask_threshold[index] *valid,\n                                     0,\n                                     remaining_scores)\n        # zero the scores of the eliminated tensors (not including\n        # the chosen index)\n        out_scores = jnp.where(mask_threshold2[index]*valid,\n                               0,\n                               out_scores)\n\n        i = i + 1\n        return i, remaining_scores, out_scores\n\n    def cond_fun(state):\n        i, _, _ = state\n        return (i < max_output_size)\n\n    i = 0\n    state = (i, remaining_scores, out_scores)\n\n    _, _, out_scores = jax.lax.while_loop(cond_fun, choose_box, state)\n\n    # Output the resultant scores. To extract the chosen boxes,\n    # Take the max_output_size highest scores:\n    # min = jnp.minimum(jnp.count_nonzero(scores), max_output_size)\n    # indexes = jnp.argsort(out_scores, descending=True)[:min]\n    return out_scores\n\n# nms_jax can be run on either the CPU the TPU\nrand_boxes, rand_scores = generate_random_boxes(run_on_cpu=True)\n\ntime = benchmark(nms_jax)(rand_boxes, rand_scores, max_output_size=128)\nprint(f'nms_jax on CPU: {time}')\n\nrand_boxes, rand_scores = generate_random_boxes(run_on_cpu=False)\n\ntime = benchmark(nms_jax)(rand_boxes, rand_scores, max_output_size=128)\nprint(f'nms_jax on TPU: {time}')\n```", "```py\nfrom jax.experimental import pallas as pl\nfrom jax.experimental.pallas import tpu as pltpu\n\n# argmax helper function\ndef pallas_argmax(scores, n_boxes):\n    # we assume that the index of each box is stored in the\n    # least significant bits of the score (see below)\n    idx = jnp.max(scores.astype(float)).astype(int) % n_boxes\n    return idx\n\n# Pallas kernel definition\ndef choose_box(scores, thresh_mask1, thresh_mask2, ret_scores,\n               scores_scratch, remaining_scores_scratch, *, nsteps, n_boxes):\n    # initialize scratch memory on first step\n    @pl.when(pl.program_id(0) == 0)\n    def _():\n        scores_scratch[...] = scores[...]\n        remaining_scores_scratch[...] = scores[...]\n\n    remaining_scores = remaining_scores_scratch[...]\n\n    # choose box\n    idx = pallas_argmax(remaining_scores, n_boxes)\n\n    # we use any to verfiy validity of the chosen box due\n    # to limitations on indexing in pallas\n    valid = (remaining_scores>0).any()\n\n    # updating score tensors\n    remaining_scores_scratch[...] = jnp.where(thresh_mask1[idx,...]*valid,\n                                              0,\n                                              remaining_scores)\n    scores_scratch[...] = jnp.where(thresh_mask2[idx,...]*valid,\n                                    0,\n                                    scores_scratch[...])\n\n    # set return value on final step\n    @pl.when(pl.program_id(0) == nsteps - 1)\n    def _():\n        ret_scores[...] = scores_scratch[...]\n\n@functools.partial(jax.jit, static_argnames=['max_output_size', 'threshold'])\ndef nms_pallas(boxes, scores, max_output_size, threshold=0.1):\n    n_boxes = scores.size\n    mask_threshold, mask_threshold2, scores = init_tensors(boxes, \n                                                           scores,\n                                                           threshold)\n\n    # In order to work around the Pallas argsort limitation\n    # we create a new scores tensor with the same ordering of\n    # the input scores tensor in which the index of each score\n    # in the ordering is encoded in the least significant bits\n    sorted = jnp.argsort(scores, descending=True)\n\n    # descending integers: n_boxes-1, ..., 2, 1, 0\n    descending = jnp.flip(jnp.arange(n_boxes))\n\n    # new scores in descending with the least significant\n    # bits carrying the argsort of the input scores\n    ordered_scores = n_boxes * descending + sorted\n\n    # new scores with same ordering as input scores\n    scores = jnp.empty_like(ordered_scores\n                            ).at[sorted].set(ordered_scores)\n\n    grid = (max_output_size,)\n    return pl.pallas_call(\n        functools.partial(choose_box, \n                          nsteps=max_output_size,\n                          n_boxes=n_boxes),\n        grid_spec=pltpu.PrefetchScalarGridSpec(\n            num_scalar_prefetch=0,\n            in_specs=[\n                pl.BlockSpec(block_shape=(n_boxes,)),\n                pl.BlockSpec(block_shape=(n_boxes, n_boxes)),\n                pl.BlockSpec(block_shape=(n_boxes, n_boxes)),\n            ],\n            out_specs=pl.BlockSpec(block_shape=(n_boxes,)),\n            scratch_shapes=[pltpu.VMEM((n_boxes,), scores.dtype),\n                            pltpu.VMEM((n_boxes,), scores.dtype)],\n            grid=grid,\n        ),\n        out_shape=jax.ShapeDtypeStruct((n_boxes,), scores.dtype),\n        compiler_params=dict(mosaic=dict(\n            dimension_semantics=(\"arbitrary\",)))\n    )(scores, mask_threshold, mask_threshold2)\n\nrand_boxes, rand_scores = generate_random_boxes(run_on_cpu=False)\n\ntime = benchmark(nms_pallas)(rand_boxes, rand_scores, max_output_size=128)\nprint(f'nms_pallas: {time}')\n```"]
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Constructive Heuristics in Discrete Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Constructive Heuristics in Discrete Optimization</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/constructive-heuristics-in-discrete-optimization-f6a41bf26d01?source=collection_archive---------5-----------------------#2024-05-30">https://towardsdatascience.com/constructive-heuristics-in-discrete-optimization-f6a41bf26d01?source=collection_archive---------5-----------------------#2024-05-30</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="1d99" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Obtain initial solutions for combinatorial optimization problems with Python examples</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@bruscalia12?source=post_page---byline--f6a41bf26d01--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Bruno Scalia C. F. Leite" class="l ep by dd de cx" src="../Images/1042cd04be047c0811fef79ecd04e69c.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*8bCRllKtDxr9MY9TXeWezQ.png"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--f6a41bf26d01--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@bruscalia12?source=post_page---byline--f6a41bf26d01--------------------------------" rel="noopener follow">Bruno Scalia C. F. Leite</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--f6a41bf26d01--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">11 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">May 30, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">1</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/a97a50e5ff6012c41ccf3d6b3143c9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_USUJKdTCmdKt4BSTbxcQ.jpeg"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Representation of a constructive heuristic selecting elements from a ground set. (Image by the author).</figcaption></figure><p id="53a6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Discrete or Combinatorial Optimization is a relevant study area in Operations Research (OR) and Computer Science, dedicated to identifying the best (or a suitable) solution from a finite set of possibilities. With applications including vehicle routing, operations scheduling, and network design, often the problems cannot be tackled by exact approaches in tractable runtimes. Therefore, heuristics can be an interesting alternative to provide fast and good quality solutions guiding operations in reasonable computing time.</p><p id="39ae" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Not only as stand-alone techniques, constructive heuristics can be coupled with other algorithms to improve their runtimes, cost functions, or other performance aspects. For instance, providing an initial solution to a Mixed-Integer Programming (MIP) solver can establish a dual bound that helps to prune the search space. Additionally, this initial solution can enable the solver to incorporate local search heuristics more effectively, potentially leading to faster convergence and better overall solution quality.</p><p id="ab09" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In this article, you will find basic definitions of discrete optimization with an introduction to constructive heuristics. Python examples will be used to illustrate the topics with applications to the <em class="ny">Knapsack</em> and <em class="ny">Maximum Independent Set</em> problems. Random choices and greedy selection of elements will be analyzed as we create our solutions.</p><p id="6390" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The complete code for these problems, besides several other optimization examples, is available in my <a class="af nz" href="https://github.com/bruscalia/optimization-demo-files" rel="noopener ugc nofollow" target="_blank">GitHub repository</a>.</p></div></div></div><div class="ab cb oa ob oc od" role="separator"><span class="oe by bm of og oh"/><span class="oe by bm of og oh"/><span class="oe by bm of og"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="40b3" class="oi oj fq bf ok ol om gq on oo op gt oq or os ot ou ov ow ox oy oz pa pb pc pd bk">Discrete Optimization</h1><p id="7b8a" class="pw-post-body-paragraph nc nd fq ne b go pe ng nh gr pf nj nk nl pg nn no np ph nr ns nt pi nv nw nx fj bk">In a broad sense, a numerical optimization problem aims to find the best value of an objective <em class="ny">f </em>which is a function of decision variables <strong class="ne fr"><em class="ny">x</em></strong> and might be subject to some equality and inequality constraints, functions of <strong class="ne fr"><em class="ny">x</em></strong> as well. The objective can be defined in either a <em class="ny">minimization </em>or a <em class="ny">maximization </em>sense.</p><p id="af5e" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Discrete optimization refers to a category of optimization problems in which decision variables can assume only discrete values. Therefore one faces a finite (although it might be large) set <em class="ny">S</em> of possible solutions from which it must be selected a feasible one leading to the best objective.</p><h2 id="f238" class="pj oj fq bf ok pk pl pm on pn po pp oq nl pq pr ps np pt pu pv nt pw px py pz bk">Solution Construction</h2><blockquote class="qa qb qc"><p id="dcd1" class="nc nd ny ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Many algorithms for combinatorial optimization problems build a solution incrementally from scratch, where at each step, a single ground set element is added to the partial solution under construction. A ground set element to be added at each step cannot be such that its combination with one or more previously added elements leads to an infeasibility <em class="fq">(Resende &amp; Ribeiro, 2016)</em>.</p></blockquote><p id="1428" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Suppose we have a ground set <em class="ny">E</em> of elements that might be used to compose a solution <em class="ny">S</em>. Suppose <em class="ny">F</em> is a subset of elements from <em class="ny">E</em> that included into a partial solution <em class="ny">S</em> would not lead to infeasibility and would improve the overall results. A pseudocode for a constructive heuristic can be described as the following.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="0610" class="qh oj fq qe b bg qi qj l qk ql">function constructive(E){<br/>    S = {}<br/>    F = {i for i in E if S union {i} is feasible}<br/>    while F is not empty{<br/>        i = choose(F)<br/>        S = S union {i}<br/>        F = {i for i in E if S union {i} is feasible}<br/>    }<br/>    return S<br/>}</span></pre><p id="d5e6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The choice of the next element to include in the solution can vary according to the problem and strategy adopted. In some situations, choosing one element that leads to the best immediate effect in the partial solution can be an interesting alternative, in other situations random effects might be desirable. We will compare both approaches in two different problems in the remainder of this article.</p><p id="1c00" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In some problems, there are exact constructive algorithms in polynomial time even when adopting a greedy incremental approach as will be presented in this article. An interesting example is the Minimum Spanning Tree (MST) problem. However, this is not the case for the problems that will be presented here.</p></div></div></div><div class="ab cb oa ob oc od" role="separator"><span class="oe by bm of og oh"/><span class="oe by bm of og oh"/><span class="oe by bm of og"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="442c" class="oi oj fq bf ok ol om gq on oo op gt oq or os ot ou ov ow ox oy oz pa pb pc pd bk">The knapsack problem</h1><p id="afbd" class="pw-post-body-paragraph nc nd fq ne b go pe ng nh gr pf nj nk nl pg nn no np ph nr ns nt pi nv nw nx fj bk">In the knapsack problem, from a set of items with individual attributes of weight and value, one must select the most valuable ones to include in a knapsack of pre-defined capacity in such a way that the total weight of items selected does not exceed it. In this problem, we can think of the items available as our <em class="ny">ground set</em>.</p><p id="bdd7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">So let us create a Python class to represent each of our items available.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="25f6" class="qh oj fq qe b bg qi qj l qk ql">class Item:<br/><br/>    index: int<br/>    weight: float<br/>    value: float<br/>    density: float<br/>    selected: bool<br/><br/>    def __init__(self, index, weight, value) -&gt; None:<br/>        self.index = index<br/>        self.weight = weight<br/>        self.value = value<br/>        self.density = value / weight<br/>        self.selected = False<br/><br/>    @classmethod<br/>    def from_dict(cls, x: dict):<br/>        index = x["index"]<br/>        weight = x["weight"]<br/>        value = x["value"]<br/>        return cls(index, weight, value)</span></pre><p id="0b39" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">We also create attributes <code class="cx qm qn qo qe b">density</code> with the corresponding “value per weight” ratio of the given item, <code class="cx qm qn qo qe b">index</code> with its corresponding identifier, and <code class="cx qm qn qo qe b">selected</code> to indicate if that item is part of our final solution. The <em class="ny">classmethod </em><code class="cx qm qn qo qe b">from_dict</code> is useful for initializing a new item from a Python <code class="cx qm qn qo qe b">dict</code> with keys <em class="ny">index</em>, <em class="ny">weight</em>, and <em class="ny">value</em>.</p><p id="e356" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, let us think of an abstraction of a constructive heuristic for the knapsack problem. It takes as initialization arguments the knapsack capacity and a list of items (as dictionaries). Both should be available as attributes of our class to be used in the solution procedure.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="670e" class="qh oj fq qe b bg qi qj l qk ql">from typing import Dict, List, Union<br/><br/><br/>class BaseConstructive:<br/><br/>    items: List[Item]<br/>    capacity: float<br/>    solution: List[Item]<br/><br/>    def __init__(self, capacity: float, items: List[Dict[str, Union[int, float]]]) -&gt; None:<br/>        self.items = []<br/>        self.capacity = capacity<br/>        for new_element in items:<br/>            item = Item.from_dict(new_element)<br/>            self.items.append(item)<br/>        self.solution = []<br/><br/>    @property<br/>    def cost(self):<br/>        return sum(i.value for i in self.solution)</span></pre><p id="868a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A naive solution procedure can iterate over our set of items and include the next item in the solution if its corresponding weight is lesser than or equal to the remaining capacity.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="7bc8" class="qh oj fq qe b bg qi qj l qk ql">class BaseConstructive:<br/>    # Check previous definition<br/><br/>    def solve(self):<br/>        remaining = self.capacity<br/>        for item in self.items:<br/>            if remaining &gt;= item.weight:<br/>                item.selected = True<br/>                self.solution.append(item)<br/>                remaining = remaining - item.weight</span></pre><p id="0686" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">However, this method can lead to poor-quality solutions. Suppose at the beginning of our list there was a heavy item with a small value. It would be included in the solution occupying available space that more valuable alternatives could use.</p><p id="c813" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A better choice could have been to first sort items by their <em class="ny">density</em> and then run the previous procedure of including the next from the input if it fits in the remaining space. That leads us to the <em class="ny">Greedy</em> selection.</p><h2 id="3074" class="pj oj fq bf ok pk pl pm on pn po pp oq nl pq pr ps np pt pu pv nt pw px py pz bk">Greedy selection</h2><blockquote class="qa qb qc"><p id="dfed" class="nc nd ny ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">A greedy approximation algorithm is an iterative algorithm which produces a partial solution incrementally. Each iteration makes a locally optimal or suboptimal augmentation to the current partial solution, so that a globally suboptimal solution is reached at the end of the algorithm <em class="fq">(Wan, 2013)</em>.</p></blockquote><p id="c5d9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In the context of the knapsack problem, we could choose the next element using a priority of <em class="ny">density</em> as previously suggested. In this case, a greedy approach does not guarantee the optimality of the solution, but it can be an interesting alternative for fast and good-quality results. In our Python code, we can achieve that just by sorting our items in place previously to applying the solution procedure.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="13b9" class="qh oj fq qe b bg qi qj l qk ql">class GreedyConstructive(BaseConstructive):<br/><br/>    def solve(self):<br/>        self.items.sort(key=lambda x: x.density, reverse=True)<br/>        super().solve()</span></pre><p id="f4e2" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In my <a class="af nz" href="https://github.com/bruscalia/optimization-demo-files/tree/main/mip/knapsack/heuristics" rel="noopener ugc nofollow" target="_blank">GitHub repository</a>, you might find an instance with 10 items to which I applied both methods. While the choice based on the original input sequence produced a solution with a total value of 68, the choice based on density resulted in a total value of 91. I would go with the greedy approach for good-quality and fast solutions on this one.</p></div></div></div><div class="ab cb oa ob oc od" role="separator"><span class="oe by bm of og oh"/><span class="oe by bm of og oh"/><span class="oe by bm of og"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="193f" class="oi oj fq bf ok ol om gq on oo op gt oq or os ot ou ov ow ox oy oz pa pb pc pd bk">The maximum independent set problem</h1><p id="2a87" class="pw-post-body-paragraph nc nd fq ne b go pe ng nh gr pf nj nk nl pg nn no np ph nr ns nt pi nv nw nx fj bk">The next example is a classical problem on subset partitioning in which our goal is to find a subset of elements from an undirected graph <em class="ny">G</em>(<em class="ny">V</em>, <em class="ny">E</em>) with the maximum number of elements such that there are no edges connecting any pair from the given subset.</p><p id="5437" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let us start by creating classes to work with the graph elements of this problem. The class <code class="cx qm qn qo qe b">Node</code> will be used to represent a vertice (or node) from our undirected graph. It will have as attributes:</p><ul class=""><li id="a86c" class="nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx qp qq qr bk"><code class="cx qm qn qo qe b">neighbors</code>: A list of neighbor vertices</li><li id="e46b" class="nc nd fq ne b go qs ng nh gr qt nj nk nl qu nn no np qv nr ns nt qw nv nw nx qp qq qr bk"><code class="cx qm qn qo qe b">index</code>: Its identifier</li><li id="53c3" class="nc nd fq ne b go qs ng nh gr qt nj nk nl qu nn no np qv nr ns nt qw nv nw nx qp qq qr bk"><code class="cx qm qn qo qe b">selected</code>: A boolean to indicate when it was included in the solution</li></ul><p id="3596" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Whenever a <code class="cx qm qn qo qe b">Node</code> instance is deleted from our feasible subset of elements, we must remove it from its neighbors’ list of neighbors, so we create a method <code class="cx qm qn qo qe b">delete</code> to make it easier.</p><p id="1949" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The property <code class="cx qm qn qo qe b">degree</code> computes the number of neighbors from a given node and will be used as our criterion for choosing the next element in the <em class="ny">greedy</em> approach.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="64c6" class="qh oj fq qe b bg qi qj l qk ql">import copy<br/>from typing import Dict, List, Optional, Tuple<br/><br/><br/>class Node:<br/><br/>    neighbors: List['Node']<br/>    index: int<br/>    selected: bool<br/><br/>    def __init__(self, index):<br/>        self.index = index<br/>        self.neighbors = []<br/>        self.selected = False<br/><br/>    def __repr__(self) -&gt; str:<br/>        return f"N{self.index}"<br/><br/>    def add_neighbor(self, node: 'Node'):<br/>        if node not in self.neighbors:<br/>            self.neighbors.append(node)<br/><br/>    def delete(self):<br/>        for n in self.neighbors:<br/>            n.neighbors.remove(self)<br/><br/>    @property<br/>    def degree(self):<br/>        return len(self.neighbors)</span></pre><p id="41b9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, let us create our <code class="cx qm qn qo qe b">Graph</code> class. It should be instantiated from a list of edges and an optional list of nodes. It should have an attribute <code class="cx qm qn qo qe b">N</code> which is a dictionary of existing nodes (or vertices).</p><p id="15e0" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The property <code class="cx qm qn qo qe b">queue</code> should return a list of nodes not yet selected for us to consider including in the solution at each step of our constructive heuristic.</p><p id="03c1" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Whenever a new <code class="cx qm qn qo qe b">Node</code> instance is selected, the method <code class="cx qm qn qo qe b">select</code> should be called, which changes its <code class="cx qm qn qo qe b">selected</code> attribute and calls its <code class="cx qm qn qo qe b">delete</code> method.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="9204" class="qh oj fq qe b bg qi qj l qk ql">class Graph:<br/><br/>    N: Dict[int, Node]<br/><br/>    def __init__(<br/>        self,<br/>        edges: List[Tuple[int, int]],<br/>        nodes: Optional[List[int]] = None<br/>    ):<br/>        # Start the set<br/>        if nodes is None:<br/>            self.N = {}<br/>        else:<br/>            self.N = {i: Node(i) for i in nodes}<br/><br/>        # Include all neighbors<br/>        for i, j in edges:<br/>            self._new_edge(i, j)<br/><br/>    @property<br/>    def active_nodes(self):<br/>        return [node for node in self.N.values() if node.selected]<br/><br/>    @property<br/>    def inactive_nodes(self):<br/>        return [node for node in self.N.values() if not node.selected]<br/><br/>    @property<br/>    def nodelist(self):<br/>        return list(self.N.values())<br/><br/>    @property<br/>    def queue(self):<br/>        return [n for n in self.nodelist if not n.selected]<br/><br/>    def _new_node(self, i: int):<br/>        if i not in self.N:<br/>            self.N[i] = Node(i)<br/><br/>    def _new_edge(self, i: int, j: int):<br/>        self._new_node(i)<br/>        self._new_node(j)<br/>        self.N[i].add_neighbor(self.N[j])<br/>        self.N[j].add_neighbor(self.N[i])<br/><br/>    def select(self, node: Node):<br/>        node.selected = True<br/>        selected_neighbors = node.neighbors.copy()<br/>        for n in selected_neighbors:<br/>            other = self.N.pop(n.index)<br/>            other.delete()<br/><br/>    def deactivate(self):<br/>        for n in self.N.values():<br/>            n.selected = False<br/><br/>    def copy(self):<br/>        return copy.deepcopy(self)</span></pre><p id="b0c7" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Now, let us create an abstraction for our constructive heuristic. It should be instantiated, as its corresponding <code class="cx qm qn qo qe b">Graph</code>, from a list of edges and an optional list of nodes. When instantiated, its attribute <code class="cx qm qn qo qe b">graph</code> is defined from the original graph of the problem instance.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="fb4b" class="qh oj fq qe b bg qi qj l qk ql">from abc import ABC, abstractmethod<br/>from mis.graph import Graph, Node<br/>from typing import List, Optional, Tuple<br/><br/><br/>class BaseConstructive(ABC):<br/><br/>    graph: Graph<br/><br/>    def __init__(<br/>        self,<br/>        edges: List[Tuple[int, int]],<br/>        nodes: Optional[List[int]] = None,<br/>    ):<br/>        self.graph = Graph(edges, nodes)</span></pre><p id="840a" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The <code class="cx qm qn qo qe b">solve</code> method will be at the core of our solution procedure. It should return a subgraph of <em class="ny">G</em>(<em class="ny">V</em>, <em class="ny">E</em>) with a candidate solution. When using an instance of the solution procedure as a callable, it should overwrite its nodes’ <code class="cx qm qn qo qe b">selected</code> attributes based on the result returned by the <code class="cx qm qn qo qe b">solve</code> method.</p><p id="963d" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Notice the <code class="cx qm qn qo qe b">choice</code> method here is an abstraction yet to be overwritten by child classes.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="d584" class="qh oj fq qe b bg qi qj l qk ql">class BaseConstructive(ABC):<br/>    # Check previous definitions<br/><br/>    def __call__(self, *args, **kwargs):<br/>        S = self.solve(*args, **kwargs)<br/>        for i, n in S.N.items():<br/>            self.graph.N[i].selected = n.selected<br/><br/>    @property<br/>    def cost(self):<br/>        return len(self.graph.active_nodes)<br/><br/>    def solve(self, *args, **kwargs) -&gt; Graph:<br/>        self.graph.deactivate()<br/>        G = self.graph.copy()<br/>        for i in range(len(G.N)):<br/>            n = self.choice(G)<br/>            G.select(n)<br/>            if len(G.queue) == 0:<br/>                assert len(G.N) == i + 1, "Unexpected behavior in remaining nodes and iterations"<br/>                break<br/><br/>        return G<br/><br/>    @abstractmethod<br/>    def choice(self, graph: Graph) -&gt; Node:<br/>        pass</span></pre><p id="ec48" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let us first create an algorithm that randomly chooses the next node to include into our solution.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="ce86" class="qh oj fq qe b bg qi qj l qk ql">import random<br/><br/><br/>class RandomChoice(BaseConstructive):<br/><br/>    rng: random.Random<br/><br/>    def __init__(<br/>        self,<br/>        edges: List[Tuple[int, int]],<br/>        nodes: Optional[List[int]] = None,<br/>        seed=None<br/>    ):<br/>        super().__init__(edges, nodes)<br/>        self.rng = random.Random(seed)<br/><br/>    def choice(self, graph: Graph) -&gt; Node:<br/>        return self.rng.choice(graph.queue)</span></pre><p id="ccb6" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">It can already be used in our solution procedure and creates feasible solutions that are <em class="ny">maximal independent sets</em> (not <em class="ny">maximum</em>). However, its performance varies according to the random sequence and we might be vulnerable to poor results.</p><h2 id="29ea" class="pj oj fq bf ok pk pl pm on pn po pp oq nl pq pr ps np pt pu pv nt pw px py pz bk">Adaptive greedy</h2><p id="a10c" class="pw-post-body-paragraph nc nd fq ne b go pe ng nh gr pf nj nk nl pg nn no np ph nr ns nt pi nv nw nx fj bk">Alternatively, at each step, we could have chosen the next node that has the smallest impact on the “pool” of feasible elements from the ground set. It would mean choosing the next element that in the subgraph has the smallest number of neighbors. In other words, with the smallest <code class="cx qm qn qo qe b">degree</code> attribute. This is the same approach adopted by Feo et al. (1994).</p><p id="18e9" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Notice the <code class="cx qm qn qo qe b">degree</code> of our nodes might vary as the partial solution changes and elements are removed from the subgraph. It can be therefore defined as an <em class="ny">adaptive greedy</em> procedure.</p><blockquote class="qa qb qc"><p id="d8ce" class="nc nd ny ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">There are other situations where the cost of the contribution of an element is affected by the previous choices of elements made by the algorithm. We shall call these adaptive greedy algorithms <em class="fq">(Resende &amp; Ribeiro, 2016)</em>.</p></blockquote><p id="da37" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Let us then implement an algorithm that chooses as the next element the one from the subgraph with the smallest <code class="cx qm qn qo qe b">degree</code>.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="40e6" class="qh oj fq qe b bg qi qj l qk ql">class GreedyChoice(BaseConstructive):<br/><br/>    def choice(self, graph: Graph) -&gt; Node:<br/>        return min([n for n in graph.queue], key=lambda x: x.degree)</span></pre><p id="01ed" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Although it does not provide proof of optimality, the adaptive greedy approach can also be an interesting strategy for providing fast and good-quality results to this problem. But try running the random approach multiple times… In some instances, it might outperform the greedy strategy (at least in one or a few runs). Why not implement a multi-start framework then?</p><h2 id="7906" class="pj oj fq bf ok pk pl pm on pn po pp oq nl pq pr ps np pt pu pv nt pw px py pz bk">Multistarts</h2><p id="ed87" class="pw-post-body-paragraph nc nd fq ne b go pe ng nh gr pf nj nk nl pg nn no np ph nr ns nt pi nv nw nx fj bk">In this approach, multiple independent runs are performed, and a registry of the best solution is kept. In the end, the best solution is returned.</p><pre class="mm mn mo mp mq qd qe qf bp qg bb bk"><span id="c325" class="qh oj fq qe b bg qi qj l qk ql">class MultiRandom(RandomChoice):<br/><br/>    def solve(self, n_iter: int = 10) -&gt; Graph:<br/>        best_sol = None<br/>        best_cost = 0<br/>        for _ in range(n_iter):<br/>            G = super().solve()<br/>            if len(G.N) &gt; best_cost:<br/>                best_cost = len(G.N)<br/>                best_sol = G<br/>        return best_sol</span></pre><p id="0700" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">In my <a class="af nz" href="https://github.com/bruscalia/optimization-demo-files/blob/5546625793917492f4abe1aca0a571527e256e32/graph-coloring/max_independent_set.ipynb" rel="noopener ugc nofollow" target="_blank">GitHub repository</a>, you will find an example of a 32-node graph in which the <em class="ny">adaptive greedy</em> found a subset of 5 vertices, but a random framework with multi-start found a solution with 6. The solution procedure is represented below.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk qx"><img src="../Images/abb86a60627ac000096137ee77138ed8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aDQsX_5fOZCGapaF8bxqCA.gif"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Solution procedure of constructive heuristic applied to a maximum independent set problem. (Animation by the author).</figcaption></figure></div></div></div><div class="ab cb oa ob oc od" role="separator"><span class="oe by bm of og oh"/><span class="oe by bm of og oh"/><span class="oe by bm of og"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="bc28" class="oi oj fq bf ok ol om gq on oo op gt oq or os ot ou ov ow ox oy oz pa pb pc pd bk">Further reading</h1><p id="4901" class="pw-post-body-paragraph nc nd fq ne b go pe ng nh gr pf nj nk nl pg nn no np ph nr ns nt pi nv nw nx fj bk">At the beginning of this text, I suggested constructive heuristics can be coupled with local search techniques. One fantastic meta-heuristic that explores it is called <em class="ny">Greedy Randomized Adaptive Search Procedure</em> (GRASP).</p><p id="fafd" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">The idea of GRASP is to use a multi-start framework in which a random element will lead the constructive phase to produce different initial solutions to which local search should be applied. This way, the solution procedure escapes local optima. For those interested in exploring heuristics and meta-heuristics in more detail, it is worth checking the <a class="af nz" href="https://mauricio.resende.info/" rel="noopener ugc nofollow" target="_blank">website of Prof Mauricio Resende</a>, one of the authors who originally proposed GRASP. There, he lists several of his works and contributions to the academic community on operations research.</p><p id="cbf8" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Those interested in coding examples of GRASP might also check my <a class="af nz" href="https://github.com/bruscalia/jobshop" rel="noopener ugc nofollow" target="_blank">GitHub repository</a> with an application for the Job-Shop Scheduling Problem.</p><p id="0fb8" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">To those interested in exploring more optimization problems and solution techniques, I have several other stories available on Medium which I have aggregated on a comprehensive list.</p><div class="qy qz ra rb rc"><div role="button" tabindex="0" class="ab bx cp ke io rd re bp rf lr ao"><div class="rg l"><div class="ab q"><div class="l ed"><img alt="Bruno Scalia C. F. Leite" class="l ep by rh ri cx" src="../Images/0c7396e41d4b598be2349eaea982c984.png" width="20" height="20" loading="lazy" data-original-src="https://miro.medium.com/v2/resize:fill:40:40/1*8bCRllKtDxr9MY9TXeWezQ.png"/><div class="el by l rh ri em n ay tt"/></div><div class="rj l ig"><p class="bf b dy z io ip iq ir is it iu iv dx"><a class="af ag ah ai aj ak al am an ao ap aq ar as at" href="https://medium.com/@bruscalia12?source=post_page-----f6a41bf26d01--------------------------------" rel="noopener follow" target="_top">Bruno Scalia C. F. Leite</a></p></div></div><div class="cq rm hk l"><h2 class="bf fr wr hx io ws iq ir wt it iv fp bk">Tales of the Optimization Age</h2></div><div class="ab q"><div class="l ig"><a class="bf b dy z bk wu vt vu vv vw le vx vy ue id vz wa wb ui uj uk ep bm ul my" href="https://medium.com/@bruscalia12/list/tales-of-the-optimization-age-c15faf64a6ca?source=post_page-----f6a41bf26d01--------------------------------" rel="noopener follow" target="_top">View list</a></div><div class="wv l ig"><span class="bf b dy z dx">15 stories</span></div></div></div><div class="rv dz rw io ab rx ig ed"><div class="ed rp bx rq rr"><div class="dz l"><img alt="" class="dz" src="../Images/848ca03a7d7366b8a040f720f5d51f5c.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/da:true/resize:fill:388:388/0*paOyr29vZn2R9DSY"/></div></div><div class="ed rp bx kf rs rt"><div class="dz l"><img alt="" class="dz" src="../Images/b79fd62ce301f6295199d983f7633588.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/da:true/resize:fill:388:388/0*tVmGXGO3AB0QNMmN"/></div></div><div class="ed bx hs ru rt"><div class="dz l"><img alt="" class="dz" src="../Images/a6e8cbe0e088f4e7b1edcf27c524b072.png" width="194" height="194" loading="lazy" role="presentation" data-original-src="https://miro.medium.com/v2/da:true/resize:fill:388:388/0*GlSqcjzymt1QZMQw"/></div></div></div></div></div></div></div></div><div class="ab cb oa ob oc od" role="separator"><span class="oe by bm of og oh"/><span class="oe by bm of og oh"/><span class="oe by bm of og"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="47ec" class="oi oj fq bf ok ol om gq on oo op gt oq or os ot ou ov ow ox oy oz pa pb pc pd bk">Conclusions</h1><p id="dc38" class="pw-post-body-paragraph nc nd fq ne b go pe ng nh gr pf nj nk nl pg nn no np ph nr ns nt pi nv nw nx fj bk">Throughout this article, constructive heuristics in the context of discrete optimization were introduced and applied to the <em class="ny">knapsack </em>and the <em class="ny">maximum independent set</em> problems. Intuitions on how to choose ground elements to build a solution were presented exemplifying a greedy choice, random factors, and multi-starts. The complete code is available in my <a class="af nz" href="https://github.com/bruscalia/optimization-demo-files" rel="noopener ugc nofollow" target="_blank">GitHub repository</a>.</p></div></div></div><div class="ab cb oa ob oc od" role="separator"><span class="oe by bm of og oh"/><span class="oe by bm of og oh"/><span class="oe by bm of og"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="fc34" class="oi oj fq bf ok ol om gq on oo op gt oq or os ot ou ov ow ox oy oz pa pb pc pd bk">References</h1><p id="210d" class="pw-post-body-paragraph nc nd fq ne b go pe ng nh gr pf nj nk nl pg nn no np ph nr ns nt pi nv nw nx fj bk">Feo, T. A., Resende, M. G., &amp; Smith, S. H., 1994. A greedy randomized adaptive search procedure for maximum independent set. <em class="ny">Operations Research</em>, <em class="ny">42</em>(5), 860–878.</p><p id="43e1" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Resende, M. G., &amp; Ribeiro, C. C., 2016. <em class="ny">Optimization by GRASP</em>. Springer Science+ Business Media New York.</p><p id="0881" class="pw-post-body-paragraph nc nd fq ne b go nf ng nh gr ni nj nk nl nm nn no np nq nr ns nt nu nv nw nx fj bk">Wan, PJ., 2013. Greedy Approximation Algorithms. In: Pardalos, P., Du, DZ., Graham, R. (eds) Handbook of Combinatorial Optimization. Springer, New York, NY.</p></div></div></div></div>    
</body>
</html>
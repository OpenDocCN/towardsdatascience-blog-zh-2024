- en: Improving Business Performance with Machine Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/improving-business-performance-with-machine-learning-fbdf5e280923?source=collection_archive---------3-----------------------#2024-06-13](https://towardsdatascience.com/improving-business-performance-with-machine-learning-fbdf5e280923?source=collection_archive---------3-----------------------#2024-06-13)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether you are a data scientist, analyst, or business analyst, your goal is
    to deliver projects that improve business performance.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@juanjosemunozp?source=post_page---byline--fbdf5e280923--------------------------------)[![Juan
    Jose Munoz](../Images/b42d72e9e2a2eaf11da5465e9b041d53.png)](https://medium.com/@juanjosemunozp?source=post_page---byline--fbdf5e280923--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--fbdf5e280923--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--fbdf5e280923--------------------------------)
    [Juan Jose Munoz](https://medium.com/@juanjosemunozp?source=post_page---byline--fbdf5e280923--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--fbdf5e280923--------------------------------)
    ¬∑15 min read¬∑Jun 13, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d28fb9d54d5dd553dc3c6563016f0125.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Daria Nepriakhina üá∫üá¶](https://unsplash.com/@epicantus?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: It might be tempting to focus on the latest machine learning developments or
    tackling the big problems. However, you can often deliver great value by solving
    low-hanging fruit with simple machine-learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking is one of those low-hanging fruits. It is the process of measuring
    business KPIs against similar organizations. It allows businesses to learn from
    the best and continuously improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of Benchmarking:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. Internal**: measure KPI against units/products in the same company'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**2\. External**: measure KPI against competitors'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In my daily work in the hotel industry, we often rely on third-party companies
    that collect hotel data for external benchmarking. However, the data we get from
    them is limited. On the other hand, we manage over 500 hotels and are sitting
    on vast amounts of data for potential benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: This is the low-hanging fruit we set up to solve recently.
  prefs: []
  type: TYPE_NORMAL
- en: No matter which type of benchmarking exercise you are conducting, the first
    step is to select a set of hotels similar to the subject hotel. In the hotel industry,
    we usually rely on location indicators, brand tier, number of rooms, price range,
    and market demand. We typically do this manually when we are doing it for one
    or two hotels, but doing this manually for 500 hotels is not feasible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a problem to solve, the next step is to select with tool to use.
    Machine learning offers many tools. However, this problem can be solved with a
    simple family of algorithms: Nearest Neighbors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Nearest Neighbors algorithm family**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The nearest neighbors algorithm family is a form of optimization problem that
    aims to find the points in a given data set that are the closest or most similar
    to a given point.
  prefs: []
  type: TYPE_NORMAL
- en: These algorithms have been very successful in tackling many classification and
    regression problems. As such, Scikit Learn API has a fantastic Nearest Neighbors
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '[](https://scikit-learn.org/stable/modules/classes.html?source=post_page-----fbdf5e280923--------------------------------#module-sklearn.neighbors)
    [## API Reference'
  prefs: []
  type: TYPE_NORMAL
- en: This is the class and function reference of scikit-learn. Please refer to the
    full user guide for further details, as‚Ä¶
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: scikit-learn.org](https://scikit-learn.org/stable/modules/classes.html?source=post_page-----fbdf5e280923--------------------------------#module-sklearn.neighbors)
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most people are familiar with K-Nearest Neighbor (KNN); however, Scikit Learn
    offers a wide variety of Nearest Neighbors algorithms, covering both supervised
    and unsupervised tasks.
  prefs: []
  type: TYPE_NORMAL
- en: For our problem, we don‚Äôt have any labels. Therefore, we are looking for an
    unsupervised algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: If you look through the scikit learn documentation, you will find `NearestNeighbors`
    . This algorithm performs unsupervised learning for implementing neighbor searches.
  prefs: []
  type: TYPE_NORMAL
- en: This seems to cover what we need to solve our problem. Let‚Äôs start by getting
    the data ready and running a baseline model.
  prefs: []
  type: TYPE_NORMAL
- en: Baseline Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1\. Loading the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A hotel‚Äôs performance usually depends on location, brand, and size. For our
    analysis, we use two data sets:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hotel data: The hotel data used below has been generated artificially based
    on the original dataset used for this analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: '`BRAND`: defines the service level of the hotel: Luxury, Upscale, Economy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Room_count`: number of rooms available for sale'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Market`: Name of the city in which the hotel is located'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Country`: Name of the country'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Latitude`: Hotel''s Latitude location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Longitude`: Hotel''s Longitude location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Airport Code`: 3 Letter code of the nearest international airport'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Market Tier`: defines the market development level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HCLASS`: indicates if the hotel is a city hotel or resort'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Demand`: indicates hotel yearly occupancy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Price range`: indicates the average price for the hotel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also know how hotel performance can be impacted by accessibility. To measure
    accessibility, we can measure how far the hotel is from the main international
    airport. The airport data is from the World Bank: [https://datacatalog.worldbank.org/search/dataset/0038117](https://datacatalog.worldbank.org/search/dataset/0038117)'
  prefs: []
  type: TYPE_NORMAL
- en: '`Orig`: 3 Letter Airport code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: Airport name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TotalSeats`: Annual passenger volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Country name`: Airport country name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Airpot1Latitude`: Aiport Latitude'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Airport1Longitude`: Airport Longitude'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global Airports dataset is licensed under Creative Commons Attribution 4.0*'
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs import the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/5a02a04415f60ae25407698a38693530.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample of Hotel data. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1d2b250de192743886e633b4d2eb9f60.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample Airport data. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, hotel performance is highly dependent on location. In our
    data set, we have many measures of location, such as Market Country‚Ä¶ however,
    this is not always ideal as those definitions are quite broad. To narrow down
    similar locations, we need to create a `accessability` measure, defined by the
    distance to the closest international airport.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate the distance from a hotel to the airport, we use the haversine
    formula. The haversine formula is used to calculate the distance between two points
    in a sphere, given their latitude and longitude.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f42916249a4d86d75892a53743b9a4f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Resulting data frame with distance to airport feature. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The next step is removing any column we won‚Äôt need for our model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we encode all non-numerical variables so that we can pass them into our
    model. At this point, it is important to keep in mind that we will need the original
    labels to present our suggested groupings to the team and for ease of validation.
    To do so, we will store the encoding information in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/765d8ac866bab658217e85f9dde837cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Encoded data. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Our data is now numerical, but as you can see the values in each column have
    very different ranges. To avoid the ranges of any features from disproportionately
    affecting our model, we need to rescale our data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a885e446568eb13a0c3a01d119cf4258.png)'
  prefs: []
  type: TYPE_IMG
- en: Scaled data. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we are ready to generate a baseline model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/c1e08da417e6a83c4a372f5b5c1436df.png)'
  prefs: []
  type: TYPE_IMG
- en: Model output. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: The output of the model is a list of indexes, where the first index is the subject
    hotel, and the other indexes represent the nearest hotels.
  prefs: []
  type: TYPE_NORMAL
- en: To validate the model, we can visually inspect the results. We can create a
    function that takes in the list of indexes and decodes the values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/4d295e60f17cf12d9ffb4270c94a3250.png)'
  prefs: []
  type: TYPE_IMG
- en: Initial benchmark groups. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Because we are using an unsupervised learning algorithm, there is not a widely
    available measure of accuracy. However, we can use domain knowledge to validate
    our groups.
  prefs: []
  type: TYPE_NORMAL
- en: Visually inspecting the groups, we can see some benchmarking groups have a mix
    of Economy and Luxury hotels, which doesn't make business sense as the demand
    for hotels is fundamentally different.
  prefs: []
  type: TYPE_NORMAL
- en: '**We can scroll to the data and note some of those differences, but can we
    come up with our own accuracy measure?**'
  prefs: []
  type: TYPE_NORMAL
- en: We want to create a function to measure the consistency of the recommended Benchmarking
    sets across each feature. One way of doing this is by calculating the variance
    in each feature for each set. For each cluster, we can compute an average of each
    feature variance, and we can then average each hotel cluster variance to get a
    total model score.
  prefs: []
  type: TYPE_NORMAL
- en: From our domain knowledge, we know that in order to set up a comparable benchmark
    set, we need to prioritize hotels in the same Brand, possibly the same market,
    and the same country, and if we use different markets or countries, then the market
    tier should be the same.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, we want our measure to have a higher penalty for variance
    in those features. To do so, we will use a weighted average to calculate each
    benchmark set variance. We will also print the variance of the key features and
    secondary features separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, to create our accuracy measure, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Calculate variance for categorical variables**: One common approach is to
    use an ‚Äúentropy-based‚Äù measure, where higher diversity in categories indicates
    higher entropy (variance).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Calculate variance for numerical variables**: we can compute the standard
    deviation or the range (difference between maximum and minimum values). This measures
    the spread of numerical data within each cluster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Normalize the data**: normalize the variance scores for each category before
    applying weights to ensure that no single feature dominates the weighted average
    due to scale differences alone.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Apply weights for different metrics**: Weight each type of variance based
    on its importance to the clustering logic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Calculating weighted averages**: Compute the weighted average of these variance
    scores for each cluster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Aggregating scores across clusters**: The total score is the average of these
    weighted variance scores across all clusters or rows. A lower average score would
    indicate that our model effectively groups similar hotels together, minimizing
    intra-cluster variance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To keep our code clean and track our experiments , let‚Äôs also define a function
    to store the results of our experiments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/07f338459cb382b9bf734562b11c454b.png)'
  prefs: []
  type: TYPE_IMG
- en: Baseline model results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a baseline, let‚Äôs see if we can improve our model.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our Model Through Experimentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up until now, we did not have to know what was going on under the hood when
    we ran this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To improve our model, we will need to understand the model parameters and how
    we can interact with them to get better benchmark sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let‚Äôs start by looking at the Scikit Learn documentation and source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are quite a few things going on here.
  prefs: []
  type: TYPE_NORMAL
- en: The `Nearestneighbor` class inherits from`NeighborsBase`, which is the case
    class for nearest neighbor estimators. This class handles the common functionalities
    required for nearest-neighbor searches, such as
  prefs: []
  type: TYPE_NORMAL
- en: n_neighbors (the number of neighbors to use)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: radius (the radius for radius-based neighbor searches)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: algorithm (the algorithm used to compute the nearest neighbors, such as ‚Äòball_tree‚Äô,
    ‚Äòkd_tree‚Äô, or ‚Äòbrute‚Äô)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: metric (the distance metric to use)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: metric_params (additional keyword arguments for the metric function)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Nearestneighbor` class also inherits from`KNeighborsMixin` and `RadiusNeighborsMixin`classes.
    These Mixin classes add specific neighbor-search functionalities to the `Nearestneighbor`
  prefs: []
  type: TYPE_NORMAL
- en: '`KNeighborsMixin` provides functionality to find the nearest fixed number k
    of neighbors to a point. It does that by finding the distance to the neighbors
    and their indices and constructing a graph of connections between points based
    on the k-nearest neighbors of each point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RadiusNeighborsMixin` is based on the radius neighbors algorithm, which finds
    all neighbors within a given radius of a point. This method is useful in scenarios
    where the focus is on capturing all points within a meaningful distance threshold
    rather than a fixed number of points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on our scenario, KNeighborsMixin provides the functionality we need.
  prefs: []
  type: TYPE_NORMAL
- en: We need to understand one key parameter before we can improve our model; this
    is the distance metric.
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to distance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documentation mentions that the NearestNeighbor algorithm uses the ‚ÄúMinkowski‚Äù
    distance by default and gives us a reference to the SciPy API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `scipy.spatial.distance`, we can see two mathematical representations of
    "Minkowski" distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '*‚à•u‚àív‚à• p‚Äã=( i ‚àë‚Äã‚à£u i‚Äã‚àív i‚Äã‚à£ p ) 1/p*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This formula calculates the p-th root of the sum of powered differences across
    all elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second mathematical representation of ‚ÄúMinkowski‚Äù distance is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*‚à•u‚àív‚à• p‚Äã=( i ‚àë‚Äãw i‚Äã(‚à£u i‚Äã‚àív i‚Äã‚à£ p )) 1/p*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is very similar to the first one, but it introduces weights `wi` to the
    differences, emphasizing or de-emphasizing specific dimensions. This is useful
    where certain features are more relevant than others. By default, the setting
    is None, which gives all features the same weight of 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**This is a great option for improving our model as it allows us to pass domain
    knowledge to our model and emphasize similarities that are most relevant to users.**'
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the formulas, we see the parameter. `p`. This parameter affects
    the "path" the algorithm takes to calculate the distance. **By default, p=2, which
    represents the Euclidian distance.**
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of the Euclidian distance as calculating the distance by drawing
    a straight line between 2 points. This is usally the shortest distance, however,
    this is not always the most desirable way of calculating the distance, specially
    in higher dimention spaces. For more information on why this is the case, there
    is this great paper online: [https://bib.dbvis.de/uploadedFiles/155.pdf](https://www.google.com/url?q=https%3A%2F%2Fbib.dbvis.de%2FuploadedFiles%2F155.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Another common value for p is 1\. This represents the Manhattan distance.**
    You think of it as the distance between two points measured along a grid-like
    path.'
  prefs: []
  type: TYPE_NORMAL
- en: '**On the other hand, if we increase p towards infinity, we end up with the
    Chebyshev distance, defined as the maximum absolute difference between any corresponding
    elements of the vectors**. It essentially measures the worst-case difference,
    making it useful in scenarios where you want to ensure that no single feature
    varies too much.'
  prefs: []
  type: TYPE_NORMAL
- en: By reading and getting familiar with the documentation, we have uncovered a
    few possible options to improve our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 1: Baseline model with n_neighbors = 4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default n_neighbors is 5, however, for our benchmark set, we want to compare
    each hotel to the 3 most similar hotels. To do so, we need to set n_neighbors
    = 4 (Subject hotel + 3 peers)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/573845ae760e04d4c0d1b3a414bd3e40.png)'
  prefs: []
  type: TYPE_IMG
- en: Slight improvement in our primary features. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 2: adding weights'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the documentation, we can pass weights to the distance calculation
    to emphasize the relationship across some features. Based on our domain knowledge,
    we have identified the features we want to emphasize, in this case, Brand, Market,
    Country, and Market Tier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/a0c93e3306379ea2efef56846f0f095f.png)'
  prefs: []
  type: TYPE_IMG
- en: Primary features score keeps improving. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Passing domain knowledge to the model via weights increased the score significantly.
    Next, let‚Äôs test the impact of the distance measure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 3: use Manhattan distance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the Euclidian distance. Let‚Äôs see what happens if
    we use the Manhattan distance instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2139801c701f67fa1332a9ac59be5543.png)'
  prefs: []
  type: TYPE_IMG
- en: Significant decrease in primary score. image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 4: use Chebyshev distance'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decreasing p to 1 resulted in some good improvements. Let‚Äôs see what happens
    as p approximates infinity.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Chebyshev distance, we will change the metric parameter to `Chebyshev.`
    The default sklearn Chebyshev metric doesn‚Äôt have a weight parameter. To get around
    this, we will define a custom `weighted_chebyshev` metric.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/17c6cda0b99cf5ebd7ac39902c0cf08f.png)'
  prefs: []
  type: TYPE_IMG
- en: Better than the baseline but higher than the previous experiment. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: We managed to decrease the primary feature variance scores through experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs visualize the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e5deb0e34f1ce91bf97eb1f80d7ec4cd.png)'
  prefs: []
  type: TYPE_IMG
- en: Experimentation results. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: Using Manhattan distance with weights seems to give the most accurate benchmark
    sets according to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: The last step before implementing the benchmark sets would be to examine the
    sets with the highest Primary features scores and identify what steps to take
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/9fe38e3b7fcdc89974b7cebd25e6e230.png)'
  prefs: []
  type: TYPE_IMG
- en: Score distribution. Image by author
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/1c862f02f1fa83283cbd36ef588e4292.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author
  prefs: []
  type: TYPE_NORMAL
- en: These 18 cases will need to be reviewed to ensure the benchmark sets are relevant.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with a few lines of code and some understanding of Nearest neighbor
    search, we managed to set internal benchmark sets. We can now distribute the sets
    and start measuring hotels' KPIs against their benchmark sets.
  prefs: []
  type: TYPE_NORMAL
- en: You don‚Äôt always have to focus on the most cutting-edge machine learning methods
    to deliver value. Very often, simple machine learning can deliver great value.
  prefs: []
  type: TYPE_NORMAL
- en: What are some low-hanging fruits in your business that you could easily tackle
    with Machine learning?
  prefs: []
  type: TYPE_NORMAL
- en: REFERENCES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: World Bank. ‚ÄúWorld Development Indicators.‚Äù Retrieved June 11, 2024, from [https://datacatalog.worldbank.org/search/dataset/0038117](https://datacatalog.worldbank.org/search/dataset/0038117)
  prefs: []
  type: TYPE_NORMAL
- en: Aggarwal, C. C., Hinneburg, A., & Keim, D. A. (n.d.). On the Surprising Behavior
    of Distance Metrics in High Dimensional Space. IBM T. J. Watson Research Center
    and Institute of Computer Science, University of Halle. Retrieved from [https://bib.dbvis.de/uploadedFiles/155.pdf](https://bib.dbvis.de/uploadedFiles/155.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: SciPy v1.10.1 Manual. `scipy.spatial.distance.minkowski`. Retrieved June 11,
    2024, from [https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.minkowski.html](https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.minkowski.html)
  prefs: []
  type: TYPE_NORMAL
- en: GeeksforGeeks. Haversine formula to find distance between two points on a sphere.
    Retrieved June 11, 2024, from [https://www.geeksforgeeks.org/haversine-formula-to-find-distance-between-two-points-on-a-sphere/](https://www.geeksforgeeks.org/haversine-formula-to-find-distance-between-two-points-on-a-sphere/)
  prefs: []
  type: TYPE_NORMAL
- en: scikit-learn. Neighbors Module. Retrieved June 11, 2024, from [https://scikit-learn.org/stable/modules/classes.html#module-sklearn.neighbors](https://scikit-learn.org/stable/modules/classes.html#module-sklearn.neighbors)
  prefs: []
  type: TYPE_NORMAL

["```py\ndef getIntinsicMatrix(\n    focal_x: torch.Tensor,\n    focal_y: torch.Tensor,\n    height: torch.Tensor,\n    width: torch.Tensor,\n    znear: torch.Tensor = torch.Tensor([100.0]),\n    zfar: torch.Tensor = torch.Tensor([0.001]),,\n) -> torch.Tensor:\n    \"\"\"\n    Gets the internal perspective projection matrix\n\n    znear: near plane set by user\n    zfar: far plane set by user\n    fovX: field of view in x, calculated from the focal length\n    fovY: field of view in y, calculated from the focal length\n    \"\"\"\n    fovX = torch.Tensor([2 * math.atan(width / (2 * focal_x))])\n    fovY = torch.Tensor([2 * math.atan(height / (2 * focal_y))])\n\n    tanHalfFovY = math.tan((fovY / 2))\n    tanHalfFovX = math.tan((fovX / 2))\n\n    top = tanHalfFovY * znear\n    bottom = -top\n    right = tanHalfFovX * znear\n    left = -right\n\n    P = torch.zeros(4, 4)\n\n    z_sign = 1.0\n\n    P[0, 0] = 2.0 * znear / (right - left)\n    P[1, 1] = 2.0 * znear / (top - bottom)\n    P[0, 2] = (right + left) / (right - left)\n    P[1, 2] = (top + bottom) / (top - bottom)\n    P[3, 2] = z_sign\n    P[2, 2] = z_sign * zfar / (zfar - znear)\n    P[2, 3] = -(zfar * znear) / (zfar - znear)\n    return P\n```", "```py\ndef compute_2d_covariance(\n    points: torch.Tensor,\n    external_matrix: torch.Tensor,\n    covariance_3d: torch.Tensor,\n    tan_fovY: torch.Tensor,\n    tan_fovX: torch.Tensor,\n    focal_x: torch.Tensor,\n    focal_y: torch.Tensor,\n) -> torch.Tensor:\n    \"\"\"\n    Compute the 2D covariance matrix for each gaussian\n    \"\"\"\n    points = torch.cat(\n        [points, torch.ones(points.shape[0], 1, device=points.device)], dim=1\n    )\n    points_transformed = (points @ external_matrix)[:, :3]\n    limx = 1.3 * tan_fovX\n    limy = 1.3 * tan_fovY\n    x = points_transformed[:, 0] / points_transformed[:, 2]\n    y = points_transformed[:, 1] / points_transformed[:, 2]\n    z = points_transformed[:, 2]\n    x = torch.clamp(x, -limx, limx) * z\n    y = torch.clamp(y, -limy, limy) * z\n\n    J = torch.zeros((points_transformed.shape[0], 3, 3), device=covariance_3d.device)\n    J[:, 0, 0] = focal_x / z\n    J[:, 0, 2] = -(focal_x * x) / (z**2)\n    J[:, 1, 1] = focal_y / z\n    J[:, 1, 2] = -(focal_y * y) / (z**2)\n\n    # transpose as originally set up for perspective projection\n    # so we now transform back\n    W = external_matrix[:3, :3].T\n\n    return (J @ W @ covariance_3d @ W.T @ J.transpose(1, 2))[:, :2, :2]\n```", "```py\ndef compute_inverted_covariance(covariance_2d: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    Compute the inverse covariance matrix\n\n    For a 2x2 matrix\n    given as\n    [[a, b],\n     [c, d]]\n     the determinant is ad - bc\n\n    To get the inverse matrix reshuffle the terms like so\n    and multiply by 1/determinant\n    [[d, -b],\n     [-c, a]] * (1 / determinant)\n    \"\"\"\n    determinant = (\n        covariance_2d[:, 0, 0] * covariance_2d[:, 1, 1]\n        - covariance_2d[:, 0, 1] * covariance_2d[:, 1, 0]\n    )\n    determinant = torch.clamp(determinant, min=1e-3)\n    inverse_covariance = torch.zeros_like(covariance_2d)\n    inverse_covariance[:, 0, 0] = covariance_2d[:, 1, 1] / determinant\n    inverse_covariance[:, 1, 1] = covariance_2d[:, 0, 0] / determinant\n    inverse_covariance[:, 0, 1] = -covariance_2d[:, 0, 1] / determinant\n    inverse_covariance[:, 1, 0] = -covariance_2d[:, 1, 0] / determinant\n    return inverse_covariance\n```", "```py\ndef compute_extent_and_radius(covariance_2d: torch.Tensor):\n    mid = 0.5 * (covariance_2d[:, 0, 0] + covariance_2d[:, 1, 1])\n    det = covariance_2d[:, 0, 0] * covariance_2d[:, 1, 1] - covariance_2d[:, 0, 1] ** 2\n    intermediate_matrix = (mid * mid - det).view(-1, 1)\n    intermediate_matrix = torch.cat(\n        [intermediate_matrix, torch.ones_like(intermediate_matrix) * 0.1], dim=1\n    )\n\n    max_values = torch.max(intermediate_matrix, dim=1).values\n    lambda1 = mid + torch.sqrt(max_values)\n    lambda2 = mid - torch.sqrt(max_values)\n    # now we have the eigenvalues, we can calculate the max radius\n    max_radius = torch.ceil(3.0 * torch.sqrt(torch.max(lambda1, lambda2)))\n\n    return max_radius\n```"]
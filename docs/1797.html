<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>A Visual Guide to Quantization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>A Visual Guide to Quantization</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-visual-guide-to-quantization-930ebcd9be94?source=collection_archive---------0-----------------------#2024-07-24">https://towardsdatascience.com/a-visual-guide-to-quantization-930ebcd9be94?source=collection_archive---------0-----------------------#2024-07-24</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="f9e5" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Demystifying the compression of large language models</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@maartengrootendorst?source=post_page---byline--930ebcd9be94--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Maarten Grootendorst" class="l ep by dd de cx" src="../Images/58e24b9cf7e10ff1cd5ffd75a32d1a26.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*k0XjRqlY6vxKmBSr-uySMQ.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--930ebcd9be94--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@maartengrootendorst?source=post_page---byline--930ebcd9be94--------------------------------" rel="noopener follow">Maarten Grootendorst</a></p></div></div></div><div class="hz ia l"><div class="ab ib"><div class="ab"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewbox="0 0 16 16"><path fill="#437AFF" d="M15.163 8c0 .65-.459 1.144-.863 1.575-.232.244-.471.5-.563.719s-.086.543-.092.875c-.006.606-.018 1.3-.49 1.781-.47.481-1.15.494-1.744.5-.324.006-.655.013-.857.094s-.465.337-.704.575c-.422.412-.906.881-1.542.881-.637 0-1.12-.469-1.543-.881-.239-.238-.49-.482-.704-.575-.214-.094-.532-.088-.857-.094-.593-.006-1.273-.019-1.744-.5s-.484-1.175-.49-1.781c-.006-.332-.012-.669-.092-.875-.08-.207-.33-.475-.563-.719-.404-.431-.863-.925-.863-1.575s.46-1.144.863-1.575c.233-.244.472-.5.563-.719.092-.219.086-.544.092-.875.006-.606.019-1.3.49-1.781s1.15-.494 1.744-.5c.325-.006.655-.012.857-.094.202-.081.465-.337.704-.575C7.188 1.47 7.671 1 8.308 1s1.12.469 1.542.881c.239.238.49.481.704.575s.533.088.857.094c.594.006 1.273.019 1.745.5.47.481.483 1.175.49 1.781.005.331.011.669.091.875s.33.475.563.719c.404.431.863.925.863 1.575"/><path fill="#fff" d="M7.328 10.5c.195 0 .381.08.519.22.137.141.215.331.216.53 0 .066.026.13.072.177a.24.24 0 0 0 .346 0 .25.25 0 0 0 .071-.177c.001-.199.079-.389.216-.53a.73.73 0 0 1 .519-.22h1.959c.13 0 .254-.053.346-.146a.5.5 0 0 0 .143-.354V6a.5.5 0 0 0-.143-.354.49.49 0 0 0-.346-.146h-1.47c-.324 0-.635.132-.865.366-.23.235-.359.552-.359.884v2.5c0 .066-.025.13-.071.177a.24.24 0 0 1-.346 0 .25.25 0 0 1-.072-.177v-2.5c0-.332-.13-.65-.359-.884A1.21 1.21 0 0 0 6.84 5.5h-1.47a.49.49 0 0 0-.346.146A.5.5 0 0 0 4.88 6v4c0 .133.051.26.143.354a.49.49 0 0 0 .347.146z"/></svg></div></div></div><span class="ic id" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ie if ah ai aj ak al am an ao ap aq ar ig ih ii" disabled="">Follow</button></p></div></div></span></div></div><div class="l ij"><span class="bf b bg z dx"><div class="ab cn ik il im"><div class="in io ab"><div class="bf b bg z dx ab ip"><span class="iq l ij">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--930ebcd9be94--------------------------------" rel="noopener follow"><p class="bf b bg z ir is it iu iv iw ix iy bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="ic id" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">20 min read</span><div class="iz ja l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Jul 24, 2024</span></div></span></div></span></div></div></div><div class="ab cp jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq"><div class="h k w ea eb q"><div class="kg l"><div class="ab q kh ki"><div class="pw-multi-vote-icon ed iq kj kk kl"><div class=""><div class="km kn ko kp kq kr ks am kt ku kv kl"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kw kx ky kz la lb lc"><p class="bf b dy z dx"><span class="kn">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao km lf lg ab q ee lh li" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="le"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count ld le">2</span></p></button></div></div></div><div class="ab q jr js jt ju jv jw jx jy jz ka kb kc kd ke kf"><div class="lj k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lk an ao ap ig ll lm ln" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lo cn"><div class="l ae"><div class="ab cb"><div class="lp lq lr ls lt lu ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lk an ao ap ig lv lw li lx ly lz ma mb s mc md me mf mg mh mi u mj mk ml"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lk an ao ap ig lv lw li lx ly lz ma mb s mc md me mf mg mh mi u mj mk ml"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lk an ao ap ig lv lw li lx ly lz ma mb s mc md me mf mg mh mi u mj mk ml"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><p id="7104" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As their name suggests, Large Language Models (LLMs) are often too large to run on consumer hardware. These models may exceed billions of parameters and generally need GPUs with large amounts of VRAM to speed up inference.</p><p id="f83d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As such, more and more research has been focused on making these models smaller through improved training, adapters, etc. One major technique in this field is called <em class="ni">quantization</em>.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div class="nj nk ch"><img src="../Images/1d5698c50d7a9eef4025fa20af6cf525.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/0*yNQsRRiAaEx45eWM.png"/></div></figure><p id="5c93" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In this post, I will introduce the field of quantization in the context of language modeling and explore concepts one by one to develop an intuition about the field. We will explore various methodologies, use cases, and the principles behind quantization.</p><p id="bdaa" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As a visual guide, expect many visualizations to develop an intuition about quantization!</p><h1 id="d9c1" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Part 1: The “Problem“ with LLMs</h1><p id="dc31" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">LLMs get their name due to the number of parameters they contain. Nowadays, these models typically have billions of parameters (mostly <em class="ni">weights</em>) which can be quite expensive to store.</p><p id="7ed4" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">During inference, activations are created as a product of the input and the weights, which similarly can be quite large.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk ot"><img src="../Images/563c7cc75056061c3d3a9cfb39560079.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ry6aF2LlzQl9nbar.png"/></div></div></figure><p id="3404" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As a result, we would like to represent billions of values as efficiently as possible, minimizing the amount of space we need to store a given value.</p><p id="4fe4" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Let’s start from the beginning and explore how numerical values are represented in the first place before optimizing them.</p><h1 id="bcc5" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">How to Represent Numerical Values</h1><p id="a05d" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">A given value is often represented as a floating point number (or <em class="ni">floats</em> in computer science): a positive or negative number with a decimal point.</p><p id="457e" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">These values are represented by “<em class="ni">bits</em>”, or binary digits. The <a class="af oy" href="https://en.wikipedia.org/wiki/IEEE_754" rel="noopener ugc nofollow" target="_blank">IEEE-754</a> standard describes how bits can represent one of three functions to represent the value: the <em class="ni">sign</em>, <em class="ni">exponent</em>, or <em class="ni">fraction (</em>or mantissa<em class="ni">)</em>.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk oz"><img src="../Images/3c93e39aace5e63020679e4f3852edf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*bC_pJHMZ55qJelrr.png"/></div></div></figure><p id="275b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Together, these three aspects can be used to calculate a value given a certain set of bit values:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/79a81ec5110972525d2cf5e2871d26ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U_67dVZ8ygA6caZB.png"/></div></div></figure><p id="867e" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The more bits we use to represent a value, the more precise it generally is:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/a80df1e4cd1b75723774d3edc4c0b902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cyNrQleAPu12acT4.png"/></div></div></figure><h1 id="3d2e" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Memory Constraints</h1><p id="6165" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">The more bits we have available, the larger the range of values that can be represented.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pb"><img src="../Images/d2e279156746043dbd567d2b092338fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hX-c5LCRSNCpqf8l.png"/></div></div></figure><p id="0359" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The interval of representable numbers a given representation can take is called the <em class="ni">dynamic range</em> whereas the distance between two neighboring values is called <em class="ni">precision</em>.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pc"><img src="../Images/4c2302280fe771745bde748168ea2ebc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qRPQqw6o3yeP3B2X.png"/></div></div></figure><p id="cc47" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">A nifty feature of these bits is that we can calculate how much memory your device needs to store a given value. Since there are 8 bits in a byte of memory, we can create a basic formula for most forms of floating point representation.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pb"><img src="../Images/9b8d3210d37f26c8dbb0ad7b529a0bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qID-nX4h-bmRU-Jd.png"/></div></div></figure><p id="a48f" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk"><strong class="mo fr">NOTE</strong>: In practice, more things relate to the amount of (V)RAM you need during inference, like the context size and architecture.</p><p id="777a" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Now let’s assume that we have a model with 70 billion parameters. Most models are natively represented with float 32-bit (often called <em class="ni">full-precision</em>), which would require <strong class="mo fr">280GB</strong> of memory just to load the model.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pb"><img src="../Images/6e223615a34a4df51c622ead98f7af9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Yg5kjBXbmpvJoRAo.png"/></div></div></figure><p id="b469" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As such, it is very compelling to minimize the number of bits to represent the parameters of your model (as well as during training!). However, as the precision decreases the accuracy of the models generally does as well.</p><p id="6eb1" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We want to reduce the number of bits representing values while maintaining accuracy… This is where <em class="ni">quantization</em> comes in!</p><h1 id="7603" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Part 2: Introduction to Quantization</h1><p id="2893" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">Quantization aims to reduce the precision of a model’s parameter from higher bit-widths (like 32-bit floating point) to lower bit-widths (like 8-bit integers).</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pd"><img src="../Images/800e4ae3fc95e6227e560635a33b176b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W8MbIIuIww0iBt33.png"/></div></div></figure><p id="b1ea" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">There is often some loss of precision (granularity) when reducing the number of bits to represent the original parameters.</p><p id="7769" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">To illustrate this effect, we can take any image and use only 8 colors to represent it:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/44c2bfa5a66104dad4b645292dec21fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*abf3zQzmNhEoJf3B.png"/></div></div></figure><p id="4244" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Image adapted from the original by <a class="af oy" href="https://pixabay.com/users/slava_web-designer-39623293/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=8668140" rel="noopener ugc nofollow" target="_blank">Slava Sidorov</a>.</p><p id="3c67" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Notice how the zoomed-in part seems more “grainy” than the original since we can use fewer colors to represent it.</p><p id="8313" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The main goal of quantization is to reduce the number of bits (colors) needed to represent the original parameters while preserving the precision of the original parameters as best as possible.</p><h1 id="5fc7" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Common Data Types</h1><p id="d9ed" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">First, let’s look at common data types and the impact of using them rather than 32-bit (called <em class="ni">full-precision</em> or <em class="ni">FP32</em>) representations.</p><h2 id="dedf" class="pe nt fq bf nu pf pg ph nx pi pj pk oa mv pl pm pn mz po pp pq nd pr ps pt pu bk">FP16</h2><p id="5143" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">Let’s look at an example of going from 32-bit to 16-bit (called <em class="ni">half precision </em>or <em class="ni">FP16</em>) floating point:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/e7dc0fe11f24c9aa61beeb507ec0c07d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3-_HYOcrRsBi5fK_.png"/></div></div></figure><p id="a28c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Notice how the range of values FP16 can take is quite a bit smaller than FP32.</p><h2 id="a52a" class="pe nt fq bf nu pf pg ph nx pi pj pk oa mv pl pm pn mz po pp pq nd pr ps pt pu bk">BF16</h2><p id="d258" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">To get a similar range of values as the original FP32, <em class="ni">bfloat 16</em> was introduced as a type of “truncated FP32”:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/5ecc3dee020b41a16315446bea8d875b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3I_0FLJWgVnmqDUt.png"/></div></div></figure><p id="ced1" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">BF16 uses the same amount of bits as FP16 but can take a wider range of values and is often used in deep learning applications.</p><h2 id="d6b5" class="pe nt fq bf nu pf pg ph nx pi pj pk oa mv pl pm pn mz po pp pq nd pr ps pt pu bk">INT8</h2><p id="7e0d" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">When we reduce the number of bits even further, we approach the realm of <em class="ni">integer-based representations</em> rather than floating-point representations. To illustrate, going FP32 to INT8, which has only 8 bits, results in a fourth of the original number of bits:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/ddb5e4b4685fe6c463bb4c29cea1d22d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ePlMkplOnpgRMeXn.png"/></div></div></figure><p id="b627" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Depending on the hardware, integer-based calculations might be faster than floating-point calculations but this isn’t always the case. However, computations are generally faster when using fewer bits.</p><p id="7a40" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">For each reduction in bits, a mapping is performed to “squeeze” the initial FP32 representations into lower bits.</p><p id="64fc" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In practice, we do not need to map the entire FP32 range [-3.4e38, 3.4e38] into INT8. We merely need to find a way to map the range of our data (the model’s parameters) into IN8.</p><p id="2d47" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Common squeezing/mapping methods are <em class="ni">symmetric</em> and <em class="ni">asymmetric</em> quantization and are forms of <em class="ni">linear mapping</em>.</p><p id="def8" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Let’s explore these methods to quantize from FP32 to INT8.</p><h1 id="b62d" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Symmetric Quantization</h1><p id="ccc6" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">In symmetric quantization, the range of the original floating-point values is mapped to a symmetric range around zero in the quantized space. In the previous examples, notice how the ranges before and after quantization remain centered around zero.</p><p id="b756" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This means that the quantized value for zero in the floating-point space is exactly zero in the quantized space.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pv"><img src="../Images/724c7aff658a290a3200d6146c0ebeec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7EY480L69kMF47Zy.png"/></div></div></figure><p id="653a" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">A nice example of a form of symmetric quantization is called absolute maximum (<em class="ni">absmax</em>) quantization.</p><p id="5ed2" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Given a list of values, we take the <em class="ni">highest </em>absolute value (<strong class="mo fr">α</strong>) as the range to perform the linear mapping.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pw"><img src="../Images/e892f689d2be15f0337a0aaca10bb0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sV-eNa_xxZxDv9TM.png"/></div></div></figure><p id="138b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Note the [-127, 127] range of values represents the restricted range. The unrestricted range is [-128, 127] and depends on the quantization method.</p><p id="6488" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Since it is a linear mapping centered around zero, the formula is straightforward.</p><p id="f79f" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We first calculate a scale factor (<strong class="mo fr"><em class="ni">s</em></strong>) using:</p><ul class=""><li id="a262" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh px py pz bk"><strong class="mo fr"><em class="ni">b</em></strong> is the number of bytes that we want to quantize to (8),</li><li id="52cf" class="mm mn fq mo b go qa mq mr gr qb mt mu mv qc mx my mz qd nb nc nd qe nf ng nh px py pz bk"><strong class="mo fr">α<em class="ni"> </em></strong>is the <em class="ni">highest </em>absolute value,</li></ul><p id="d4b2" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Then, we use the <strong class="mo fr"><em class="ni">s</em></strong> to quantize the input <strong class="mo fr"><em class="ni">x</em></strong>:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/4acaa26b1f84826907c832d05fe26d20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7dSpZkmBTgZasw_p.png"/></div></div></figure><p id="9fd6" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Filling in the values would then give us the following:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/c1e85a8311f1c11636e62add702385c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RA8OE_uY_w9kw27G.png"/></div></div></figure><p id="e6fb" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">To retrieve the original FP32 values, we can use the previously calculated <em class="ni">scaling factor</em> (<strong class="mo fr"><em class="ni">s</em></strong>) to <em class="ni">dequantize</em> the quantized values.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/8aa12dab62a9c5dc0684ec985e8767a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*qGP-SL9J8cI6RzQI.png"/></div></div></figure><p id="4e83" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Applying the quantization and then dequantization process to retrieve the original looks as follows:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qf"><img src="../Images/1277ab53f019e59413d6749142350224.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PNh5L-9VIKsVdimv.png"/></div></div></figure><p id="90b3" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">You can see certain values, such as <strong class="mo fr">3.08</strong> and <strong class="mo fr">3.02</strong> being assigned to the INT8, namely <strong class="mo fr">36</strong>. When you dequantize the values to return to FP32, they lose some precision and are not distinguishable anymore.</p><p id="1e85" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This is often referred to as the <em class="ni">quantization error</em> which we can calculate by finding the difference between the original and dequantized values.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qf"><img src="../Images/1bf22d8878eb82d368c01509b922d9bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3Xlz7sFvo21h-2e6.png"/></div></div></figure><p id="8579" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Generally, the lower the number of bits, the more quantization error we tend to have.</p><h1 id="03c2" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Asymmetric Quantization</h1><p id="c826" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">Asymmetric quantization, in contrast, is not symmetric around zero. Instead, it maps the minimum (<strong class="mo fr">β</strong>) and maximum (<strong class="mo fr">α</strong>) values from the float range to the minimum and maximum values of the quantized range.</p><p id="b5ab" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The method we are going to explore is called <em class="ni">zero-point quantization</em>.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pw"><img src="../Images/75eb1a6364b57a9497d80f563e23f6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8r6IzRqZGGlN283R.png"/></div></div></figure><p id="860b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Notice how the 0 has shifted positions? That’s why it’s called <em class="ni">asymmetric quantization</em>. The min/max values have different distances to 0 in the range [-7.59, 10.8].</p><p id="072f" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Due to its shifted position, we have to calculate the zero-point for the INT8 range to perform the linear mapping. As before, we also have to calculate a <em class="ni">scale factor </em>(<strong class="mo fr"><em class="ni">s</em></strong>) but use the difference of INT8’s range instead [-128, 127]</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qg"><img src="../Images/a8e96941b8aaf3158cb6a9570e6a89a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EB9JEXAU7fEiGtYp.png"/></div></div></figure><p id="341c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Notice how this is a bit more involved due to the need to calculate the <em class="ni">zeropoint </em>(<strong class="mo fr"><em class="ni">z</em></strong>) in the INT8 range to shift the weights.</p><p id="ac5c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As before, let’s fill in the formula:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qg"><img src="../Images/0111294f49ba0ed2916c2d3393a968ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8GoATjRGYzXow_yQ.png"/></div></div></figure><p id="eae8" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">To dequantize the quantized from INT8 back to FP32, we will need to use the previously calculated <em class="ni">scale factor</em> (<strong class="mo fr"><em class="ni">s</em></strong>) and <em class="ni">zeropoint </em>(<strong class="mo fr"><em class="ni">z</em></strong>).</p><p id="f864" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Other than that, dequantization is straightforward:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qh"><img src="../Images/d484ec53b8893487c618e793099c23b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_ZCnouV5fJ6QDtZ7.png"/></div></div></figure><p id="9916" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">When we put symmetric and asymmetric quantization side-by-side, we can quickly see the difference between methods:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pw"><img src="../Images/fd90cb9a22b149c32c5c1e2b3955aeaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JM96kwiPlFTjX3oY.png"/></div></div></figure><p id="59a5" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Note the zero-centered nature of symmetric quantization versus the offset of asymmetric quantization.</p><h1 id="9e31" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Range Mapping and Clipping</h1><p id="f890" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">In our previous examples, we explored how the range of values in a given vector could be mapped to a lower-bit representation. Although this allows for the full range of vector values to be mapped, it comes with a major downside, namely <em class="ni">outliers</em>.</p><p id="779b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Imagine that you have a vector with the following values:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pw"><img src="../Images/e26dc53821610741f8618258732e7c7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QvAvobbGdVolkp8n.png"/></div></div></figure><p id="969c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Note how one value is much larger than all others and could be considered an outlier. If we were to map the full range of this vector, all small values would get mapped to the same lower-bit representation and lose their differentiating factor:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qi"><img src="../Images/00ea8f5efc68a537694b1c64caf67148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PoQ6Wl4GLff6VLCt.png"/></div></div></figure><p id="6d05" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This is the absmax method we used earlier. Note that the same behavior happens with asymmetric quantization if we do not apply clipping.</p><p id="6bb5" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Instead, we can choose to <em class="ni">clip</em> certain values. Clipping involves setting a different dynamic range of the original values such that all outliers get the same value.</p><p id="8c76" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In the example below, if we were to manually set the dynamic range to [-5, 5] all values outside that will either be mapped to -127 or to 127 regardless of their value:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qi"><img src="../Images/3c5d4d2a1ccead9642fa5af70a20974d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8qG36_DZxSTcBdP_.png"/></div></div></figure><p id="f3ba" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The major advantage is that the quantization error of the <em class="ni">non-outliers</em> is reduced significantly. However, the quantization error of <em class="ni">outliers</em> increases.</p><h1 id="92e3" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Calibration</h1><p id="64f5" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">In the example, I showed a naive method of choosing an arbitrary range of [-5, 5]. The process of selecting this range is known as <em class="ni">calibration</em> which aims to find a range that includes as many values as possible while minimizing the quantization error.</p><p id="4010" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Performing this calibration step is not equal for all types of parameters.</p><h2 id="c0a2" class="pe nt fq bf nu pf pg ph nx pi pj pk oa mv pl pm pn mz po pp pq nd pr ps pt pu bk">Weights (and Biases)</h2><p id="a8f2" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">We can view the weights and biases of an LLM as <em class="ni">static</em> values since they are known before running the model. For instance, the <a class="af oy" href="https://huggingface.co/meta-llama/Meta-Llama-3-8B/tree/main" rel="noopener ugc nofollow" target="_blank">~20GB file of Llama 3</a> consists mostly of its weight and biases.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/6d0fd23498dde269231c7988ebfdf7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GKp1m0_jrZqlyAPk.png"/></div></div></figure><p id="979b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Since there are significantly fewer biases (millions) than weights (billions), the biases are often kept in higher precision (such as INT16), and the main effort of quantization is put towards the weights.</p><p id="88e4" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">For weights, which are static and known, calibration techniques for choosing the range include:</p><ul class=""><li id="a8fb" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh px py pz bk">Manually choosing a <em class="ni">percentile</em> of the input range</li><li id="f642" class="mm mn fq mo b go qa mq mr gr qb mt mu mv qc mx my mz qd nb nc nd qe nf ng nh px py pz bk">Optimize the <em class="ni">mean squared error</em> (MSE) between the original and quantized weights.</li><li id="152e" class="mm mn fq mo b go qa mq mr gr qb mt mu mv qc mx my mz qd nb nc nd qe nf ng nh px py pz bk">Minimizing <em class="ni">entropy</em> (KL-divergence) between the original and quantized values</li></ul><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qj"><img src="../Images/bb30d435cec911f17d435c4a0ad0f34d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LWf4Q2sGPn2iPHTt.png"/></div></div></figure><p id="6392" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Choosing a percentile, for instance, would lead to similar clipping behavior as we have seen before.</p><h2 id="a838" class="pe nt fq bf nu pf pg ph nx pi pj pk oa mv pl pm pn mz po pp pq nd pr ps pt pu bk">Activations</h2><p id="1adb" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">The input that is continuously updated throughout the LLM is typically referred to as “<em class="ni">activations</em>”.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/62a87756db38fd50c429d4d7118731b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yTWVro2rDl8uGoVv.png"/></div></div></figure><p id="415e" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Note that these values are called activations since they often go through some activation function, like sigmoid or relu.</p><p id="8a63" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Unlike weights, activations vary with each input data fed into the model during inference, making it challenging to quantize them accurately.</p><p id="18bc" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Since these values are updated after each hidden layer, we only know what they will be during inference as the input data passes through the model.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qk"><img src="../Images/c9850f46ac0337b283b8fde060895dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Jwov-YqDrRemGi0M.png"/></div></div></figure><p id="9f84" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Broadly, there are two methods for calibrating the quantization method of the weights and activations:</p><ul class=""><li id="3d82" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh px py pz bk">Post-Training Quantization (PTQ) — Quantization <strong class="mo fr"><em class="ni">after</em></strong> training</li><li id="5d34" class="mm mn fq mo b go qa mq mr gr qb mt mu mv qc mx my mz qd nb nc nd qe nf ng nh px py pz bk">Quantization Aware Training (QAT) — Quantization <strong class="mo fr"><em class="ni">during</em></strong> training/fine-tuning</li></ul><h1 id="4507" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Part 3: Post-Training Quantization</h1><p id="d758" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">One of the most popular quantization techniques is post-training quantization (PTQ). It involves quantizing a model’s parameters (both weights and activations) <strong class="mo fr">after</strong> training the model.</p><p id="0097" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Quantization of the <em class="ni">weights</em> is performed using either symmetric or asymmetric quantization.</p><p id="6de3" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Quantization of the <em class="ni">activations</em>, however, requires inference of the model to get their potential distribution since we do not know their range.</p><p id="8bf4" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">There are two forms of quantization of the activations:</p><ul class=""><li id="c55e" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh px py pz bk"><em class="ni">Dynamic </em>Quantization</li><li id="74a7" class="mm mn fq mo b go qa mq mr gr qb mt mu mv qc mx my mz qd nb nc nd qe nf ng nh px py pz bk"><em class="ni">Static</em> Quantization</li></ul><h1 id="6f74" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Dynamic Quantization</h1><p id="4099" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">After data passes a hidden layer, its activations are collected:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/cb0cbd3a3829bb0cb3d85762e2878201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*y_Pdi9ZAeKoBWgt0.png"/></div></div></figure><p id="9d5f" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This distribution of activations is then used to calculate the <em class="ni">zeropoint</em> (<strong class="mo fr"><em class="ni">z</em></strong>) and <em class="ni">scale factor</em> (<strong class="mo fr">s</strong>) values needed to quantize the output:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/078163c8a7e46c300281f5968f9dba80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rj8hd2AqnK5wyPbL.png"/></div></div></figure><p id="3ebd" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The process is repeated each time data passes through a new layer. Therefore, each layer has its own separate <strong class="mo fr"><em class="ni">z</em></strong> and <strong class="mo fr"><em class="ni">s</em></strong> values and therefore different quantization schemes.</p><h1 id="dfaf" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Static Quantization</h1><p id="a808" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">In contrast to dynamic quantization, static quantization does not calculate the <em class="ni">zeropoint</em> (<strong class="mo fr"><em class="ni">z</em></strong>) and scale factor (<strong class="mo fr"><em class="ni">s</em></strong>) during inference but beforehand.</p><p id="0a49" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">To find those values, a <strong class="mo fr">calibration dataset</strong> is used and given to the model to collect these potential distributions.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk ql"><img src="../Images/7c6fd75060b58d14d8c58f73f5dd107d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vy1gCm4vKALns9bS.png"/></div></div></figure><p id="101b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">After these values have been collected, we can calculate the necessary <strong class="mo fr"><em class="ni">s</em></strong> and <strong class="mo fr"><em class="ni">z</em></strong> values to perform quantization during inference.</p><p id="74b2" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">When you are performing actual inference, the <strong class="mo fr"><em class="ni">s</em></strong> and <strong class="mo fr"><em class="ni">z</em></strong> values are not recalculated but are used globally over all activations to quantize them.</p><p id="7f2a" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In general, dynamic quantization tends to be a bit more accurate since it only attempts to calculate the <strong class="mo fr"><em class="ni">s</em></strong> and <strong class="mo fr"><em class="ni">z</em></strong> values per hidden layer. However, it might increase compute time as these values need to be calculated.</p><p id="5b3d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In contrast, static quantization is less accurate but is faster as it already knows the <strong class="mo fr"><em class="ni">s</em></strong> and <strong class="mo fr"><em class="ni">z</em></strong> values used for quantization.</p><h1 id="0013" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">The Realm of 4-bit Quantization</h1><p id="76db" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">Going below 8-bit quantization has proved to be a difficult task as the quantization error increases with each loss of bit. Fortunately, there are several smart ways to reduce the bits to 6, 4, and even 2-bits (although going lower than 4-bits using these methods is typically not advised).</p><p id="5c70" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We will explore two methods that are commonly shared on HuggingFace:</p><ul class=""><li id="f9e9" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh px py pz bk"><em class="ni">GPTQ — </em>full model on GPU</li><li id="9f10" class="mm mn fq mo b go qa mq mr gr qb mt mu mv qc mx my mz qd nb nc nd qe nf ng nh px py pz bk"><em class="ni">GGUF — </em>potentially offload layers on the CPU</li></ul><h1 id="05e4" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">GPTQ</h1><p id="93f1" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">GPTQ is arguably one of the most well-known methods used in practice for quantization to 4-bits.</p><p id="86c0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">It uses asymmetric quantization and does so layer by layer such that each layer is processed independently before continuing to the next:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qk"><img src="../Images/5d08178bc862bc52c3084fe65bd078e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NTD6lUbocwdKkOMt.png"/></div></div></figure><p id="7dc5" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">During this layer-wise quantization process, it first converts the layer’s weights into the inverse-<strong class="mo fr">Hessian</strong>. It is a second-order derivative of the model’s loss function and tells us how sensitive the model’s output is to changes in each weight.</p><p id="98a3" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Simplified, it essentially demonstrates the (<em class="ni">inverse</em>) <strong class="mo fr">importance of each weight</strong> in a layer.</p><p id="0a86" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Weights associated with smaller values in the Hessian matrix are more crucial because small changes in these weights can lead to significant changes in the model’s performance.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qm"><img src="../Images/4aa81d22bc428d5b5e956e539655bbc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*IdqRqY3TYUdtZ3EH.png"/></div></div></figure><p id="225e" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In the inverse-Hessian, lower values indicate more “important” weights.</p><p id="7167" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Next, we quantize and then dequantize the weight of the first row in our weight matrix:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qn"><img src="../Images/67a39f66598eeecf55587eeea2cc6ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U4H0ax0IgtVlQik6.png"/></div></div></figure><p id="8e0c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This process allows us to calculate the <strong class="mo fr">quantization error (<em class="ni">q</em>)</strong> which we can weigh using the inverse-Hessian (<strong class="mo fr"><em class="ni">h_1</em></strong><em class="ni">)</em> that we calculated beforehand.</p><p id="4b86" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Essentially, we are creating a weighted-quantization error based on the importance of the weight:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qg"><img src="../Images/0dab4e2a5c306d26d24ff12bd188b4e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3asLCqMtrPPKwtzo.png"/></div></div></figure><p id="e589" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Next, we redistribute this weighted quantization error over the other weights in the row. This allows for maintaining the overall function and output of the network.</p><p id="db65" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">For example, if we were to do this for the second weight, namely .3 (<strong class="mo fr"><em class="ni">x_2</em></strong>), we would add the quantization error (<strong class="mo fr"><em class="ni">q</em></strong>) multiplied by the inverse-Hessian of the second weight (<strong class="mo fr"><em class="ni">h</em>_2</strong>)</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qg"><img src="../Images/2771deaf0b7f15ced1e99e6a53828f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jbdFV8y340RbTwNl.png"/></div></div></figure><p id="c8a8" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We can do the same process over the third weight in the given row:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qo"><img src="../Images/c2a779fc041aea05239fe43da6ebbf80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b_lgEseDEgP70Iqu.png"/></div></div></figure><p id="8ee0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">We iterate over this process of redistributing the weighted quantization error until all values are quantized.</p><p id="ee5c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This works so well because weights are typically related to one another. So when one weight has a quantization error, related weights are updated accordingly (through the inverse-Hessian).</p><blockquote class="qp qq qr"><p id="4ff4" class="mm mn ni mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk"><strong class="mo fr"><em class="fq">NOTE</em></strong><em class="fq">: </em><a class="af oy" href="https://arxiv.org/pdf/2210.17323" rel="noopener ugc nofollow" target="_blank"><em class="fq">The authors</em></a><em class="fq"> used several tricks to speed up computation and improve performance, such as adding a dampening factor to the Hessian, “lazy batching”, and precomputing information using the Cholesky method. I would highly advise checking out </em><a class="af oy" href="https://www.youtube.com/watch?v=mii-xFaPCrA" rel="noopener ugc nofollow" target="_blank"><em class="fq">this YouTube video</em></a><em class="fq"> on the subject.</em></p><p id="8deb" class="mm mn ni mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk"><strong class="mo fr"><em class="fq">TIP</em></strong><em class="fq">: Check out </em><a class="af oy" href="https://github.com/turboderp/exllamav2" rel="noopener ugc nofollow" target="_blank"><em class="fq">EXL2</em></a><em class="fq"> if you want a quantization method aimed at performance optimizations and improving inference speed.</em></p></blockquote><h1 id="e203" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">GGUF</h1><p id="4d6f" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">While GPTQ is a great quantization method to run your full LLM on a GPU, you might not always have that capacity. Instead, we can use GGUF to offload any layer of the LLM to the CPU.</p><p id="c10c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This allows you to use both the CPU and GPU when you do not have enough VRAM.</p><p id="70c8" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The quantization method GGUF is updated frequently and might depend on the level of bit quantization. However, the general principle is as follows.</p><p id="541c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">First, the weights of a given layer are split into “super” blocks each containing a set of “sub” blocks. From these blocks, we extract the scale factor (<strong class="mo fr"><em class="ni">s</em></strong>) and alpha (<strong class="mo fr"><em class="ni">α</em></strong>):</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qs"><img src="../Images/b160bf227643b7221cbb561c8335b4cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cl70hiZbHnalLrHU.png"/></div></div></figure><p id="0a62" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">To quantize a given “sub” block, we can use the <em class="ni">absmax</em> quantization we used before. Remember that it multiplies a given weight by the scale factor <strong class="mo fr">(<em class="ni">s</em>)</strong>:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qg"><img src="../Images/90491819aebf3ecd21c99cff26ea881d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZhCmvOjgAMCIh0p9.png"/></div></div></figure><p id="fab9" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The scale factor is calculated using the information from the “sub” block but is quantized using the information from the “super” block which has its own scale factor:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qg"><img src="../Images/674b771ec4778d6014a45f2f9787c3b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-wutOP7NX_fehtVW.png"/></div></div></figure><p id="618e" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This block-wise quantization uses the scale factor (<strong class="mo fr">s_super</strong>) from the “super” block to quantize the scale factor (<strong class="mo fr">s_sub</strong>) from the “sub” block.</p><p id="9e20" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The quantization level of each scale factor might differ with the “super” block generally having a higher precision than the scale factor of the “sub” block.</p><p id="3bb1" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">To illustrate, let’s explore a couple of quantization levels (2-bit, 4-bit, and 6-bit):</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/a715fae8e4bd90416502893d2c72e07a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Jyrmo70UMmxWeGht.png"/></div></div></figure><p id="6f0c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk"><strong class="mo fr">NOTE</strong>: Depending on the quantization type, an additional minimum value (<strong class="mo fr"><em class="ni">m</em></strong>) is needed to adjust the zero-point. These are quantized the same as the scale factor (<strong class="mo fr"><em class="ni">s</em></strong>).</p><p id="545f" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Check out <a class="af oy" href="https://github.com/ggerganov/llama.cpp/pull/1684" rel="noopener ugc nofollow" target="_blank">the original pull request</a> for an overview of all quantization levels. Also, see <a class="af oy" href="https://github.com/ggerganov/llama.cpp/pull/4861" rel="noopener ugc nofollow" target="_blank">this pull request</a> for more information on quantization using importance matrices.</p><h1 id="fcd5" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Part 4: Quantization Aware Training</h1><p id="7150" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">In Part 3, we saw how we could quantize a model <strong class="mo fr"><em class="ni">after</em></strong> training. A downside to this approach is that this quantization does not consider the actual training process.</p><p id="92f5" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This is where Quantization Aware Training (QAT) comes in. Instead of quantizing a model <strong class="mo fr"><em class="ni">after</em></strong> it was trained with post-training quantization (PTQ), QAT aims to learn the quantization procedure <strong class="mo fr"><em class="ni">during</em></strong> training.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk ot"><img src="../Images/ef4186f67e2cec1e59556df15191f2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x3OqozjKDIsvccJ-.png"/></div></div></figure><p id="549a" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">QAT tends to be more accurate than PTQ since the quantization was already considered during training. It works as follows:</p><p id="b8dc" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">During training, so-called “<em class="ni">fake</em>” quants are introduced. This is the process of first quantizing the weights to, for example, INT4 and then dequantizing back to FP32:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk pa"><img src="../Images/f82f9314295ffc5de26231825652cd9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YLH0wcjGKhL8CVzm.png"/></div></div></figure><p id="18e9" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This process allows the model to consider the quantization process during training, the calculation of loss, and weight updates.</p><p id="5ce0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">QAT attempts to explore the loss landscape for “<em class="ni">wide</em>” minima to minimize the quantization errors as “<em class="ni">narrow</em>” minima tend to result in larger quantization errors.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qt"><img src="../Images/c1c351f258b013ba16e3875f3774f018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2L_WiPOp1zmbwQOv.png"/></div></div></figure><p id="3644" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">For example, imagine if we did not consider quantization during the backward pass. We choose the weight with the smallest loss according to gradient descent. However, that would introduce a larger quantization error if it’s in a “<em class="ni">narrow</em>” minima.</p><p id="c6c0" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In contrast, if we consider quantization, a different updated weight will be selected in a “<em class="ni">wide</em>” minima with a much lower quantization error.</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qt"><img src="../Images/c0ec4111a1b509814dcf7c5655f5f389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QM2LlIot-65nLjbF.png"/></div></div></figure><p id="d1ea" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As such, although PTQ has a lower loss in high precision (e.g., FP32), QAT results in a lower loss in lower precision (e.g., INT4) which is what we aim for.</p><h1 id="893a" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">The Era of 1-bit LLMs: BitNet</h1><p id="4aa9" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">Going to 4-bits as we saw before is already quite small but what if we were to reduce it even further?</p><p id="35a6" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">This is where <a class="af oy" href="https://arxiv.org/pdf/2310.11453" rel="noopener ugc nofollow" target="_blank">BitNet</a> comes in, representing the weights of a model single 1-bit, using either <strong class="mo fr">-1</strong> or <strong class="mo fr">1</strong> for a given weight.<a class="af oy" href="https://newsletter.maartengrootendorst.com/p/a-visual-guide-to-quantization#footnote-3-145531349" rel="noopener ugc nofollow" target="_blank">3</a></p><p id="a431" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">It does so by injecting the quantization process directly into the Transformer architecture.</p><p id="cd8a" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Remember that the Transformer architecture is used as the foundation of most LLMs and is composed of computations that involve linear layers:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qu"><img src="../Images/d199e450db63f85fcc96eeae29033c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3XlDE-q0oV6OkbwJ.png"/></div></div></figure><p id="82b7" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">These linear layers are generally represented with higher precision, like FP16, and are where most of the weights reside.</p><p id="2e5c" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">BitNet replaces these linear layers with something they call the <strong class="mo fr">BitLlinear</strong>:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qu"><img src="../Images/6974ee25c63c942d077b49cffa35ae6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TgXYTjb30pWRMzIG.png"/></div></div></figure><p id="d973" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">A BitLinear layer works the same as a regular linear layer and calculates the output based on the weights multiplied by the activation.</p><p id="cd7d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In contrast, a BitLinear layer represents the weights of a model using 1-bit and activations using INT8:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qv"><img src="../Images/c538a9cc49bf74c2fe445107d8d1abd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CvMZHaEPfiWI0r4C.png"/></div></div></figure><p id="23e2" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">A BitLinear layer, like Quantization-Aware Training (QAT) performs a form of “fake” quantization during training to analyze the effect of quantization of the weights and activations:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qw"><img src="../Images/cc856a73580c93e702d90869ded663e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZphuXkuxhFph4IKf.png"/></div></div></figure><p id="6d6d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk"><strong class="mo fr">NOTE</strong>: In the paper they used <strong class="mo fr">γ</strong> instead of <strong class="mo fr">α</strong> but since we used a throughout our examples, I’m using that. Also, note that <strong class="mo fr">β</strong> is not the same as we used in zero-point quantization but the average absolute value.</p><p id="d491" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Let’s go through the BitLinear step-by-step.</p><h1 id="1a65" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Weight Quantization</h1><p id="10e9" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">While training, the weights are stored in INT8 and then quantized to 1-bit using a basic strategy, called the <em class="ni">signum function.</em></p><p id="b6bc" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In essence, it moves the distribution of weights to be centered around 0 and then assigns everything left to 0 to be -1 and everything to the right to be 1:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qx"><img src="../Images/a6b74a8a7fb9c3c83e65a527c64cf43a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MesHo4fAEiadhDhl.png"/></div></div></figure><p id="0ebd" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Additionally, it tracks a value <strong class="mo fr">β (</strong><em class="ni">average</em> absolute value<strong class="mo fr">)</strong> that we will use later on for dequantization.</p><h1 id="fb50" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Activation Quantization</h1><p id="598a" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">To quantize the activations, BitLinear makes use of <em class="ni">absmax quantization</em> to convert the activations from FP16 to INT8 as they need to be in higher precision for the matrix multiplication (×).</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qy"><img src="../Images/4948bc11cddc3b7fd073818748690587.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9O58aIVH2CNKBXSv.png"/></div></div></figure><p id="39ae" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Additionally, it tracks <strong class="mo fr">α (</strong><em class="ni">highest</em> absolute value<strong class="mo fr">)</strong> that we will use later on for dequantization.</p><h1 id="44dd" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Dequantization</h1><p id="423b" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">We tracked <strong class="mo fr">α (</strong><em class="ni">highest absolute value of activations</em><strong class="mo fr">) </strong>and <strong class="mo fr">β (</strong><em class="ni">average absolute value of weights</em><strong class="mo fr">) </strong>as those values will help us dequantize the activations back to FP16.</p><p id="10f4" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">The output activations are rescaled with {<strong class="mo fr">α</strong>, γ} to dequantize them to the original precision:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qw"><img src="../Images/c932398e3fdb6a868f0397ffda3d41ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*erowo5QwcOSRYHUi.png"/></div></div></figure><p id="cabc" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">And that’s it! This procedure is relatively straightforward and allows models to be represented with only two values, either <strong class="mo fr">-1</strong> or <strong class="mo fr">1</strong>.</p><p id="2924" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Using this procedure, the authors observed that as the model size grows, the smaller the performance gap between a 1-bit and FP16-trained becomes.</p><p id="e8c6" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">However, this is only for larger models (&gt;30B parameters) and the gab with smaller models is still quite large.</p><h1 id="dc66" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">All Large Language Models are in 1.58 Bits</h1><p id="ed3a" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk"><a class="af oy" href="https://arxiv.org/pdf/2402.17764" rel="noopener ugc nofollow" target="_blank">BitNet 1.58b</a> was introduced to improve upon the scaling issue previously mentioned.</p><p id="3843" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">In this new method, every single weight of the is not just <strong class="mo fr">-1</strong> or <strong class="mo fr">1</strong>, but can now also take <strong class="mo fr">0</strong> as a value, making it <em class="ni">ternary</em>. Interestingly, adding just the <strong class="mo fr">0</strong> greatly improves upon BitNet and allows for much faster computation.</p><h1 id="d1cc" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">The Power of 0</h1><p id="fdc8" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">So why is adding 0 such a major improvement?</p><p id="0be8" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">It has everything to do with <em class="ni">matrix multiplication</em>!</p><p id="21e4" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">First, let’s explore how matrix multiplication in general works. When calculating the output, we multiply a weight matrix by an input vector. Below, the first multiplication of the first layer of a weight matrix is visualized:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qz"><img src="../Images/3623b0a4d8d71d1b141fa998f1d61d7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9iZN9CKNequBkA82.png"/></div></div></figure><p id="68ed" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Note that this multiplication involves two actions, <strong class="mo fr">multiplying</strong> individual weights with the input and then <strong class="mo fr">adding</strong> them all together.</p><p id="0e9f" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">BitNet 1.58b, in contrast, manages to forego the act of multiplication since ternary weights essentially tell you the following:</p><ul class=""><li id="ed5e" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh px py pz bk"><strong class="mo fr">1 — </strong>I want to add this value</li><li id="40c2" class="mm mn fq mo b go qa mq mr gr qb mt mu mv qc mx my mz qd nb nc nd qe nf ng nh px py pz bk"><strong class="mo fr">0 </strong>— I do not want this value</li><li id="ad64" class="mm mn fq mo b go qa mq mr gr qb mt mu mv qc mx my mz qd nb nc nd qe nf ng nh px py pz bk"><strong class="mo fr">-1 — </strong>I want to subtract this value</li></ul><p id="4363" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As a result, you only need to perform addition if your weights are quantized to 1.58 bit:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk qz"><img src="../Images/ba0776a158064ae21399b74961eefd2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u-RRuP-XGsJgdFnO.png"/></div></div></figure><p id="ad4d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Not only can this speed up computation significantly, but it also allows for <strong class="mo fr">feature filtering</strong>.</p><p id="1619" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">By setting a given weight to 0 you can now ignore it instead of either adding or subtracting the weights as is the case with 1-bit representations.</p><h1 id="c59e" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Quantization</h1><p id="a922" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">To perform weight quantization BitNet 1.58b uses <em class="ni">absmean</em> quantization which is a variation of the absmax quantization that we saw before.</p><p id="9d82" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">It simply compresses the distribution of weights and uses the absolute mean (<strong class="mo fr">α</strong>) to quantize values. They are then rounded to either -1, 0, or 1:</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div role="button" tabindex="0" class="ou ov ed ow bh ox"><div class="nj nk ra"><img src="../Images/051c2bcc456142b4b3600c594232a3eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sF6GJAhBzXnI8-eO.png"/></div></div></figure><p id="2f76" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">Compared to BitNet the activation quantization is the same except for one thing. Instead of scaling the activations to range [<strong class="mo fr">0</strong>, <strong class="mo fr">2ᵇ⁻¹</strong>], they are now scaled to<br/>[<strong class="mo fr">-2ᵇ⁻¹</strong>,<strong class="mo fr"> 2ᵇ⁻¹</strong>] instead using <em class="ni">absmax quantization</em>.</p><p id="2480" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">And that’s it! 1.58-bit quantization required (mostly) two tricks:</p><ul class=""><li id="b743" class="mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh px py pz bk">Adding <strong class="mo fr">0</strong> to create ternary representations [-1, 0, 1]</li><li id="b43e" class="mm mn fq mo b go qa mq mr gr qb mt mu mv qc mx my mz qd nb nc nd qe nf ng nh px py pz bk"><em class="ni">absmean quantization</em> for weights</li></ul><p id="0ffa" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">As a result, we get lightweight models due to having only 1.58 computationally efficient bits!</p><h1 id="fcc1" class="ns nt fq bf nu nv nw gq nx ny nz gt oa ob oc od oe of og oh oi oj ok ol om on bk">Thank You For Reading!</h1><p id="e04b" class="pw-post-body-paragraph mm mn fq mo b go oo mq mr gr op mt mu mv oq mx my mz or nb nc nd os nf ng nh fj bk">This concludes our journey in quantization! Hopefully, this post gives you a better understanding of the potential of quantization, GPTQ, GGUF, and BitNet. Who knows how small the models will be in the future?!</p><p id="d433" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">To see more visualizations related to LLMs and to support this newsletter, check out the book I’m writing with Jay Alammar. It will be released soon!</p><figure class="nl nm nn no np nq nj nk paragraph-image"><div class="nj nk rb"><img src="../Images/ca223b3b0991f513aacab1f56a18c8e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*lP5RaXj__ZgOMzkA.jpeg"/></div></figure><p id="ba2b" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">You can view the book with a free trial on the <a class="af oy" href="https://www.oreilly.com/library/view/hands-on-large-language/9781098150952/" rel="noopener ugc nofollow" target="_blank">O’Reilly website</a> or pre-order the book on <a class="af oy" href="https://www.amazon.com/Hands-Large-Language-Models-Understanding/dp/1098150961" rel="noopener ugc nofollow" target="_blank">Amazon</a>. All code will be uploaded to <a class="af oy" href="https://github.com/HandsOnLLM/Hands-On-Large-Language-Models" rel="noopener ugc nofollow" target="_blank">Github</a>.</p><p id="208d" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk">If you are, like me, passionate about <em class="ni">AI </em>and/or <em class="ni">Psychology</em>, please feel free to add me on <a class="af oy" href="https://www.linkedin.com/in/mgrootendorst/" rel="noopener ugc nofollow" target="_blank"><strong class="mo fr">LinkedIn</strong></a><strong class="mo fr"> </strong>and <a class="af oy" href="https://twitter.com/MaartenGr" rel="noopener ugc nofollow" target="_blank"><strong class="mo fr">Twitter</strong></a>, or subscribe to my <a class="af oy" href="http://maartengrootendorst.substack.com/" rel="noopener ugc nofollow" target="_blank"><strong class="mo fr">Newsletter</strong></a>. You can also find some of my content on my <a class="af oy" href="https://maartengrootendorst.com/" rel="noopener ugc nofollow" target="_blank"><strong class="mo fr">Personal Website</strong></a><strong class="mo fr">.</strong></p><div class="rc rd re rf rg rh"><a href="https://newsletter.maartengrootendorst.com/?source=post_page-----930ebcd9be94--------------------------------" rel="noopener  ugc nofollow" target="_blank"><div class="ri ab ij"><div class="rj ab co cb rk rl"><h2 class="bf fr hw z ir rm it iu rn iw iy fp bk">Exploring Language Models | Maarten Grootendorst | Substack</h2><div class="ro l"><h3 class="bf b hw z ir rm it iu rn iw iy dx">ML Engineer writing about the intersection of AI, Language Models, and Psychology. Open Source Developer (BERTopic…</h3></div><div class="rp l"><p class="bf b dy z ir rm it iu rn iw iy dx">newsletter.maartengrootendorst.com</p></div></div><div class="rq l"><div class="rr l rs rt ru rq rv lu rh"/></div></div></a></div><p id="349e" class="pw-post-body-paragraph mm mn fq mo b go mp mq mr gr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh fj bk"><em class="ni">All images without a source credit were created by the author — Which means all of them (except for one!), I like creating my own images ;)</em></p></div></div></div></div>    
</body>
</html>
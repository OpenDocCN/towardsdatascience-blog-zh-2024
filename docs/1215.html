<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Bird by Bird Using Finite Automata</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Bird by Bird Using Finite Automata</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/bird-by-bird-using-finite-automata-6a822af54455?source=collection_archive---------8-----------------------#2024-05-14">https://towardsdatascience.com/bird-by-bird-using-finite-automata-6a822af54455?source=collection_archive---------8-----------------------#2024-05-14</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="63d9" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Finite-state machine modelling and simulation for real-world AI systems on object detection using Python</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://slipnitskaya.medium.com/?source=post_page---byline--6a822af54455--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Sofya Lipnitskaya" class="l ep by dd de cx" src="../Images/9ea0dd0af32232eb4c8db0cb96f66449.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/da:true/resize:fill:88:88/0*oHbEuNgH0O5mLHBF"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--6a822af54455--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://slipnitskaya.medium.com/?source=post_page---byline--6a822af54455--------------------------------" rel="noopener follow">Sofya Lipnitskaya</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--6a822af54455--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">17 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">May 14, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj la lb ab q ee lc ld" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="le"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lf k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lg an ao ap id lh li lj" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lk cn"><div class="l ae"><div class="ab cb"><div class="ll lm ln lo lp lq ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj mk"><img src="../Images/c81c58a8ab45f4b63344efe5ae0663f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cH-O66Lv8Pw3_IRA"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Image by author</figcaption></figure><h1 id="9aef" class="nb nc fq bf nd ne nf gq ng nh ni gt nj nk nl nm nn no np nq nr ns nt nu nv nw bk"><strong class="al">Background</strong></h1><p id="37ad" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk"><em class="ot">“When life gives you chickens, let AI handle the fowl play.” — Unknown Engineer.</em></p><p id="49d2" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Why on earth do we need simulations? What is the advantage we can get by sampling something and getting an average? But that is never only this. Real life is usually far more complex compared to simplistic tasks we encounter in computer science classes. Sometimes we can’t find an analytical solution, we can’t find population parameters. Sometimes we have to build a model to reflect specifics of the system’s dynamics, we have to run simulations to study the underlying processes so as to gain a better understanding of real-world situations. Simulation modelling provides an invaluable tool for systems design and engineering across a range of industries and applications. It helps to analyse system performance, identify potential bottlenecks and inefficiencies, thus allowing for iterative refinements and improvements.</p><p id="e98d" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Speaking about our very special challenge, here, we are going to create an FSM simulation replicating the behavior of an AI-assisted security system for lawn monitoring and cleaning. In particular, we will tackle the task of simulating processes to intelligently manage the coming and going of birds through object detection and water sprinkling subsystems. In the <a class="af oz" rel="noopener" target="_blank" href="/bird-by-bird-using-finite-automata-9d50b36bcbd3">previous article</a>, you had been introduced to the theory and design principles on finite state machines (FSM) for dealing with the infamous Chicken-and-Turkey (CaT) problem, resulting in the creation of a model that describes complex lawn scenarios at a high level of abstraction. Through this article, we will further investigate the topic of practical aspects of an FSM-based simulation for leveraging the real-life system operation. In addition, we are going to implement the FSM simulation in Python so that we can later improve it via optimization and XAI techniques. By the end of the tutorial, you’ll have a fully functional FSM solution along with a better understanding of simulation modelling for solving engineering problems.</p><p id="66e6" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk"><strong class="nz fr"><em class="ot">Disclaimer:</em></strong><em class="ot"> This work is a part of the “</em><a class="af oz" rel="noopener" target="_blank" href="/bird-by-bird-using-deep-learning-4c0fa81365d7"><em class="ot">Bird by Bird using Deep Learning</em></a><em class="ot">” series and is devoted to modelling and simulation of real-life systems for computer vision applications using finite automata. All actors, states, events and outputs are the products of the FSM design process for educational purposes only. Any resemblance to actual persons, birds, or real events is purely coincidental.</em></p></div></div></div><div class="ab cb pa pb pc pd" role="separator"><span class="pe by bm pf pg ph"/><span class="pe by bm pf pg ph"/><span class="pe by bm pf pg"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="495f" class="nb nc fq bf nd ne pi gq ng nh pj gt nj nk pk nm nn no pl nq nr ns pm nu nv nw bk">Finite automata for system modelling</h1><p id="7e27" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk"><em class="ot">“When asked about systems design sans abstractions, just describe if-then loops for real-life scenarios, making sure to stutter while juggling multiple conditions. Then, gracefully retreat, leaving these trivialities behind.” — Unknown Engineer.</em></p><h2 id="67ab" class="pn nc fq bf nd po pp pq ng pr ps pt nj og pu pv pw ok px py pz oo qa qb qc qd bk">Bringing the theory alive</h2><p id="5291" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">Simulation, a special case of mathematical modelling, involves creating simplified representations of real-world systems to understand their behavior under various conditions. At its core, a model is to capture intrinsic patterns of a real-life system through equations, while simulation relates to the algorithmic approximation of these equations by running a program. This process enables generation of simulation results, facilitating comparison with theoretical assumptions and driving improvements in the actual system. Simulation modelling allows to provide insights on the system behavior and predict outcomes when it’s too expensive and/or challenging to run real experiments. It can be especially useful when an analytical solution is not feasible (e.g., warehouse management processes).</p><p id="8a8e" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">When dealing with the CaT-problem, the objective is clear: we want to maintain a pristine lawn and save resources. Rather than relying on traditional experimentation, we opt for a simulation-based approach to find a setup that allows us to minimize water usage and bills. To achieve this, we will develop an FSM-based model that reflects the key system processes, including bird intrusion, bird detection, and water sprinkling. Throughout the simulation, we will then assess the system performance to guide further optimization efforts towards improved efficiency on bird detection.</p><h2 id="5c75" class="pn nc fq bf nd po pp pq ng pr ps pt nj og pu pv pw ok px py pz oo qa qb qc qd bk">Why not if-else instructions</h2><p id="ed96" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">Using if-else conditional branching for system modelling is a naïve solution that will ultimately lead to increased complexity and error-proneness by design, making further development and maintenance more difficult. Below you find how to (not) describe a simple chicken-on-the-lawn system, considering an example of the FSM we discussed earlier (see <a class="af oz" rel="noopener" target="_blank" href="/bird-by-bird-using-finite-automata-9d50b36bcbd3">Figure 1</a> for FSM state transition diagram with simplified CaT- system scenarios).</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="6d14" class="qi nc fq qf b bg qj qk l ql qm"># import functions with input events and actions<br/>from events import (<br/>   simulate_chicken_intrusion,<br/>   initiate_shooing_chicken,<br/>)<br/>from actions import (<br/>  spoil_the_lawn,<br/>  start_lawn_cleaning,<br/>  one_more_juice<br/>)<br/><br/># define states<br/>START = 0<br/>CHICKEN_PRESENT = 1<br/>NO_CHICKEN = 2<br/>LAWN_SPOILING = 3<br/>ENGINER_REST = 4<br/>END = 5<br/><br/># initialise simulation step and duration<br/>sim_step = 0<br/>max_sim_steps = 8<br/><br/># initialise states<br/>prev_state = None<br/>current_state = START<br/><br/># monitor for events<br/>while current_state != END:<br/>   # update state transitions<br/>   if current_state == START:<br/>       current_state = NO_CHICKEN<br/>       prev_state = START<br/>   elif current_state == NO_CHICKEN:<br/>       if prev_state == CHICKEN_PRESENT:<br/>           start_lawn_cleaning()<br/>       if simulate_chicken_intrusion():<br/>           current_state = CHICKEN_PRESENT<br/>       else:<br/>           current_state = ENGINER_REST<br/>       prev_state = NO_CHICKEN<br/>   elif current_state == CHICKEN_PRESENT:<br/>       if initiate_shooing_chicken():<br/>           current_state = NO_CHICKEN<br/>       else:<br/>           current_state = LAWN_SPOILING<br/>       prev_state = CHICKEN_PRESENT<br/>   elif current_state == LAWN_SPOILING:<br/>       spoil_the_lawn()<br/>       current_state = CHICKEN_PRESENT<br/>       prev_state = LAWN_SPOILING<br/>   elif current_state == ENGINER_REST:<br/>       one_more_juice()<br/>       current_state = NO_CHICKEN<br/>       prev_state = ENGINER_REST<br/><br/>   sim_step += 1<br/>   if sim_step &gt;= max_sim_steps:<br/>       current_state = END</span></pre><p id="0e1a" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">In this code snippet, we define constants to represent each state of the FSM (e.g., CHICKEN_PRESENT). Then, we initialize the current state to START and continuously monitor for events within a while loop, simulating the behavior of the simplified system. Based on the current state and associated events, we use if-else conditional branching instructions to switch between states and invoke corresponding actions. A state transition can have side effects, such as initiating the process of the lawn spoiling for chickens and starting the lawn cleaning for the engineer. Here, functionality related to input events and actions indicates processes that can be automated, so we mock importing the associated functions for simplicity. Note, that whilst chickens can spoil a lawn nearly endlessly, excessive quantities of juice are fraught with the risk of hyperhydration. Be careful with this and don’t forget to add constraints on the duration of your simulation. In our case, this will be the end of the day, as defined by the `max_sim_steps` variable. Looks ugly, right?</p><p id="6e94" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">This should work, but imagine how much time it would take to update if-else instructions if we wanted to extend the logic, repeating the same branching and switching between states over and over. As you can imagine, as the number of states and events increases, the size of the system state space grows rapidly. Unlike if-else branching, FSMs are really good at handling complex tasks, allowing complex systems to be decomposed into manageable states and transitions, hence enhancing code modularity and scalability. Here, we are about to embark on a journey in implementing the system behavior using finite automata to reduce water usage for AI-system operation without compromising accuracy on bird detection.</p><h1 id="e058" class="nb nc fq bf nd ne nf gq ng nh ni gt nj nk nl nm nn no np nq nr ns nt nu nv nw bk">FSM implementation in Python</h1><p id="f558" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk"><em class="ot">“Ok, kiddo, we are about to create a chicken now.” — Unknown Engineer.</em></p><h2 id="332f" class="pn nc fq bf nd po pp pq ng pr ps pt nj og pu pv pw ok px py pz oo qa qb qc qd bk">FSM all the way down</h2><p id="6d5b" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">In this section, we delve into the design choices underlying FSM implementation, elucidating strategies to streamline the simulation process and maximize its utility in real-world system optimization. To build the simulation, we first need to create a model representing the system based on our assumptions about the underlying processes. One way to do this is to start with encapsulating functionally for individual states and transitions. Then we can combine them to create a sequence of events by replicating a real system behavior. We also want to track output statistics for each simulation run to provide an idea of its performance. What we want to do is watch how the system evolves over time given variation in conditions (e.g., stochastic processes of birds spawning and spoiling the lawn given a probability). For this, let’s start with defining and arranging building blocks we are going to implement later on. Here is the plan:</p><ol class=""><li id="805a" class="nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os qn qo qp bk">Define class contracts.</li><li id="3d3b" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qn qo qp bk">Build class hierarchy for targets, describe individual targets.</li><li id="b8bd" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qn qo qp bk">Implement transition logic between states.</li><li id="5779" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qn qo qp bk">Implement a single simulation step along with the full run.</li><li id="da79" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qn qo qp bk">Track output statistics of the simulation run.</li></ol><h2 id="3589" class="pn nc fq bf nd po pp pq ng pr ps pt nj og pu pv pw ok px py pz oo qa qb qc qd bk">Let’s talk abstract</h2><p id="66ca" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">First, we need to create a class hierarchy for our simulation, spanning from base classes for states to a more domain specific yard simulation subclass. We will use `@abc.abstractmethod` and `@property` decorators to mark abstract methods and properties, respectively. In the AbstractSimulation class, we will define `step()` and `run()` abstract methods to make sure that child classes implement them.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="0a98" class="qi nc fq qf b bg qj qk l ql qm">class AbstractSimulation(abc.ABC):<br/>   @abc.abstractmethod<br/>   def step(self) -&gt; Tuple[int, List['AbstractState']]:<br/>       pass<br/><br/>   @abc.abstractmethod<br/>   def run(self) -&gt; Iterator[Tuple[int, List['AbstractState']]]:<br/>       pass</span></pre><p id="0ef3" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Similar applies to AbstractState, which defines an abstract method `transit()` to be implemented by subclasses:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="f7b4" class="qi nc fq qf b bg qj qk l ql qm">class AbstractState(abc.ABC):<br/>   def __init__(self, state_machine: AbstractSimulation):<br/>       super().__init__()<br/>       self.state_machine = state_machine<br/><br/>   def __eq__(self, other):<br/>       return self.__class__ is other.__class__<br/><br/>   @abc.abstractmethod<br/>   def transit(self) -&gt; 'AbstractState':<br/>       pass</span></pre><p id="d92a" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">For our FSM, more specific aspects of the system simulation will be encapsulated in the AbstractYardSimulation class, which inherits from AbstractSimulation. As you can see in its name, AbstractYardSimulation outlines the domain of simulation more precisely, so we can define some extra methods and properties that are specific to the yard simulation in the context of the CaT problem, including `simulate_intrusion()`, `simulate_detection()`, `simulate_sprinkling()`, `simulate_spoiling()`.</p><p id="4a3c" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">We will also create an intermediate abstract class named AbstractYardState to enforce typing consistency in the hierarchy of classes:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="949b" class="qi nc fq qf b bg qj qk l ql qm">class AbstractYardState(AbstractState, abc.ABC):<br/>   state_machine: AbstractYardSimulation</span></pre><p id="daea" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Now, let’s take a look at the inheritance tree reflecting an entity named Target and its descendants.</p><h2 id="ffd8" class="pn nc fq bf nd po pp pq ng pr ps pt nj og pu pv pw ok px py pz oo qa qb qc qd bk">Chicken and Turkey creation</h2><p id="b161" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">Target behavior is a cornerstone of our simulation, as it affects all the aspects towards building an effective model along with its optimization downstream. Figure 1 shows a class diagram for the target classes we are going to implement.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj qv"><img src="../Images/84fac7433b526cba359328705f488ccb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b6ysgRZc-29-37zx"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Figure 1. Class hierarchy for the target classes (Image by author)</figcaption></figure><p id="cf8c" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">For our system, it’s important to note that a target appears with a certain frequency, it may cause some damage to the lawn, and it also has a health property. The latter is related to the size of the target, which may differ, thus a water gun can aim for either smaller or larger targets (which, in turn, affects the water consumption). Consequently, a large target has a lot of health points, so a small water stream will not be able to effectively manage it.</p><p id="9ce9" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">To model targets trespassing the lawn with different frequencies we also create the associated property. Here we go:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="97d1" class="qi nc fq qf b bg qj qk l ql qm">class AbstractTarget(int, abc.ABC):<br/>   @property<br/>   @abc.abstractmethod<br/>   def health(self) -&gt; float:<br/>       pass<br/><br/>   @property<br/>   @abc.abstractmethod<br/>   def damage(self) -&gt; float:<br/>       pass<br/><br/>   @property<br/>   @abc.abstractmethod<br/>   def frequency(self) -&gt; float:<br/>       pass</span></pre><p id="ed0f" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Note that in our implementation we want the target objects to be valid integers, which will be of use for modelling randomness in the simulation.</p><p id="f595" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Next, we create child classes to implement different kinds of targets. Below is the code of the class Chicken, where we override abstract methods inherited from the parent:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="1937" class="qi nc fq qf b bg qj qk l ql qm">class Chicken(AbstractTarget):<br/>   @property<br/>   def health(self) -&gt; float:<br/>       return 4<br/><br/>   @property<br/>   def damage(self) -&gt; float:<br/>       return 10<br/><br/>   @property<br/>   def frequency(self) -&gt; float:<br/>       return 9</span></pre><p id="d418" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">We repeat the similar procedure for remaining Turkey and Empty classes. In the case of Turkey, health and damage parameters will be set to 7 and 17, respectively (let’s see how we can handle these bulky ones with our AI-assisted system). Empty is a special type of Target that refers to the absence of either bird species on the lawn. Although we can’t assign to its health and damage properties other values than 0, an unconditional (i.e. not caused by the engineer) birdlessness on the lawn has a non-zero probability reflected by the frequency value of 9.</p><h2 id="b929" class="pn nc fq bf nd po pp pq ng pr ps pt nj og pu pv pw ok px py pz oo qa qb qc qd bk">From Intrusion to Enemy Spotted with ease</h2><p id="0d9e" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">Now imagine a bird in its natural habitat. It can exhibit a wide variety of agonistic behaviors and displays. In the face of challenge, animals may employ a set of adaptive strategies depending on the circumstances, including fight, or flight responses and other intermediate actions. Following up on the previous article on the FSM design and modelling, you may remember that we already described the key components of the CaT system, which we will use for the actual implementation (see <a class="af oz" rel="noopener" target="_blank" href="/bird-by-bird-using-finite-automata-9d50b36bcbd3">Table 2</a> for FSM inputs describing the events triggering state changes).</p><p id="54ce" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">In the realm of the FSM simulation, a bird can be viewed as an independent actor triggering a set of events: trespassing the yard, spoiling the grass, and so on. In particular, we expect the following sequential patterns in case of an optimistic scenario (success in bird detection and identification, defense actions): a bird invades the yard before possibly being recognized by the CV-based bird detector in order to move ahead with water sprinkling module, those configuration is dependent on the invader class predicted upstream. This way, the bird can be chased away successfully (hit) or not (miss). For this scenario (success in bird detection, class prediction, defense actions), the bird, eventually, escapes from the lawn. Mission complete. Tadaa!</p><p id="5313" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">You may remember that the FSM can be represented graphically as a state transition diagram, which we covered in the previous tutorial (see <a class="af oz" rel="noopener" target="_blank" href="/bird-by-bird-using-finite-automata-9d50b36bcbd3">Table 3</a> for FSM state transition table with next-stage transition logic). Considering that, now we will create subclasses of AbstractYardState and override the `transit()` method to specify transitions between states based on the current state and events.</p><p id="11fb" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Start is the initial state from which the state machine transits to Spawn.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="b5fc" class="qi nc fq qf b bg qj qk l ql qm">class Start(AbstractYardState):<br/>   def transit(self) -&gt; 'Spawn':<br/>       return Spawn(self.state_machine)</span></pre><p id="7d1d" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">From Spawn, the system can transit to one of the following states: Intrusion, Empty, or End.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="762a" class="qi nc fq qf b bg qj qk l ql qm">class Spawn(AbstractYardState):<br/>   def transit(self) -&gt; Union['Intrusion', 'Empty', 'End']:<br/>       self.state_machine.stayed_steps += 1<br/><br/>       self.state_machine.simulate_intrusion()<br/><br/>       next_state: Union['Intrusion', 'Empty', 'End']<br/>       if self.state_machine.max_steps_reached:<br/>           next_state = End(self.state_machine)<br/>       elif self.state_machine.bird_present:<br/>           next_state = Intrusion(self.state_machine)<br/>       else:<br/>           next_state = Empty(self.state_machine)<br/><br/>       return next_state</span></pre><p id="7570" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Transition to the End state happens if we reach the limit on the number of simulation time steps. The state machine switches to Intrusion if a bird invades or is already present on the lawn, while Empty is the next state otherwise.</p><p id="0bfe" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Both Intrusion and Empty states are followed by a detection attempt, so they share a transition logic. Thus, we can reduce code duplication by creating a parent class, namely IntrusionStatus, to encapsulate this logic, while aiming the subclasses at making the actual states of the simulation Intrusion and Empty distinguishable at the type level.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="2f6e" class="qi nc fq qf b bg qj qk l ql qm">class IntrusionStatus(AbstractYardState):<br/>   intruder_class: Target<br/><br/>   def transit(self) -&gt; Union['Detected', 'NotDetected']:<br/>       self.state_machine.simulate_detection()<br/>       self.intruder_class = self.state_machine.intruder_class<br/><br/>       next_state: Union['Detected', 'NotDetected']<br/>       if self.state_machine.predicted_bird:<br/>           next_state = Detected(self.state_machine)<br/>       else:<br/>           next_state = NotDetected(self.state_machine)<br/><br/>       return next_state</span></pre><p id="9643" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">We apply a similar approach to the Detected and NotDetected classes, those superclass DetectionStatus handles target prediction.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="af9a" class="qi nc fq qf b bg qj qk l ql qm">class DetectionStatus(AbstractYardState):<br/>   detected_class: Target<br/><br/>   def transit(self) -&gt; 'DetectionStatus':<br/>       self.detected_class = self.state_machine.detected_class<br/><br/>       return self</span></pre><p id="f994" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">However, in contrast to the Intrusion/Empty pair, the NotDetected class introduces an extra transition logic steering the simulation flow with respect to the lawn contamination/spoiling.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="4004" class="qi nc fq qf b bg qj qk l ql qm">class Detected(DetectionStatus):<br/>   def transit(self) -&gt; 'Sprinkling':<br/>       super().transit()<br/><br/>       return Sprinkling(self.state_machine)<br/><br/><br/>class NotDetected(DetectionStatus):<br/>   def transit(self) -&gt; Union['Attacking', 'NotAttacked']:<br/>       super().transit()<br/><br/>       next_state: Union['Attacking', 'NotAttacked']<br/>       if self.state_machine.bird_present:<br/>           next_state = Attacking(self.state_machine)<br/>       else:<br/>           next_state = NotAttacked(self.state_machine)<br/><br/>       return next_state</span></pre><p id="d1c3" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">The Detected class performs an unconditional transition to Sprinkling. For its antagonist, there are two possible next states, depending on whether a bird is actually on the lawn. If the bird is not there, no poops are anticipated for obvious reasons, while there may potentially be some grass cleaning needed otherwise (or not, the CaT universe is full of randomness).</p><p id="c385" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Getting back to Sprinkling, it has two possible outcomes (Hit or Miss), depending on whether the system was successful in chasing the bird away (this time, at least).</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="dcc3" class="qi nc fq qf b bg qj qk l ql qm">class Sprinkling(AbstractYardState):<br/>   def transit(self) -&gt; Union['Hit', 'Miss']:<br/>       self.state_machine.simulate_sprinkling()<br/><br/>       next_state: Union['Hit', 'Miss']<br/>       if self.state_machine.hit_successfully:<br/>           next_state = Hit(self.state_machine)<br/>       else:<br/>           next_state = Miss(self.state_machine)<br/><br/>       return next_state</span></pre><p id="15d9" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Note: The Hit state does not bring a dedicated transition logic and is included to follow semantics of the domain of wing-aided attacking on the grass. Omitting it will cause the Shooting state transition to Leaving directly.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="495d" class="qi nc fq qf b bg qj qk l ql qm">class Hit(AbstractYardState):<br/>   def transit(self) -&gt; 'Leaving':<br/>       return Leaving(self.state_machine)</span></pre><p id="3618" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">If the water sprinkler was activated and there was no bird on the lawn (detector mis-predicted the bird), the state machine will return to Spawn. In case the bird was actually present and we missed it, there’s a possibility of bird spoils on the grass.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="b202" class="qi nc fq qf b bg qj qk l ql qm">class Miss(AbstractYardState):<br/>   def transit(self) -&gt; Union['Attacking', 'Spawn']:<br/>       next_state: Union['Attacking', 'Spawn']<br/>       if self.state_machine.bird_present:<br/>           next_state = Attacking(self.state_machine)<br/>       else:<br/>           next_state = Spawn(self.state_machine)<br/><br/>       return next_state</span></pre><p id="d7d4" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Eventually, the attacking attempt can result in a real damage to the grass, as reflected by the Attacking class and its descendants:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="1a1d" class="qi nc fq qf b bg qj qk l ql qm">class Attacking(AbstractYardState):<br/>   def transit(self) -&gt; Union['Attacked', 'NotAttacked']:<br/>       self.state_machine.simulate_spoiling()<br/><br/>       next_state: Union['Attacked', 'NotAttacked']<br/>       if self.state_machine.spoiled:<br/>           next_state = Attacked(self.state_machine)<br/>       else:<br/>           next_state = NotAttacked(self.state_machine)<br/><br/>       return next_state<br/><br/><br/>class Attacked(AfterAttacking):<br/>   def transit(self) -&gt; Union['Leaving', 'Spawn']:<br/>       return super().transit()<br/><br/><br/>class NotAttacked(AfterAttacking):<br/>   def transit(self) -&gt; Union['Leaving', 'Spawn']:<br/>       return super().transit()</span></pre><p id="1715" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">We can employ the same idea as for the Intrusion status and encapsulate the shared transition logic into a superclass AfterAttacking, resulting in either Leaving or returning to the Spawn state:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="9758" class="qi nc fq qf b bg qj qk l ql qm">class AfterAttacking(AbstractYardState):<br/>   def transit(self) -&gt; Union['Leaving', 'Spawn']:<br/>       next_state: Union['Leaving', 'Spawn']<br/>       if self.state_machine.max_stay_reached:<br/>           next_state = Leaving(self.state_machine)<br/>       else:<br/>           next_state = Spawn(self.state_machine)<br/><br/>       return next_state</span></pre><p id="0145" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">What happens next? When the simulation reaches the limit of steps, it stucks in the End state:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="7d2f" class="qi nc fq qf b bg qj qk l ql qm">class End(AbstractYardState):<br/>   def transit(self) -&gt; 'End':<br/>       return self</span></pre><p id="4d63" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">In practice, we don’t want the program to execute endlessly. So, subsequently, once the simulation detects a transition into the End state, it shuts down.</p><h1 id="5786" class="nb nc fq bf nd ne nf gq ng nh ni gt nj nk nl nm nn no np nq nr ns nt nu nv nw bk">Simulating the CaT-system</h1><p id="4a28" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk"><em class="ot">“In the subtle world of bird detection, remember: while a model says “no chickens detected,” a sneaky bird may well be on the lawn unnoticed. This discrepancy stands as a call to refine and enhance our AI systems.” — Unknown Engineer.</em></p><p id="30c3" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Now, we’d like to simulate a process of birds trespassing the lawn, spoiling it and leaving. To do so, we will turn to a kind of simulation modelling called discrete-event simulation. We will reproduce the system behavior by analyzing the most significant relationships between its elements and developing a simulation based on finite automata mechanics. For this, we have to consider the following aspects:</p><ol class=""><li id="f704" class="nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os qn qo qp bk">Birds can trespass in the backyard of the property.</li><li id="7ddf" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qn qo qp bk">CV-based system attempts to detect and classify the intruding object.</li><li id="9eab" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qn qo qp bk">Based on the above, in case the object was identified as a particular bird variety, we model the water sprinkling process to drive it away.</li><li id="d96c" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qn qo qp bk">It should be mentioned that there is also a probabilistic process that results in a bird spoiling the lawn (again, nothing personal, feathery).</li></ol><h2 id="8f8a" class="pn nc fq bf nd po pp pq ng pr ps pt nj og pu pv pw ok px py pz oo qa qb qc qd bk">Yard simulation processes</h2><p id="55e4" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">Now, it’s time to explore the magic of probability to simulate these processes using the implemented FSM. For that, we need to create a YardSimulation class that encapsulates the simulation logic. As said, the simulation is more than an FSM. The same applies to the correspondences between simulation steps and state machine transitions. That is, the system needs to perform several state transitions to switch to the next time step.</p><p id="c065" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Here, the `step()` method handles transitions from the current to the next state and invokes the FSM’s method `transit()` until the state machine returns into the Spawn state or reaches End.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="f136" class="qi nc fq qf b bg qj qk l ql qm">def step(self) -&gt; Tuple[int, List[AbstractYardState]]:<br/>   self.step_idx += 1<br/><br/>   transitions = list()<br/>   while True:<br/>       next_state = self.current_state.transit()<br/>       transitions.append(next_state)<br/>       self.current_state = next_state<br/><br/>       if self.current_state in (Spawn(self), End(self)):<br/>           break<br/><br/>   return self.step_idx, transitions</span></pre><p id="891c" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">In the `run()` method, we call `step()` in the loop and yield its outputs until the system transits to the End step:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="6568" class="qi nc fq qf b bg qj qk l ql qm">def run(self) -&gt; Iterator[Tuple[int, List[AbstractYardState]]]:<br/>   while self.current_state != End(self):<br/>       yield self.step()</span></pre><p id="af3b" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">The `reset()` method resets the FSM memory after the bird leaves.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="8ba0" class="qi nc fq qf b bg qj qk l ql qm">def reset(self) -&gt; 'YardSimulation':<br/>   self.current_state = Start(self)<br/>   self.intruder_class = Target.EMPTY<br/>   self.detected_class = Target.EMPTY<br/>   self.hit_successfully = False<br/>   self.spoiled = False<br/>   self.stayed_steps = 0<br/><br/>   return self</span></pre><p id="0a1d" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">A bird is leaving when either it’s successfully hit by the water sprinkler or it stays too long on the lawn (e.g., assuming it got bored). The latter is equivalent to having a bird present on the lawn during 5 simulation steps (= minutes). Not that long, who knows, maybe the neighbor's lawn looks more attractive. Let’s implement some essential pieces of our system’s behavior.</p><p id="ac26" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">First, if no bird is present on the lawn (true intruder class), we try to spawn the one.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="4f1f" class="qi nc fq qf b bg qj qk l ql qm">def simulate_intrusion(self) -&gt; Target:<br/>   if not self.bird_present:<br/>       self.intruder_class = self.spawn_target()<br/><br/>   return self.intruder_class</span></pre><p id="32be" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Here, spawning relates to the live creation of the trespassing entity (bird or nothing).</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="9756" class="qi nc fq qf b bg qj qk l ql qm">@property<br/>def bird_present(self) -&gt; bool:<br/>   return self.intruder_class != Target.EMPTY</span></pre><p id="0e94" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Then, the CV-based system — that is described by a class confusion matrix — tries to detect and classify the intruding object. For this process, we simulate a prediction generation, while keeping in mind the actual intruder class (ground truth).</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="a7dc" class="qi nc fq qf b bg qj qk l ql qm">def simulate_detection(self) -&gt; Target:<br/>   self.detected_class = self.get_random_target(self.intruder_class)<br/><br/>   return self.detected_class</span></pre><p id="ba52" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Detector works on every timestep of the simulation, as the simulated system doesn’t know the ground truth (otherwise, why would we need the detector?). If the detector identifies a bird, we try to chase it away with the water sprinkler tuned to a specific water flow rate that depends on the detected target class:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="7cf9" class="qi nc fq qf b bg qj qk l ql qm">def simulate_sprinkling(self) -&gt; bool:<br/>   self.hit_successfully = self.bird_present and (self.rng.uniform() &lt;= self.hit_proba) and self.target_vulnerable<br/><br/>   return self.hit_successfully</span></pre><p id="5b69" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Regardless of the success of the sprinkling, the system consumes water anyway. Hit success criteria includes the following conditions: a bird was present on the lawn (a), water sprinkler hit the bird (b), the shot was adequate/sufficient to treat the bird of a given size (c). Note, that (c) the chicken “shot” won’t treat the turkey, but applies otherwise.</p><p id="7615" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Spoiling part — a bird can potentially mess up with the grass. If this happens, the lawn damage rate increases (obviously).</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="412c" class="qi nc fq qf b bg qj qk l ql qm">def simulate_spoiling(self) -&gt; bool:<br/>   self.spoiled = self.bird_present and (self.rng.uniform() &lt;= self.shit_proba)<br/>   if self.spoiled:<br/>       self.lawn_damage[self.intruder_class] += self.intruder_class.damage<br/><br/>   return self.spoiled</span></pre><p id="83d3" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Now we have all the essentials to simulate a single time step for the CaT problem we are going to handle. Simulation time!</p><h2 id="b4f3" class="pn nc fq bf nd po pp pq ng pr ps pt nj og pu pv pw ok px py pz oo qa qb qc qd bk">Bird on the run</h2><p id="9ba8" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">Now, we are all set to employ our FSM simulation to emulate an AI-assisted lawn security system across different settings. While running a yard simulation, the `YardSimulation.run()` method iterates over a sequence of state transitions until the system reaches the limit of steps. For this, we instantiate a simulation object (a.k.a. state machine), setting the `num_steps` argument that reflects the total amount of the simulation timesteps (let’s say 12 hours or daytime) and `detector_matrix` that relates to the confusion matrix of the CV-based bird detector subsystem trained to predict chickens and turkeys:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="0397" class="qi nc fq qf b bg qj qk l ql qm">sim = YardSimulation(detector_matrix=detector_matrix, num_steps=num_steps)</span></pre><p id="6c6d" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Now we can run the FSM simulation and print state transitions that the FSM undergoes at every timestep:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="b2b2" class="qi nc fq qf b bg qj qk l ql qm">for step_idx, states in sim.run():<br/>   print(f'\t{step_idx:0&gt;3}: {" -&gt; ".join(map(str, states))}')</span></pre><p id="bb4f" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">In addition, we accumulate simulation statistics related to the water usage for bird sprinkling (`simulate_sprinkling`) and grass cleaning after birds arrive (`simulate_spoiling`).</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="1bd6" class="qi nc fq qf b bg qj qk l ql qm">def simulate_sprinkling(self) -&gt; bool:<br/>   ...<br/>   self.water_consumption[self.detected_class] += self.detected_class.health<br/>   ...<br/><br/><br/>def simulate_spoiling(self) -&gt; bool:<br/>   ...<br/>   if self.spoiled:<br/>       self.lawn_damage[self.intruder_class] += self.intruder_class.damage<br/>   ...</span></pre><p id="de56" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">When the simulation reaches its limit, we can then compute the total water consumption by the end of the day for each of the categories. What we would like to see is what happens after each run of the simulation.</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="9cb5" class="qi nc fq qf b bg qj qk l ql qm">water_sprinkling_total = sum(sim.water_consumption.values())<br/>lawn_damage_total = sum(sim.lawn_damage.values())</span></pre><p id="f3ab" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Finally, let’s conduct experiments to assess how the system can perform given changes in the computer vision-based subsystem. To that end, we will run simulations using YardSimulation.run()` method for 100 trials for a non-trained (baseline) and perfect detection matrices:</p><pre class="ml mm mn mo mp qe qf qg bp qh bb bk"><span id="2ad6" class="qi nc fq qf b bg qj qk l ql qm">detector_matrix_baseline = np.full(<br/>     (len(Target),) * 2,  # size of the confusion matrix (3 x 3)<br/>     len(Target) ** -1    # prediction probability for each class is the same and equals to 1/3 <br/>)<br/>detector_matrix_perfect = np.eye(len(Target))</span></pre><p id="567f" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">Thereafter, we can aggregate and compare output statistics related to the total water usage for target sprinkling and lawn cleaning for different experimental settings:</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qw"><img src="../Images/358c0e78bfce985a406f93e3b1888da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/0*MUcaXa8UXTnW4NNw"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Figure 2. FSM simulation output statistics across edge cases of the bird detection subsystem (Image by author)</figcaption></figure><p id="f887" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">A comparison of summary results across experiments reveals that having a better CV model would contribute to increased efficiency in minimizing water usage by 37.8% (70.9 vs. 44.1), compared to the non-trained baseline detector for birds under the given input parameters and simulation conditions — a concept both intuitive and anticipated. But what does “better” mean quantitatively? Is it worth fiddling around with refining the model? The numerical outcomes demonstrate the value of improving the model, motivating further refinement efforts. Going forward, we will use the resulting statistics as an objective for global optimization to improve efficiency of the bird detection subsystem and cut down on water consumption for system operation and maintenance, making the engineer a little happier.</p><p id="9e08" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">The source code used for this tutorial can be found in this GitHub repository: <a class="af oz" href="https://github.com/slipnitskaya/computer-vision-birds" rel="noopener ugc nofollow" target="_blank">https://github.com/slipnitskaya/computer-vision-birds</a>.</p><h1 id="4f47" class="nb nc fq bf nd ne nf gq ng nh ni gt nj nk nl nm nn no np nq nr ns nt nu nv nw bk"><strong class="al">Conclusions</strong></h1><p id="b48a" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">To sum up, simulation modelling is a useful tool that can be used to estimate efficiency of processes, enable rapid testing of anticipated changes, and understand how to improve processes through operation and maintenance. Through this article, you have gained a better understanding on practical applications of simulation modelling for solving engineering problems. In particular, we’ve covered the following:</p><ul class=""><li id="7e9b" class="nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os qx qo qp bk">How to design a model to approximate a complex system to improve its operation on bird detection and water sprinkling.</li><li id="df46" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qx qo qp bk">How to create a simulation of real-world processes to understand the CaT-system behavior under various conditions.</li><li id="94c5" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qx qo qp bk">How to implement an FSM-based solution in Python for the system to track relevant statistics of the simulation.</li></ul><h1 id="2831" class="nb nc fq bf nd ne nf gq ng nh ni gt nj nk nl nm nn no np nq nr ns nt nu nv nw bk">What’s next</h1><p id="6d38" class="pw-post-body-paragraph nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os fj bk">Focusing on improving resource efficiency, in the follow-up articles, you will discover how to address a non-analytic optimization problem of the water cost reduction by applying Monte-Carlo and eXplainable AI (XAI) methods to enhance the computer vision-based bird detection subsystem, thus advancing our simulated AI-assisted lawn security system.</p><p id="db9e" class="pw-post-body-paragraph nx ny fq nz b go ou ob oc gr ov oe of og ow oi oj ok ox om on oo oy oq or os fj bk">What are other important concepts in simulation modelling and optimization for vision projects? Find out more on <a class="af oz" href="https://towardsdatascience.com/tagged/bird-by-bird-tech" rel="noopener" target="_blank">Bird by Bird Tech</a>.</p><h1 id="a11c" class="nb nc fq bf nd ne nf gq ng nh ni gt nj nk nl nm nn no np nq nr ns nt nu nv nw bk">References</h1><ol class=""><li id="11c9" class="nx ny fq nz b go oa ob oc gr od oe of og oh oi oj ok ol om on oo op oq or os qn qo qp bk">Forsyth, David. Probability and statistics for computer science. Vol. 13. Cham: Springer International Publishing, 2018.</li><li id="38d9" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qn qo qp bk">Knuth, Donald Ervin. The art of computer programming. Vol. 3. Reading, MA: Addison-Wesley, 1973.</li><li id="1315" class="nx ny fq nz b go qq ob oc gr qr oe of og qs oi oj ok qt om on oo qu oq or os qn qo qp bk">Wagner, Ferdinand, et al. Modeling software with finite state machines: a practical approach. Auerbach Publications, 2006.</li></ol></div></div></div></div>    
</body>
</html>
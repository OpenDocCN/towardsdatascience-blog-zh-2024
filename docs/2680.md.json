["```py\ndef main():\n    pdf_files = [filename for filename in os.listdir('./data/input/') if filename.endswith('.pdf')]\n\n    for pdf_filename in pdf_files:\n        print('Processing ' + pdf_filename + '...')    \n        # Extract content from PDF using the assistant\n        complete_response = process_pdf('./data/input/' + pdf_filename)\n        # Log the complete response to debug\n        save_json_string_to_file(complete_response, './data/debug/complete_response_' + pdf_filename + '.json') \n```", "```py\ndef process_pdf(pdf_filename):\n    # Create OpenAI message thread\n    thread = client.beta.threads.create()\n    # Upload PDF file to the thread\n    file = client.files.create(file=open(pdf_filename, \"rb\"), purpose=\"assistants\")\n    # Create message with contract as attachment and extraction_prompt\n    client.beta.threads.messages.create(thread_id=thread.id,role=\"user\",\n        attachments=[\n            Attachment(\n                file_id=file.id, tools=[AttachmentToolFileSearch(type=\"file_search\")])\n        ],\n        content=extraction_prompt,\n    )\n    # Run the message thread\n    run = client.beta.threads.runs.create_and_poll(\n        thread_id=thread.id, assistant_id=pdf_assistant.id, timeout=1000)\n    # Retrieve messages\n    messages_cursor = client.beta.threads.messages.list(thread_id=thread.id)\n    messages = [message for message in messages_cursor]\n    # Return last message in Thread \n    return messages[0].content[0].text.value\n```", "```py\n{\n    \"agreement\": {\n        \"agreement_name\": \"Marketing Affiliate Agreement\",\n        \"agreement_type\": \"Marketing Affiliate Agreement\",\n        \"effective_date\": \"May 8, 2014\",\n        \"expiration_date\": \"December 31, 2014\",\n        \"renewal_term\": \"1 year\",\n        \"Notice_period_to_Terminate_Renewal\": \"30 days\",\n        \"parties\": [\n            {\n                \"role\": \"Company\",\n                \"name\": \"Birch First Global Investments Inc.\",\n                \"incorporation_country\": \"United States Virgin Islands\",\n                \"incorporation_state\": \"N/A\"\n            },\n            {\n                \"role\": \"Marketing Affiliate\",\n                \"name\": \"Mount Knowledge Holdings Inc.\",\n                \"incorporation_country\": \"United States\",\n                \"incorporation_state\": \"Nevada\"\n            }\n        ],\n        \"governing_law\": {\n            \"country\": \"United States\",\n            \"state\": \"Nevada\",\n            \"most_favored_country\": \"United States\"\n        },\n        \"clauses\": [\n            {\n                \"clause_type\": \"Competitive Restriction Exception\",\n                \"exists\": false,\n                \"excerpts\": []\n            },\n            {\n                \"clause_type\": \"Exclusivity\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"Company hereby grants to MA the right to advertise, market and sell to corporate users, government agencies and educational facilities for their own internal purposes only, not for remarketing or redistribution.\"\n                ]\n            },\n            {\n                \"clause_type\": \"Non-Disparagement\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"MA agrees to conduct business in a manner that reflects favorably at all times on the Technology sold and the good name, goodwill and reputation of Company.\"\n                ]\n            },\n            {\n                \"clause_type\": \"Termination For Convenience\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"This Agreement may be terminated by either party at the expiration of its term or any renewal term upon thirty (30) days written notice to the other party.\"\n                ]\n            },\n            {\n                \"clause_type\": \"Anti-Assignment\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"MA may not assign, sell, lease or otherwise transfer in whole or in part any of the rights granted pursuant to this Agreement without prior written approval of Company.\"\n                ]\n            },\n\n            {\n                \"clause_type\": \"Price Restrictions\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"Company reserves the right to change its prices and/or fees, from time to time, in its sole and absolute discretion.\"\n                ]\n            },\n            {\n                \"clause_type\": \"Minimum Commitment\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"MA commits to purchase a minimum of 100 Units in aggregate within the Territory within the first six months of term of this Agreement.\"\n                ]\n            },\n\n            {\n                \"clause_type\": \"IP Ownership Assignment\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"Title to the Technology and all copyrights in Technology shall remain with Company and/or its Affiliates.\"\n                ]\n            },\n\n            {\n                \"clause_type\": \"License grant\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"Company hereby grants to MA the right to advertise, market and sell the Technology listed in Schedule A of this Agreement.\"\n                ]\n            },\n            {\n                \"clause_type\": \"Non-Transferable License\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"MA acknowledges that MA and its Clients receive no title to the Technology contained on the Technology.\"\n                ]\n            },\n            {\n                \"clause_type\": \"Cap On Liability\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"In no event shall Company be liable to MA, its Clients, or any third party for any tort or contract damages or indirect, special, general, incidental or consequential damages.\"\n                ]\n            },\n\n            {\n                \"clause_type\": \"Warranty Duration\",\n                \"exists\": true,\n                \"excerpts\": [\n                    \"Company's sole and exclusive liability for the warranty provided shall be to correct the Technology to operate in substantial accordance with its then current specifications.\"\n                ]\n            }\n\n        ]\n    }\n}\n```", "```py\n Node properties:\nAgreement {agreement_type: STRING, contract_id: INTEGER,\n          effective_date: STRING, expiration_date: STRING,\n          renewal_term: STRING, name: STRING}\nContractClause {name: STRING, type: STRING}\nClauseType {name: STRING}\nCountry {name: STRING}\nExcerpt {text: STRING}\nOrganization {name: STRING}\n\nRelationship properties:\nIS_PARTY_TO {role: STRING}\nGOVERNED_BY_LAW {state: STRING}\nHAS_CLAUSE {type: STRING}\nINCORPORATED_IN {state: STRING} \n```", "```py\nNEO4J_URI=os.getenv('NEO4J_URI', 'bolt://localhost:7687')\nNEO4J_USER=os.getenv('NEO4J_USERNAME', 'neo4j')\nNEO4J_PASSWORD=os.getenv('NEO4J_PASSWORD')\nOPENAI_API_KEY = os.getenv('OPENAI_API_KEY')\nJSON_CONTRACT_FOLDER = './data/output/'\n\ndriver = GraphDatabase.driver(NEO4J_URI, auth=(NEO4J_USER, NEO4J_PASSWORD))\n\ncontract_id = 1\n\njson_contracts = [filename for filename in os.listdir(JSON_CONTRACT_FOLDER) if filename.endswith('.json')]\nfor json_contract in json_contracts:\n  with open(JSON_CONTRACT_FOLDER + json_contract,'r') as file:\n    json_string = file.read()\n    json_data = json.loads(json_string)\n    agreement = json_data['agreement']\n    agreement['contract_id'] = contract_id\n    driver.execute_query(CREATE_GRAPH_STATEMENT,  data=json_data)\n    contract_id+=1\n\ncreate_full_text_indices(driver)\ndriver.execute_query(CREATE_VECTOR_INDEX_STATEMENT)\nprint (\"Generating Embeddings for Contract Excerpts...\")\ndriver.execute_query(EMBEDDINGS_STATEMENT, token = OPENAI_API_KEY)\n```", "```py\nCREATE_GRAPH_STATEMENT = \"\"\"\nWITH $data AS data\nWITH data.agreement as a\n\nMERGE (agreement:Agreement {contract_id: a.contract_id})\nON CREATE SET \n  agreement.contract_id  = a.contract_id,\n  agreement.name = a.agreement_name,\n  agreement.effective_date = a.effective_date,\n  agreement.expiration_date = a.expiration_date,\n  agreement.agreement_type = a.agreement_type,\n  agreement.renewal_term = a.renewal_term,\n  agreement.most_favored_country = a.governing_law.most_favored_country\n  //agreement.Notice_period_to_Terminate_Renewal = a.Notice_period_to_Terminate_Renewal\n\nMERGE (gl_country:Country {name: a.governing_law.country})\nMERGE (agreement)-[gbl:GOVERNED_BY_LAW]->(gl_country)\nSET gbl.state = a.governing_law.state\n\nFOREACH (party IN a.parties |\n  // todo proper global id for the party\n  MERGE (p:Organization {name: party.name})\n  MERGE (p)-[ipt:IS_PARTY_TO]->(agreement)\n  SET ipt.role = party.role\n  MERGE (country_of_incorporation:Country {name: party.incorporation_country})\n  MERGE (p)-[incorporated:INCORPORATED_IN]->(country_of_incorporation)\n  SET incorporated.state = party.incorporation_state\n)\n\nWITH a, agreement, [clause IN a.clauses WHERE clause.exists = true] AS valid_clauses\nFOREACH (clause IN valid_clauses |\n  CREATE (cl:ContractClause {type: clause.clause_type})\n  MERGE (agreement)-[clt:HAS_CLAUSE]->(cl)\n  SET clt.type = clause.clause_type\n  // ON CREATE SET c.excerpts = clause.excerpts\n  FOREACH (excerpt IN clause.excerpts |\n    MERGE (cl)-[:HAS_EXCERPT]->(e:Excerpt {text: excerpt})\n  )\n  //link clauses to a Clause Type label\n  MERGE (clType:ClauseType{name: clause.clause_type})\n  MERGE (cl)-[:HAS_TYPE]->(clType)\n)\"\"\"\n```", "```py\nWITH $data AS data\nWITH data.agreement as a\n```", "```py\nMERGE (agreement:Agreement {contract_id: a.contract_id})\nON CREATE SET \n  agreement.name = a.agreement_name,\n  agreement.effective_date = a.effective_date,\n  agreement.expiration_date = a.expiration_date,\n  agreement.agreement_type = a.agreement_type,\n  agreement.renewal_term = a.renewal_term,\n  agreement.most_favored_country = a.governing_law.most_favored_country\n```", "```py\nMERGE (gl_country:Country {name: a.governing_law.country})\nMERGE (agreement)-[gbl:GOVERNED_BY_LAW]->(gl_country)\nSET gbl.state = a.governing_law.state\n```", "```py\nFOREACH (party IN a.parties |\n  MERGE (p:Organization {name: party.name})\n  MERGE (p)-[ipt:IS_PARTY_TO]->(agreement)\n  SET ipt.role = party.role\n  MERGE (country_of_incorporation:Country {name: party.incorporation_country})\n  MERGE (p)-[incorporated:INCORPORATED_IN]->(country_of_incorporation)\n  SET incorporated.state = party.incorporation_state\n)\n```", "```py\nWITH a, agreement, [clause IN a.clauses WHERE clause.exists = true] AS valid_clauses\nFOREACH (clause IN valid_clauses |\n  CREATE (cl:ContractClause {type: clause.clause_type})\n  MERGE (agreement)-[clt:HAS_CLAUSE]->(cl)\n  SET clt.type = clause.clause_type\n  FOREACH (excerpt IN clause.excerpts |\n    MERGE (cl)-[:HAS_EXCERPT]->(e:Excerpt {text: excerpt})\n  )\n  MERGE (clType:ClauseType{name: clause.clause_type})\n  MERGE (cl)-[:HAS_TYPE]->(clType)\n)\n```", "```py\nfrom typing import List, Optional, Annotated\nfrom AgreementSchema import Agreement, ClauseType\nfrom semantic_kernel.functions import kernel_function\nfrom ContractService import  ContractSearchService\n\nclass ContractPlugin:\n    def __init__(self, contract_search_service: ContractSearchService ):\n        self.contract_search_service = contract_search_service\n\n    @kernel_function\n    async def get_contract(self, contract_id: int) -> Annotated[Agreement, \"A contract\"]:\n        \"\"\"Gets details about a contract with the given id.\"\"\"\n        return await self.contract_search_service.get_contract(contract_id)\n\n    @kernel_function\n    async def get_contracts(self, organization_name: str) -> Annotated[List[Agreement], \"A list of contracts\"]:\n        \"\"\"Gets basic details about all contracts where one of the parties has a name similar to the given organization name.\"\"\"\n        return await self.contract_search_service.get_contracts(organization_name)\n\n    @kernel_function\n    async def get_contracts_without_clause(self, clause_type: ClauseType) -> Annotated[List[Agreement], \"A list of contracts\"]:\n        \"\"\"Gets basic details from contracts without a clause of the given type.\"\"\"\n        return await self.contract_search_service.get_contracts_without_clause(clause_type=clause_type)\n\n    @kernel_function\n    async def get_contracts_with_clause_type(self, clause_type: ClauseType) -> Annotated[List[Agreement], \"A list of contracts\"]:\n        \"\"\"Gets basic details from contracts with a clause of the given type.\"\"\"\n        return await self.contract_search_service.get_contracts_with_clause_type(clause_type=clause_type)\n\n    @kernel_function\n    async def get_contracts_similar_text(self, clause_text: str) -> Annotated[List[Agreement], \"A list of contracts with similar text in one of their clauses\"]:\n        \"\"\"Gets basic details from contracts having semantically similar text in one of their clauses to the to the 'clause_text' provided.\"\"\"\n        return await self.contract_search_service.get_contracts_similar_text(clause_text=clause_text)\n\n    @kernel_function\n    async def answer_aggregation_question(self, user_question: str) -> Annotated[str, \"An answer to user_question\"]:\n        \"\"\"Answer obtained by turning user_question into a CYPHER query\"\"\"\n        return await self.contract_search_service.answer_aggregation_question(user_question=user_question)\n```", "```py\nasync def get_contract(self, contract_id: int) -> Agreement:\n\n        GET_CONTRACT_BY_ID_QUERY = \"\"\"\n            MATCH (a:Agreement {contract_id: $contract_id})-[:HAS_CLAUSE]->(clause:ContractClause)\n            WITH a, collect(clause) as clauses\n            MATCH (country:Country)-[i:INCORPORATED_IN]-(p:Organization)-[r:IS_PARTY_TO]-(a)\n            WITH a, clauses, collect(p) as parties, collect(country) as countries, collect(r) as roles, collect(i) as states\n            RETURN a as agreement, clauses, parties, countries, roles, states\n        \"\"\"\n\n        agreement_node = {}\n\n        records, _, _  = self._driver.execute_query(GET_CONTRACT_BY_ID_QUERY,{'contract_id':contract_id})\n\n        if (len(records)==1):\n            agreement_node =    records[0].get('agreement')\n            party_list =        records[0].get('parties')\n            role_list =         records[0].get('roles')\n            country_list =      records[0].get('countries')\n            state_list =        records[0].get('states')\n            clause_list =       records[0].get('clauses')\n\n        return await self._get_agreement(\n            agreement_node, format=\"long\",\n            party_list=party_list, role_list=role_list,\n            country_list=country_list,state_list=state_list,\n            clause_list=clause_list\n        )\n```", "```py\nclass Agreement(TypedDict):  \n    contract_id: int\n    agreement_name: str\n    agreement_type: str\n    effective_date: str\n    expiration_date: str\n    renewal_term: str\n    notice_period_to_terminate_Renewal: str\n    parties: List[Party]\n    clauses: List[ContractClause]\n```", "```py\nasync def get_contracts_without_clause(self, clause_type: ClauseType) -> List[Agreement]:\n        GET_CONTRACT_WITHOUT_CLAUSE_TYPE_QUERY = \"\"\"\n            MATCH (a:Agreement)\n            OPTIONAL MATCH (a)-[:HAS_CLAUSE]->(cc:ContractClause {type: $clause_type})\n            WITH a,cc\n            WHERE cc is NULL\n            WITH a\n            MATCH (country:Country)-[i:INCORPORATED_IN]-(p:Organization)-[r:IS_PARTY_TO]-(a)\n            RETURN a as agreement, collect(p) as parties, collect(r) as roles, collect(country) as countries, collect(i) as states\n        \"\"\"\n\n        #run the Cypher query\n        records, _ , _ = self._driver.execute_query(GET_CONTRACT_WITHOUT_CLAUSE_TYPE_QUERY,{'clause_type':clause_type.value})\n\n        all_agreements = []\n        for row in records:\n            agreement_node =  row['agreement']\n            party_list =  row['parties']\n            role_list =  row['roles']\n            country_list = row['countries']\n            state_list = row['states']\n            agreement : Agreement = await self._get_agreement(\n                format=\"short\",\n                agreement_node=agreement_node,\n                party_list=party_list,\n                role_list=role_list,\n                country_list=country_list,\n                state_list=state_list\n            )\n            all_agreements.append(agreement)\n        return all_agreements\n```", "```py\nasync def get_contracts_similar_text(self, clause_text: str) -> List[Agreement]:\n\n        #Cypher to traverse from the semantically similar excerpts back to the agreement\n        EXCERPT_TO_AGREEMENT_TRAVERSAL_QUERY=\"\"\"\n            MATCH (a:Agreement)-[:HAS_CLAUSE]->(cc:ContractClause)-[:HAS_EXCERPT]-(node) \n            RETURN a.name as agreement_name, a.contract_id as contract_id, cc.type as clause_type, node.text as excerpt\n        \"\"\"\n\n        #Set up vector Cypher retriever\n        retriever = VectorCypherRetriever(\n            driver= self._driver,  \n            index_name=\"excerpt_embedding\",\n            embedder=self._openai_embedder, \n            retrieval_query=EXCERPT_TO_AGREEMENT_TRAVERSAL_QUERY,\n            result_formatter=my_vector_search_excerpt_record_formatter\n        )\n\n        # run vector search query on excerpts and get results containing the relevant agreement and clause \n        retriever_result = retriever.search(query_text=clause_text, top_k=3)\n\n        #set up List of Agreements (with partial data) to be returned\n        agreements = []\n        for item in retriever_result.items:\n            //extract information from returned items and append agreement to results\n            // full code not shown here but available on the Github repo\n\n        return agreements\n```", "```py\nEXCERPT_TO_AGREEMENT_TRAVERSAL_QUERY=\"\"\"\n  MATCH (a:Agreement)-[:HAS_CLAUSE]->(cc:ContractClause)-[:HAS_EXCERPT]-(node) \n  RETURN a.name as agreement_name, a.contract_id as contract_id, cc.type as clause_type, node.text as excerpt\n\"\"\"\n```", "```py\n async def answer_aggregation_question(self, user_question) -> str:\n        answer = \"\"\n\n        NEO4J_SCHEMA = \"\"\"\n            omitted for brevity (see below for the full value)\n        \"\"\"\n\n        # Initialize the retriever\n        retriever = Text2CypherRetriever(\n            driver=self._driver,\n            llm=self._llm,\n            neo4j_schema=NEO4J_SCHEMA\n        )\n\n        # Generate a Cypher query using the LLM, send it to the Neo4j database, and return the results\n        retriever_result = retriever.search(query_text=user_question)\n\n        for item in retriever_result.items:\n            content = str(item.content)\n            if content:\n                answer += content + '\\n\\n'\n\n        return answer\n```", "```py\nNEO4J_SCHEMA = \"\"\"\nNode properties:\nAgreement {agreement_type: STRING, contract_id: INTEGER,effective_date: STRING,renewal_term: STRING, name: STRING}\nContractClause {name: STRING, type: STRING}\nClauseType {name: STRING}\nCountry {name: STRING}\nExcerpt {text: STRING}\nOrganization {name: STRING}\n\nRelationship properties:\nIS_PARTY_TO {role: STRING}\nGOVERNED_BY_LAW {state: STRING}\nHAS_CLAUSE {type: STRING}\nINCORPORATED_IN {state: STRING}\n\nThe relationships:\n(:Agreement)-[:HAS_CLAUSE]->(:ContractClause)\n(:ContractClause)-[:HAS_EXCERPT]->(:Excerpt)\n(:ContractClause)-[:HAS_TYPE]->(:ClauseType)\n(:Agreement)-[:GOVERNED_BY_LAW]->(:Country)\n(:Organization)-[:IS_PARTY_TO]->(:Agreement)\n(:Organization)-[:INCORPORATED_IN]->(:Country)\n  \"\"\"\n```", "```py\nlogging.basicConfig(level=logging.INFO)\n\n# Initialize the kernel\nkernel = Kernel()\n\n# Add the Contract Search plugin to the kernel\ncontract_search_neo4j = ContractSearchService(NEO4J_URI,NEO4J_USER,NEO4J_PASSWORD)\nkernel.add_plugin(ContractPlugin(contract_search_service=contract_search_neo4j),plugin_name=\"contract_search\")\n\n# Add the OpenAI chat completion service to the Kernel\nkernel.add_service(OpenAIChatCompletion(ai_model_id=\"gpt-4o\",api_key=OPENAI_KEY, service_id=service_id))\n\n# Enable automatic function calling\nsettings: OpenAIChatPromptExecutionSettings = kernel.get_prompt_execution_settings_from_service_id(service_id=service_id)\nsettings.function_choice_behavior = FunctionChoiceBehavior.Auto(filters={\"included_plugins\": [\"contract_search\"]})\n\n# Create a history of the conversation\nhistory = ChatHistory()\n\nasync def basic_agent() :\n    userInput = None\n    while True:\n        # Collect user input\n        userInput = input(\"User > \")\n\n        # Terminate the loop if the user says \"exit\"\n        if userInput == \"exit\":\n            break\n\n        # Add user input to the history\n        history.add_user_message(userInput)\n\n        # 3\\. Get the response from the AI with automatic function calling\n        chat_completion : OpenAIChatCompletion = kernel.get_service(type=ChatCompletionClientBase)\n        result = (await chat_completion.get_chat_message_contents(\n            chat_history=history,\n            settings=settings,\n            kernel=kernel,\n            arguments=KernelArguments(),\n        ))[0]\n\n        # Print the results\n        print(\"Assistant > \" + str(result))\n\n        # Add the message from the agent to the chat history\n        history.add_message(result)\n\nif __name__ == \"__main__\":\n    asyncio.run(basic_agent())\n```", "```py\nAssistant > I found the following contract that contains a Price Restrictions clause but does not contain an Insurance clause:\n\n- **Name:** Birch First Global Investments Inc. and Mount Knowledge Holdings Inc. MARKETING AFFILIATE AGREEMENT\n- **Agreement Type:** MARKETING AFFILIATE AGREEMENT\n- **Parties:**\n  - **MOUNT KNOWLEDGE HOLDINGS INC.** (Marketing Affiliate), incorporated in Nevada, USA\n  - **BIRCH FIRST GLOBAL INVESTMENTS INC.** (Company), incorporated in the Virgin Islands (VIR)\n\nWould you like to know more details about this contract?\n```", "```py\nAssistant > Here are the detailed information about the contract:\n\n### Contract Details:\n- **Name:** Birch First Global Investments Inc. and Mount Knowledge Holdings Inc. MARKETING AFFILIATE AGREEMENT\n- **Agreement Type:** MARKETING AFFILIATE AGREEMENT\n- **Expiration Date:** December 31, 2014\n- **Renewal Term:** One (1) year\n\n### Parties Involved:\n1\\. **MOUNT KNOWLEDGE HOLDINGS INC.** \n   - **Role:** Marketing Affiliate\n   - **Incorporation Country:** USA\n   - **Incorporation State:** Nevada\n2\\. **BIRCH FIRST GLOBAL INVESTMENTS INC.**\n   - **Role:** Company\n   - **Incorporation Country:** Virgin Islands (VIR)\n\n### Clauses Included:\n- No-Solicit Of Employees\n- Third Party Beneficiary\n- Price Restrictions\n- Affiliate License-Licensee\n- Affiliate License-Licensor\n- Cap On Liability\n- Audit Rights\n- Warranty Duration\n- Post-Termination Services\n- Non-Transferable License\n- License grant\n- IP Ownership Assignment\n- Minimum Commitment\n- Anti-Assignment\n- Non-Disparagement\n\n### Clauses Not Included:\n- Insurance\n\nIs there anything specific you would like to know or any particular clause details you are interested in?\n```", "```py\nAssistant > Yes, there is a contract that mentions \nthe ability to make price changes from time to time. \nHere is the relevant excerpt:\n\n1\\. **Birch First Global Investments Inc. and Mount Knowledge Holdings Inc. MARKETING AFFILIATE AGREEMENT**\n   - **Contract ID:** 1\n   - **Clause Type:** Price Restrictions\n   - **Excerpt:**\n     ```", "```py\n\nWould you like more information about this contract or any other details?\n```", "```py\nUser > any contract mentions the ability to make price changes from time to time\nINFO:semantic_kernel.connectors.ai.open_ai.services.open_ai_chat_completion_base:processing 1 tool calls in parallel.\n\nINFO:semantic_kernel.kernel:Calling contract_search-get_contracts_similar_text\n function with args: {\"clause_text\":\"price changes from time to time\"}\n\nAssistant > Yes, there is a contract that mentions the ability to make price changes from time to time. Here is the relevant excerpt:\n\n1\\. **Birch First Global Investments Inc. and Mount Knowledge Holdings Inc. MARKETING AFFILIATE AGREEMENT**\n   - **Contract ID:** 1\n   - **Clause Type:** Price Restrictions\n   - **Excerpt:**\n     ```", "```py\n```", "```py\nAssistant > There are a total of 3 contracts in the database.\n```", "```py\nUser >  how many contracts are there on the database?\nINFO:httpx:HTTP Request: POST https://api.openai.com/v1/chat/completions \"HTTP/1.1 200 OK\"\nINFO:semantic_kernel.connectors.ai.open_ai.services.open_ai_chat_completion_base:processing 1 tool calls in parallel.\n\nINFO:semantic_kernel.kernel:Calling contract_search-answer_aggregation_question function \nwith args: {\"user_question\":\"How many contracts are there in the database?\"}\n\nINFO:semantic_kernel.functions.kernel_function:Function completed. Duration: 0.588805s\n\nINFO:semantic_kernel.connectors.ai.open_ai.services.open_ai_handler:OpenAI usage: CompletionUsage(completion_tokens=13, prompt_tokens=3328, total_tokens=3341, completion_tokens_details={'reasoning_tokens': 0})\n\nAssistant > There are a total of 3 contracts in the database.\n```"]
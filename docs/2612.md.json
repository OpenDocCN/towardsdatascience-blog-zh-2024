["```py\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# In order to split our data into several parts equally lets assign KFold numbers to each of the data randomly.\n\n# Calculate the number of samples per fold\nnum_samples = len(df) // 8\n\n# Assign fold numbers\ndf['kfold'] = np.repeat(np.arange(1, 9), num_samples)\n\n# Handle any remaining samples (if len(df) is not divisible by 8)\nremaining_samples = len(df) % 8\nif remaining_samples > 0:\n    df.loc[-remaining_samples:, 'kfold'] = np.arange(1, remaining_samples + 1)\n\n# Shuffle again to ensure randomness\nfold_df = df.sample(frac=1, random_state=42).reset_index(drop=True)\n```", "```py\n# First we have to encode the categorical features using K-Fold target encoding\n\ndef useful_feature(df, target, weight):\n  utilized_feature = [c for c in df.columns if c not in (target)]\n  obj = [col for col in df.columns if df[col].dtype == 'object']\n  global_mean = df[target].mean()\n\n  for objek in obj:\n        df[f\"countperobject_{objek}\"] = 0\n        df[f\"meanperobject_{objek}\"] = 0\n\n        # Compute aggregations\n        agg = df.groupby(objek)[target].agg(['count', 'mean']).reset_index()\n\n        counts = agg['count'].values\n        mean = agg['mean'].values\n\n        # Iterate over each row\n        for i in range(1, 9): # design regarding to the length of the k-fold\n          for index, row in df.iterrows():\n\n              # Get the category and target value\n              if row[\"kfold\"] != i:\n                  category = row[objek]\n                  target_val = row[target]\n\n                  # Get the count from agg\n                  count_agg = agg[(agg[objek] == category)]['count'].values\n                  if len(count_agg) > 0:\n                      df.at[index, f\"countperobject_{objek}\"] = count_agg[0]\n\n                  # Get the mean from agg\n                  mean_agg = agg[(agg[objek] == category)]['mean'].values\n                  if len(mean_agg) > 0:\n                      df.at[index, f\"meanperobject_{objek}\"] = mean_agg[0]\n\n        # Now find the weighted mean\n        df[f\"weightedmean_{objek}\"] = ((df[f\"countperobject_{objek}\"] * df[f\"meanperobject_{objek}\"]) + (weight * global_mean))/(weight + df[f\"countperobject_{objek}\"])\n\n  encoding_maps = {}\n  for objek in obj:\n      encoding_maps[objek] = df.groupby(objek)[[f\"countperobject_{objek}\", f\"meanperobject_{objek}\"]].mean().to_dict()\n\n  return df, encoding_maps\n```"]
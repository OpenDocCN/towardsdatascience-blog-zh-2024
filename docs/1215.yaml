- en: Bird by Bird Using Finite Automata
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步实现：使用有限自动机
- en: 原文：[https://towardsdatascience.com/bird-by-bird-using-finite-automata-6a822af54455?source=collection_archive---------8-----------------------#2024-05-14](https://towardsdatascience.com/bird-by-bird-using-finite-automata-6a822af54455?source=collection_archive---------8-----------------------#2024-05-14)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/bird-by-bird-using-finite-automata-6a822af54455?source=collection_archive---------8-----------------------#2024-05-14](https://towardsdatascience.com/bird-by-bird-using-finite-automata-6a822af54455?source=collection_archive---------8-----------------------#2024-05-14)
- en: Finite-state machine modelling and simulation for real-world AI systems on object
    detection using Python
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 对物体检测的现实 AI 系统进行有限状态机建模与仿真
- en: '[](https://slipnitskaya.medium.com/?source=post_page---byline--6a822af54455--------------------------------)[![Sofya
    Lipnitskaya](../Images/9ea0dd0af32232eb4c8db0cb96f66449.png)](https://slipnitskaya.medium.com/?source=post_page---byline--6a822af54455--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--6a822af54455--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--6a822af54455--------------------------------)
    [Sofya Lipnitskaya](https://slipnitskaya.medium.com/?source=post_page---byline--6a822af54455--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://slipnitskaya.medium.com/?source=post_page---byline--6a822af54455--------------------------------)[![Sofya
    Lipnitskaya](../Images/9ea0dd0af32232eb4c8db0cb96f66449.png)](https://slipnitskaya.medium.com/?source=post_page---byline--6a822af54455--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--6a822af54455--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--6a822af54455--------------------------------)
    [Sofya Lipnitskaya](https://slipnitskaya.medium.com/?source=post_page---byline--6a822af54455--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--6a822af54455--------------------------------)
    ·17 min read·May 14, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--6a822af54455--------------------------------)
    ·阅读时间 17 分钟·2024年5月14日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/c81c58a8ab45f4b63344efe5ae0663f5.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c81c58a8ab45f4b63344efe5ae0663f5.png)'
- en: Image by author
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供
- en: '**Background**'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**背景**'
- en: '*“When life gives you chickens, let AI handle the fowl play.” — Unknown Engineer.*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*“当生活给你鸡时，让 AI 处理这些鸡毛蒜皮的事。” — 无名工程师*'
- en: Why on earth do we need simulations? What is the advantage we can get by sampling
    something and getting an average? But that is never only this. Real life is usually
    far more complex compared to simplistic tasks we encounter in computer science
    classes. Sometimes we can’t find an analytical solution, we can’t find population
    parameters. Sometimes we have to build a model to reflect specifics of the system’s
    dynamics, we have to run simulations to study the underlying processes so as to
    gain a better understanding of real-world situations. Simulation modelling provides
    an invaluable tool for systems design and engineering across a range of industries
    and applications. It helps to analyse system performance, identify potential bottlenecks
    and inefficiencies, thus allowing for iterative refinements and improvements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要仿真？通过采样并获得平均值，我们到底能获得什么优势？但实际上，它从来不仅仅是这些。与我们在计算机科学课程中遇到的简单任务相比，现实生活通常要复杂得多。有时我们无法找到解析解，无法找到总体参数。有时我们必须建立一个模型，以反映系统动态的具体情况，我们必须运行仿真来研究潜在过程，从而更好地理解现实世界的情况。仿真建模为各行各业和应用中的系统设计与工程提供了无价的工具。它有助于分析系统性能，识别潜在的瓶颈和低效问题，从而允许进行迭代改进和优化。
- en: Speaking about our very special challenge, here, we are going to create an FSM
    simulation replicating the behavior of an AI-assisted security system for lawn
    monitoring and cleaning. In particular, we will tackle the task of simulating
    processes to intelligently manage the coming and going of birds through object
    detection and water sprinkling subsystems. In the [previous article](/bird-by-bird-using-finite-automata-9d50b36bcbd3),
    you had been introduced to the theory and design principles on finite state machines
    (FSM) for dealing with the infamous Chicken-and-Turkey (CaT) problem, resulting
    in the creation of a model that describes complex lawn scenarios at a high level
    of abstraction. Through this article, we will further investigate the topic of
    practical aspects of an FSM-based simulation for leveraging the real-life system
    operation. In addition, we are going to implement the FSM simulation in Python
    so that we can later improve it via optimization and XAI techniques. By the end
    of the tutorial, you’ll have a fully functional FSM solution along with a better
    understanding of simulation modelling for solving engineering problems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 说到我们这个非常特别的挑战，在这里，我们将创建一个FSM仿真，模拟一个AI辅助的草坪监控和清洁安全系统的行为。特别地，我们将处理模拟过程，通过物体检测和喷水子系统智能管理鸟类的进出。在[上一篇文章](/bird-by-bird-using-finite-automata-9d50b36bcbd3)中，你已经了解了有限状态机（FSM）的理论和设计原则，旨在解决臭名昭著的鸡与火鸡（CaT）问题，从而创建了一个在高层次抽象下描述复杂草坪场景的模型。通过本文，我们将进一步探讨基于FSM的仿真在利用实际系统操作方面的实际应用。此外，我们还将用Python实现FSM仿真，以便后续通过优化和XAI技术对其进行改进。在本教程结束时，你将拥有一个完全功能的FSM解决方案，并对通过仿真建模解决工程问题有更深入的理解。
- en: '***Disclaimer:*** *This work is a part of the “*[*Bird by Bird using Deep Learning*](/bird-by-bird-using-deep-learning-4c0fa81365d7)*”
    series and is devoted to modelling and simulation of real-life systems for computer
    vision applications using finite automata. All actors, states, events and outputs
    are the products of the FSM design process for educational purposes only. Any
    resemblance to actual persons, birds, or real events is purely coincidental.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '***免责声明：*** *本作品是“*[*鸟瞰深度学习*](/bird-by-bird-using-deep-learning-4c0fa81365d7)*”系列的一部分，专注于使用有限自动机进行计算机视觉应用的实际系统建模与仿真。所有的参与者、状态、事件和输出仅为FSM设计过程中的教育性产物。与实际人物、鸟类或真实事件的任何相似之处纯属巧合。*'
- en: Finite automata for system modelling
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用有限自动机进行系统建模
- en: '*“When asked about systems design sans abstractions, just describe if-then
    loops for real-life scenarios, making sure to stutter while juggling multiple
    conditions. Then, gracefully retreat, leaving these trivialities behind.” — Unknown
    Engineer.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*“当被问及没有抽象的系统设计时，只需描述现实场景中的‘如果-那么’循环，确保在处理多个条件时有所停顿。然后，优雅地退后，留下这些琐碎的事情。” —
    未知工程师。*'
- en: Bringing the theory alive
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让理论走向实践
- en: Simulation, a special case of mathematical modelling, involves creating simplified
    representations of real-world systems to understand their behavior under various
    conditions. At its core, a model is to capture intrinsic patterns of a real-life
    system through equations, while simulation relates to the algorithmic approximation
    of these equations by running a program. This process enables generation of simulation
    results, facilitating comparison with theoretical assumptions and driving improvements
    in the actual system. Simulation modelling allows to provide insights on the system
    behavior and predict outcomes when it’s too expensive and/or challenging to run
    real experiments. It can be especially useful when an analytical solution is not
    feasible (e.g., warehouse management processes).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真，作为数学建模的一种特殊形式，涉及创建简化的现实世界系统的表示，以了解其在各种条件下的行为。其核心是通过方程捕捉真实系统的内在模式，而仿真则是通过运行程序来近似这些方程的算法过程。这个过程能够生成仿真结果，便于与理论假设进行比较，并推动实际系统的改进。仿真建模可以为系统行为提供洞察，并在进行真实实验过于昂贵和/或困难时预测结果。尤其当无法获得解析解时（例如仓库管理过程），仿真会特别有用。
- en: 'When dealing with the CaT-problem, the objective is clear: we want to maintain
    a pristine lawn and save resources. Rather than relying on traditional experimentation,
    we opt for a simulation-based approach to find a setup that allows us to minimize
    water usage and bills. To achieve this, we will develop an FSM-based model that
    reflects the key system processes, including bird intrusion, bird detection, and
    water sprinkling. Throughout the simulation, we will then assess the system performance
    to guide further optimization efforts towards improved efficiency on bird detection.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 CaT 问题时，目标很明确：我们希望保持草坪的整洁并节省资源。我们不依赖传统的实验方法，而是选择基于模拟的方式，寻找一种能够最小化水资源使用和水费的设置。为了实现这一目标，我们将开发一个基于有限状态机（FSM）的模型，反映系统中的关键过程，包括鸟类侵入、鸟类检测和喷水。整个模拟过程中，我们将评估系统性能，以指导进一步的优化工作，从而提高鸟类检测的效率。
- en: Why not if-else instructions
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么不用 if-else 语句
- en: Using if-else conditional branching for system modelling is a naïve solution
    that will ultimately lead to increased complexity and error-proneness by design,
    making further development and maintenance more difficult. Below you find how
    to (not) describe a simple chicken-on-the-lawn system, considering an example
    of the FSM we discussed earlier (see [Figure 1](/bird-by-bird-using-finite-automata-9d50b36bcbd3)
    for FSM state transition diagram with simplified CaT- system scenarios).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 if-else 条件分支进行系统建模是一种幼稚的解决方案，最终会导致复杂性和易出错性增加，从而使得进一步开发和维护变得更加困难。下面你将看到如何（不）描述一个简单的草坪上的鸡系统，考虑我们之前讨论过的有限状态机的示例（请参见[图
    1](/bird-by-bird-using-finite-automata-9d50b36bcbd3)，该图展示了简化的 CaT 系统场景下的 FSM 状态转换图）。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code snippet, we define constants to represent each state of the FSM
    (e.g., CHICKEN_PRESENT). Then, we initialize the current state to START and continuously
    monitor for events within a while loop, simulating the behavior of the simplified
    system. Based on the current state and associated events, we use if-else conditional
    branching instructions to switch between states and invoke corresponding actions.
    A state transition can have side effects, such as initiating the process of the
    lawn spoiling for chickens and starting the lawn cleaning for the engineer. Here,
    functionality related to input events and actions indicates processes that can
    be automated, so we mock importing the associated functions for simplicity. Note,
    that whilst chickens can spoil a lawn nearly endlessly, excessive quantities of
    juice are fraught with the risk of hyperhydration. Be careful with this and don’t
    forget to add constraints on the duration of your simulation. In our case, this
    will be the end of the day, as defined by the `max_sim_steps` variable. Looks
    ugly, right?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们定义常量来表示 FSM 的每个状态（例如，CHICKEN_PRESENT）。然后，我们将当前状态初始化为 START，并在一个 while
    循环中持续监控事件，模拟简化系统的行为。根据当前状态和相关事件，我们使用 if-else 条件分支语句在状态之间切换，并调用相应的操作。状态转换可能会有副作用，例如启动鸡群污染草坪的过程并开始为工程师清理草坪。这里，输入事件和动作相关的功能表示可以自动化的过程，因此我们为了简化模拟，假设引入了相关的函数。请注意，虽然鸡可以几乎无限制地破坏草坪，但过量的果汁却存在过度水化的风险。请小心这一点，并且不要忘记为你的模拟设定时间限制。在我们的案例中，时间限制是一天的结束，由
    `max_sim_steps` 变量定义。看起来很丑对吧？
- en: This should work, but imagine how much time it would take to update if-else
    instructions if we wanted to extend the logic, repeating the same branching and
    switching between states over and over. As you can imagine, as the number of states
    and events increases, the size of the system state space grows rapidly. Unlike
    if-else branching, FSMs are really good at handling complex tasks, allowing complex
    systems to be decomposed into manageable states and transitions, hence enhancing
    code modularity and scalability. Here, we are about to embark on a journey in
    implementing the system behavior using finite automata to reduce water usage for
    AI-system operation without compromising accuracy on bird detection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法应该是可行的，但想象一下，如果我们想扩展逻辑，需要不断更新 if-else 语句，重复相同的分支和状态切换。正如你可以想象的那样，随着状态和事件的增加，系统状态空间的规模迅速增长。与
    if-else 分支不同，有限状态机（FSM）非常适合处理复杂任务，它允许将复杂系统分解为可管理的状态和转换，从而提高代码的模块化和可扩展性。在这里，我们即将开始使用有限自动机（FSM）实现系统行为，以减少
    AI 系统操作的水资源使用，同时不影响鸟类检测的准确性。
- en: FSM implementation in Python
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用 Python 实现 FSM
- en: '*“Ok, kiddo, we are about to create a chicken now.” — Unknown Engineer.*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*“好了，孩子，我们现在要做一只鸡。” — 未知工程师。*'
- en: FSM all the way down
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从FSM到底层
- en: 'In this section, we delve into the design choices underlying FSM implementation,
    elucidating strategies to streamline the simulation process and maximize its utility
    in real-world system optimization. To build the simulation, we first need to create
    a model representing the system based on our assumptions about the underlying
    processes. One way to do this is to start with encapsulating functionally for
    individual states and transitions. Then we can combine them to create a sequence
    of events by replicating a real system behavior. We also want to track output
    statistics for each simulation run to provide an idea of its performance. What
    we want to do is watch how the system evolves over time given variation in conditions
    (e.g., stochastic processes of birds spawning and spoiling the lawn given a probability).
    For this, let’s start with defining and arranging building blocks we are going
    to implement later on. Here is the plan:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了有限状态机实现的设计选择，阐明了简化模拟过程和最大化其在现实系统优化中效用的策略。为了构建模拟，我们首先需要基于对基础过程的假设创建一个系统模型。一种方法是从封装个体状态和过渡的功能开始。然后，我们可以将它们组合起来，通过复制真实系统行为来创建一系列事件。我们还希望跟踪每次模拟运行的输出统计数据，以提供其性能的概念。我们想要做的是观察系统如何随着时间的推移在条件变化下演变（例如，基于概率的鸟类孵化和破坏草坪的随机过程）。为此，让我们首先定义和安排我们稍后将要实现的构建模块。以下是计划：
- en: Define class contracts.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类契约。
- en: Build class hierarchy for targets, describe individual targets.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建目标类的层次结构，描述个体目标。
- en: Implement transition logic between states.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现状态之间的过渡逻辑。
- en: Implement a single simulation step along with the full run.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现单步模拟以及完整的运行。
- en: Track output statistics of the simulation run.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪模拟运行的输出统计数据。
- en: Let’s talk abstract
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们谈谈抽象
- en: First, we need to create a class hierarchy for our simulation, spanning from
    base classes for states to a more domain specific yard simulation subclass. We
    will use `@abc.abstractmethod` and `@property` decorators to mark abstract methods
    and properties, respectively. In the AbstractSimulation class, we will define
    `step()` and `run()` abstract methods to make sure that child classes implement
    them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为我们的模拟创建一个类层次结构，从表示状态的基类到更具领域特定的院子模拟子类。我们将使用`@abc.abstractmethod`和`@property`装饰器来分别标记抽象方法和属性。在AbstractSimulation类中，我们将定义`step()`和`run()`抽象方法，以确保子类实现它们。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similar applies to AbstractState, which defines an abstract method `transit()`
    to be implemented by subclasses:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对AbstractState也有类似的应用，它定义了一个抽象方法`transit()`，由子类实现：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For our FSM, more specific aspects of the system simulation will be encapsulated
    in the AbstractYardSimulation class, which inherits from AbstractSimulation. As
    you can see in its name, AbstractYardSimulation outlines the domain of simulation
    more precisely, so we can define some extra methods and properties that are specific
    to the yard simulation in the context of the CaT problem, including `simulate_intrusion()`,
    `simulate_detection()`, `simulate_sprinkling()`, `simulate_spoiling()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的有限状态机（FSM），系统模拟的更具体方面将封装在继承自AbstractSimulation的AbstractYardSimulation类中。如其名称所示，AbstractYardSimulation更精确地概述了模拟的领域，因此我们可以在CaT问题的背景下定义一些特定于院子模拟的额外方法和属性，包括`simulate_intrusion()`、`simulate_detection()`、`simulate_sprinkling()`、`simulate_spoiling()`。
- en: 'We will also create an intermediate abstract class named AbstractYardState
    to enforce typing consistency in the hierarchy of classes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个中间抽象类AbstractYardState，以确保类层次结构中的类型一致性：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let’s take a look at the inheritance tree reflecting an entity named Target
    and its descendants.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下反映名为Target及其后代的继承树。
- en: Chicken and Turkey creation
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鸡和火鸡的创建
- en: Target behavior is a cornerstone of our simulation, as it affects all the aspects
    towards building an effective model along with its optimization downstream. Figure
    1 shows a class diagram for the target classes we are going to implement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Target行为是我们模拟的基石，因为它影响着所有方面，助力构建有效的模型以及后续的优化。图1展示了我们将要实现的目标类的类图。
- en: '![](../Images/84fac7433b526cba359328705f488ccb.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/84fac7433b526cba359328705f488ccb.png)'
- en: Figure 1\. Class hierarchy for the target classes (Image by author)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图1\. 目标类的类层次结构（图示由作者提供）
- en: For our system, it’s important to note that a target appears with a certain
    frequency, it may cause some damage to the lawn, and it also has a health property.
    The latter is related to the size of the target, which may differ, thus a water
    gun can aim for either smaller or larger targets (which, in turn, affects the
    water consumption). Consequently, a large target has a lot of health points, so
    a small water stream will not be able to effectively manage it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的系统，重要的是要注意目标出现的频率，它可能会对草坪造成一定的损害，而且它还具有健康属性。后者与目标的大小有关，大小可能不同，因此水枪可以瞄准较小或较大的目标（这反过来会影响水的消耗）。因此，大目标具有较多的生命值，小水流无法有效地处理它。
- en: 'To model targets trespassing the lawn with different frequencies we also create
    the associated property. Here we go:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟不同频率的目标穿越草坪，我们还创建了相关的属性。以下是代码：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that in our implementation we want the target objects to be valid integers,
    which will be of use for modelling randomness in the simulation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的实现中，我们希望目标对象是有效的整数，这将在模拟中用于建模随机性。
- en: 'Next, we create child classes to implement different kinds of targets. Below
    is the code of the class Chicken, where we override abstract methods inherited
    from the parent:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建子类来实现不同类型的目标。以下是类Chicken的代码，我们在其中重写了从父类继承的抽象方法：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We repeat the similar procedure for remaining Turkey and Empty classes. In the
    case of Turkey, health and damage parameters will be set to 7 and 17, respectively
    (let’s see how we can handle these bulky ones with our AI-assisted system). Empty
    is a special type of Target that refers to the absence of either bird species
    on the lawn. Although we can’t assign to its health and damage properties other
    values than 0, an unconditional (i.e. not caused by the engineer) birdlessness
    on the lawn has a non-zero probability reflected by the frequency value of 9.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对剩余的火鸡和空目标类执行类似的过程。对于火鸡，生命值和损害参数分别设置为7和17（让我们看看如何用我们的AI辅助系统处理这些笨重的家伙）。空目标是一个特殊类型的目标，表示草坪上没有任何鸟类。虽然我们不能给它的生命值和损害属性赋予其他值，除了0，但草坪上无鸟的无条件（即不是由工程师引起的）状态有非零的概率，这个概率反映在频率值为9的设定中。
- en: From Intrusion to Enemy Spotted with ease
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从入侵到敌人被轻松发现
- en: Now imagine a bird in its natural habitat. It can exhibit a wide variety of
    agonistic behaviors and displays. In the face of challenge, animals may employ
    a set of adaptive strategies depending on the circumstances, including fight,
    or flight responses and other intermediate actions. Following up on the previous
    article on the FSM design and modelling, you may remember that we already described
    the key components of the CaT system, which we will use for the actual implementation
    (see [Table 2](/bird-by-bird-using-finite-automata-9d50b36bcbd3) for FSM inputs
    describing the events triggering state changes).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一只鸟在其自然栖息地中的样子。它可以表现出各种各样的敌对行为和展示。在面对挑战时，动物可能会根据具体情况采用一系列适应性策略，包括战斗、逃跑反应以及其他中间行为。接续上一篇关于FSM设计与建模的文章，你可能还记得我们已经描述了CaT系统的关键组成部分，我们将用它来进行实际实现（参见[表2](/bird-by-bird-using-finite-automata-9d50b36bcbd3)，其中列出了描述触发状态变化的FSM输入事件）。
- en: 'In the realm of the FSM simulation, a bird can be viewed as an independent
    actor triggering a set of events: trespassing the yard, spoiling the grass, and
    so on. In particular, we expect the following sequential patterns in case of an
    optimistic scenario (success in bird detection and identification, defense actions):
    a bird invades the yard before possibly being recognized by the CV-based bird
    detector in order to move ahead with water sprinkling module, those configuration
    is dependent on the invader class predicted upstream. This way, the bird can be
    chased away successfully (hit) or not (miss). For this scenario (success in bird
    detection, class prediction, defense actions), the bird, eventually, escapes from
    the lawn. Mission complete. Tadaa!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在FSM模拟领域，一只鸟可以被看作是一个独立的触发一系列事件的行为体：侵犯院子、破坏草坪等等。特别地，在乐观的场景下（鸟类检测和识别成功，防御行为）：鸟类在可能被基于CV的鸟类检测器识别之前侵入院子，以便继续进行喷水模块，这些配置依赖于上游预测的入侵者类别。通过这种方式，鸟类可以成功地被赶走（击中）或未能被赶走（未击中）。在这个场景下（鸟类检测成功、类别预测、防御行为），最终，鸟类逃离了草坪。任务完成。哒哒！
- en: You may remember that the FSM can be represented graphically as a state transition
    diagram, which we covered in the previous tutorial (see [Table 3](/bird-by-bird-using-finite-automata-9d50b36bcbd3)
    for FSM state transition table with next-stage transition logic). Considering
    that, now we will create subclasses of AbstractYardState and override the `transit()`
    method to specify transitions between states based on the current state and events.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，有限状态机（FSM）可以通过状态转移图来图形化表示，这一点我们在之前的教程中已经涉及过（参见[表3](/bird-by-bird-using-finite-automata-9d50b36bcbd3)，其中展示了FSM状态转移表及下一阶段的转移逻辑）。考虑到这一点，接下来我们将创建AbstractYardState的子类，并重写`transit()`方法，根据当前状态和事件来指定状态之间的转移。
- en: Start is the initial state from which the state machine transits to Spawn.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Start是初始状态，状态机从该状态过渡到Spawn。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From Spawn, the system can transit to one of the following states: Intrusion,
    Empty, or End.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从Spawn状态，系统可以过渡到以下状态之一：Intrusion、Empty或End。
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Transition to the End state happens if we reach the limit on the number of simulation
    time steps. The state machine switches to Intrusion if a bird invades or is already
    present on the lawn, while Empty is the next state otherwise.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们达到模拟时间步数的上限，状态机会过渡到End状态。如果有鸟侵入或者已经在草地上，状态机会切换到Intrusion状态，否则下一状态是Empty。
- en: Both Intrusion and Empty states are followed by a detection attempt, so they
    share a transition logic. Thus, we can reduce code duplication by creating a parent
    class, namely IntrusionStatus, to encapsulate this logic, while aiming the subclasses
    at making the actual states of the simulation Intrusion and Empty distinguishable
    at the type level.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Intrusion和Empty状态都跟随一个检测尝试，因此它们共享转移逻辑。因此，我们可以通过创建一个父类——IntrusionStatus来封装这一逻辑，从而减少代码重复，同时使得子类能够在类型层面区分模拟中的实际状态Intrusion和Empty。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We apply a similar approach to the Detected and NotDetected classes, those superclass
    DetectionStatus handles target prediction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对Detected和NotDetected类采取类似的方法，那个超类DetectionStatus负责目标预测。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, in contrast to the Intrusion/Empty pair, the NotDetected class introduces
    an extra transition logic steering the simulation flow with respect to the lawn
    contamination/spoiling.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与Intrusion/Empty组合状态不同，NotDetected类引入了额外的转移逻辑，用以指引模拟流程，特别是关于草地污染/损坏的情况。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Detected class performs an unconditional transition to Sprinkling. For its
    antagonist, there are two possible next states, depending on whether a bird is
    actually on the lawn. If the bird is not there, no poops are anticipated for obvious
    reasons, while there may potentially be some grass cleaning needed otherwise (or
    not, the CaT universe is full of randomness).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Detected类会无条件地过渡到Sprinkling状态。对于其对立面，有两个可能的下一个状态，取决于草地上是否真的有鸟。如果鸟不在，那显然不会有鸟屎，而如果有鸟屎的可能性，则可能需要进行草地清理（或者不需要，CaT世界充满了随机性）。
- en: Getting back to Sprinkling, it has two possible outcomes (Hit or Miss), depending
    on whether the system was successful in chasing the bird away (this time, at least).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 回到喷洒状态，它有两个可能的结果（命中或未命中），取决于系统是否成功将鸟驱赶走（至少这次是如此）。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note: The Hit state does not bring a dedicated transition logic and is included
    to follow semantics of the domain of wing-aided attacking on the grass. Omitting
    it will cause the Shooting state transition to Leaving directly.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注：Hit状态没有专门的转移逻辑，它的存在是为了遵循关于草地上翼助攻击领域的语义。忽略它会导致Shooting状态直接过渡到Leaving。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the water sprinkler was activated and there was no bird on the lawn (detector
    mis-predicted the bird), the state machine will return to Spawn. In case the bird
    was actually present and we missed it, there’s a possibility of bird spoils on
    the grass.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果水喷洒器被激活且草地上没有鸟（检测器错误预测了鸟的存在），状态机将返回到Spawn状态。如果鸟实际上在场且我们没有检测到，草地上可能会有鸟屎。
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Eventually, the attacking attempt can result in a real damage to the grass,
    as reflected by the Attacking class and its descendants:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，攻击尝试可能会对草地造成实际的损害，正如Attacking类及其子类所体现的那样：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can employ the same idea as for the Intrusion status and encapsulate the
    shared transition logic into a superclass AfterAttacking, resulting in either
    Leaving or returning to the Spawn state:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用与Intrusion状态相同的思路，将共享的转移逻辑封装到一个名为AfterAttacking的超类中，从而得到Leaving或返回Spawn状态：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What happens next? When the simulation reaches the limit of steps, it stucks
    in the End state:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来会发生什么呢？当模拟达到步数限制时，它会卡在End状态：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In practice, we don’t want the program to execute endlessly. So, subsequently,
    once the simulation detects a transition into the End state, it shuts down.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，我们不希望程序无休止地执行。因此，一旦模拟检测到过渡到结束状态，它将关闭。
- en: Simulating the CaT-system
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟CaT系统
- en: '*“In the subtle world of bird detection, remember: while a model says “no chickens
    detected,” a sneaky bird may well be on the lawn unnoticed. This discrepancy stands
    as a call to refine and enhance our AI systems.” — Unknown Engineer.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*“在鸟类探测的微妙世界中，请记住：当一个模型说“未检测到鸡”时，可能有一只狡猾的鸟正悄悄地站在草坪上，未被发现。这种差异提醒我们需要完善和增强我们的人工智能系统。”
    — 无名工程师。*'
- en: 'Now, we’d like to simulate a process of birds trespassing the lawn, spoiling
    it and leaving. To do so, we will turn to a kind of simulation modelling called
    discrete-event simulation. We will reproduce the system behavior by analyzing
    the most significant relationships between its elements and developing a simulation
    based on finite automata mechanics. For this, we have to consider the following
    aspects:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望模拟鸟类闯入草坪、破坏草坪并离开的过程。为此，我们将采用一种称为离散事件模拟的模拟建模方法。我们将通过分析系统各个元素之间最重要的关系，并基于有限自动机原理开发一个模拟系统来再现系统行为。为此，我们需要考虑以下几个方面：
- en: Birds can trespass in the backyard of the property.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鸟类可以闯入房产的后院。
- en: CV-based system attempts to detect and classify the intruding object.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于计算机视觉的系统尝试检测和分类入侵对象。
- en: Based on the above, in case the object was identified as a particular bird variety,
    we model the water sprinkling process to drive it away.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于以上情况，如果对象被识别为某种特定的鸟类，我们将建模水洒喷头的过程以将其驱逐。
- en: It should be mentioned that there is also a probabilistic process that results
    in a bird spoiling the lawn (again, nothing personal, feathery).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还应该提到，有一个概率过程会导致鸟类破坏草坪（再次声明，没什么个人恩怨，只是羽毛）。
- en: Yard simulation processes
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草坪模拟过程
- en: Now, it’s time to explore the magic of probability to simulate these processes
    using the implemented FSM. For that, we need to create a YardSimulation class
    that encapsulates the simulation logic. As said, the simulation is more than an
    FSM. The same applies to the correspondences between simulation steps and state
    machine transitions. That is, the system needs to perform several state transitions
    to switch to the next time step.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候探索概率的魔力，通过实现的有限状态机来模拟这些过程了。为此，我们需要创建一个`YardSimulation`类来封装模拟逻辑。如前所述，模拟不仅仅是有限状态机。模拟步骤与状态机过渡之间的对应关系也适用。也就是说，系统需要执行多个状态过渡才能切换到下一个时间步骤。
- en: Here, the `step()` method handles transitions from the current to the next state
    and invokes the FSM’s method `transit()` until the state machine returns into
    the Spawn state or reaches End.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`step()`方法处理从当前状态到下一个状态的过渡，并调用有限状态机（FSM）的`transit()`方法，直到状态机返回到生成状态或达到结束状态。
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `run()` method, we call `step()` in the loop and yield its outputs until
    the system transits to the End step:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run()`方法中，我们在循环中调用`step()`并生成其输出，直到系统过渡到结束步骤：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `reset()` method resets the FSM memory after the bird leaves.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset()`方法在鸟离开后重置有限状态机的记忆。'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A bird is leaving when either it’s successfully hit by the water sprinkler or
    it stays too long on the lawn (e.g., assuming it got bored). The latter is equivalent
    to having a bird present on the lawn during 5 simulation steps (= minutes). Not
    that long, who knows, maybe the neighbor's lawn looks more attractive. Let’s implement
    some essential pieces of our system’s behavior.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当一只鸟被水洒喷头成功喷到，或者它在草坪上停留太久（例如，假设它感到无聊）时，它就离开了。后者相当于鸟在草坪上停留了 5 个模拟步骤（即 5 分钟）。时间并不长，谁知道呢，也许邻居的草坪看起来更吸引人。让我们实现一些我们系统行为的核心部分。
- en: First, if no bird is present on the lawn (true intruder class), we try to spawn
    the one.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果草坪上没有鸟类（即真正的入侵者类别），我们尝试生成一只。
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, spawning relates to the live creation of the trespassing entity (bird
    or nothing).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，生成与非法入侵实体（鸟或无物）实时创建相关。
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, the CV-based system — that is described by a class confusion matrix —
    tries to detect and classify the intruding object. For this process, we simulate
    a prediction generation, while keeping in mind the actual intruder class (ground
    truth).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，基于计算机视觉的系统——由类混淆矩阵描述——尝试检测和分类入侵对象。在这个过程中，我们模拟一个预测生成，同时牢记实际的入侵者类别（地面真相）。
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Detector works on every timestep of the simulation, as the simulated system
    doesn’t know the ground truth (otherwise, why would we need the detector?). If
    the detector identifies a bird, we try to chase it away with the water sprinkler
    tuned to a specific water flow rate that depends on the detected target class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 检测器在模拟的每个时间步上都在工作，因为模拟系统并不知道实际情况（否则我们为什么还需要检测器呢？）。如果检测器识别到鸟类，我们会尝试用水喷洒器把它赶走，水流量依赖于检测到的目标类别：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Regardless of the success of the sprinkling, the system consumes water anyway.
    Hit success criteria includes the following conditions: a bird was present on
    the lawn (a), water sprinkler hit the bird (b), the shot was adequate/sufficient
    to treat the bird of a given size (c). Note, that (c) the chicken “shot” won’t
    treat the turkey, but applies otherwise.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 无论喷水是否成功，系统都会消耗水。成功的判定标准包括以下条件：草坪上有鸟类存在（a），水喷洒器击中鸟类（b），喷洒的水量足够/适合处理给定大小的鸟类（c）。请注意，（c）鸡“喷洒”不会处理火鸡，但其他情况下适用。
- en: Spoiling part — a bird can potentially mess up with the grass. If this happens,
    the lawn damage rate increases (obviously).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 草地污染部分——鸟类有可能弄脏草坪。如果发生这种情况，草坪损坏率就会增加（显然）。
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now we have all the essentials to simulate a single time step for the CaT problem
    we are going to handle. Simulation time!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们具备了所有必要的条件来模拟我们将要处理的 CaT 问题的单一时间步。模拟时间开始！
- en: Bird on the run
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鸟类逃跑
- en: 'Now, we are all set to employ our FSM simulation to emulate an AI-assisted
    lawn security system across different settings. While running a yard simulation,
    the `YardSimulation.run()` method iterates over a sequence of state transitions
    until the system reaches the limit of steps. For this, we instantiate a simulation
    object (a.k.a. state machine), setting the `num_steps` argument that reflects
    the total amount of the simulation timesteps (let’s say 12 hours or daytime) and
    `detector_matrix` that relates to the confusion matrix of the CV-based bird detector
    subsystem trained to predict chickens and turkeys:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用 FSM 模拟来模拟一个在不同设置下的 AI 辅助草坪安全系统。在进行草坪模拟时，`YardSimulation.run()`
    方法会遍历一系列的状态转移，直到系统达到最大步数。在此过程中，我们实例化一个模拟对象（即状态机），设置 `num_steps` 参数，这个参数反映了模拟的总时间步数（比如
    12 小时或白天），以及与计算机视觉（CV）基础的鸟类检测子系统的混淆矩阵相关的 `detector_matrix`，该子系统经过训练，用来预测鸡和火鸡：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can run the FSM simulation and print state transitions that the FSM
    undergoes at every timestep:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行 FSM 模拟，并打印 FSM 在每个时间步经历的状态转移：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In addition, we accumulate simulation statistics related to the water usage
    for bird sprinkling (`simulate_sprinkling`) and grass cleaning after birds arrive
    (`simulate_spoiling`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还积累了与鸟类喷水（`simulate_sprinkling`）和鸟类到达后的草地清理（`simulate_spoiling`）相关的水使用模拟统计数据。
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the simulation reaches its limit, we can then compute the total water consumption
    by the end of the day for each of the categories. What we would like to see is
    what happens after each run of the simulation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟达到其限制时，我们可以计算每个类别到一天结束时的总水消耗。我们希望看到的是每次模拟运行后的变化情况。
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, let’s conduct experiments to assess how the system can perform given
    changes in the computer vision-based subsystem. To that end, we will run simulations
    using YardSimulation.run()` method for 100 trials for a non-trained (baseline)
    and perfect detection matrices:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们进行实验，评估在计算机视觉子系统发生变化时，系统的表现如何。为此，我们将使用 `YardSimulation.run()` 方法进行 100
    次试验，分别针对未经训练的（基准）和完美检测矩阵进行模拟：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Thereafter, we can aggregate and compare output statistics related to the total
    water usage for target sprinkling and lawn cleaning for different experimental
    settings:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以聚合并比较不同实验设置下与目标喷水和草坪清理的总水使用量相关的输出统计数据：
- en: '![](../Images/358c0e78bfce985a406f93e3b1888da8.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/358c0e78bfce985a406f93e3b1888da8.png)'
- en: Figure 2\. FSM simulation output statistics across edge cases of the bird detection
    subsystem (Image by author)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2\. FSM 模拟输出统计数据，涵盖了鸟类检测子系统的边缘情况（图片由作者提供）
- en: A comparison of summary results across experiments reveals that having a better
    CV model would contribute to increased efficiency in minimizing water usage by
    37.8% (70.9 vs. 44.1), compared to the non-trained baseline detector for birds
    under the given input parameters and simulation conditions — a concept both intuitive
    and anticipated. But what does “better” mean quantitatively? Is it worth fiddling
    around with refining the model? The numerical outcomes demonstrate the value of
    improving the model, motivating further refinement efforts. Going forward, we
    will use the resulting statistics as an objective for global optimization to improve
    efficiency of the bird detection subsystem and cut down on water consumption for
    system operation and maintenance, making the engineer a little happier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 实验结果的总结对比显示，拥有一个更好的计算机视觉（CV）模型可以使得水使用量减少37.8%（70.9与44.1），相较于未经过训练的基线检测器，在给定输入参数和仿真条件下对鸟类的检测——这一概念既直观又在预期之中。但“更好”的定量意义是什么呢？是否值得费力地精细调整模型？数值结果展示了改进模型的价值，激励了进一步优化的努力。未来，我们将把这些统计结果作为全局优化的目标，以提高鸟类检测子系统的效率，并减少系统操作和维护中的水消耗，从而让工程师稍微高兴一点。
- en: 'The source code used for this tutorial can be found in this GitHub repository:
    [https://github.com/slipnitskaya/computer-vision-birds](https://github.com/slipnitskaya/computer-vision-birds).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程所使用的源代码可以在此GitHub仓库中找到：[https://github.com/slipnitskaya/computer-vision-birds](https://github.com/slipnitskaya/computer-vision-birds)。
- en: '**Conclusions**'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**结论**'
- en: 'To sum up, simulation modelling is a useful tool that can be used to estimate
    efficiency of processes, enable rapid testing of anticipated changes, and understand
    how to improve processes through operation and maintenance. Through this article,
    you have gained a better understanding on practical applications of simulation
    modelling for solving engineering problems. In particular, we’ve covered the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，仿真建模是一个有用的工具，可以用来估算过程的效率、快速测试预期的变化，并了解如何通过操作和维护改进过程。通过本文，你对仿真建模在解决工程问题中的实际应用有了更好的理解。特别是，我们已经涵盖了以下内容：
- en: How to design a model to approximate a complex system to improve its operation
    on bird detection and water sprinkling.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计一个模型来近似一个复杂系统，从而改进其在鸟类检测和水洒布方面的操作。
- en: How to create a simulation of real-world processes to understand the CaT-system
    behavior under various conditions.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建现实世界过程的仿真，以便在不同条件下理解CaT系统的行为。
- en: How to implement an FSM-based solution in Python for the system to track relevant
    statistics of the simulation.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Python中实现基于FSM的解决方案，使得系统能够追踪仿真过程中的相关统计数据。
- en: What’s next
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来做什么
- en: Focusing on improving resource efficiency, in the follow-up articles, you will
    discover how to address a non-analytic optimization problem of the water cost
    reduction by applying Monte-Carlo and eXplainable AI (XAI) methods to enhance
    the computer vision-based bird detection subsystem, thus advancing our simulated
    AI-assisted lawn security system.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 聚焦于提高资源效率，在后续文章中，你将发现如何通过应用蒙特卡洛方法和可解释AI（XAI）技术来解决水成本降低的非解析优化问题，从而增强基于计算机视觉的鸟类检测子系统，推动我们的仿真AI辅助草坪安防系统的发展。
- en: What are other important concepts in simulation modelling and optimization for
    vision projects? Find out more on [Bird by Bird Tech](https://towardsdatascience.com/tagged/bird-by-bird-tech).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在视觉项目的仿真建模和优化中，还有哪些重要的概念？请访问[Bird by Bird Tech](https://towardsdatascience.com/tagged/bird-by-bird-tech)了解更多。
- en: References
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Forsyth, David. Probability and statistics for computer science. Vol. 13\.
    Cham: Springer International Publishing, 2018.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Forsyth, David. 《计算机科学中的概率与统计》。第13卷。Cham: Springer International Publishing,
    2018。'
- en: 'Knuth, Donald Ervin. The art of computer programming. Vol. 3\. Reading, MA:
    Addison-Wesley, 1973.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Knuth, Donald Ervin. 《计算机程序设计的艺术》。第3卷。Reading, MA: Addison-Wesley, 1973。'
- en: 'Wagner, Ferdinand, et al. Modeling software with finite state machines: a practical
    approach. Auerbach Publications, 2006.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Wagner, Ferdinand 等. 《使用有限状态机建模软件：一种实用方法》。Auerbach Publications, 2006。

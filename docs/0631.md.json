["```py\nimport numpy as np\n\n# Solve the 3D visibility problem using a simple grid-based method\ndef grid_visibility(grid0):\n    grid = grid0.copy()\n    for x in range(grid.shape[0]):\n        for y in range(grid.shape[1]):\n            for z in range(int(x==0 and y==0), grid.shape[2]):\n                vx = grid[x-1,y,z]\n                vy = grid[x,y-1,z]\n                vz = grid[x,y,z-1]\n                grid[x,y,z] *= (x*vx + y*vy + z*vz) / (x + y + z)\n    return grid >= 0.5\n```", "```py\n# Solve the 3D visibility problem by modifying a grid within a cone\ndef visibility_within_cone(grid, u_vector, v_vector, w_vector):\n    u = np.asarray(u_vector, dtype=int)\n    v = np.asarray(v_vector, dtype=int)\n    w = np.asarray(w_vector, dtype=int)\n    origin = np.array([0,0,0], dtype=int)\n    dims = np.asarray(grid.shape, dtype=int)\n    m = 0\n    k = 0\n    q = 0\n    pos = np.array([0,0,0], dtype=int)\n    while np.all(pos < dims):\n        while np.all(pos < dims):\n            while np.all(pos < dims):\n                if not np.all(pos == 0):\n                    p = tuple(pos)\n                    if grid[p] == 1:\n                        pu = tuple(np.maximum(origin, pos - u))\n                        pv = tuple(np.maximum(origin, pos - v))\n                        pw = tuple(np.maximum(origin, pos - w))\n                        grid[p] = (m*grid[pu] + \n                                   k*grid[pv] +\n                                   q*grid[pw]) / (m + k + q)\n                q += 1\n                pos += w\n            k += 1\n            q = 0\n            pos = m*u + k*v\n        m += 1\n        k = 0\n        q = 0\n        pos = m*u\n```", "```py\n# Solve the 3D visibility problem using the 6-neighborhood\ndef grid6_visibility(grid0):\n    grid = grid0.copy()\n    visibility_within_cone(grid, [1,0,0], [0,1,0], [0,0,1])\n    return grid >= 0.5\n```", "```py\n# Solve the 3D visibility problem using the 26-neighborhood\ndef grid26_visibility(grid0):\n    grid = grid0.copy()\n    visibility_within_cone(grid, [1,0,0], [1,1,0], [1,1,1])\n    visibility_within_cone(grid, [1,0,0], [1,0,1], [1,1,1])\n    visibility_within_cone(grid, [0,1,0], [1,1,0], [1,1,1])\n    visibility_within_cone(grid, [0,1,0], [0,1,1], [1,1,1])\n    visibility_within_cone(grid, [0,0,1], [1,0,1], [1,1,1])\n    visibility_within_cone(grid, [0,0,1], [0,1,1], [1,1,1])\n    return grid >= 0.5\n```", "```py\n# Solve the 3D visibility problem using the 74-neighborhood\ndef grid74_visibility(grid0):\n    grid = grid0.copy()\n    visibility_within_cone(grid, [1,0,0], [2,1,0], [2,1,1])\n    visibility_within_cone(grid, [1,1,0], [2,1,0], [2,1,1])\n    visibility_within_cone(grid, [1,1,0], [1,1,1], [2,1,1])    \n    visibility_within_cone(grid, [1,0,0], [2,0,1], [2,1,1])\n    visibility_within_cone(grid, [1,0,1], [2,0,1], [2,1,1])\n    visibility_within_cone(grid, [1,0,1], [1,1,1], [2,1,1])\n    visibility_within_cone(grid, [0,1,0], [1,2,0], [1,2,1])\n    visibility_within_cone(grid, [1,1,0], [1,2,0], [1,2,1])\n    visibility_within_cone(grid, [1,1,0], [1,1,1], [1,2,1])\n    visibility_within_cone(grid, [0,1,0], [0,2,1], [1,2,1])\n    visibility_within_cone(grid, [0,1,1], [0,2,1], [1,2,1])\n    visibility_within_cone(grid, [0,1,1], [1,1,1], [1,2,1])\n    visibility_within_cone(grid, [0,0,1], [1,0,2], [1,1,2])\n    visibility_within_cone(grid, [1,0,1], [1,0,2], [1,1,2])\n    visibility_within_cone(grid, [1,0,1], [1,1,1], [1,1,2])\n    visibility_within_cone(grid, [0,0,1], [0,1,2], [1,1,2])\n    visibility_within_cone(grid, [0,1,1], [0,1,2], [1,1,2])\n    visibility_within_cone(grid, [0,1,1], [1,1,1], [1,1,2])\n    return grid >= 0.5\n```", "```py\n# Solve the 3D visibility problem using the 18-neighborhood\ndef grid18_visibility(grid0):\n    grid = grid0.copy()\n    visibility_within_cone(grid, [2,0,0], [1,1,0], [1,0,1])\n    visibility_within_cone(grid, [0,2,0], [1,1,0], [0,1,1])\n    visibility_within_cone(grid, [0,0,2], [1,0,1], [0,1,1])\n    visibility_within_cone(grid, [1,1,0], [1,0,1], [0,1,1])\n    return grid >= 0.5\n```", "```py\n# Solve the 3D visibility problem using the 50-neighborhood\ndef grid50_visibility(grid0):\n    grid = grid0.copy()\n    visibility_within_cone(grid, [2,0,0], [1,1,0], [2,1,1])\n    visibility_within_cone(grid, [2,0,0], [1,0,1], [2,1,1])\n    visibility_within_cone(grid, [1,1,0], [2,1,1], [2,2,2])\n    visibility_within_cone(grid, [1,0,1], [2,1,1], [2,2,2])\n    visibility_within_cone(grid, [0,2,0], [1,1,0], [1,2,1])\n    visibility_within_cone(grid, [0,2,0], [0,1,1], [1,2,1])\n    visibility_within_cone(grid, [1,1,0], [1,2,1], [2,2,2])\n    visibility_within_cone(grid, [0,1,1], [1,2,1], [2,2,2])\n    visibility_within_cone(grid, [0,0,2], [1,0,1], [1,1,2])\n    visibility_within_cone(grid, [0,0,2], [0,1,1], [1,1,2])\n    visibility_within_cone(grid, [1,0,1], [1,1,2], [2,2,2])\n    visibility_within_cone(grid, [0,1,1], [1,1,2], [2,2,2])\n    return grid >= 0.5\n```", "```py\nfrom grid_visibility_3D import *\n\nimport matplotlib.pyplot as plt\nimport sys\n\n# Set dimensions for the test scenario\nnx = 40\nny = 40\nnz = 40\n\n# Set spherical obstacle parameters for the test scenario\nx_sphere = 10\ny_sphere = 20\nz_sphere = 16\nr_sphere = 8\n\n# Initialize the 3D visibility problem for the test scenario \ndef initial_grid():\n    grid = np.ones((nx,ny,nz))\n    p_sphere = np.array([x_sphere, y_sphere, z_sphere])\n    for x in range(nx):\n        for y in range(ny):\n            for z in range(nz):\n                p = np.array([x,y,z])\n                r = np.sqrt(np.sum((p - p_sphere)**2))\n                if r < r_sphere:\n                    grid[x,y,z] = 0\n    return grid\n\n# Solve the 3D visibility problem analytically for the test scenario\ndef analytic_solution():\n    grid = initial_grid()\n    p_sphere = np.array([x_sphere, y_sphere, z_sphere])\n    d_sphere = np.sqrt(np.sum(p_sphere**2))\n    u = p_sphere/d_sphere\n    for x in range(nx):\n        for y in range(ny):\n            for z in range(nz):\n                if grid[x,y,z]:\n                    p = np.array([x,y,z])\n                    d = np.sum(p*u)\n                    if d > d_sphere:\n                        h = np.sqrt(np.sum((p - d*u)**2))\n                        grid[x,y,z] = h*d_sphere >= d*r_sphere\n    return grid\n\n# Compare the 3D grid-based results to the analytic solution\ndef evaluate_grid(test_name, grid, solution, triangular=False):\n    error_grid = np.abs(grid - solution)\n    total_count = nx*ny*nz\n    if triangular:\n        for x in range(nx):\n            for y in range(ny):\n                for z in range(nz):\n                    if (x + y + z)%2 == 1:\n                        error_grid[x,y,z] = 0\n                        total_count -= 1 \n    error_count = int(np.sum(error_grid))\n    accuracy = 100*(1 - error_count/total_count)\n    print(test_name + \" accuracy: %.3f\" % accuracy)\n    return error_grid\n\n# Plot the 3D visibility problem with or without resulting errors\ndef plot_test_scenario(error_grid=None, obstacle=True, pretty=True):\n    elevation = 19\n    azimuth = 33\n    ax = plt.figure().add_subplot(projection='3d')\n    ax.view_init(elev=elevation, azim=azimuth, roll=0)\n    ax.set_aspect('equal')\n    ax.set_xlabel('X')\n    ax.set_ylabel('Y')\n    ax.set_zlabel('Z')\n    ax.scatter(0, 0, 0, color='#6A22C2', s=64)  # Render viewpoint\n    if pretty:\n        # Choose limits that avoid padding \n        ax.set_xlim(0.9, nx - 0.9)\n        ax.set_ylim(0.9, ny - 0.9)\n        ax.set_zlim(0.9, nz - 0.9)\n        # Ensure axes are prominently displayed \n        ax.plot([0,nx], [0,0], [0,0], color='gray', linewidth=2)\n        ax.plot([0,nx], [ny,ny], [0,0], color='black', linewidth=1)\n        ax.plot([0,nx], [0, 0], [nz,nz], color='black', linewidth=1)\n        ax.plot([0,0], [0,ny], [0,0], color='gray', linewidth=2)\n        ax.plot([nx,nx], [0,ny], [0,0], color='black', linewidth=1)\n        ax.plot([0,0], [0,ny], [nz,nz], color='black', linewidth=1)\n        ax.plot([0,0], [0,0], [0,nz], color='gray', linewidth=2)\n        ax.plot([0,0], [ny,ny], [0,nz], color='black', linewidth=1)\n        ax.plot([nx,nx], [0,0], [0,nz], color='black', linewidth=1)\n    else:\n        ax.set_xlim(0, nx)\n        ax.set_ylim(0, ny)\n        ax.set_zlim(0, nz)\n    if obstacle:\n        n = 100\n        us = np.linspace(0, 2*np.pi, n)\n        vs = np.linspace(0, np.pi, n)\n        xs = r_sphere*np.outer(np.cos(us), np.sin(vs)) + x_sphere\n        ys = r_sphere*np.outer(np.sin(us), np.sin(vs)) + y_sphere\n        zs = r_sphere*np.outer(np.ones(n), np.cos(vs)) + z_sphere\n        ax.plot_surface(xs, ys, zs, color='lightgray')\n    if np.all(error_grid) != None:\n        error_count = int(np.sum(error_grid))\n        xs = np.zeros(error_count)\n        ys = np.zeros(error_count)\n        zs = np.zeros(error_count)\n        i = 0\n        for x in range(nx):\n            for y in range(ny):\n                for z in range(nz):\n                    if error_grid[x,y,z]:\n                        xs[i] = x\n                        ys[i] = y\n                        zs[i] = z\n                        i += 1\n        ax.scatter(xs, ys, zs, color='red')\n    plt.show()\n\nif __name__ == \"__main__\":\n    # Compute the grid-based solutions\n    grid0 = initial_grid()\n    grid = grid_visibility(grid0)\n    grid6 = grid6_visibility(grid0)\n    grid18 = grid18_visibility(grid0)\n    grid26 = grid26_visibility(grid0)\n    grid50 = grid50_visibility(grid0)\n    grid74 = grid74_visibility(grid0)\n    # Ensure that 6-neighbor solutions are identical\n    if np.any(grid != grid6):\n        print(\"Warning: Alternative 6-neighbor solutions differ\")\n    # Compute the analytic solution\n    solution = analytic_solution()\n    # Compute the errors and report accuracy\n    error_grid6 = evaluate_grid(' 6-neighbor', grid6, solution)\n    error_grid18 = evaluate_grid('18-neighbor', grid18, solution, True)\n    error_grid26 = evaluate_grid('26-neighbor', grid26, solution)\n    error_grid50 = evaluate_grid('50-neighbor', grid50, solution, True)\n    error_grid74 = evaluate_grid('74-neighbor', grid74, solution)\n    # Plot the results\n    error_grid = None\n    if len(sys.argv) >= 2:\n        if sys.argv[1] == \"6\":\n            error_grid = error_grid6\n        elif sys.argv[1] == \"18\":\n            error_grid = error_grid18\n        elif sys.argv[1] == \"26\":\n            error_grid = error_grid26\n        elif sys.argv[1] == \"50\":\n            error_grid = error_grid50\n        elif sys.argv[1] == \"74\":\n            error_grid = error_grid74\n    plot_test_scenario(error_grid)\n```"]
- en: Revolutionize Web Browsing with AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/revolutionize-web-browsing-with-ai-5d5f6ce5f5df?source=collection_archive---------4-----------------------#2024-03-10](https://towardsdatascience.com/revolutionize-web-browsing-with-ai-5d5f6ce5f5df?source=collection_archive---------4-----------------------#2024-03-10)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unlock Interactive Online Experiences Using GPT-4V and Puppeteer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@bianbianzhu123?source=post_page---byline--5d5f6ce5f5df--------------------------------)[![Tianyi
    Li](../Images/40fce472f42c650daa1433641bf732df.png)](https://medium.com/@bianbianzhu123?source=post_page---byline--5d5f6ce5f5df--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--5d5f6ce5f5df--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--5d5f6ce5f5df--------------------------------)
    [Tianyi Li](https://medium.com/@bianbianzhu123?source=post_page---byline--5d5f6ce5f5df--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--5d5f6ce5f5df--------------------------------)
    ¬∑23 min read¬∑Mar 10, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: 'Authors: [Tianyi Li](https://medium.com/u/4092d7367010?source=post_page---user_mention--5d5f6ce5f5df--------------------------------),
    [Selina Li](https://medium.com/u/7b9ea39b0d79?source=post_page---user_mention--5d5f6ce5f5df--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5534a8ac0a28ede1472534e7d922e9d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Image generated by the author with DALL¬∑E
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑ [Introduction](#ced3)
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑ [Potential Use Cases](#b5c4)
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑ [High-level Workflow](#efe3)
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑ [Architecture](#2455)
  prefs: []
  type: TYPE_NORMAL
- en: ‚àò [Starting Out](#1813)
  prefs: []
  type: TYPE_NORMAL
- en: ‚àò [Pick the Right Path](#3fd7)
  prefs: []
  type: TYPE_NORMAL
- en: ‚àò [IT IS A LOOP!](#ce07)
  prefs: []
  type: TYPE_NORMAL
- en: ‚àò [Directory Structure](#30b8)
  prefs: []
  type: TYPE_NORMAL
- en: ‚àò [Browser Controller Service](#c456)
  prefs: []
  type: TYPE_NORMAL
- en: ‚àò [Element Annotation Service](#d19c)
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑ [Conclusion](#b379)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you are keen on attending an AI event in your city this month, but
    you have specific criteria in mind, perhaps related to timing or the focus of
    the event. Normally, this would involve the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: Launching a web search with terms like ‚ÄúAI events in [your city] this month.‚Äù
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sifting through search results to find a link that seems promising.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the chosen website to determine its relevance, possibly needing to
    delve deeper through additional links.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After much back and forth, finally pinpointing the event that fits your criteria
    and noting its details for your calendar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we break down the above process, it basically involves steps that can be
    categorized into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Control the browser, such as go to a URL, click on a link, go back, etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse through the content of a page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make decisions based on the content of that page, such as determining which
    link is relevant to your query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By utilizing the emerging Large Language Model (LLM) technology, now we are
    able to **automate the whole process through a LLM powered AI Agent**.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the AI agent, it does exactly what you do as we described above.
  prefs: []
  type: TYPE_NORMAL
- en: '**Browser Control**: the AI uses tools like `Puppeteer` to navigate the internet.
    Think of Puppeteer as the AI''s hands, allowing it to open tabs, click on links,
    and navigate web pages with ease.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Content Browsing**: Think of this as the AI‚Äôs eyes. `Puppeteer` can take
    screenshots of web pages, and feed them to the AI.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Decision-Making**: This is where the AI‚Äôs brain, powered by Large Language
    Models (LLM), comes into play. It assesses the screenshot of each page, analyzing
    the image, determining relevance and deciding on the next steps, mimicking human
    judgment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this article, we will explore and build an AI agent that utilizes the power
    of the `gpt-4-vision-preview` model from OpenAI. The model can **analyze images**
    and provide textual responses.
  prefs: []
  type: TYPE_NORMAL
- en: This agent will be able to interact with the user, control a web browser, and
    process data. We‚Äôll explore its structure and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: This article is inspired by a youtube video [GPT4V + Puppeteer = AI agent browse
    web like human? ü§ñ](https://www.youtube.com/watch?v=IXRkmqEYGZA&t=184s) from [AI
    Jason](https://www.youtube.com/@AIJasonZ).
  prefs: []
  type: TYPE_NORMAL
- en: '**All the code shown in this article can be found in this Github repo** [**AI
    Web Agent**](https://github.com/bianbianzhu/ai-web-agent/tree/main/agent)**.**'
  prefs: []
  type: TYPE_NORMAL
- en: Potential Use Cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pairing with Text to speech, it can allow people with visual impairments to
    browse the web.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quickly locate a product on an E-commerce website.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-browse websites with dynamic loading contents (e.g. Real Estate listings)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto-browse websites requiring personal logins (e.g. LinkedIn, Instagram, Facebook)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take online quiz and tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play web games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Online seats / tickets grabbing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated application feature testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-level Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/586a1f94e2d077c069b61fadefe44de0.png)'
  prefs: []
  type: TYPE_IMG
- en: The flowchart showing the high-level workflow of the agent.
  prefs: []
  type: TYPE_NORMAL
- en: First user raises a question to the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the question, GPT-4V is going to return a URL as an entry point
    of the web searching. The URL can be specified by the user as part of the question;
    and if not specified, by default it will be a Google search on key words extracted
    by GPT from user‚Äôs question.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the URL, puppeteer will open the URL in webpage. It will highlight
    all interactive elements on the page such as links, clicks, buttons, and then
    take a screenshot of the page and return it.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the screenshot, GPT-4V will look into the page and process the
    highlighted information. As a brain, GPT will decide if it has already got a good
    answer to user‚Äôs questions.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a good answer, GPT will provide the answer back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If not, GPT-4V will decide which URL or click to visit for the next step. Puppeteer
    will again opens the new URL, highlight the interactive elements and take a screenshot
    for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: This process will repeat until GPT decides it has got a good answer for the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are now clear on how the AI agent works, let‚Äôs take a look at the architecture
    of the agent. The agent is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5a8375fa18a3f3434a9572dbdf104d0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Overview of the agent‚Äôs architecture
  prefs: []
  type: TYPE_NORMAL
- en: This architecture may look complex at first, but it‚Äôs actually quite simple
    once you understand the different components and how they work together. Let‚Äôs
    break it down.
  prefs: []
  type: TYPE_NORMAL
- en: Starting Out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the starting point of the workflow. The user interacts with the agent
    by providing a prompt which clarifies the task (`user task prompt`). At the same
    time, the agent gets some default instructions (`system prompt`), about how it
    should do its job. These instructions tell the agent what its role is, how to
    format its answers, and other important info.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs a simple view of the starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fffb4608e71295968f9cdae12e5bada0.png)'
  prefs: []
  type: TYPE_IMG
- en: The initial step
  prefs: []
  type: TYPE_NORMAL
- en: 'The example of the `user task prompt` might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here‚Äôs what the system prompt might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dd728c47d52c1476b78ddd1a127ed3d6.png)'
  prefs: []
  type: TYPE_IMG
- en: A typical system prompt that provides context for the agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Credit: [JayZeeDesign](https://github.com/JayZeeDesign/Scrape-anything---Web-AI-agent)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The system prompt is crucial because they help the agent decide how to act.
    The three main areas are highlighted in different colors:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the role of the agent. (Aqua)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the agent should present its answers. (Red)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra instructions to help the agent. (Yellow)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prompts are then sent to the openai service, which is responsible for generating
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on these prompts, the agent‚Äôs response will be shaped into only 3 types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{ "url": "https://www.example.com" }` - The agent wants to navigate to a specific
    webpage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{ "click": "text on a button" }` - The agent wants to click on a specific
    element on the page.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`regular message` - The agent has finished the task and extracted the required
    information to the user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the initial conversation, the response would normally be a Google search
    url, such as `https://www.google.com/search?q=AI+events+in+Melbourne+March`. This
    response would then trigger the browser-controller service to navigate to the
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code implementation of the starting point**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following function creates the interface in the terminal for the user to
    input their query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And you may notice the `promptMap` object in the code. It is a map of functions
    that returns all the prompts. Making it a function allows the prompts to be dynamic
    and change based on the context of the conversation. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An important note is that to allow the LLM to have the `memory` of the conversation,
    we need to always push the new prompts to the message array and send the whole
    array to the LLM. This could cause the explosion of the tokens. Use the `max_tokens`
    parameter to build the safe net.
  prefs: []
  type: TYPE_NORMAL
- en: Below is how to use the openai service to generate the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: And of course, to use `openai` service, you need to have the `openai` package
    installed and the API key. Here is a seperate file to handle the openai service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Pick the Right Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, the LLM response will be shaped into only 3 types.
    Each of these types will trigger a different browser-controller service to act
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6ca654ab4349b5e66c39e9985ead90bc.png)'
  prefs: []
  type: TYPE_IMG
- en: Agent choosing the optimal path guided by LLM feedback.
  prefs: []
  type: TYPE_NORMAL
- en: '**URL Response Flow**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response format { ‚Äúurl‚Äù: ‚Äú**[**https://www.example.com**](https://www.example.com)**"
    }**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indicate that the agent should navigate to a specific webpage.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**This response would trigger the following steps in the script:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the URL from the response
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Opens a browser using Puppeteer and navigates to the URL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent then takes a screenshot of the page and sends it with another special
    instruction prompt back to the LLM to analyze the content of the page and decide
    on the next steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/97229ad5607b2a6fcf9d24c47a1fe5a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Processing flow for ‚Äòurl‚Äô response messages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Click Response Flow**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Response format { ‚Äúclick‚Äù: ‚Äútext on a button‚Äù }**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Indicate that the agent should click on a specific element on the page.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The agent will undergo the following steps:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the link text from the response
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent then uses Puppeteer to find the element with the matching text and
    clicks on it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent takes a screenshot of the page and sends it with another special instruction
    prompt back to the LLM to analyze the content of the page and decide on the next
    steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/a2d29ca66285afcabd6ea669bf885bc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Processing flow for ‚Äòclick‚Äô response messages.
  prefs: []
  type: TYPE_NORMAL
- en: Let‚Äôs take a look at the `special instruction prompt` that the agent sends to
    the LLM after taking a screenshot of the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ff292db3f933db519ba4f04613fe2010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Credit: [JayZeeDesign](https://github.com/JayZeeDesign/Scrape-anything---Web-AI-agent)'
  prefs: []
  type: TYPE_NORMAL
- en: This prompt basically tells the LLM to analyze the screenshot of the page and
    decide on the next steps. The response format should be exactly as we mentioned
    in the system prompt. With LLMs, it‚Äôs often necessary to reiterate rules or guidelines
    to ensure consistent performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Regular Message Flow ‚Äî Regular message**'
  prefs: []
  type: TYPE_NORMAL
- en: Indicate that the agent has finished the task and extracted the required information
    to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is normally the end of the current task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent will simply display the information to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code implementation of the path selection**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A function that converts the **plain string response** from the LLM to the defined
    type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `Path Selection`, the code should have the following backbone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: IT IS A LOOP!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we are clear on the different paths the agent can take. One thing to note
    is that the agent will keep looping through these steps until the task is completed
    and respond with a regular message.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the loop is like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cece81855a5ee85556bb1ccc9b2efffb.png)'
  prefs: []
  type: TYPE_IMG
- en: The agent workflow is a loop!
  prefs: []
  type: TYPE_NORMAL
- en: The URL or Click Response Flow will be fired multiple times until the agent
    has found the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the loop, the code should have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: first, a helper function to determine when to stop the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, the main loop function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you may notice, we didn‚Äôt specify the regular message flow in the loop. This
    is because the regular message does not trigger any browser-controller service.
    It simply ends the loop and displays the message to the user, basically a `console.log`
    statement. Of course, you can add more logic to the regular message flow such
    as saving the message to a csv file, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Directory Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After understanding the main flow of the agent, let‚Äôs take a look at the directory
    structure of the agent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`agent.ts`: This is the main script for our agent. It orchestrates the other
    services and is responsible for the main execution flow of the agent. It contains
    the starting point, the main loop, and the path selection logic.'
  prefs: []
  type: TYPE_NORMAL
- en: '`services/`: This directory contains various services used by the agent. Each
    service is responsible for a specific task.'
  prefs: []
  type: TYPE_NORMAL
- en: 'browser-controller.ts: This service controls the browser using Puppeteer. It
    can navigate to pages, interact with elements, and take screenshots.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'data-transformer.ts: This service transforms data for the agent. It can format
    data, clean it, and prepare it for further processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'element-annotator.ts: This service annotates HTML elements for the agent. It
    can highlight elements, add unique identifiers to them, and more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'openai.ts: This service interfaces with the OpenAI API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'prompt-map.ts: This service maps user prompts to actions. It can determine
    what action the agent should take based on the user‚Äôs input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'user-prompt-interface.ts: This service interfaces with the user to get prompts.
    It can read user input and pass it to the agent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`utils.ts`: This file contains utility functions used by the agent. These functions
    are used throughout the agent code to perform common tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: For the full code implementation, please refer to the [Ai Web Agent](https://github.com/bianbianzhu/ai-web-agent).
  prefs: []
  type: TYPE_NORMAL
- en: Browser Controller Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let‚Äôs dive into how the agent controls the browser ‚Äî how its hands work.
    A library called `Puppeteer` is used here. It provides a high-level API over the
    Chrome DevTools Protocol. See the [Puppeteer documentation](https://pptr.dev/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, Puppeteer gets called after the agent receives a response from
    the LLM. Under different paths as we mentioned above, Puppeteer will execute different
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the browser-controller service is responsible for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to a URL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clicking on a link
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Taking a screenshot of the page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](../Images/3a30655d1ff49b52ff7e6a8eaa31cb5f.png)'
  prefs: []
  type: TYPE_IMG
- en: The tasks that Puppeteer would do in the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: There is, in fact, another step taken before the agent takes a screenshot of
    the page ‚Äî `Highlighting interactive elements`. We have separated this service
    into a different file to make the code more modular and easier to maintain. It
    will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code implementation of the browser-controller service**'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 ‚Äî Initialize the browser and open a new tab
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Based on different response flows, the agent would either navigate to a URL
    and take a screenshot, or click on a link which triggers a navigation and take
    a screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2 ‚Äî `URL Response Flow`: Navigate to a URL and take a screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `waitAndScreenshot` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The screenshot is simply taken by calling `page.screenshot()`. You may change
    the configuration to meet your needs.
  prefs: []
  type: TYPE_NORMAL
- en: The `waitTillHTMLRendered` function
  prefs: []
  type: TYPE_NORMAL
- en: As shown, the navigation to the URL is done via `page.goto()`. This method utilizes
    the `waitUntil` option for the page load. After the page is loaded, the agent
    takes a screenshot. It is very crucial to wait for all the visual content to be
    loaded before taking the screenshot to ensure the agent gets the full info of
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, in many cases, the `waitUntil` in `GoToOptions` (page.goto())
    is not enough to wait for the page to load completely (especially with dynamic
    loading content), so we need to use the custom function `waitTillHTMLRendered`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function basically checks if the page is still loading via `document.readyState`
    or if there is a loading indicator on the page. If the page is still loading,
    the function will call `waitTillHTMLRendered` to undertake a comprehensive check:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks the HTML size every second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the HTML size remains the same for 3 consecutive seconds, it assumes the
    page has finished loading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Throw error if the page is still loading after 30 seconds (timeout).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The flowchart below shows the logic of the `waitTillHTMLRendered` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5620f6b1b199b44699cdf9b89410420e.png)'
  prefs: []
  type: TYPE_IMG
- en: Flowchart of function `waitTillHTMLRendered.`
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a better understanding of the `waitAndScreenshot` function, let''s
    take a look at the log of the function in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/76781d17a83b9de376b0b37229a00f7c.png)'
  prefs: []
  type: TYPE_IMG
- en: Logs capturing dynamic content rendering.
  prefs: []
  type: TYPE_NORMAL
- en: After the page is **completely** loaded, all interactive elements are highlighted
    and a screenshot is taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2 (cont.) ‚Äî `Click Response Flow`: The `clickNavigationAndScreenshot`
    function'
  prefs: []
  type: TYPE_NORMAL
- en: This function is used to click on a specific element on the page and wait for
    the page to load completely and then take a screenshot. For the `click` action,
    it utilizes another function called `clickOnLink`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `clickOnLink` function
  prefs: []
  type: TYPE_NORMAL
- en: This function loops through all the elements with the `gpt-link-text` attribute
    (unique identifier received during element annotation) and clicks on the one that
    matches the link text provided by the LLM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Element Annotation Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let‚Äôs look deeper into the `highlightInteractiveElements` function that is called
    inside `waitAndScreenshot`.
  prefs: []
  type: TYPE_NORMAL
- en: It is a service that annotates the interactive HTML elements for the agent.
    It can highlight elements with a `red bounding box` and add unique identifiers
    to them.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine giving your AI agent a special pair of glasses that lets it see the
    interactive spots on a website ‚Äî the buttons, links, and fields ‚Äî like glowing
    treasures on a treasure map.
  prefs: []
  type: TYPE_NORMAL
- en: That‚Äôs essentially what the `highlightInteractiveElements` function does. It's
    like a highlighter for the digital world, sketching red boxes around clickable
    items and tagging them with digital nametags.
  prefs: []
  type: TYPE_NORMAL
- en: '**With the annotation, the accuracy of the agent‚Äôs interpretation of the image
    is largely improved**. This concept is called `Set-of-Mark Prompting`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the annotated screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b85a7f190d2179f011cdda31a784a805.png)'
  prefs: []
  type: TYPE_IMG
- en: E-commerce site with interactive elements highlighted in red. Image from Officeworks
    website.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a research paper discussing the importance of this topic in detail:
    [Set-of-Mark Prompting](https://arxiv.org/abs/2310.11441).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here‚Äôs how it performs:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts by removing any old digital nametags (html attribute `gpt-link-text`)
    that might confuse our AI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it lights up every clickable thing it finds with a red outline to help
    the AI spot where to ‚Äòclick‚Äô.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each interactive element gets a unique nametag. This tag/attribute will be used
    to identify the element that Puppeteer can later interact with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One key detail to remember is when dealing with puppeteer or any other testing
    framework that programmatically interacts with the web, the element with a link
    text may not be visible. Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The parent div is hidden, so the link is not visible. This element should be
    excluded. Recursive checking the parent element is necessary to ensure the element
    is visible. See below graph for the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/171f42e9c803a67604cb42a80db2a9c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Flowchart of function isElementVisible.
  prefs: []
  type: TYPE_NORMAL
- en: Code implementation of the `highlightInteractiveElements` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we have gone through the architecture of the AI agent, the
    code implementation of each step, and some concepts behind the design, such as
    Set-of-Mark Prompting. The agent is an elegant system that requires careful orchestration
    of different services to work effectively, and currently it has plenty of issues
    and limitations. If you have any questions or suggestions, please feel free to
    reach out to me. I would be happy to discuss this topic further.
  prefs: []
  type: TYPE_NORMAL
- en: Enjoyed This Story?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Jason Li** ([Tianyi Li](https://medium.com/u/4092d7367010), [LinkedIn](https://www.linkedin.com/in/tianyi-li-jason/))
    is a Full-stack Developer working at [Mindset Health](https://www.mindsethealth.com/)
    in Melbourne Australia. Jason is passionate about AI, front-end development and
    space related technologies.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selina Li** ([Selina Li](https://medium.com/u/7b9ea39b0d79), [LinkedIn](https://www.linkedin.com/in/selina-zhuohang-li-3b7355120/))
    is a Principal Data Engineer working at [Officeworks](https://www.officeworks.com.au/)
    in Melbourne Australia. Selina is passionate about AI/ML, data engineering and
    investment.'
  prefs: []
  type: TYPE_NORMAL
- en: Jason and Selina would love to explore technologies to help people achieve their
    goals.
  prefs: []
  type: TYPE_NORMAL
- en: '*Unless otherwise noted, all images are by the authors.*'
  prefs: []
  type: TYPE_NORMAL

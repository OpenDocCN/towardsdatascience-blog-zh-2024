["```py\nWITH beta_draws AS (\n SELECT\n (alpha — 1) / (alpha + beta — 2) AS a,\n (beta — 1) / (alpha + beta — 2) AS b\n FROM\n (SELECT 2 AS alpha, 5 AS beta) — Set your desired alpha and beta values\n)\nSELECT\n (a * POW(RAND(), alpha - 1) * POW(1 - RAND(), beta - 1) + b) AS beta_draw\nFROM\n beta_draws,\n UNNEST(GENERATE_ARRAY(1, 1000)) AS rand_num\n```", "```py\nWITH raw_data AS (\n SELECT\n ‘user_a’ AS contact_id\n , 0.674 AS probability\n , 72 AS lifetime_messages_received\n), parameters AS (\n SELECT\n contact_id\n , probability*lifetime_messages_received AS alpha\n , (1.0 — probability)*lifetime_messages_received AS beta\n , RAND() AS x\n FROM raw_data\n CROSS JOIN UNNEST(GENERATE_ARRAY(1, 1000)) AS draw_id\n)\nSELECT\n contact_id\n , ARRAY_AGG(POW(x, alpha — 1.0) * POW(1.0 — x, beta — 1)) AS beta_x\nFROM parameters\nGROUP BY contact_id\n```", "```py\nfrom scipy.stats import beta\n\nalpha_param = 0.674 * 72\nbeta_param = (1–0.674) * 72\n\nscipy_beta_draw = beta.rvs(alpha_param, beta_param, size=1000)\n```", "```py\nimport numpy as np\nfrom scipy.special import gamma\nfrom scipy.stats import uniform\n\nalpha_param = 0.674 * 72\nbeta_param = (1–0.674) * 72\n\nconstant = gamma(alpha_param + beta_param) / (gamma(alpha_param) * gamma(beta_param))\nscipy_manual_beta_draw = np.array([\n constant*pow(x, alpha_param-1)*pow(1-x, beta_param-1)\n for x in uniform.rvs(size=1000)\n])\n```", "```py\nimport numpy as np\nfrom scipy.special import gamma\nfrom scipy.stats import uniform, beta\n\nalpha_param = 0.674 * 72\nbeta_param = (1–0.674) * 72\nn_draws = 1000\n\n# Use SciPy RVS for comparison\nscipy_beta_draw = beta.rvs(alpha_param, beta_param, size=n_draws)\n\n# Manual beta draw with the help of the SciPy Gamma function\n\n# We start with a discrete analogue of the Beta PDF we wish to draw from.\n# This is just sampling from the PDF at fixed intervals but do check out\n# this review for a more in-depth treatment of the subject:\n# https://jsdajournal.springeropen.com/articles/10.1186/s40488-015-0028-6\n\n# Set the resolution for generating the discrete PDF\nn_samples = 1000\n\n# The beta distribution is supported on the range [0, 1], so we set the\n# pdf min and max parameters accordingly\npdf_min = 0.0\npdf_max = 1.0\n\nx_span = np.linspace(pdf_min, pdf_max, n_samples)\nconstant = gamma(alpha_param + beta_param) / (gamma(alpha_param) * gamma(beta_param))\nbeta_pdf = np.array([\n constant * pow(x, alpha_param — 1) * pow(1 — x, beta_param — 1)\n for x in x_span\n])\n\n# Using the discrete Beta PDF, we now compute a discrete Beta CDF.\n# To do that, we integrate the PDF. For each point x, we sum the PDF until\n# that point and multiple with the width of each sample.\nfreq = 1.0 / n_samples\nbeta_cdf = beta_pdf.cumsum() * freq\n\ndef inv(cdf, q):\n “””Return inverse CDF for value q using the quantile function”””\n return x_span[np.argmin(cdf < q)]\n\n# Finally, we can now draw n_draws from the discrete inverse of CDF, aka\n# generate random samples from a beta distribution\nmanual_beta_draw = np.array([\n inv(beta_cdf, x)\n for x in uniform.rvs(size=n_draws)\n])\n```", "```py\n — The following 3 parameters need to be adjusted based on the support of the\n — PDF of the distribution you wish to draw from. This values are set for a logistic\n — distribution with a=0 and b=1\n\nDECLARE pdf_min INT64 DEFAULT -10;\nDECLARE pdf_max INT64 DEFAULT 10;\nDECLARE n_samples INT64 DEFAULT 5000;\nDECLARE sampling_step FLOAT64 DEFAULT (pdf_max — pdf_min) / n_samples;\n\n— The number of random draws you wish to perform\nDECLARE n_draws INT64 DEFAULT 1000;\n\nWITH pdf AS (\n\n — The discrete sampling of the logistic distribution PDF\n\n SELECT\n x\n , exp(-x) / pow(1 + exp(-x), 2) AS y — a=0, b=1\n FROM UNNEST(GENERATE_ARRAY(pdf_min, pdf_max, sampling_step)) AS x\n), cdf AS (\n\n — The discrete CDF\n\n SELECT\n x\n , SUM(y)\n OVER (\n ORDER BY x\n ) * (1.0 / n_samples) AS y\n FROM pdf\n), random_draws AS (\n\n — Random draws in the range of [0, max(cdf)]\n\n SELECT\n RAND() * (SELECT MAX(y) FROM cdf) as q\n , draw_id\n FROM UNNEST(GENERATE_ARRAY(1, n_draws)) AS draw_id\n)\n\n — Calculate the inverse CDF per draw using the quantile function by generating\n — and array of the discrete support of the distribution and returning the value\n — of the index just before the randomly generated number is larger than the CDF\n\nSELECT\n ARRAY_AGG(x ORDER BY x)[OFFSET(SUM(CAST(y < q AS INT64)))] AS x\nFROM random_draws\nJOIN cdf\nON TRUE\nGROUP BY draw_id;\n```"]
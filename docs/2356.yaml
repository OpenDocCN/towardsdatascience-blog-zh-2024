- en: Depth-First Search — Fundamental Graph Algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/deep-first-search-fundamental-graph-algorithm-d22991d5c144?source=collection_archive---------16-----------------------#2024-09-26](https://towardsdatascience.com/deep-first-search-fundamental-graph-algorithm-d22991d5c144?source=collection_archive---------16-----------------------#2024-09-26)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Python recursive implementation of DFS algorithm with examples and step-by-step
    explanations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://robertkwiatkowski01.medium.com/?source=post_page---byline--d22991d5c144--------------------------------)[![Robert
    Kwiatkowski](../Images/94ec06b3647aef0b65fce2dd97972318.png)](https://robertkwiatkowski01.medium.com/?source=post_page---byline--d22991d5c144--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--d22991d5c144--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--d22991d5c144--------------------------------)
    [Robert Kwiatkowski](https://robertkwiatkowski01.medium.com/?source=post_page---byline--d22991d5c144--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--d22991d5c144--------------------------------)
    ·5 min read·Sep 26, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e102239d6a800cae7b1add7f322d78db.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Shubham Dhage](https://unsplash.com/@theshubhamdhage?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In computer science, algorithms are the backbone of various useful technologies
    (like AI), helping us efficiently tackle a wide range of real-life challenges.
    Among these, graph algorithms hold a special place due to their applicability
    as many problems can be modeled using graphs. A graph is a collection of nodes
    (or vertices) connected by edges, representing relationships (or connections)
    between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Social Networks:** In a social network, like Facebook or Instagram, users
    can be represented as nodes, and friendships or connections between them are edges.
    [[1](https://www.researchgate.net/publication/368287579_Graph_Models_of_Social_Media_Network_As_Applied_to_Facebook_and_Facebook_Messenger_Groups/citation/download)]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Route Planning and Navigation:** In maps, locations (cities, intersections,
    or landmarks) are modeled as nodes, and roads or paths between them are edges.
    [[2](https://www.sciencedirect.com/science/article/pii/S1877050920315799)]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web Crawling**: The web can be seen as a massive graph where web pages are
    nodes, and hyperlinks between them are edges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduling and Task Management**: Many task dependencies can be modeled as
    directed acyclic graphs (DAGs), where tasks are nodes and dependencies between
    them are edges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Connectivity**: In computer networks, devices (routers, computers)
    are nodes, and communication links are edges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the fundamental algorithms used to traverse or explore graphs is **Depth
    First Search (DFS)**. It is used to explore (visit) all nodes in the graph. Another,
    complementary and fundamental algorithm to accomplish that goal is called Breadth
    First Search (BFS) which will be a subject of a separate article.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will dive into how DFS works, with simple code, intuitive examples,
    and some cool animations showing you how this algorithm works step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: 'DFS can be implemented in two ways: iterative and recursive. Here, I’ll show
    you how to do it recursively as IMHO it is easier to understand and to code. This
    is also a fantastic opportunity to learn how recursion works if you’re not familiar
    with it yet. DFS implementation will be in pure Python.'
  prefs: []
  type: TYPE_NORMAL
- en: Below there is a code for the DFS algorithm itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three inputs to the function: a set of visited nodes (usually initially
    empty), a graph definition and a starting node. The logic is simple, yet effective:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. First, we check if we have visited a given node already
  prefs: []
  type: TYPE_NORMAL
- en: a. If yes, skip checking its neighbors
  prefs: []
  type: TYPE_NORMAL
- en: b. If no, print the node and start visiting its neighbors (the “for loop”)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Repeat, till all nodes are in the list of visited nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the function returns None (effectively nothing) because it prints
    the visited nodes and writes them to the set defined externally. We can change
    its behavior to return a set of all visited nodes without printing values like
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1**'
  prefs: []
  type: TYPE_NORMAL
- en: First, we must define our exemplary graph. For this, we’ll use the adjacency
    matrix as a Python dictionary. In each key-value pair, a key is a node, and a
    value is a list of nodes connected to it (neighbors).
  prefs: []
  type: TYPE_NORMAL
- en: Below is the code creating the first exemplary graph in the computer memory.
    In this case, it is a directed graph (for clarity and simplicity) but DFS works
    well for undirected ones too.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running a function call command the output is a series of nodes that
    were visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e42a0daac1b8eae9d701370902efba4c.png)'
  prefs: []
  type: TYPE_IMG
- en: '*image by author*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or with the alternative version of the code like below. Here we can just make
    a small change to the input not to use any global variable and pass an empty set
    directly. Output then is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2be81efa6ee462192689ee59ede3e39f.png)'
  prefs: []
  type: TYPE_IMG
- en: '*image by author*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s visualize how a functions stack and a final set is being built step-by-step.
    This is depicted on the animation below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/936f1ed77a81e5cf952a270f656fcdb3.png)'
  prefs: []
  type: TYPE_IMG
- en: '*image by author*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 2**'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will build and traverse a special kind of graph — a decision
    tree. A definition of the graph is below.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the DFS on this graph the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/be4a9512a550c4ff4c0ba87c7cd8e4bb.png)'
  prefs: []
  type: TYPE_IMG
- en: image by author
  prefs: []
  type: TYPE_NORMAL
- en: The animation below shows what the graph looks like and how DFS traversed it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7fa20b9ce3e24f8cadf6ec4f00bc1908.png)'
  prefs: []
  type: TYPE_IMG
- en: DFS traversing a tree; image by author
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: Depth First Search is an essential algorithm in graph theory, widely used across
    multiple domains from social networks to decision trees. Its recursive nature
    makes it easy to understand and implement, as demonstrated by the examples in
    this article. The simplicity of DFS, along with its ability to efficiently explore
    all nodes in a graph, makes it a powerful tool for solving various computational
    problems. Understanding how DFS works lays the groundwork for mastering other
    algorithms such as Breadth First Search (BFS) and path-finding algorithms like
    Dijkstra’s or A*.
  prefs: []
  type: TYPE_NORMAL
- en: Try experimenting with larger and more complex graphs, and explore how it behaves
    with different data structures. In future articles, we will explore other traversal
    methods like BFS and further investigate their use cases, advantages, and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Keep practicing and pushing your limits, and soon graph algorithms like DFS
    will become second nature. Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] Tsok, Samuel & Yakubu, Hosea & Solomon, Rwat. (2023). Graph Models of Social
    Media Network As Applied to Facebook and Facebook Messenger Groups. International
    Journal on Computer Science and Engineering. Vol. 9\. Pg 1\. 10.56201/ijcsmt.v9.no1.2023.pg1.12\.
    [[link](https://www.researchgate.net/publication/368287579_Graph_Models_of_Social_Media_Network_As_Applied_to_Facebook_and_Facebook_Messenger_Groups)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[2] Tianlun Dai, Wenchao Zheng, Jiayue Sun, Cun Ji, Tao Zhou, Mingtong Li,
    Wei Hu, Ziqiang Yu, Continuous Route Planning over a Dynamic Graph in Real-Time,
    Procedia Computer Science, Volume 174, 2020 [[link](https://www.sciencedirect.com/science/article/pii/S1877050920315799)]'
  prefs: []
  type: TYPE_NORMAL

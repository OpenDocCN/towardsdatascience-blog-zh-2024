["```py\nmountains = np.load(os.path.join(figure_path, 'mountains.npy'))\n\nH = mountains.shape[0]\nW = mountains.shape[1]\nprint('Mountain at Dusk is H =', H, 'and W =', W, 'pixels.')\nprint('\\n')\n\nfig = plt.figure(figsize=(10,6))\nplt.imshow(mountains, cmap='Purples_r')\nplt.xticks(np.arange(-0.5, W+1, 10), labels=np.arange(0, W+1, 10))\nplt.yticks(np.arange(-0.5, H+1, 10), labels=np.arange(0, H+1, 10))\nplt.clim([0,1])\ncbar_ax = fig.add_axes([0.95, .11, 0.05, 0.77])\nplt.clim([0, 1])\nplt.colorbar(cax=cbar_ax);\n#plt.savefig(os.path.join(figure_path, 'mountains.png'), bbox_inches='tight')\n```", "```py\nMountain at Dusk is H = 60 and W = 100 pixels.\n```", "```py\nP = 20\nN = int((H*W)/(P**2))\nprint('There will be', N, 'patches, each', P, 'by', str(P)+'.')\nprint('\\n')\n\nfig = plt.figure(figsize=(10,6))\nplt.imshow(mountains, cmap='Purples_r')\nplt.clim([0,1])\nplt.hlines(np.arange(P, H, P)-0.5, -0.5, W-0.5, color='w')\nplt.vlines(np.arange(P, W, P)-0.5, -0.5, H-0.5, color='w')\nplt.xticks(np.arange(-0.5, W+1, 10), labels=np.arange(0, W+1, 10))\nplt.yticks(np.arange(-0.5, H+1, 10), labels=np.arange(0, H+1, 10))\nx_text = np.tile(np.arange(9.5, W, P), 3)\ny_text = np.repeat(np.arange(9.5, H, P), 5)\nfor i in range(1, N+1):\n    plt.text(x_text[i-1], y_text[i-1], str(i), color='w', fontsize='xx-large', ha='center')\nplt.text(x_text[2], y_text[2], str(3), color='k', fontsize='xx-large', ha='center');\n#plt.savefig(os.path.join(figure_path, 'mountain_patches.png'), bbox_inches='tight')\n```", "```py\nThere will be 15 patches, each 20 by 20.\n```", "```py\nnp.random.seed(21)\nscramble_order = np.random.permutation(N)\nleft_x = np.tile(np.arange(0, W-P+1, 20), 3)\nright_x = np.tile(np.arange(P, W+1, 20), 3)\ntop_y = np.repeat(np.arange(0, H-P+1, 20), 5)\nbottom_y = np.repeat(np.arange(P, H+1, 20), 5)\n\nscramble = np.zeros_like(mountains)\nfor i in range(N):\n    t = scramble_order[i]\n    scramble[top_y[i]:bottom_y[i], left_x[i]:right_x[i]] = mountains[top_y[t]:bottom_y[t], left_x[t]:right_x[t]]\n\nfig = plt.figure(figsize=(10,6))\nplt.imshow(scramble, cmap='Purples_r')\nplt.clim([0,1])\nplt.hlines(np.arange(P, H, P)-0.5, -0.5, W-0.5, color='w')\nplt.vlines(np.arange(P, W, P)-0.5, -0.5, H-0.5, color='w')\nplt.xticks(np.arange(-0.5, W+1, 10), labels=np.arange(0, W+1, 10))\nplt.yticks(np.arange(-0.5, H+1, 10), labels=np.arange(0, H+1, 10))\nx_text = np.tile(np.arange(9.5, W, P), 3)\ny_text = np.repeat(np.arange(9.5, H, P), 5)\nfor i in range(N):\n    plt.text(x_text[i], y_text[i], str(scramble_order[i]+1), color='w', fontsize='xx-large', ha='center')\n\ni3 = np.where(scramble_order==2)[0][0]\nplt.text(x_text[i3], y_text[i3], str(scramble_order[i3]+1), color='k', fontsize='xx-large', ha='center');\n#plt.savefig(os.path.join(figure_path, 'mountain_scrambled_patches.png'), bbox_inches='tight')\n```", "```py\nn_tokens = 4\nl_tokens = 9\nshape = n_tokens, l_tokens\nmx = 20 #max integer for generated matricies\n\n# Generate Normal Matricies\nnp.random.seed(21)\nQ = np.random.randint(1, mx, shape)\nK = np.random.randint(1, mx, shape)\nV = np.random.randint(1, mx, shape)\n\n# Generate Row-Swapped Matricies\nswapQ = copy.deepcopy(Q)\nswapQ[[0, 2]] = swapQ[[2, 0]]\nswapK = copy.deepcopy(K)\nswapK[[0, 2]] = swapK[[2, 0]]\nswapV = copy.deepcopy(V)\nswapV[[0, 2]] = swapV[[2, 0]]\n\n# Plot Matricies\nfig, axs = plt.subplots(nrows=3, ncols=2, figsize=(8,8))\nfig.tight_layout(pad=2.0)\nplt.subplot(3, 2, 1)\nmat_plot(Q, 'Q')\nplt.subplot(3, 2, 2)\nmat_plot(swapQ, r'$Q_S$')\nplt.subplot(3, 2, 3)\nmat_plot(K, 'K')\nplt.subplot(3, 2, 4)\nmat_plot(swapK, r'$K_S$')\nplt.subplot(3, 2, 5)\nmat_plot(V, 'V')\nplt.subplot(3, 2, 6)\nmat_plot(swapV, r'$V_S$')\n```", "```py\nA = Q @ K.transpose()\nswapA = swapQ @ swapK.transpose()\nmodA = copy.deepcopy(A)\nmodA[[0,2]] = modA[[2,0]] #swap rows\nmodA[:, [2, 0]] = modA[:, [0, 2]] #swap cols\n\nfig, axs = plt.subplots(nrows=1, ncols=3, figsize=(8,3))\nfig.tight_layout(pad=1.0)\nplt.subplot(1, 3, 1)\nmat_plot(A, r'$A = Q*K^T$')\nplt.subplot(1, 3, 2)\nmat_plot(swapA, r'$A_S = Q_S * K_S^T$')\nplt.subplot(1, 3, 3)\nmat_plot(modA, 'A\\nwith rows [0,2] swaped\\n and cols [0,2] swaped')\n```", "```py\nA = A @ V\nswapA = swapA @ swapV\nmodA = copy.deepcopy(A)\nmodA[[0,2]] = modA[[2,0]] #swap rows\n\nfig, axs = plt.subplots(nrows=2, ncols=2, figsize=(12, 7))\nfig.tight_layout(pad=1.0)\nplt.subplot(2, 2, 1)\nmat_plot(A, r'$A = A*V$')\nplt.subplot(2, 2, 2)\nmat_plot(swapA, r'$A_S = A_S * V_S$')\nplt.subplot(2, 2, 4)\nmat_plot(modA, 'A\\nwith rows [0,2] swaped')\naxs[1,0].axis('off')\n```", "```py\ndef get_sinusoid_encoding(num_tokens, token_len):\n    \"\"\" Make Sinusoid Encoding Table\n\n        Args:\n            num_tokens (int): number of tokens\n            token_len (int): length of a token\n\n        Returns:\n            (torch.FloatTensor) sinusoidal position encoding table\n    \"\"\"\n\n    def get_position_angle_vec(i):\n        return [i / np.power(10000, 2 * (j // 2) / token_len) for j in range(token_len)]\n\n    sinusoid_table = np.array([get_position_angle_vec(i) for i in range(num_tokens)])\n    sinusoid_table[:, 0::2] = np.sin(sinusoid_table[:, 0::2])\n    sinusoid_table[:, 1::2] = np.cos(sinusoid_table[:, 1::2]) \n\n    return torch.FloatTensor(sinusoid_table).unsqueeze(0)\n```", "```py\nPE = get_sinusoid_encoding(num_tokens=176, token_len=768)\n```", "```py\nfig = plt.figure(figsize=(10, 8))\nplt.imshow(PE[0, :, :], cmap='PuOr_r')\nplt.xlabel('Along Length of Token')\nplt.ylabel('Individual Tokens');\ncbar_ax = fig.add_axes([0.95, .36, 0.05, 0.25])\nplt.clim([-1, 1])\nplt.colorbar(label='Value of Position Encoding', cax=cbar_ax);\n#plt.savefig(os.path.join(figure_path, 'fullPE.png'), bbox_inches='tight')\n```", "```py\nfig = plt.figure()\nplt.imshow(PE[0, :, 0:301], cmap='PuOr_r')\nplt.xlabel('Along Length of Token')\nplt.ylabel('Individual Tokens');\ncbar_ax = fig.add_axes([0.95, .2, 0.05, 0.6])\nplt.clim([-1, 1])\nplt.colorbar(label='Value of Position Encoding', cax=cbar_ax);\n#plt.savefig(os.path.join(figure_path, 'zoomedinPE.png'), bbox_inches='tight')\n```", "```py\nfig = plt.figure(figsize=(10,6))\nplt.imshow(mountains, cmap='Purples_r')\nplt.hlines(np.arange(P, H, P)-0.5, -0.5, W-0.5, color='w')\nplt.vlines(np.arange(P, W, P)-0.5, -0.5, H-0.5, color='w')\nplt.xticks(np.arange(-0.5, W+1, 10), labels=np.arange(0, W+1, 10))\nplt.yticks(np.arange(-0.5, H+1, 10), labels=np.arange(0, H+1, 10))\nx_text = np.tile(np.arange(9.5, W, P), 3)\ny_text = np.repeat(np.arange(9.5, H, P), 5)\nfor i in range(1, N+1):\n    plt.text(x_text[i-1], y_text[i-1], str(i), color='w', fontsize='xx-large', ha='center')\nplt.text(x_text[2], y_text[2], str(3), color='k', fontsize='xx-large', ha='center')\ncbar_ax = fig.add_axes([0.95, .11, 0.05, 0.77])\nplt.clim([0, 1])\nplt.colorbar(cax=cbar_ax);\n#plt.savefig(os.path.join(figure_path, 'mountain_patches_w_colorbar.png'), bbox_inches='tight')\n```", "```py\ntokens = np.zeros((15, 20**2))\nfor i in range(15):\n    patch = gray_mountains[top_y[i]:bottom_y[i], left_x[i]:right_x[i]]\n    tokens[i, :] = patch.reshape(1, 20**2)\ntokens = tokens.astype(int)\ntokens = tokens/255\n\nfig = plt.figure(figsize=(10,6))\nplt.imshow(tokens, aspect=5, cmap='Purples_r')\nplt.xlabel('Length of Tokens')\nplt.ylabel('Number of Tokens')\ncbar_ax = fig.add_axes([0.95, .36, 0.05, 0.25])\nplt.clim([0, 1])\nplt.colorbar(cax=cbar_ax)\n```", "```py\nPE = get_sinusoid_encoding(num_tokens=15, token_len=400).numpy()[0,:,:]\nfig = plt.figure(figsize=(10,6))\nplt.imshow(PE, aspect=5, cmap='PuOr_r')\nplt.xlabel('Length of Tokens')\nplt.ylabel('Number of Tokens')\ncbar_ax = fig.add_axes([0.95, .36, 0.05, 0.25])\nplt.clim([0, 1])\nplt.colorbar(cax=cbar_ax)\n```", "```py\nmountainsPE = tokens + PE\nresclaed_mtPE = (position_mountains - np.min(position_mountains)) / np.max(position_mountains - np.min(position_mountains))\n\nfig = plt.figure(figsize=(10,6))\nplt.imshow(resclaed_mtPE, aspect=5, cmap='Purples_r')\nplt.xlabel('Length of Tokens')\nplt.ylabel('Number of Tokens')\ncbar_ax = fig.add_axes([0.95, .36, 0.05, 0.25])\nplt.clim([0, 1])\nplt.colorbar(cax=cbar_ax)\n```"]
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>How Bend Works: A Parallel Programming Language That “Feels Like Python but Scales Like CUDA”</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>How Bend Works: A Parallel Programming Language That “Feels Like Python but Scales Like CUDA”</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/how-bend-works-a-parallel-programming-language-that-feels-like-python-but-scales-like-cuda-48be5bf0fc2c?source=collection_archive---------1-----------------------#2024-06-26">https://towardsdatascience.com/how-bend-works-a-parallel-programming-language-that-feels-like-python-but-scales-like-cuda-48be5bf0fc2c?source=collection_archive---------1-----------------------#2024-06-26</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="15d8" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">A brief introduction to Lambda Calculus, Interaction Combinators, and how they are used to parallelize operations on Bend / HVM.</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@lucasdelimanogueira?source=post_page---byline--48be5bf0fc2c--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Lucas de Lima Nogueira" class="l ep by dd de cx" src="../Images/76edd8ee4005d4c0b8bd476261eb06ae.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*6SXwrSnYs8I7IjjWUJsIQg.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--48be5bf0fc2c--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@lucasdelimanogueira?source=post_page---byline--48be5bf0fc2c--------------------------------" rel="noopener follow">Lucas de Lima Nogueira</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--48be5bf0fc2c--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">22 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Jun 26, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">9</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/398ffec82c1dd32cf300f28b5c5ae933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u0W_UXjwFVdTxh9x2YkxVg.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author</figcaption></figure><h1 id="be55" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Introduction</h1><p id="8abf" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">If you are reading this article, you probably recently heard about Bend, a new programming language that aims to be massively parallel but without you worrying about things like threads creation, and other common parallel programming terms.</p><p id="c21e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">If you do not know what I am talking about, watch the video below:</p><figure class="mm mn mo mp mq mr"><div class="oz io l ed"><div class="pa pb l"/></div></figure><p id="4317" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">They claim “<strong class="oa fr"><em class="pc">it feels like Python, but scales like CUDA”.</em></strong> As an enthusiast of parallel programming, it caught my attention immediately. After some reading, I found that Bend is powered by HVM (Higher-Order Virtual Machine), the runtime where the magic happens. That is, in a Bend program, the Bend code is compiled into HVM, which does some magic to run this program in an inherently parallel manner. In some way, all operations that can be parallelized are automatically parallelized by this runtime.</p><p id="ca99" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Straight away, I wanted to learn how all of the HVM magic happens. How can all of this be possible? After some reading, I learned that the magic behind HVM is mostly based on Interaction Combinators, which is a model of computation based on graphs and graphical rules developed by Yves Lafont in the 1990s. So, I opened the Lafont <a class="af pd" href="https://core.ac.uk/download/pdf/81113716.pdf" rel="noopener ugc nofollow" target="_blank">paper</a>, rolled some pages and saw this:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pe"><img src="../Images/8dd7792bc5d746abcd3c81f8bbbb06bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8JOziv56pXuryLhUbP11kA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">???? Interaction Combinators alien code. Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="8dab" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">I felt like I was in that movie <em class="pc">Arrival</em>, where the aliens try to communicate with us using a strange symbolic language.</p><p id="22e0" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">That’s when I closed the laptop and gave up on trying to understand that.</p><p id="b9b5" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">A while later, when I turned on my machine again, those symbols were there, staring at me, as if they were asking me to be understood.</p><p id="1e5c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">After a lot of reading, watching videos and alien help, I somehow started to understand this thing.</p><p id="3223" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The purpose of this article is to briefly clarify how all the HVM magic happens and facilitate your further understanding by explaining some common terms you might find during your learning journey. In order to do that, we need to first learn some basic concepts.</p><h1 id="05c7" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">λ-Calculus (Lambda Calculus)</h1><p id="2b33" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">The Lambda Calculus is a formal system in mathematical logic created by Alonzo Church in the 1930s. Its purpose was to investigate some aspects of logic theory from a purely mathematical point of view. Church was aiming to define what is computability in mathematical terms (what can be calculated using a set of fundamental rules). Let’s start:</p><p id="be06" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">You probably have already used Lambda Calculus before. For example, imagine a function to multiply a number by two:</p><p id="100a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">f(x) = 2 * x</p><p id="b280" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">On Python, you can express a named function for that like this:</p><pre class="mm mn mo mp mq pf pg ph bp pi bb bk"><span id="2655" class="pj nd fq pg b bg pk pl l pm pn">def multiply_by_two(x):<br/>    return 2 * x<br/><br/>print(multiply_by_two(2))<br/># 4</span></pre><p id="d2bc" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">But you can also express that using lambdas, which are basically an anonymous function:</p><pre class="mm mn mo mp mq pf pg ph bp pi bb bk"><span id="f900" class="pj nd fq pg b bg pk pl l pm pn">multiply_by_two_lambda = lambda x: x * 2<br/><br/>print(multiply_by_two_lambda(2))<br/># 4</span></pre><p id="820b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">So, let’s go back to mathematics. In Lambda Calculus, you express this same function using the notation<em class="pc"> λx.2x, </em>where <em class="pc">x </em>is the the <em class="pc">parameter</em> and <em class="pc">2x</em> the <em class="pc">body.</em></p><p id="81bc" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λ&lt;parameter&gt;.&lt;body&gt;</em></p><p id="3dc8" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This is called an <em class="pc">abstraction. </em>An abstraction <em class="pc">λx.t </em>denotes an anonymous function that takes a single input variable <em class="pc">x </em>and returns<em class="pc"> t. </em>For example, <em class="pc">λx.(x²+2x) </em>is an abstraction representing the function f defined by f(x) = x²+2x. So, an abstraction basically defines a function but does not invoke it.</p><p id="c4eb" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">You can also have a term like <em class="pc">λx.(x+y)</em>, which is the definition of f(x) = x+y. Here, <em class="pc">y</em> has not been defined yet. The expression <em class="pc">λx.(x+y) </em>is a valid abstraction and represents a function that adds its input to the yet-unknown <em class="pc">y.</em></p><p id="5eca" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">If using <em class="pc">λx.2x </em>defines a function, <em class="pc">(λx.2x)a “</em>calls” a function with argument “<em class="pc">a”</em>. That is, we basically substitute the variable “x” with “a”.</p><p id="811e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">f(x) = 2x</p><p id="6d6a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">f(2) = 4</p><p id="d9f6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This is the same as:</p><p id="d67e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λx.2x</em></p><p id="c959" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λx.2x)2 = 4</em></p><p id="4dbe" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This is called an <em class="pc">application. </em>We are “applying” the <em class="pc">abstraction (λx.2x) </em>to the number <em class="pc">2.</em></p><p id="70a6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">You can also apply a lambda expression to another lambda expression, such as nested functions:</p><p id="4f7d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Take f(x) = 2x and g(x) = x³</p><p id="54be" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">And you want g(f(x)):</p><p id="e4ad" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">You can express this using lambda expressions:</p><p id="4597" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λx.2x</em></p><p id="fd9f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λx.x³</em></p><p id="a62b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">=&gt; (λx.x³)(λx.2x)</em></p><p id="7821" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Do not try to solve it for now, first understand the notation, and further I will show you how to solve it!</p><p id="1e10" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">It’s important to not confuse the parenthesis. For example:</p><p id="a70e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">1 — λx.((λx.x)x) </em>is an <em class="pc">abstraction </em>(function definition).</p><p id="f408" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">2 — (λx.(λx.x))x </em>is an<em class="pc"> application</em> (funtion application)<em class="pc">.</em></p><p id="1b0a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">On the Example 1, we are defining a function <em class="pc">λx.B</em>, where B is the expression (<em class="pc">λx.x)x, </em>which is the anonymous function <em class="pc">λx.x </em>applied to the input x.</p><p id="f2fe" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">On Example 2, we are applying the anonymous function <em class="pc">λx.(λx.x) </em>to the input<em class="pc"> x.</em></p><p id="ce18" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">Applications </em>can also be represented as <em class="pc">f</em> <em class="pc">x </em>(applying function <em class="pc">f </em>to the variable <em class="pc">x</em>).</p><p id="4961" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">We can also represent functions with <em class="pc">n</em> parameters using Lambda Calculus. This can be done by using nested functions, each taking a single parameter: <em class="pc">f(x,y,z) → λx.</em>λy.λz</p><p id="6b01" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Thus, <em class="pc">f(x, y, z) = x + y + z </em>can be expressed by the <em class="pc">abstraction:</em></p><p id="4b86" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λx.</em>λy.λz.(x + y + z).</p><p id="e2aa" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Using this <em class="pc">abstraction</em> we can construct <em class="pc">applications</em>:</p><p id="7a4a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λx.</em>λy.λz.(x + y + z))1 2 3 =&gt; 6</p><p id="5d95" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">When studying Lambda Calculus, there are also two common terms you might find:</p><p id="31bc" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Alpha conversion (<strong class="oa fr">α-conversion</strong>) and Beta reduction (<strong class="oa fr">β-reduction)</strong></p><h2 id="0b8c" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Alpha conversion</h2><p id="15f9" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">When evaluating more complex lambda expressions, you may obtain some expression like this:</p><p id="e89e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λx.(λx.x+x)x)</em></p><p id="8243" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In this expression, the inner <em class="pc">x </em>could be mistakenly interpreted as the outer <em class="pc">x</em>. In order to avoid that, we can rename the inner variable x:</p><p id="c5c2" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λx.(λy.y+y)x)</em></p><p id="c5e0" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This process is what it is called <em class="pc">α-conversion, </em>the name seems something complex, but it is this simple renaming of a variable to avoid mistakes.</p><p id="e23a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λx.x → λy.y (α-conversion)</em></p><p id="4fad" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Both expressions represents the same function. The <em class="pc">α-conversion </em>does not change the function’s behavior, just the variable name.</p><h2 id="5d04" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Beta reduction</h2><p id="0cac" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk"><em class="pc">β-reduction </em>is simply the process of calculating the result from an application of a function to an expression. For instance:<br/><em class="pc">(λx.xy)z</em></p><p id="036f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">On the output <em class="pc">xy, </em>substitute every occurrence of x by z</p><p id="8d2f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">= <em class="pc">zy</em></p><p id="6036" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">You also might found the following notation:</p><p id="1d45" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λ param . output)input =&gt; output [param := input] =&gt; result</em></p><p id="f16d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This basically means that to get the result, you look at the <em class="pc">output</em> and substitute every occurrence of <em class="pc">param</em> by the <em class="pc">input. </em>In the previous expression:</p><p id="471d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λx.xy)z =&gt; (xy)[x := z] =&gt; zy</em></p><h2 id="7e77" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Example</h2><p id="dc5b" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Going back to our example f(x) = 2x; g(x) = x³ and we want g(f(1)).</p><p id="324a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In order to not mix up terms incorrectly, we can rewrite:</p><p id="8152" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">f(x) = 2x and g(y) = y³</p><p id="e280" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Then, we substitute f within g:</p><p id="a00d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">g(f(1)) = (f(1))³</p><p id="d170" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">=&gt; g(f(1)) = (2*1)³</p><p id="25a9" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">=&gt; 8*x = 8.</p><p id="2b9a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now with Lambda Calculus:</p><p id="9328" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λx.2x</em></p><p id="fcca" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λx.x³</em></p><p id="9d4b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">=&gt; (λx.x³)((λx.2x)1)</em></p><p id="da0f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">First, apply <em class="pc">α-conversion </em>in order to not mix up things:</p><p id="37b0" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λy.y³)((λx.2x)1)</em></p><p id="29cd" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Then, <em class="pc">β-reduction </em>on the inner most expression <em class="pc">(λx.2x)1:</em></p><p id="aed5" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λ param . output)input =&gt; output [param := input] =&gt; result</em></p><p id="169e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λx.2x)1 =&gt; 2x [x := 1] =&gt; 2*1 = 2.</em></p><p id="520b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Then, <em class="pc">β-reduction </em>again on the resulting expression <em class="pc">(λy.y³)2:</em></p><p id="93e1" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λ param . output)input =&gt; output [param := input] =&gt; result</em></p><p id="b498" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λy.y³)2 =&gt; y³[y := 2] =&gt; 2³ =&gt; 8.</em></p><p id="16d7" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">We got the same result! That’s brilliant right?</p><p id="b349" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">_________________________________________________________________</p><p id="ef33" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">⚠️ If you’re starting to feel confused at this point, please don’t close the article!! I understand it can be challenging at first, but I promise you, when you sleep today, you will wake up with things more clear! So, keep reading and enjoy the rest of the article :)</p><p id="4e6f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">_________________________________________________________________</p><p id="16e3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Some years after the Lambda Calculus, Alan Turing introduced the concept of Turing machines, an abstract mathematical model of a computer capable of simulating any algorithmic process that can be described mathematically. Building on the work of both Church and Turing, it was established that there exists a theoretical equivalence between Lambda Calculus and Turing machines. This equivalence means that, despite not having numbers or booleans, any problem computable by a Turing machine can also be expressed in Lambda Calculus terms. Thus, we can express any computable algorithm using Lambda Calculus!! Let’s understand how this can be done.</p><h2 id="4a43" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Numbers</h2><p id="a602" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">I mentioned that Lambda Calculus does not have numbers, only lambda expressions. But then how could I have written things like <em class="pc">λx.(x+2) </em>before?</p><p id="814e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Well, I lied to you… 😞</p><p id="83da" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">But don’t get angry, it was only to facilitate understanding 😀</p><p id="0233" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now, let’s understand how Church represented numbers using only lambda expressions:</p><p id="176a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The Church representation of numerals is a bit complicated to understand at the beginning but it will get clearer further.</p><p id="26be" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The chuch numeral <code class="cx qf qg qh pg b">n</code> is defined as a function that takes a function <code class="cx qf qg qh pg b">f</code> and returns the application of <code class="cx qf qg qh pg b">f</code> to its argument <code class="cx qf qg qh pg b">n</code> times.</p><p id="0164" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">0: λf.λx.x (applies <code class="cx qf qg qh pg b">f</code> to <code class="cx qf qg qh pg b">x</code> 0 times)</p><p id="f157" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">1: λf.λx.f x (applies <code class="cx qf qg qh pg b">f</code> to <code class="cx qf qg qh pg b">x</code> 1 time)</p><p id="f627" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">2: λf.λx.f(f x) (applies <code class="cx qf qg qh pg b">f</code> to <code class="cx qf qg qh pg b">x</code> 2 times)</p><p id="6ef4" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">3: λf.λx.f(f(f x)) (applies <code class="cx qf qg qh pg b">f</code> to <code class="cx qf qg qh pg b">x</code> 3 times)</p><p id="008e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">and so on…</p><p id="a4fe" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">It seems confusing, but after some though, it starts to make sense. The church numeral <code class="cx qf qg qh pg b">n</code> simply means to do anything <code class="cx qf qg qh pg b">n</code> times.</p><p id="b23f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">A good way to illustrate this is to remember that the idea of numbers comes from the process of counting. For example, imagine that you have a stair with 20 steps. When it is said that to climb the stairs you have to go up 20 steps, it means that you will climb one step 20 times, right? That’s exactly the same idea of Church encoding: You have a function <code class="cx qf qg qh pg b">f</code> that means ‘go up one step’ and if you want to express the idea of 20 steps, you apply <code class="cx qf qg qh pg b">f</code> <code class="cx qf qg qh pg b">20 </code>times.</p><h2 id="1983" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Numerical Operations</h2><p id="7326" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">After defining the Church numerals, we can define the numerical operations. The first one is to define a successor function <strong class="oa fr"><em class="pc">s</em></strong>. It is basically a function that increments a Church numeral by 1. Thus, the successor is a function that takes a Church numeral representing the number <code class="cx qf qg qh pg b">n</code> and returns a Church numerical representation of <code class="cx qf qg qh pg b">n+1</code>.</p><p id="b997" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">For example, if λf.λx.f(f x) represents the number 2, if we apply the successor function <strong class="oa fr">s </strong>to that, we will get λf.λx.f(f(f x)) (Church numerical representation of number 3).</p><p id="c63d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The successor function is defined as follows:</p><p id="a7ff" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">s(n) =λn.λf.λx.f((n f) x), </em>where <code class="cx qf qg qh pg b">n</code> is the Church numeral <code class="cx qf qg qh pg b">n</code>.</p><p id="8f0e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Let’s analyze it:</p><ul class=""><li id="f114" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot qi qj qk bk"><strong class="oa fr">Input</strong>: <code class="cx qf qg qh pg b">n</code> (a Church numeral), <code class="cx qf qg qh pg b">f</code> (a function), and <code class="cx qf qg qh pg b">x</code> (an argument)</li><li id="1fc1" class="ny nz fq oa b go ql oc od gr qm of og oh qn oj ok ol qo on oo op qp or os ot qi qj qk bk"><strong class="oa fr"><em class="pc">Application</em> of n</strong>: The term <code class="cx qf qg qh pg b">(nf)x</code> represents the application of the function <code class="cx qf qg qh pg b">f</code> to the argument <code class="cx qf qg qh pg b">x</code> <code class="cx qf qg qh pg b">n</code> times.</li><li id="67b5" class="ny nz fq oa b go ql oc od gr qm of og oh qn oj ok ol qo on oo op qp or os ot qi qj qk bk"><strong class="oa fr">Additional Application</strong>: The term <code class="cx qf qg qh pg b">f((nf)x)</code> applies <code class="cx qf qg qh pg b">f</code> one more time to the result of <code class="cx qf qg qh pg b">(nf)x</code>.</li></ul><p id="4add" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">If the Church numeral <code class="cx qf qg qh pg b">n</code> means to do something <code class="cx qf qg qh pg b">n</code> times, <code class="cx qf qg qh pg b">s n</code> means do something <code class="cx qf qg qh pg b">n+1</code> times.</p><p id="bad8" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Let’s for example apply the successor function to the Church numeral for 1:</p><p id="358f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr">Church numeral for 2</strong>: <a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><em class="pc">λf.λx.f(f x)</em></a></p><p id="376b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr">Applying successor of this expression:</strong></p><p id="35e6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">We know that<em class="pc"> s(n) = λn.λf.λx.f((n f) x)</em></p><p id="b88c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Our n = 2 = <a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><em class="pc">λf.λx.f(f x)</em></a></p><p id="4349" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Thus, we apply the successor function on that:</p><p id="ff63" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">s(<a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">λf.λx.f(f x)</strong></a><em class="pc">) = ( λn.λf.λx.f((n f) x) )( </em><a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">λf.λx.f(f x)</strong></a><em class="pc"> )</em></p><p id="f1e2" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Using the first <em class="pc">β-reduction </em>on the <em class="pc">application </em>expression<em class="pc">:</em></p><p id="1b41" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(λ param . output)input =&gt; output [param := input] =&gt; result</em></p><p id="977f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">( λn.λf.λx.f((n f) x) )( </em><a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">λf.λx.f(f x)</strong></a><em class="pc"> ) =&gt; λf.λx.f((n f) x) [n := </em><a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">λf.λx.f(f x)</strong></a><strong class="oa fr">]</strong></p><p id="3dba" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">=&gt; <em class="pc">λf.λx.f((</em><a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">λf.λx.f(f x)</strong></a><strong class="oa fr"> </strong><em class="pc">f x)</em></p><p id="7ded" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now, let’s analyze the inner <em class="pc">application </em>expression:</p><p id="b5e8" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(</em><a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">λf.λx.f(fx)</strong></a><strong class="oa fr"> </strong><em class="pc">f x</em></p><p id="c910" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The underlined term is the Church numeral 2, right? And it can be read as:</p><p id="e4ed" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Given a function <em class="pc">f</em>, apply <em class="pc">f</em> 2 times to its argument, which is<em class="pc"> x.</em></p><p id="5f71" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">(</em><a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">λf.λx.f(fx)</strong></a><strong class="oa fr"> </strong><em class="pc">f x </em>turns into<em class="pc"> f(f x)</em></p><p id="4b9c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Substituting on our expression <em class="pc">λf.λx.f((</em><a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr">λf.λx.f(fx)</strong></a><strong class="oa fr"> </strong><em class="pc">f x), </em>we get:</p><p id="7fe7" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λf.λx.f(f(f x)), </em>which is exactly the Church numerical representation of the number 3!</p><p id="5bfe" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">So, we just defined the successor lambda operation. By using this idea, if we define 0 = λf.λx.x, we can obtain the other Church numerals using the successor function recursively:</p><p id="e199" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">1 = <strong class="oa fr">s</strong> <strong class="oa fr">0</strong></p><p id="2868" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">2 = s(<strong class="oa fr">s</strong> <strong class="oa fr">0</strong>)</p><p id="a86b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">3 = <strong class="oa fr">s</strong>(<strong class="oa fr">s</strong>(<strong class="oa fr">s</strong> <strong class="oa fr">0</strong>))</p><p id="3349" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">…</p><p id="2cd3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">We can take advantage of this functions to implement other operations such as addition and multiplication.</p><p id="c80c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The addition of two numbers m + n is defined as:</p><p id="a8dc" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">ADD(m, n) = λm.λn.λf.λx.(m f)((n f) x)</em></p><p id="7268" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Thus, if we define <em class="pc">m</em> and <em class="pc">n</em> as the Church numerical representations of 3 and 4, respectively, and then apply this ADD function, we will get the Church numerical representation of 7.</p><p id="9cbd" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The same logic applies to multiplication of two numbers m * n:</p><p id="0153" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">MUL(m, n) = λm.λn.λf.λx.m (n f)</em></p><p id="82e7" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Try to apply yourself anytime!</p><h2 id="28bf" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Booleans</h2><p id="46f2" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Before we get into the Church definitions, let’s think of booleans as some operation that we can do for <em class="pc">selection. </em>Among two options A and B, depending on some condition, we select A or B.</p><p id="5614" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><code class="cx qf qg qh pg b">IF [CONDITION] THEN [RESULT A] ELSE [RESULT B]</code>.</p><p id="b0d2" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">For example, during some app execution, if we want to use booleans to change the background color of the screen:</p><p id="6aac" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">“red_theme = True”</p><p id="17d3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This will only be useful when at some other part of the program we do some <em class="pc">selection:</em></p><p id="348b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">background_color = IF red_theme THEN red ELSE white.</p><p id="a95b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Thus, all we need from booleans is some manner of conditionally selecting two options.</p><p id="d45d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Based on that, in Lambda Calculus, the Church definition of <em class="pc">true</em> and <em class="pc">false</em> are defined as functions of two parameters:</p><ul class=""><li id="3333" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot qi qj qk bk"><em class="pc">true</em> chooses the first parameter.</li><li id="67ed" class="ny nz fq oa b go ql oc od gr qm of og oh qn oj ok ol qo on oo op qp or os ot qi qj qk bk"><em class="pc">false</em> chooses the second parameter.</li></ul><p id="1fc2" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">TRUE</em> = <em class="pc">λx.λy.x</em></p><p id="b001" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">FALSE</em> = <em class="pc">λx.λy.y</em></p><p id="3174" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">It seems strange, right? But let’s define some boolean operations and see how it goes:</p><p id="126d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr">NOT</strong>: Takes a Boolean and returns the opposite.</p><p id="34fa" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><code class="cx qf qg qh pg b">NOT = λp. p FALSE TRUE</code></p><p id="2669" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This means: “Take a Boolean function <code class="cx qf qg qh pg b">p</code>. Apply <code class="cx qf qg qh pg b">p</code> to the two parameters <code class="cx qf qg qh pg b">FALSE</code> <code class="cx qf qg qh pg b">TRUE</code>."</p><p id="9325" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Remember the definition of booleans on Church enconding? <em class="pc">TRUE</em> returns the first parameter and <em class="pc">FALSE</em> returns the second parameter? Thus:</p><p id="3ffd" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">→ If <code class="cx qf qg qh pg b">p</code> is <code class="cx qf qg qh pg b">TRUE</code>, it returns <code class="cx qf qg qh pg b">FALSE</code>.</p><p id="8a33" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">→ If <code class="cx qf qg qh pg b">p</code> is <code class="cx qf qg qh pg b">FALSE</code>, it returns <code class="cx qf qg qh pg b">TRUE</code>.</p><p id="d0ea" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr">AND</strong>: Takes two Booleans and returns <em class="pc">TRUE</em> if both are <em class="pc">TRUE</em>, otherwise FALSE.</p><p id="2162" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><code class="cx qf qg qh pg b">AND = λp.λq.p q p</code></p><p id="a252" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This means: “Take two Boolean functions <code class="cx qf qg qh pg b">p</code> and <code class="cx qf qg qh pg b">q</code>. Apply <code class="cx qf qg qh pg b">p</code> to <code class="cx qf qg qh pg b">q</code> and <code class="cx qf qg qh pg b">p</code>."</p><p id="82d6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Let’s try on practice:</p><p id="65e1" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">AND TRUE FALSE</em> = (<em class="pc">λp.λq.p q p) TRUE FALSE:</em></p><p id="b266" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Given <em class="pc">TRUE</em> and <em class="pc">FALSE</em>, return <em class="pc">TRUE FALSE TRUE</em>:</p><p id="d730" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">=&gt; <em class="pc">TRUE</em> <em class="pc">FALSE</em> <em class="pc">TRUE</em> = <em class="pc">λx.λy.x FALSE TRUE</em></p><p id="e4dd" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Given <em class="pc">FALSE</em> and <em class="pc">TRUE</em>, return the first parameter:</p><p id="8927" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">λx.λy.x FALSE TRUE = FALSE</em></p><p id="e75c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The definitions of the other boolean operations such as OR, XOR and others follow the same idea.</p><h2 id="2db0" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Practice</h2><p id="0bc8" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Now, let’s use some Lambda Calculus in practice:</p><pre class="mm mn mo mp mq pf pg ph bp pi bb bk"><span id="b26b" class="pj nd fq pg b bg pk pl l pm pn"># Lambda function abstraction<br/>def L(f):<br/>    return f<br/><br/># Church numeral 0<br/>ZERO = L(lambda f: L(lambda x: x))<br/><br/># Successor function: λn.λf.λx.f (n f x)<br/>SUCC = L(lambda n: L(lambda f: L(lambda x: f(n(f)(x)))))<br/><br/># Addition: λm.λn.λf.λx.m f (n f x)<br/>ADD = L(lambda m: L(lambda n: L(lambda f: L(lambda x: m(f)(n(f)(x))))))<br/><br/># Multiplication: λm.λn.λf.m (n f)<br/>MUL = L(lambda m: L(lambda n: L(lambda f: m(n(f)))))<br/><br/># Convert integer to Church numeral<br/>def to_church(n):<br/>    if n == 0:<br/>        return ZERO<br/>    else:<br/>        return SUCC(to_church(n - 1))<br/><br/># Helper function to compare Church numerals<br/>def church_equal(church_number_1, church_number_2):<br/>    f = lambda x: x + 1<br/>    return church_number_1(f)(0) == church_number_2(f)(0)<br/><br/>church_two = to_church(2)<br/>church_three = to_church(3)<br/>church_five = to_church(5)<br/>church_six = to_church(6)<br/><br/># Successor of 2 is 3<br/>assert church_equal(SUCC(church_two), church_three)<br/><br/># 2 + 3 = 5<br/>assert church_equal(ADD(church_two)(church_three), church_five)<br/><br/># 2 * 3 = 6<br/>assert church_equal(MUL(church_two)(church_three), church_six)<br/><br/>print("All tests passed.")</span></pre><p id="788f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">As you can see, we are performing numerical operations using only lambda functions!! Also, by extending this with lambda boolean logic, we could implement if/else, loops and even an entire programming language solely with lambda functions! Amazing right?</p><p id="4062" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Okay, now after this brief introduction to Lambda Calculus, we can go to the next topic of our journey.</p><h1 id="5b93" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Interaction Nets</h1><p id="f4fc" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Before going directly to Interaction Combinators, let’s first learn another earlier work by Yves Lafont: Interaction Nets. This foundation will make understanding Interaction Combinators easier.</p><p id="3a8e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Interaction Nets are a model of computation created by Yves Lafont in 1990. They use graph-like structures and a set of interaction rules to represent algorithms.</p><p id="0807" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The first thing we need to define is a <em class="pc">cell. </em>A consists of a some symbol<em class="pc"> e.g. α, </em>a principal port and n auxiliary ports<em class="pc">, </em>represented by the image below:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qq"><img src="../Images/ba40de956a0e60e58c173fb65fa5a68b.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*vowv094TMPhCXLx3I9T51g.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Cell — Image by author</figcaption></figure><p id="427f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">When a <em class="pc">cell</em> has n = 0 auxiliary ports, it is represented as follows:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qr"><img src="../Images/8e7e876645ce29028268c7ee95d7299e.png" data-original-src="https://miro.medium.com/v2/resize:fit:144/format:webp/1*FUTzRzopCEXPe3tFagQ0RA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Cell of arity n=0 — Image by author</figcaption></figure><p id="382c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">By connecting a set of <em class="pc">cells </em>through <em class="pc">wires </em>on their <em class="pc">ports </em>we construct a <em class="pc">net</em>. For example, a net with <em class="pc">cells α, β </em>and<em class="pc"> γ, </em>with <a class="af pd" href="https://en.wikipedia.org/wiki/Arity" rel="noopener ugc nofollow" target="_blank">arities</a> n = 2, 1 and 0, respectively.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qs"><img src="../Images/93ad5ba679bdd192864241e7bc4f7d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*p9oCpp4QK1FypWziS8UcFQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="e101" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Note that a <em class="pc">wire</em> can connect two<em class="pc"> ports</em> of the same<em class="pc"> cell</em> and a <em class="pc">net</em> may not be necessarily connected. Also, in this example there are three free ports <em class="pc">x</em>, <em class="pc">y</em> and <em class="pc">z.</em></p><p id="4ce3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Whenever a pair of cells is connected through their <a class="af pd" href="http://." rel="noopener ugc nofollow" target="_blank"><strong class="oa fr"><em class="pc">principal</em></strong></a><em class="pc"> ports, </em>there will be an<em class="pc"> interaction. </em>An <em class="pc">interaction</em> is a rule that will modify the <em class="pc">net. </em>This pairs connected through their <em class="pc">active </em>ports and ready to interact are called an <em class="pc">active pair (</em>or <em class="pc">redex).</em></p><p id="0bc9" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">On the previous example, there are two possible <em class="pc">interactions </em>(<em class="pc">active pairs</em>) on the first<em class="pc"> iteration.</em></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qt"><img src="../Images/5c5f9513d5084292e2586a53b4e278a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*m6Fy9-_GtrHothH-GurwtA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="4fd0" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">After applying these rules, the <em class="pc">net </em>will be modified. We then repeatdly apply these rules again to the resulting <em class="pc">nets </em>until we reach an irreducible form, when no more <em class="pc">interaction </em>rules can be applied. This process of repeatedly applying <em class="pc">interaction </em>rules is also known as reduction.</p><p id="6a16" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">An <em class="pc">interaction system </em>is constructed with a set of interaction rules that can be applied without ambiguity. That is, if we define an <em class="pc">interaction </em>rule for an <em class="pc">active pair (αi, αj)</em>, it will be the same for all<em class="pc"> (αi, αj) </em>that appear.</p><p id="8879" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">After this brief explanation, let’s do some practice.</p><h2 id="ee8b" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk"><em class="qu">Building an interaction system for arithmetics</em></h2><p id="5fdf" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Let’s build an interaction system for doing arithmetics. In order to create that, let’s first forget our basic intuition about numbers and try to create a system that can model natural numbers. In 1889, Giuseppe Peano introduced five axioms to formalize natural numbers, similar to how Euclid defined his axioms for geometry. The Peano’s axioms enable an infinite set to be generated by a finite set of symbols and rules. Using these axioms, Peano defined some rules for a finite set of symbols to model natural numbers and their arithmetic properties:</p><p id="96ea" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr"><em class="pc">0 → Symbolizes the number zero</em></strong></p><p id="3a0e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr"><em class="pc">s(n) → Represents the successor function. It returns the next natural number.</em></strong></p><p id="b4aa" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Using <strong class="oa fr">s</strong> and <strong class="oa fr">0 </strong>we can define the natural numbers, as we have previously seen during lambda calculus studies:</p><p id="26b6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">1 = <strong class="oa fr">s(0)</strong></p><p id="7e3c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">2 = <strong class="oa fr">s(s(0))</strong></p><p id="35ba" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">3 = <strong class="oa fr">s(s(s(0)))</strong></p><p id="e73a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">and so on…</p><p id="28f5" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr"><em class="pc">+ → Represents addition. It is a function recursively defined as:</em></strong></p><p id="cfd0" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr"><em class="pc">Base case:</em></strong> 0 + a = a</p><p id="3eaf" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr"><em class="pc">Recursion:</em></strong> a + s(b) = s(a+b)</p><p id="741f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">For example:</p><p id="249c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">a + 3:</p><p id="89a4" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">= a + s(2)</p><p id="5618" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">= s(a+2)</p><p id="1b04" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">= s(a+s(1))</p><p id="f387" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">= s(s(a+1))</p><p id="4e9b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">= s(s(a+s(0)))</p><p id="6135" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">= s(s(s(a+0)))</p><p id="fccc" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">= s(s(s(a)))</p><p id="9bb1" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr"><em class="pc">×: Represents multiplication. It is a function recursively defined as:</em></strong></p><p id="7d18" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr"><em class="pc">Base case:</em> </strong>b × <strong class="oa fr">0</strong> = <strong class="oa fr">0</strong></p><p id="bf68" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr"><em class="pc">Recursion: </em></strong>s(a) × b = (a × b) + b</p><p id="c73a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Inspired by this, Yves Lafont built a interaction system to model natural numbers and arithmetics. Let’s understand:</p><p id="4dd3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">First, he defined <em class="pc">cells </em>for the <strong class="oa fr">s </strong>and <strong class="oa fr">0</strong> symbols:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qv"><img src="../Images/4ea3ec73a34ccf2d96466542da9acaa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*kGSLFjlO1x0E8x1-8iQZrQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="fc2b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Then, the <em class="pc">cell </em>for the addition operation:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qw"><img src="../Images/d95bc121072804cd7d37597788eb8880.png" data-original-src="https://miro.medium.com/v2/resize:fit:184/format:webp/1*vxxoT66qc5n2CJ_iBPm4vA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="e1d8" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">It seems strange, I know, but I promise will it will further make sense.</p><p id="e9f6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">If all natural numbers can be expressed using only the symbols <strong class="oa fr">0 </strong>and successor <strong class="oa fr">s</strong>, for addition we need to define just two <em class="pc">interaction </em>rules: how an addition interacts with successor and with <strong class="oa fr">0. </strong>Therefore, Lafont introduced the two following <em class="pc">interaction </em>rules:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qx"><img src="../Images/889329bea2557cffd9453a2471b0bbfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*ocuopPlOYKgHsozLuSRoMA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="9319" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Compare these rules with the Peano’s equations for addition, they are extactly the same expressions:</p><p id="4ed5" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">s(x) + y = s(x+y)</p><p id="73f0" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr">0</strong> + y = y</p><p id="9210" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now, let’s understand the <em class="pc">interaction</em> rules for multiplication. The <em class="pc">cell </em>for multiplication is defined as follows:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qy"><img src="../Images/8fd1125c9726eca7ace99e90589b24b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/1*yrsQTek7UXaQr8VQRzTmwg.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="1221" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now, take a look at Peano’s equations:</p><p id="21a6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">y × <strong class="oa fr">0</strong> = <strong class="oa fr">0</strong></p><p id="b6b6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">s(x) × y = (x × y) + y</p><p id="87db" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Note that the first equation “erases” the y variable (y appears on the left side of the equation and do not appear on the right side). In the second equation, the y is “duplicated” with another multiplication and an addition.</p><p id="e7f8" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Thus, two other symbols are needed: <em class="pc">ε (eraser) </em>and <em class="pc">δ (duplicator).</em></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qz"><img src="../Images/ad52d6c71df9df7fbe0efef5b4b1d0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*WoPcOP-DB2A_gqWBALDtcw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="c31f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The idea of this symbols is that a net representing natural numbers will be erased when connected to the principal port of <em class="pc">ε, </em>and it will be duplicated if it is connected to the principal port of<em class="pc"> δ. </em>Now, the multiplication rule can be represented as follows:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk ra"><img src="../Images/5edbb6983572225d6bf4503b71f98e38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*PsKGj_fhJhBlXM-_rWl1Xw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="9521" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Try to reflect on how they are similar to the Peano’s expressions:</p><p id="00b5" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">s(x) × y = (x × y) + y</p><p id="bcd9" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">y × <strong class="oa fr">0</strong> = <strong class="oa fr">0</strong></p><p id="d9a4" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The <em class="pc">interaction </em>rules for <em class="pc">duplicator </em>and <em class="pc">eraser </em>with <em class="pc">successor </em>and 0 are defined as follows:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rb"><img src="../Images/1fee674e8bd92a26f2008a095ee6487f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTpDMh7kas1Ta6p6Uao5nA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="c5aa" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Thus, we have a set of six symbols <strong class="oa fr">{0, s, +</strong>, ×, <em class="pc">δ, ε</em>} with the following set of eight <em class="pc">interaction </em>rules:<strong class="oa fr"> {(s</strong>, +), <strong class="oa fr">(0, +)</strong>, <strong class="oa fr">(s</strong>, ×), <strong class="oa fr">(0</strong>, ×), <strong class="oa fr">(s</strong><em class="pc">, δ</em>)<em class="pc">,</em> <strong class="oa fr">(<em class="pc">0</em></strong><em class="pc">, δ</em>)<em class="pc">,</em> <strong class="oa fr">(<em class="pc">s</em></strong><em class="pc">, ε</em>)<em class="pc">,</em> <strong class="oa fr">(<em class="pc">0</em></strong><em class="pc">, ε</em>)}. Let’s analyze them in practice for the operation 2 × 2.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rc"><img src="../Images/7761269faea0c99e55e76dd3028a0622.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*RA3FDqtoUQiMIZ1bwmcSXQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">2 x 2. Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="58e9" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">If you take a look, there is an active pair (<strong class="oa fr">s</strong>, ×) that we can apply the Rule #3.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rd"><img src="../Images/4d416f15180cb9da8b6cf32136505daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*O4FF94PigBlGvbtkYBylQQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Applying <em class="qu">interaction rule #3. </em>Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="72de" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Therefore, the operation is solved by applying the <em class="pc">interaction </em>rules until we reach an irreducible form:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk re"><img src="../Images/67e138061a4d076406a1a498898e633e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BQVKQv8MLkQdbppcn_6krg.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">2x2 = 4. Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="117f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Take a look at the final form that we have reached: <strong class="oa fr">s</strong>(<strong class="oa fr">s</strong>(<strong class="oa fr">s</strong>(<strong class="oa fr">s</strong> <strong class="oa fr">0</strong>))).</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rf"><img src="../Images/5ada222ea12c2d41ccfdf3c448047307.png" data-original-src="https://miro.medium.com/v2/resize:fit:180/format:webp/1*i8j7RmVnTqedadqxHUaYFQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="eca7" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">It is exactly the definition of the numeral 4, the result of 2 × 2! Amazing, right? After some manipulation of strange symbols, we could solve an arithmetic operation! 😀</p><p id="14ed" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">But why do such a complicated thing? What are the advantages of solving problems using these manipulations?</p><p id="0371" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Lafont’s nets have an interesting property: if a net <em class="pc">μ</em> can reduce in one step to two different possible <em class="pc">nets v </em>or <em class="pc">v’, </em>then <em class="pc">v</em> and <em class="pc">v’ </em>reduce in one step to a common net ξ.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rg"><img src="../Images/e93f8e38d3ba54b98c86d32876d794d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*K-B3UHCU-5z04jy0g6mFCw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="06bc" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The consequence of this confluence property is that if a net <em class="pc">μ </em>reduces to <em class="pc">v</em> in <em class="pc">n</em> steps, then any sequence of reductions will reach <em class="pc">v</em> in <em class="pc">n</em> steps. In other words, the order of the application of <em class="pc">interaction </em>rules does not matter, the net will reach the same form with the same amount of steps!</p><p id="4daf" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Did you get the power of this property? Basically, if the order of interactions doesn’t matter, we can apply them in parallel! 🤯</p><p id="6583" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">For instance, on our previous 2 × 2 operation, instead of applying the rules one by one, we could parallelize them at moments like this:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rh"><img src="../Images/9025d9f135f76590a34ec27617ad153c.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*cUp6_saH9lOz7MJeqwTQ9w.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="fcab" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In actual execution, both rules could be parallelized by running them in two separated threads, without concerns about thread collisions and other common issues related to parallelism. And that’s one of the core principles on which HVM/Bend is founded! Based on that, all operations that can be parallelized will be inherently parallelized!</p><p id="c871" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now that we understand interaction nets, let’s take one more step. Earlier in this article, I mentioned that HVM was based on Interaction Combinators, so let’s understand how these concepts relate.</p><h1 id="0894" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Interaction Combinators</h1><p id="aac5" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Based on his earlier Interaction Nets work, Yves Lafont created the Interaction Combinators. The idea was to create a representation of computation using a minimal set of primitives, called combinators. While interaction nets use graph rewriting to model computation explicitly, interaction combinators refine this by focusing on the fundamental combinatory logic. This shift provides a more abstract but more powerful framework for expressing computation processes.</p><p id="bfac" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">For interaction combinators, Lafont defined three symbols (also called combinators): γ (<em class="pc">constructor</em>), <em class="pc">δ </em>(<em class="pc">duplicator</em>)<em class="pc"> </em>and<em class="pc"> ε (eraser).</em></p><p id="9e1c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Using these three combinators, a total of only six rules were created. These rules are divided into:</p><p id="731a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">commutation — </em>when two cells of different symbols interact (γ<em class="pc">δ, </em>γ<em class="pc">ε, δε</em>);</p><p id="da1f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">annihilation — </em>when two cells of the same symbol interact (γγ, <em class="pc">δδ, εε</em>).</p><p id="22ce" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The rules are defined below:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pe"><img src="../Images/3aa98d277576638e82070613893d2955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O1XSNhcwA0HQNXOnl3COpw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Commutation rules. Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ri"><img src="../Images/97e11564dd402b1e26d0184ab2c06034.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UlJz3KvpB5Ha86ozsiSnqA.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Annihilation rules. Image by author, inspired from <a class="af pd" href="https://www.sciencedirect.com/science/article/pii/S0890540197926432" rel="noopener ugc nofollow" target="_blank">Lafont, 1997</a></figcaption></figure><p id="64a6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Therefore, using only these six rules you can model any computable algorithm! Amazing, right?</p><p id="c898" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">However, the HVM runtime uses a variant of Lafont’s interaction combinators, called <a class="af pd" href="https://lipn.univ-paris13.fr/~mazza/papers/CombSem-MSCS.pdf" rel="noopener ugc nofollow" target="_blank">Symmetric Interaction Combinators (SIC) (Mazza, 2007)</a>. This variant is a simplified version that uses the same rewrite rule for all of its symbols:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pe"><img src="../Images/0d41aba45a4959823ee000d41ec2d648.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zAJ-KOqTXeWfY3H4JJ3DoQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Symmetric Interaction Combinators rules. Image by author, inspired from <a class="af pd" href="https://lipn.univ-paris13.fr/~mazza/papers/CombSem-MSCS.pdf" rel="noopener ugc nofollow" target="_blank">Mazza, 2007</a></figcaption></figure><p id="0cc5" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">As you can see, the single difference is that the rules γγ and <em class="pc">δδ </em>are now the similar<em class="pc">. </em>The crucial confluence property is maintained, preserving its parallelization capability.</p><p id="154f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="pc">For now on, we will be using the SIC rules for our examples, so focus on them.</em></p><h2 id="14fe" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Lambda Calculus → Symmetric Interaction Combinators</h2><p id="27c1" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Now you may be asking “How can I write programs using that? How to transform my Python function into interaction combinators drawings?”</p><p id="7abc" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">I mentioned before that you can represent any computable algorithm using lambda calculus right?</p><p id="a2b8" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now another information: you can transform lambda calculus into interaction combinators!</p><p id="a464" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Thus, any program can be transformed into lambda calculus, then transformed into interaction combinators, run in parallel and then be transformed back!</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rj"><img src="../Images/e076537acd1508b1239640bb52df6823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xbETDlHg4hP3CUV7c1ab0Q.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author</figcaption></figure><p id="8a3d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">So, let’s understand how you can translate lambdas to interaction combinators!</p><p id="4d9d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Lambda <em class="pc">expressions ( λ ) </em>and <em class="pc">applications </em>( @ ) can be expressed using a constructor γ. For instance, a lambda <em class="pc">expression λx.y </em>can be expressed as follows:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rk"><img src="../Images/c58777ecbcf6e4a9491e3330b3b727ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:250/format:webp/1*uZdbV7rhX8o1VwPKHCdrwA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Lambda expression using SIC. Image by author</figcaption></figure><p id="ba42" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">And for a given <em class="pc">application f x, </em>we can express it as follows:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rl"><img src="../Images/ebe37c5809c0a8c423f30e0b0fd100aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*ML0LmPoLPyjTYZPXhxmyhQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Lambda application using SIC. Image by author</figcaption></figure><p id="d3d3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Using these representations, we can express the identity <em class="pc">expression λx.x (</em>given <em class="pc">x</em>, return <em class="pc">x</em> itself<em class="pc">):</em></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rm"><img src="../Images/e373013cf236a706a208fb551c9163fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:182/format:webp/1*npVeYx7R3xJ98vC3n234CQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx"><em class="qu">λx.x. Image by author</em></figcaption></figure><p id="a8fc" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now, imagine we want to do the <em class="pc">application</em> (<em class="pc">λx.x)y:</em></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rn"><img src="../Images/a35facf020a380ffda8f89664bb32938.png" data-original-src="https://miro.medium.com/v2/resize:fit:710/format:webp/1*aXo9XK_Rt_UfeGGp2gD78g.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx"><em class="qu">(λx.x)y </em>Image by author</figcaption></figure><p id="7d12" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">If we reduce the expression (<em class="pc">λx.x)y, </em>we will get <em class="pc">y </em>as result. Let’s analyze what can we get using SIC rules?</p><p id="9d03" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Notice that when there is an<em class="pc"> application</em> applied to a lambda<em class="pc"> expression,</em> there will be an <em class="pc">active pair</em> that we can reduce! In this case, we will apply the interaction rule γγ. Also, for now on, we will use a circle to identify the final calculation result we are interested in.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk ro"><img src="../Images/cc9a7092abf3788fcfe1de34ad230f0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*-k3ZhGGDL8nXbyz9LyuP8w.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image bu author</figcaption></figure><p id="3f19" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">As you can notice, (<em class="pc">λx.x)y </em>was correctly reduced to <em class="pc">y</em>! Amazing, right?</p><p id="6fe1" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now, imagine we want to express <em class="pc">λf.ff (</em>given <em class="pc">f, </em>apply <em class="pc">f </em>to itself). As you can notice, the parameter <em class="pc">f </em>is <em class="pc">duplicated</em> on the body. That’s when the <em class="pc">duplicator (</em>δ) comes into action! We can use <em class="pc">duplicators </em>to copy (duplicate) values:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rp"><img src="../Images/278b9ee8e57d4cb0d5631b5852fa73f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/format:webp/1*pwNbWK6YBhOmnw7emwGJnw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author</figcaption></figure><p id="a46c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Let’s go back to our expression <em class="pc">λf.ff. </em>First, identify that this is an <em class="pc">expression </em>that given the input <em class="pc">f, </em>it outputs the <em class="pc">application f applied to f itself. </em>Therefore, it can be expressed as follows:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rq"><img src="../Images/0ce8478c7bffeffd294cca11cf909fd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:514/format:webp/1*ndQvb3B8_pSo2NlonRrDfw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">“Given <em class="qu">f, </em>output <em class="qu">f</em> applied to <em class="qu">f”. Image by author</em></figcaption></figure><p id="bb0a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Beyond duplication, variables can also be vanished. For instance, let’s take the Church number <strong class="oa fr">0 := </strong><em class="pc">λf.λx.x. </em>This expression can be read as “given two variables <em class="pc">f </em>and <em class="pc">x, </em>return <em class="pc">x”. </em>As you can notice, the variable <em class="pc">f </em>is not used at the output. If we tried to represent using SIC with our current knowledge, we would obtain:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rr"><img src="../Images/9ae939db655d63c9f4ebd1d9413bd566.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*zNU3JKH7uKGbx7hqW7-XSQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author</figcaption></figure><p id="03a3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The <em class="pc">f</em> wire is floating. Something seems wrong, right? That’s why we have the <em class="pc">eraser ε! </em>In order to represent this variable disappearance we do:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rs"><img src="../Images/6040c5d8fa64b89e2b89de2eb863ec5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:278/format:webp/1*-DNzn_erlI246ua_eWjgrA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="12ec" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In summary, we can handle Lambda Calculus with Symmetric Interaction Combinators using:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rt"><img src="../Images/069a7921a0fe243a1b2ec902d8e22bc4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nxzm1kkhGHT5WIkXwC84iw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author. Inspired by <a class="af pd" href="https://zicklag.katharos.group/blog/interaction-nets-combinators-calculus/" rel="noopener ugc nofollow" target="_blank">https://zicklag.katharos.group/blog/interaction-nets-combinators-calculus/</a></figcaption></figure><h1 id="5f62" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Examples</h1><p id="f2a1" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Now that we covered these transformations, we are able to perform more complex operations.</p><h2 id="9b8e" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Church numbers</h2><p id="7cb9" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Let’s draw some Church numbers!</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ru"><img src="../Images/71ff48be81fb16b7f945787eb7255ece.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HYfwwZ6ub5Vxm9qyen68Ug.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author</figcaption></figure><p id="7d57" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Before we go further, try to replicate this yourself! Get a paper and start drawing! For instance, let’s try to draw together the Church number four: <em class="pc">λf.λx.f(f(f(f x))).</em></p><p id="599a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The thing that I draw is the outer lambda expression <em class="pc">λf.____</em></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rv"><img src="../Images/4baf00423b2cde5b9974dbf4bd517d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*jPaPeyspGNfROOS8IA_Qtw.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Given f, output <em class="qu">λ</em>x.f(f(f(f x))). Image by author</figcaption></figure><p id="7928" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Then, the second lambda expression __.<em class="pc">λx.</em>____:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk qq"><img src="../Images/888164d02fd47ceb1a2abb3a2ff90029.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*n7nbSki-3MHwfBy-UQDIPg.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Given x, output f(f(f(f x))). Image by author</figcaption></figure><p id="6f22" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now, we need to draw the <em class="pc">applications</em> (@). But first, notice that we have <em class="pc">f</em> repeated four times. Therefore, we need to copy (duplicate) <em class="pc">f</em> three more times (so we need three duplicators in sequence):</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rw"><img src="../Images/35deea54aa6b8d04016bec1d7ed8b016.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*Djudt8ASXvuOKxYtgMWQQA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Duplications of f. Image by author</figcaption></figure><p id="5646" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now that we have four copies<em class="pc"> </em>of<em class="pc"> f, </em>we can draw the <em class="pc">applications</em><strong class="oa fr"> </strong>of <em class="pc">f</em> to <em class="pc">f</em> in sequence!</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk rx"><img src="../Images/5669ee7a20e95e2d0fd88ff9ed37c799.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*1UVixbhzlgz4unqcjj9d8g.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Church number 4 with SIC. Image by author</figcaption></figure><p id="0685" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Using the same strategy, we can easily construct other expressions.</p><h2 id="42e7" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Successor</h2><p id="8944" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Let’s implement the successor function. It is given by <em class="pc">λn.λf.λx.f((n f) x).</em></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk ry"><img src="../Images/91eb0ac0fbac96178e46ccddbf24a7b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*umwWghNAEcNn6FMB4WD2Kg.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Successor. Image by author</figcaption></figure><p id="f252" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Let’s apply SUCC to the number <em class="pc">0 </em>and analyze what we get.</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk rz"><img src="../Images/73bd398bd363b80c9d6693a543157c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q49CmR8FUwI11xLg9hTiSw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">SUCC 0. Image by author</figcaption></figure><p id="cdad" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Let’s apply the interaction rules. In order to facilitate readability, I will draw <em class="pc">duplicators </em>δ as black cells and <em class="pc">constructors </em>γ as white cells:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sa"><img src="../Images/7483476d2c7eba05287c470db99a8219.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2XuItHcoMF71zo6prRzxg.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">SUCC 0 reductions. Image by author</figcaption></figure><p id="37d1" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Well, we should have reached the Church numeral 1, right? What went wrong? Take a look at the <em class="pc">eraser ε </em>connected to the auxiliary port of the duplicator δ (in black):</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk sb"><img src="../Images/8cc2c94526e90cb7650bcd2f8a8b940b.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*ohyXQh-FdD4GSJiDdb2TqQ.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author</figcaption></figure><p id="1a32" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This <em class="pc">eraser </em>is making this left auxiliary port to be redundant! All of the information passed through this duplicator will be erased. For any <em class="pc">cell </em>that interacts with this <em class="pc">duplicator, </em>the <em class="pc">left</em> part will be <em class="pc">erased.</em></p><p id="2f8c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">So we can remove this redundant <em class="pc">duplicator</em> and connect the<em class="pc"> wire</em> directly:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk sc"><img src="../Images/e662d51b21d3f99a9bf46d1bdad4415a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*ppBsmpCoyDBBG2IaWREvOA.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author.</figcaption></figure><p id="1ffe" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">And <em class="pc">voila! </em>After reducing SUCC(0) we got exactly the Church number 1, as expected!</p><p id="54a4" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Let’s apply SUCC againt to the number 1 and see if we get the number 2:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sd"><img src="../Images/ff417ab383f7dcf4fa7f00fbfc20c8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIFNzEt-xvdq25bRbQKNow.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">SUCC 1. Image by author</figcaption></figure><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk se"><img src="../Images/1c554d864f027d5ae5fd12834413a298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bi-htgBZjceItRSDxQnQzw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">SUCC 1 = 2. Image by author</figcaption></figure><p id="1250" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">We got exactly the Church number 2! Amazing, right?</p><h2 id="4bd2" class="po nd fq bf ne pp pq pr nh ps pt pu nk oh pv pw px ol py pz qa op qb qc qd qe bk">Addition</h2><p id="d20f" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">So far, we have just performed sequential reductions. Let’s do a more complex one, such as addition, to visualize the full parallelization potential of interaction combinators. Below the SIC representation of addition: <em class="pc">ADD(m, n) = λm.λn.λf.λx.(m f)((n f) x).</em></p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div class="mj mk sf"><img src="../Images/07cb4ec55cf4a0856b417a91a615ad90.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*BZRM164dv6LnOXi7HZls2g.png"/></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Addition. Image by author</figcaption></figure><p id="37d3" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Let’s calculate ADD 1 1:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sg"><img src="../Images/46ca9526345dc51c5260799e471fea3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zbs2qSoPznwC300j2au_aw.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">ADD 1 1. Image by author</figcaption></figure><p id="af50" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Executing the reductions:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk sh"><img src="../Images/05ad0dece29ad44eb9b72af6669863e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6GCCQ-rB7hC0vXR8j8Jd6A.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by author</figcaption></figure><p id="9b90" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Take a look at this step. There are two active pairs! In cases like this we can reduce both in parallel. In a real program, we could run them in two different threads.</p><p id="9459" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Let’s continue:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk si"><img src="../Images/0a3e0763cf67f8158a12daa49fcfac41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U9NOMElnfjU0FR4TLX95DQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">ADD 1 1 = 2. Image by author</figcaption></figure><p id="98c1" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">After reducing ADD 1 1 we got exactly the representation of the Church number 2!</p><p id="13d6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">And that’s how the operations are parallelized using Interaction Combinators. At each step, if there are multiples active pairs, all of them run in different threads.</p><h1 id="98df" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Conclusion</h1><p id="630b" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">In this post we covered basic concepts of lambda calculus, interaction combinators, and how they are combined to parallelize operations. I hope I could give you a brief explanation on how Bend/HVM works and for more information, please visit their <a class="af pd" href="https://higherorderco.com/" rel="noopener ugc nofollow" target="_blank">website</a>.</p><p id="575e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Also, follow me here and on my <a class="af pd" href="https://www.linkedin.com/in/lucas-de-lima-nogueira/" rel="noopener ugc nofollow" target="_blank">LinkedIn profile</a> to stay updated on my latest articles!</p><h1 id="7572" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">References</h1><p id="312d" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk"><a class="af pd" href="https://higherorderco.com/" rel="noopener ugc nofollow" target="_blank">HigherOrderCO website</a></p><p id="5fba" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><a class="af pd" href="https://core.ac.uk/download/pdf/81113716.pdf" rel="noopener ugc nofollow" target="_blank">Lafont’s Interaction Combinators paper</a></p><p id="657f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><a class="af pd" href="https://www.youtube.com/watch?v=sDPuQ-UjhVQ&amp;t=1591s" rel="noopener ugc nofollow" target="_blank">How HVM works video</a></p><p id="3475" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><a class="af pd" href="https://zicklag.katharos.group/blog/interaction-nets-combinators-calculus/" rel="noopener ugc nofollow" target="_blank">Interaction combinators tutorial 1</a></p><p id="74f9" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><a class="af pd" href="https://blog.stevenhuyn.com/succ/" rel="noopener ugc nofollow" target="_blank">Interaction combinators tutorial 2</a></p><p id="d73a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><a class="af pd" href="https://learnxinyminutes.com/docs/lambda-calculus/" rel="noopener ugc nofollow" target="_blank">Lambda calculus tutorial</a></p></div></div></div></div>    
</body>
</html>
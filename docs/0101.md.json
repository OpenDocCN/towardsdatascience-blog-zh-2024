["```py\nimport http.client\nimport pandas as pd\nimport json\n\nurl = '/fdsnws/event/1/query'\nquery_params = {\n    'format': 'geojson',\n    'starttime': \"2020-01-01\",\n    'limit': '10000',\n    'minmagnitude': 3,\n    'maxlatitude': '47.009499',\n    'minlatitude': '32.5295236',\n    'maxlongitude': '-114.1307816',\n    'minlongitude': '-124.482003',\n}\nfull_url = f'https://earthquake.usgs.gov{url}?{\"&\".join(f\"{key}={value}\" for key, value in query_params.items())}'\n\nprint('defined params...')\n\nconn = http.client.HTTPSConnection('earthquake.usgs.gov')\nconn.request('GET', full_url)\nresponse = conn.getresponse()\n```", "```py\nif response.status == 200:\n    print('Got a response.')\n    data = response.read()\n    print('made the GET request...')\n    data = data.decode('utf-8')\n    json_data = json.loads(data)\n    features = json_data['features']\n    df = pd.json_normalize(features)\n\n    if df.empty:\n        print('No earthquakes recorded.')\n    else:\n        df[['Longitude', 'Latitude', 'Depth']] = df['geometry.coordinates'].apply(lambda x: pd.Series(x))\n        df['datetime'] = df['properties.time'].apply(lambda x : datetime.datetime.fromtimestamp(x / 1000))\n        df['datetime'] = df['datetime'].astype(str)\n        df.sort_values(by=['datetime'], inplace=True)\nelse:\n  print(f\"Error: {response.status}\")\n```", "```py\nimport osmnx\nimport geopandas as gpd\n\nplace = \"California, USA\"\ngdf = osmnx.geocode_to_gdf(place)\n# Get the target geometry\ngdf = gdf[[\"geometry\", \"bbox_north\", \"bbox_south\", \"bbox_east\", \"bbox_west\"]]\n```", "```py\nfrom shapely.geometry import Point\n# Convert to a GeoDataFrame with Point geometry\ngeometry = [Point(xy) for xy in zip(df['Longitude'], df['Latitude'])]\nearthquake_gdf = gpd.GeoDataFrame(df, geometry=geometry, crs='EPSG:4326')\n\n# Filter to keep only points within the California bounding box\npoints_within_california = gpd.sjoin(earthquake_gdf, gdf, how='inner', predicate='within')\n\n# Extract latitude, longitude etc.\ndf = points_within_california[['id', 'Latitude', 'Longitude', 'datetime', 'properties.mag']]\n```", "```py\n# Fit HDBSCAN\nclusterer = HDBSCAN(min_cluster_size=200, metric='haversine', min_samples=20, cluster_selection_epsilon=0.05)\nresult_df['cluster_label_hdbscan'] = clusterer.fit_predict(data_scaled)\n\n# Find the number of unique cluster labels\nnum_clusters = result_df['cluster_label_hdbscan'].nunique()\n\n# Create a list of colors\ncolors = ['lightgray', 'red', 'blue', 'green'][:num_clusters]\n\n# Create a Folium map centered at the mean coordinates\nmap_center = [result_df['Latitude'].mean(), result_df['Longitude'].mean()]\nmymap = folium.Map(location=map_center, zoom_start=6)\n\n# Add markers for each data point with cluster color\nfor _, row in result_df.iterrows():\n    cluster_color = colors[row['cluster_label_hdbscan'] + 1]  # Map cluster label to color\n    folium.CircleMarker(\n        location=[row['Latitude'], row['Longitude']],\n        radius=2,\n        color=cluster_color,\n        fill=True,\n        fill_color=cluster_color,\n        fill_opacity=0.7,\n        popup=f'Cluster: {row[\"cluster_label_hdbscan\"]}'\n    ).add_to(mymap)\nmymap\n```", "```py\nfrom datetime import datetime\n\n# Convert 'time' column to datetime objects\ndf['time'] = pd.to_datetime(df['datetime'])\n\n# Sort dataframe by time\ndf.sort_values(by=['time'], inplace=True)\n\n# Calculate time elapsed between consecutive events\ndf['time_elapsed'] = df['time'].diff().shift(-1)\n```", "```py\n# Assuming present time is '2024-01-08 16:06:00.000'\npresent_time = pd.to_datetime('2024-01-08 16:06:00.000')\n\n# For the last event of each group, replace NaN with time between event and present time\ndf['time_elapsed'].fillna(present_time - df['time'], inplace=True)\n```", "```py\n# Label events based on whether they happened or not\ndf['event_happened'] = df['time_elapsed'].apply(lambda x: 1 if pd.Timedelta(days=0) > 0 else 0)\n```", "```py\nimport plotly.graph_objects as go\nfrom lifelines import KaplanMeierFitter\n\n# Initialize Kaplan-Meier Fitter\nkmf = KaplanMeierFitter()\n\n# Create a Plotly Figure\nfig = go.Figure()\n\ncolor_map = {0: 'red', 1: 'blue', 2: 'green', -1: 'gray'}\n\n# Fit and plot survival curves for each cluster excluding cluster -1\nfor label, group in result_df.groupby('cluster_label_hdbscan'):\n    if label != -1:\n        durations = group['time_elapsed'].dt.total_seconds() / 3600  # Convert hours to days\n        event_observed = group['event_happened'].values\n        kmf.fit(durations=durations, event_observed=a)\n\n        # Plot survival function\n        fig.add_trace(go.Scatter(\n            x=kmf.survival_function_.index,\n            y=1-kmf.survival_function_.KM_estimate,\n            mode='lines',\n            name=f'Cluster {label}',\n            line=dict(color=color_map[label])\n        ))\n\n# Customize the plot\nfig.update_layout(\n    xaxis_title='Elapsed Time (hours)',\n    yaxis_title='Probability of experiencing an earthquake',\n    legend_title='Cluster Labels',\n    width=800,  # Adjust width\n    height=500,  # Adjust height\n    margin=dict(l=50, r=20, t=50, b=50),  # Adjust margins\n    legend=dict(x=0.8, y=0.99),  # Adjust legend position\n)\n\n# Show the plot\nfig.show()\n```", "```py\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nimport numpy as np\n\n# Filter data\nfiltered_df = result_df[result_df['cluster_label_hdbscan'] != -1]\n\n# Create subplots in a 2 by 2 grid\nfig = make_subplots(rows=2, cols=2, subplot_titles=[f'Cluster {label}' for label in filtered_df['cluster_label_hdbscan'].unique()],\n                    shared_xaxes='all', shared_yaxes='all')\n\n# Create histograms for elapsed time for each cluster\nfor i, (label, group) in enumerate(filtered_df.groupby('cluster_label_hdbscan')):\n    # Calculate histogram\n    hist_data, bin_edges = np.histogram(group['time_elapsed'].dt.total_seconds() / 3600, bins=20)\n\n    # Add histogram trace to subplot\n    fig.add_trace(go.Bar(\n        x=bin_edges,\n        y=hist_data,\n        opacity=0.5,\n        name=f'Cluster {label}',\n        marker=dict(color=color_map[label])\n    ), row=(i // 2) + 1, col=(i % 2) + 1)\n\n    # Customise subplot\n    fig.update_xaxes(title_text='Elapsed Time (hours)', row=(i // 2) + 1, col=(i % 2) + 1)\n    fig.update_yaxes(title_text='Frequency', row=(i // 2) + 1, col=(i % 2) + 1)\n\n# Update layout\nfig.update_layout(\n    showlegend=False,\n    margin=dict(l=50, r=50, t=50, b=50),  # Adjust margins\n    height=600,\n    width=800,\n)\n\n# Show the plot\nfig.show()\n```"]
- en: An Introduction to Quantum Computers and Quantum Coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ÂéüÊñáÔºö[https://towardsdatascience.com/an-introduction-to-quantum-computers-and-quantum-coding-e5954f5a0415?source=collection_archive---------1-----------------------#2024-08-23](https://towardsdatascience.com/an-introduction-to-quantum-computers-and-quantum-coding-e5954f5a0415?source=collection_archive---------1-----------------------#2024-08-23)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Demystifying the novel world of quantum computing, quantum programming, and
    quantum algorithms.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@oliverwjohnson06?source=post_page---byline--e5954f5a0415--------------------------------)[![Oliver
    W. Johnson](../Images/66fe30ee3ccc1556ee2a4753b9c02235.png)](https://medium.com/@oliverwjohnson06?source=post_page---byline--e5954f5a0415--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e5954f5a0415--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e5954f5a0415--------------------------------)
    [Oliver W. Johnson](https://medium.com/@oliverwjohnson06?source=post_page---byline--e5954f5a0415--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ¬∑Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e5954f5a0415--------------------------------)
    ¬∑15 min read¬∑Aug 23, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d806c85c3928a9c55865f4d10b8f0717.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Manuel](https://unsplash.com/@manueljota?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Preface:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an adaptation of something I wrote for one of my physics courses, so
    it assumes a level of knowledge in mathematics and science. The topics referenced
    in the article include some linear algebra, superposition, basic algorithm concepts,
    and a bit of modular arithmetic when discussing algorithms. However, since you‚Äôre
    reading an article on quantum computing you‚Äôre likely savvy enough to look up
    and understand all the ideas referenced. Furthermore, all sources are cited, so
    you can explore all of those for deeper learning. Also, all images and figures
    used were generated by me, using tools like Microsoft Word, PyCharm, and [diagrams.net](https://www.drawio.com/)
    unless otherwise noted.
  prefs: []
  type: TYPE_NORMAL
- en: Why Does This Matter?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before committing to a somewhat lengthy and dense read, you might be wondering
    why this matters to you, even if you‚Äôve never touched a quantum computer. The
    reality is that breakthroughs are happening all the time, and quantum computing
    holds real relevance in different computational fields, especially machine learning.
    For starters, the quantum analogs of classical algorithms have potential to be
    much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: One example of this is the Quantum Support Vector Machine. Notably, classical
    SVMs often use the [kernel trick](https://en.wikipedia.org/wiki/Kernel_method)
    to transform data into a higher dimensional space so that they can locate a separating
    hyperplane. However, quantum SVMs would have a significant advantage as they naturally
    represent data in exponentially higher dimensional spaces without the computational
    strain that classical computers face. This allows quantum SVMs to handle more
    complex datasets more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is in the realm of neural network training. The basic unit of
    quantum computation, the qubit, can be entangled with other qubits, creating correlations
    that classical systems can‚Äôt replicate. While entanglement offers possibilities
    for correlated updates across a quantum neural network, it‚Äôs important to note
    that the concept is still under research.
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1: Introduction to Quantum Computing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quantum computers function very differently from classical computers, leveraging
    quantum properties and phenomena to greatly increase computational power. At a
    high level, there are a few tenets of quantum computing that differentiate it
    from classical computation: qubits versus bits, quantum versus classical logic
    gates, the presence of quantum phenomena, and the opportunities offered by quantum
    computing‚Äôs enhanced computational capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: At the core of quantum computing is the qubit, which serves as the fundamental
    unit of computation in a quantum computer‚Äì taking the place of a classical computer‚Äôs
    bit. While the bit can occupy either the 0 or 1 state exclusively, the qubit can
    be in a superposition of the 0 and 1 states (Microsoft, n.d.). It can be very
    hard to conceptualize the qubit; where the classical bit is simply an electric
    current or absence of electric current, the qubit can take many different physical
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: These include ‚Äúspin‚Äù qubits, which is the most straightforward example. This
    type of qubit uses the spin property of a particle (generally an electron) to
    complete computations. To initialize a spin qubit, an electron is trapped using
    a quantum dot, for example, then manipulated using magnetic fields that interact
    with their spin state (Harvey, 2024). The computational difference between a bit
    and qubit is significant, and stems from the qubit‚Äôs ability to be affected by
    quantum phenomena like superposition between the 0 and 1 states, and entanglement
    with other qubits (Microsoft, n.d.).
  prefs: []
  type: TYPE_NORMAL
- en: One tool that is very helpful in visualizing the state of a qubit is the Bloch
    sphere; it is effectively just a sphere with north and south poles representing
    |0‚ü© and |1‚ü© respectively, and all other points along the sphere representing linear
    combinations of the poles‚Äô values (Microsoft, 2024). Since this representation
    of the qubit uses a complex vector space, the state of the qubit will be described
    in Dirac notation hereafter. This visualization of the superposition state of
    a qubit aids in the understanding of quantum logic gates especially because it
    allows for a geometric understanding of the operation being performed. Generally,
    when a qubit is initialized it is in the z-basis |0‚ü© state, which is analogous
    to the classical 0 state (Quantum-Inspire by QuTech, 2024).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/45c0199014e8b06cb35b197936138a50.png)'
  prefs: []
  type: TYPE_IMG
- en: Bloch Sphere illustration, Wikipedia. (n.d.) [https://en.wikipedia.org/wiki/Bloch_sphere](https://en.wikipedia.org/wiki/Bloch_sphere).
    (GFDL License)
  prefs: []
  type: TYPE_NORMAL
- en: 'Another key difference between the classical and quantum computer is the logic
    gates: while classical computers use AND, OR, NOT, etc. to perform basic logic
    operations, quantum computers use quantum logic gates such as X, Hadamard, Toffoli,
    and CNOT (Wikipedia, 2024). These quantum gates are used to perform logical operations
    on a single qubit or a very small number of qubits, and can be combined with others
    to perform more complex operations and manipulations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the X gate is very similar to the classical NOT gate: it inverts the
    phase of a qubit‚Äì if a qubit is in the |0‚ü© state, it inverts to the |1‚ü© state,
    and vice versa.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the Hadamard gate is used to put a qubit in the |0‚ü© state into an equal
    superposition between |1‚ü© and |0‚ü©. Third, the Toffoli gate is an example of a
    multi-qubit gate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Toffoli gate operates with three qubits, two of them are ‚Äúcontrol‚Äù and one
    is the ‚Äútarget.‚Äù In the Toffoli gate it will invert the target qubit only if the
    two control qubits are in the |1‚ü© state (Roy & Chakrabarti, 2024).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the CNOT gate is a very common gate used in quantum computing, and
    we will examine a use case later on. The CNOT is also a multiple qubit gate, as
    it has one target qubit and one control qubit; when the control qubit is in the
    |1‚ü© state, it inverts the phase of the target qubit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These are just a few examples of many interesting quantum logic gates, and it
    is important to note that unlike classical logic gates, there is not necessarily
    a physical ‚Äúgate‚Äù that the qubits pass through, but rather these are just operations
    that are performed on the qubit which take different forms depending on many factors.
  prefs: []
  type: TYPE_NORMAL
- en: A third major difference between classical and quantum computing is the presence
    of quantum phenomena such as superposition, superconduction, entanglement and
    interference. These properties are used in different ways depending on the methods
    used to perform quantum computations (Microsoft Azure, 2024). Another property
    that is present is quantum decoherence, which poses a serious problem to the development
    of useful or widespread quantum computing. Quantum decoherence is when a particle
    in superposition interacts with its environment and becomes entangled with the
    environment, ultimately interfering with the computational outcome (Brandt, 1999).
  prefs: []
  type: TYPE_NORMAL
- en: 'The computational advances of a quantum computer are great: take, for example,
    the algorithm used for finding the prime factors of an integer. In classical computing,
    one of the leading prime factorization algorithms is General Number Field Sieve
    (Wikipedia, 2024). The program runs at a quasi-polynomial time complexity, and
    it shows how hard it can be to factor a **very** large number. Compared to the
    leading quantum algorithm, Shor‚Äôs Algorithm, which runs in logarithmic space complexity,
    and a polylogarithmic time complexity, which is once again a complicated expression,
    but boils down to the fact that it is vastly more efficient (Li et al., 2022).
    Obviously this is just one example, but it serves as a testament to the power
    of quantum computing‚Äì the power to turn a program which runs in exponential time
    into a program which runs in logarithmic time is truly remarkable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 2: Quantum Programming: Languages, Compilers and Algorithms**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though their hardware is fundamentally different from classical computers, quantum
    computers are programmed using languages often similar in syntax to classical
    languages. These include QCL, Qiskit, and Q#, who are based around the syntax
    of C, Python, and C#/F# respectively. Furthermore, their compilers are built with
    C++, Python and C++, and C# respectively. (IonQ, 2024). Thus, classical and quantum
    languages can be very similar syntactically‚Äì the main difference comes from the
    content of the programs, and how quantum algorithms are structured.
  prefs: []
  type: TYPE_NORMAL
- en: Before examining different languages, their syntaxes, and how they compare to
    the classical languages that they‚Äôre based around, it‚Äôs important to understand
    the content of a quantum program and why no matter how similar the syntax is,
    there is an unbridgeable gap between a classical and quantum program.
  prefs: []
  type: TYPE_NORMAL
- en: This stems from the mechanics of a quantum computer‚Äì as discussed before, quantum
    computation is based around holding qubits in superposition, and applying different
    ‚Äúgates‚Äù to them‚Äì effectively transformations along the Bloch sphere that they
    are represented by. What that boils down to is the fact that unlike a classical
    computer, where you write a program which will utilize a pre-made circuit to perform
    computations, quantum programming is the act of actually encoding the circuit.
    Let‚Äôs examine some pseudo code and its associated quantum circuit to better understand
    this. Maybe the simplest possible quantum program/circuit, the following program
    simply initializes a qubit, applies a Hadamard gate to put it into a superposition,
    then measures the state of the qubit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4077e897ba6ae1db001fe536e2930eda.png)'
  prefs: []
  type: TYPE_IMG
- en: Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'The associated quantum circuit for this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5c02f68d247339f85caae42b9c29a185.png)'
  prefs: []
  type: TYPE_IMG
- en: The ‚ÄúH‚Äù represents a Hadamrd gate, and the meter represents a measurement being
    taken. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: The double line following the measurement symbol indicates that the qubit is
    no longer in a superposition, but rather one of two discrete states (0 or 1) since
    its wave function was collapsed during the measurement.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better feel for the syntax of different quantum languages, let‚Äôs look
    at programs in the three aforementioned languages that all serve identical purposes.
    All three programs are made to create a Bell state, which is an entangled state
    of two qubits. The gates (operations) applied to the two qubits are: Hadamard
    on the first qubit, 0, then on the second qubit, 1, with the first qubit as the
    control. The function of the CNOT gate is effectively just to entangle two qubits
    (Rioux, 2023).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unsurprisingly, the quantum programs look very similar in syntax to the languages
    each is based on‚Äì for example the Pythonic program uses a couple built-in methods
    and doesn‚Äôt have much else going on and the C# based program is full of curly
    brackets. Reviewing the syntax of a few quantum languages is helpful to understand
    what a quantum program looks like, but the reality is that the hardware being
    used is so different that the actual code in a quantum program would be useless
    to a classical computer, and vice versa. Because of that, it would be much more
    interesting to analyze two algorithms made for the same purpose, one classical
    and one quantum, and dissect the different steps taken in each case to achieve
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: Recall the example presented in Part 1 (GNFS and Shor‚Äôs algorithm), where we
    looked at the time complexities of two prime factorization algorithms. As both
    algorithms are rather abstract and complex, it may be easier to understand their
    respective theories in paragraph format instead of examining their pseudo code.
  prefs: []
  type: TYPE_NORMAL
- en: The classical algorithm, General Number Field Sieve, can be summarized into
    five main algorithmic steps (Case, n.d.). Throughout the explanation, ‚ÄúN‚Äù refers
    to the number being factored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is polynomial selection: this step involves selecting two polynomials
    such that they multiply to smooth numbers when evaluated at certain points modulo
    N.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is the ‚Äúsieve‚Äù step: the goal is to find sets of integers (a,
    b) such that ùëì(ùëé)‚ãÖùëî(ùëè) ‚â° ‚Ñé2(mod N) where *h* is a smooth number, and store all
    values (a, b, and h).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The third step is the matrix step: a large matrix, A, is constructed from the
    relations found in the sieve step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next use Gaussian elimination to reduce A to a simpler form while preserving
    its properties. This process will identify a set of linearly independent relations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use linnear algebra methods such as Lanczos algorithm to find the null space
    of the matrix‚Äì this will give vectors that correspond to dependencies among the
    relations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Combining the relations found before will produce squares in modulo N, which
    after further mathematical manipulation give two integers X and Y.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These two integers are used to find the non trivial factors of N by computing
    the GCD of X ‚Äî Y and X + Y with respect to N (Case, n.d.). That method is described
    by quasi-polynomial complexity, which, while it does run in sub-polynomial time,
    is much slower than the quantum method, Shor‚Äôs algorithm.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process of calculating an integer N‚Äôs prime factors using Shor‚Äôs algorithm
    is entirely different from using GNFS. Shor‚Äôs algorithm can be broken down into
    a few main steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step uses classical computing: pick a random integer r such that
    1 < r < N, calculate their GCD‚Äôs and if it does not equal 1, it is a non-trivial
    factor of N.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is to prepare the needed qubits‚Äì we do this with two quantum registers,
    which function just like classical registers. In the first register there are
    enough qubits to represent integers from 0 to q‚Äì1 where q is a power of 2 that
    is at least N¬≤. The second register has enough qubits to represent integers from
    0 to N‚Äì1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step deviates from classical computing heavily: to put the entire
    first register into a superposition, apply a Hadamard transform to each qubit.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next use a quantum circuit to compute the function *f*(x) = r^x mod(N) and store
    the result in the second register; this will entangle the first and second registers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next measure the second register‚Äì this will collapse it into a state |k‚ü© (where
    k = r^x mod(N)) which leaves the first register in a superposition of values x
    that map to |k‚ü©.Now the period of the function f(x)=r^x mod(N) can be expressed
    as T.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The penultimate step of the algorithm is to apply a quantum fourier transform
    (QFT) to the first register, which will yield a series of peaks in the frequency
    domain corresponding to values of 1/T.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final step in the quantum computation is to measure the first register‚Äì
    the result will be an integer, B, such that B is q/T, recall q from when we defined
    the first register. Having completed the quantum computation, you then move onto
    the classical post-processing step to get the final result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The post-processing involves manipulating the measured result B to get the period,
    T. If T is even, compute the GCD of N with r^(T/2) + 1 and r^(T/2) - 1, which
    will yield non-trivial factors of N. If T is odd, repeat algorithm with a different
    r value. This program‚Äôs polylogarithmic time complexity is very efficient, especially
    compared to the GNFS algorithm (Pavlidis & Gizopoulos, 2022).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a visual representation of the flow of both algorithms to aid understanding,
    where red is the beginning step, blue is the GNFS algorithm, and green is Shor‚Äôs
    algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/93b009f5e65cea540c2ef53d0166bdbd.png)'
  prefs: []
  type: TYPE_IMG
- en: Blue steps correspond to GNFS, and green steps correspond to Shor‚Äôs Algorithm.
    Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'What enables Shor‚Äôs algorithm to run so much faster than the GNFS is the fundamentally
    different computational concepts being used: Shor‚Äôs algorithm leverages quantum
    mechanics to achieve polynomial time complexity. This speedup is primarily due
    to quantum parallelism (the ability to perform many quantum operations at the
    same time) and the efficient execution of the quantum Fourier transform, which
    are impossible in classical computing. By utilizing superposition and entanglement,
    Shor‚Äôs algorithm reduces factoring to a period-finding problem, solved exponentially
    faster than classical methods (Brandt, 1999).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously both algorithms are very complex, but they serve as an excellent
    example since the problem of factoring a large integer is something a quantum
    computer can do much faster than a classical computer. A much simpler example
    that we can analyze the quantum code for is a quantum take on rock-paper-scissors
    (or a coin toss if that‚Äôs easier to think about). Two players each initialize
    a qubit (one each) to the |0‚ü© state and apply a Hadamard gate which puts it into
    an equal superposition between |0‚ü© and |1‚ü©. Finally, both qubits are measured‚Äì
    if both qubits collapse to the |0‚ü© or |1‚ü© state, it is a draw. Otherwise, whoever‚Äôs
    qubit collapsed to the |0‚ü© state loses, and the one who‚Äôs qubit collapsed to the
    |1‚ü© state wins. Let‚Äôs write the code to run this program in Qiskit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of that code is simply the quantum circuit associated with the program,
    since it never actually runs the circuit on a quantum computer. However, that
    is the general format used when defining a very basic quantum circuit‚Äì a number
    of qubits and bits are allocated to it, then stating‚Äì in order‚Äì the operations
    to be performed on each qubit. The output of this code, which is just a visual
    representation of the circuit is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f617c91fb0de065d8b3028307c1f7fa0.png)'
  prefs: []
  type: TYPE_IMG
- en: The boxes with ‚ÄúH‚Äù represent Hadamard gates, those with an ‚ÄúX‚Äù represent CNOT
    gates, and those with an ‚ÄúM‚Äù represent measurements being taken. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can run this program on a quantum computer, there are a few steps
    we need to take. The most important is optimizing the circuit; not all quantum
    computers have the same ability to operate on qubits with certain gates, and they
    don‚Äôt always have the same connectivity of qubits. We need to add this circuit
    optimization into our code to prepare it to run on a real quantum computer. To
    do this we use the following code which defines our access to the IBM Quantum
    Backend using an IBM API key, then runs an optimization of the circuit, printing
    the optimized circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The output of this program is less important since it is just a more complex
    version of the same circuit, but it results in a circuit that is optimized for
    an IBM Quantum computer and while it looks much different and more complicated,
    it will function the same as the circuit from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, while the topic of quantum programming can be daunting due to
    its many languages and contrasting algorithms, as well as the background in math,
    physics, and computing needed to understand it, when broken down right it‚Äôs not
    so bad. Through incremental learning it‚Äôs very achievable to understand quantum
    computing. Furthermore, quantum computing has fascinating aspects in many STEM
    fields‚Äì number theory, linear algebra, calculus, and discrete mathematics all
    apply to the theoretical side of quantum algorithms; engineering, physics, computer
    science, and logic all apply to the actual design of quantum algorithms. Then
    again, the more you learn about the fascinating realm of quantum computing, the
    more you may find yourself feeling like Richard Feynman‚Äôs famous quote: ‚ÄúI‚Äôm smart
    enough to know that I‚Äôm dumb.‚Äù (Goodreads, 2024)'
  prefs: []
  type: TYPE_NORMAL
- en: '**References**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adedoyin, A., & et. al. (2022, January 8). *Quantum Algorithm Implementations
    for Beginners*. ACM Digital Library. Retrieved May 27, 2024, from [https://dl.acm.org/doi/10.1145/3517340#d1e3003](https://dl.acm.org/doi/10.1145/3517340#d1e3003)
  prefs: []
  type: TYPE_NORMAL
- en: Brandt, H. E. (1999, November). *Qubit devices and the issue of quantum decoherence*.
    Science Direct. Retrieved May 20, 2024, from [https://www.sciencedirect.com/science/article/pii/S0079672799000038](https://www.sciencedirect.com/science/article/pii/S0079672799000038)
  prefs: []
  type: TYPE_NORMAL
- en: Brubaker, B. (2023, October 17). *Thirty Years Later, a Speed Boost for Quantum
    Factoring*. Quanta Magazine. Retrieved May 27, 2024, from [https://www.quantamagazine.org/thirty-years-later-a-speed-boost-for-quantum-factoring-20231017/](https://www.quantamagazine.org/thirty-years-later-a-speed-boost-for-quantum-factoring-20231017/)
  prefs: []
  type: TYPE_NORMAL
- en: Case, M. (n.d.). *A Beginner‚Äôs Guide To The General Number Field Sieve*. UMD
    Computer Science. Retrieved May 26, 2024, from [https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf](https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: Goodreads. (2024). *Quotes by Richard P. Feynman (Author of Surely You‚Äôre Joking,
    Mr. Feynman!)*. Goodreads. Retrieved May 27, 2024, from [https://www.goodreads.com/author/quotes/1429989.Richard_P_Feynman](https://www.goodreads.com/author/quotes/1429989.Richard_P_Feynman)
  prefs: []
  type: TYPE_NORMAL
- en: Harvey, S. P. (2024, March 5). *Quantum Dots/Spin Qubits*. Oxford University
    Press and The American Institute of Physics. Retrieved May 19, 2024, from [https://oxfordre.com/physics/display/10.1093/acrefore/9780190871994.001.0001/acrefore-9780190871994-e-83](https://oxfordre.com/physics/display/10.1093/acrefore/9780190871994.001.0001/acrefore-9780190871994-e-83)
  prefs: []
  type: TYPE_NORMAL
- en: IBM. (2024). *IBM Qiskit Docs*. IBM Quantum Documentation. Retrieved May 26,
    2024, from [https://docs.quantum.ibm.com/](https://docs.quantum.ibm.com/)
  prefs: []
  type: TYPE_NORMAL
- en: IonQ. (2024, March 14). *Hello Many Worlds in Seven Quantum Languages*. IonQ.
    Retrieved May 26, 2024, from [https://ionq.com/docs/hello-many-worlds-seven-quantum-languages](https://ionq.com/docs/hello-many-worlds-seven-quantum-languages)
  prefs: []
  type: TYPE_NORMAL
- en: Li, J., Peng, X., Du, J., & Suter, D. (2022, January 8). *An Efficient Exact
    Quantum Algorithm for the Integer Square-free Decomposition Problem*. Nature.
    Retrieved May 26, 2024, from [https://www.nature.com/articles/srep00260](https://www.nature.com/articles/srep00260)
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft. (n.d.). *What is a Qubit?* Microsoft Azure. Retrieved May 19, 2024,
    from [https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-a-qubit](https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-a-qubit)
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft. (2024). *Azure Quantum | Single-qubit gates*. Azure Quantum. Retrieved
    May 20, 2024, from [https://quantum.microsoft.com/en-us/explore/concepts/single-qubit-gates](https://quantum.microsoft.com/en-us/explore/concepts/single-qubit-gates)
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure. (2024, January 12). *Understanding quantum computing ‚Äî Azure
    Quantum*. Microsoft Learn. Retrieved May 20, 2024, from [https://learn.microsoft.com/en-us/azure/quantum/overview-understanding-quantum-computing](https://learn.microsoft.com/en-us/azure/quantum/overview-understanding-quantum-computing)
  prefs: []
  type: TYPE_NORMAL
- en: Pavlidis, A., & Gizopoulos, D. (2022, July 19). *Quantum Cryptography ‚Äî Shor‚Äôs
    Algorithm Explained*. Classiq. Retrieved May 27, 2024, from [https://www.classiq.io/insights/shors-algorithm-explained](https://www.classiq.io/insights/shors-algorithm-explained)
  prefs: []
  type: TYPE_NORMAL
- en: Quantum-Inspire by QuTech. (2024). *Qubit basis states*. Quantum Inspire. Retrieved
    May 20, 2024, from [https://www.quantum-inspire.com/kbase/qubit-basis-states/](https://www.quantum-inspire.com/kbase/qubit-basis-states/)
  prefs: []
  type: TYPE_NORMAL
- en: 'Rioux, F. (2023, January 10). *8.53: Bell State Exercises*. Chemistry LibreTexts.
    Retrieved May 26, 2024, from [https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Quantum_Tutorials_(Rioux)/08%3A_Quantum_Teleportation/8.53%3A_Bell_State_Exercises](https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Quantum_Tutorials_(Rioux)/08%3A_Quantum_Teleportation/8.53%3A_Bell_State_Exercises)'
  prefs: []
  type: TYPE_NORMAL
- en: Roy, S. G., & Chakrabarti, A. (2024, March 5). *Toffoli Gate*. Science Direct.
    Retrieved May 20, 2024, from [https://www.sciencedirect.com/topics/computer-science/toffoli-gate](https://www.sciencedirect.com/topics/computer-science/toffoli-gate)
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia. (2024). *General number field sieve*. Wikipedia. Retrieved May 24,
    2024, from [https://en.wikipedia.org/wiki/General_number_field_sieve](https://en.wikipedia.org/wiki/General_number_field_sieve)
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia. (2024, May 15). *Quantum logic gate*. Wikipedia. Retrieved May 19,
    2024, from [https://en.wikipedia.org/wiki/Quantum_logic_gate](https://en.wikipedia.org/wiki/Quantum_logic_gate)
  prefs: []
  type: TYPE_NORMAL
- en: Wikipedia. (n.d.). *Bloch sphere*. Wikipedia. Retrieved August 20, 2024, from
    [https://en.wikipedia.org/wiki/Bloch_sphere](https://en.wikipedia.org/wiki/Bloch_sphere)
  prefs: []
  type: TYPE_NORMAL

["```py\nclass WorkflowStreamingEvent(BaseModel):\n    event_type: Literal[\"server_message\", \"request_user_input\"] = Field(\n        ..., description=\"Type of the event\"\n    )\n    event_sender: str = Field(\n        ..., description=\"Sender (workflow step name) of the event\"\n    )\n    event_content: Dict[str, Any] = Field(..., description=\"Content of the event\")\n```", "```py\n@step(pass_context=True)\nasync def tavily_query(self, ctx: Context, ev: StartEvent) -> TavilyResultsEvent:\n    ctx.data[\"research_topic\"] = ev.user_query\n    query = f\"arxiv papers about the state of the art of {ev.user_query}\"\n    ctx.write_event_to_stream(\n        Event(\n            msg=WorkflowStreamingEvent(\n                event_type=\"server_message\",\n                event_sender=inspect.currentframe().f_code.co_name,\n                event_content={\"message\": f\"Querying Tavily with: '{query}'\"},\n            ).model_dump()\n        )\n    )\n```", "```py\n@step(pass_context=True)\n    async def gather_feedback_outline(\n        self, ctx: Context, ev: OutlineEvent\n    ) -> OutlineFeedbackEvent | OutlineOkEvent:\n        \"\"\"Present user the original paper summary and the outlines generated, gather feedback from user\"\"\"\n        ...\n\n        # Send a special event indicating that user input is needed\n        ctx.write_event_to_stream(\n            Event(\n                msg=json.dumps(\n                    {\n                        \"event_type\": \"request_user_input\",\n                        \"event_sender\": inspect.currentframe().f_code.co_name,\n                        \"event_content\": {\n                            \"summary\": ev.summary,\n                            \"outline\": ev.outline.dict(),\n                            \"message\": \"Do you approve this outline? If not, please provide feedback.\",\n                        },\n                    }\n                )\n            )\n        )\n\n        ...\n```", "```py\n@step(pass_context=True)\nasync def gather_feedback_outline(\n    self, ctx: Context, ev: OutlineEvent\n) -> OutlineFeedbackEvent | OutlineOkEvent:\n    ...\n\n    # Wait for user input\n    if not self.user_input_future.done():\n        user_response = await self.user_input_future\n        logger.info(f\"gather_feedback_outline: Got user response: {user_response}\")\n\n        # Process user_response, which should be a JSON string\n        try:\n            response_data = json.loads(user_response)\n            approval = response_data.get(\"approval\", \"\").lower().strip()\n            feedback = response_data.get(\"feedback\", \"\").strip()\n        except json.JSONDecodeError:\n            # Handle invalid JSON\n            logger.error(\"Invalid user response format\")\n            raise Exception(\"Invalid user response format\")\n\n        if approval == \":material/thumb_up:\":\n            return OutlineOkEvent(summary=ev.summary, outline=ev.outline)\n        else:\n            return OutlineFeedbackEvent(\n                summary=ev.summary, outline=ev.outline, feedback=feedback\n            )\n```", "```py\n class ResearchTopic(BaseModel):\n    query: str = Field(..., example=\"example query\")\n\n@app.post(\"/run-slide-gen\")\nasync def run_workflow_endpoint(topic: ResearchTopic):\n    workflow_id = str(uuid.uuid4())\n\n    wf = SummaryAndSlideGenerationWorkflow(wid=workflow_id, timeout=2000, verbose=True)\n    wf.add_workflows(\n        summary_gen_wf=SummaryGenerationWorkflow(\n            wid=workflow_id, timeout=800, verbose=True\n        )\n    )\n    wf.add_workflows(\n        slide_gen_wf=SlideGenerationWorkflow(\n            wid=workflow_id, timeout=1200, verbose=True\n        )\n    )\n\n    async def event_generator():\n        loop = asyncio.get_running_loop()\n        logger.debug(f\"event_generator: loop id {id(loop)}\")\n        yield f\"{json.dumps({'workflow_id': workflow_id})}\\n\\n\"\n\n        task = asyncio.create_task(wf.run(user_query=topic.query))\n        logger.debug(f\"event_generator: Created task {task}\")\n        try:\n            async for ev in wf.stream_events():\n                logger.info(f\"Sending message to frontend: {ev.msg}\")\n                yield f\"{ev.msg}\\n\\n\"\n                await asyncio.sleep(0.1)  # Small sleep to ensure proper chunking\n            final_result = await task\n\n            # Construct the download URL\n            download_pptx_url = f\"http://backend:80/download_pptx/{workflow_id}\"\n            download_pdf_url = f\"http://backend:80/download_pdf/{workflow_id}\"\n\n            final_result_with_url = {\n                \"result\": final_result,\n                \"download_pptx_url\": download_pptx_url,\n                \"download_pdf_url\": download_pdf_url,\n            }\n\n            yield f\"{json.dumps({'final_result': final_result_with_url})}\\n\\n\"\n        except Exception as e:\n            error_message = f\"Error in workflow: {str(e)}\"\n            logger.error(error_message)\n            yield f\"{json.dumps({'event': 'error', 'message': error_message})}\\n\\n\"\n        finally:\n            # Clean up\n            workflows.pop(workflow_id, None)\n\n    return StreamingResponse(event_generator(), media_type=\"text/event-stream\")\n```", "```py\n@app.post(\"/submit_user_input\")\nasync def submit_user_input(data: dict = Body(...)):\n    workflow_id = data.get(\"workflow_id\")\n    user_input = data.get(\"user_input\")\n    wf = workflows.get(workflow_id)\n    if wf and wf.user_input_future:\n        loop = wf.user_input_future.get_loop()  # Get the loop from the future\n        logger.info(f\"submit_user_input: wf.user_input_future loop id {id(loop)}\")\n        if not wf.user_input_future.done():\n            loop.call_soon_threadsafe(wf.user_input_future.set_result, user_input)\n            logger.info(\"submit_user_input: set_result called\")\n        else:\n            logger.info(\"submit_user_input: future already done\")\n        return {\"status\": \"input received\"}\n    else:\n        raise HTTPException(\n            status_code=404, detail=\"Workflow not found or future not initialized\"\n        )\n```", "```py\n@app.get(\"/download_pptx/{workflow_id}\")\nasync def download_pptx(workflow_id: str):\n    file_path = (\n        Path(settings.WORKFLOW_ARTIFACTS_PATH)\n        / \"SlideGenerationWorkflow\"\n        / workflow_id\n        / \"final.pptx\"\n    )\n    if file_path.exists():\n        return FileResponse(\n            path=file_path,\n            media_type=\"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n            filename=f\"final.pptx\",\n        )\n    else:\n        raise HTTPException(status_code=404, detail=\"File not found\")\n```", "```py\ndef start_long_running_task(url, payload, message_queue, user_input_event):\n    try:\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        loop.run_until_complete(\n            get_stream_data(url, payload, message_queue, user_input_event)\n        )\n        loop.close()\n    except Exception as e:\n        message_queue.put((\"error\", f\"Exception in background thread: {str(e)}\"))\n\n...\n\ndef main():\n\n  ...\n\n  with st.sidebar:\n      with st.form(key=\"slide_gen_form\"):\n          query = st.text_input(\n              \"Enter the topic of your research:\",\n          )\n          submit_button = st.form_submit_button(label=\"Submit\")\n\n  if submit_button:\n      # Reset the workflow_complete flag for a new workflow\n      st.session_state.workflow_complete = False\n      # Start the long-running task in a separate thread\n      if (\n          st.session_state.workflow_thread is None\n          or not st.session_state.workflow_thread.is_alive()\n      ):\n          st.write(\"Starting the background thread...\")\n\n          st.session_state.workflow_thread = threading.Thread(\n              target=start_long_running_task,\n              args=(\n                  \"http://backend:80/run-slide-gen\",\n                  {\"query\": query},\n                  st.session_state.message_queue,\n                  st.session_state.user_input_event,\n              ),\n          )\n          st.session_state.workflow_thread.start()\n          st.session_state.received_lines = []\n      else:\n          st.write(\"Background thread is already running.\")\n```", "```py\nasync def fetch_streaming_data(url: str, payload: dict = None):\n    async with httpx.AsyncClient(timeout=1200.0) as client:\n        async with client.stream(\"POST\", url=url, json=payload) as response:\n            async for line in response.aiter_lines():\n                if line:\n                    yield line\n\nasync def get_stream_data(url, payload, message_queue, user_input_event):\n    # message_queue.put((\"message\", \"Starting to fetch streaming data...\"))\n    data_json = None\n    async for data in fetch_streaming_data(url, payload):\n        if data:\n            try:\n                data_json = json.loads(data)\n                if \"workflow_id\" in data_json:\n                    # Send workflow_id to main thread\n                    message_queue.put((\"workflow_id\", data_json[\"workflow_id\"]))\n                    continue\n                elif \"final_result\" in data_json:\n                    # Send final_result to main thread\n                    message_queue.put((\"final_result\", data_json[\"final_result\"]))\n                    continue\n                event_type = data_json.get(\"event_type\")\n                event_sender = data_json.get(\"event_sender\")\n                event_content = data_json.get(\"event_content\")\n                if event_type in [\"request_user_input\"]:\n                    # Send the message to the main thread\n                    message_queue.put((\"user_input_required\", data_json))\n                    # Wait until user input is provided\n                    user_input_event.wait()\n                    user_input_event.clear()\n                    continue\n                else:\n                    # Send the line to the main thread\n                    message_queue.put((\"message\", format_workflow_info(data_json)))\n            except json.JSONDecodeError:  # todo: is this necessary?\n                message_queue.put((\"message\", data))\n        if data_json and \"final_result\" in data_json or \"final_result\" in str(data):\n            break  # Stop processing after receiving the final result\n```", "```py\nif st.session_state.received_lines:\n    with expander_placeholder.container():\n        # Create or update the expander with the latest truncated line\n        expander = st.expander(st.session_state.expander_label)\n        for line in st.session_state.received_lines:\n            expander.write(line)\n            expander.divider()\n```", "```py\nif not st.session_state.workflow_complete:\n    st_autorefresh(interval=2000, limit=None, key=\"data_refresh\")\n```", "```py\ndef gather_outline_feedback(placeholder):\n    container = placeholder.container()\n    with container:\n        if st.session_state.user_input_required:\n            data = st.session_state.user_input_prompt\n            event_type = data.get(\"event_type\")\n            if event_type == \"request_user_input\":\n                summary = data.get(\"event_content\").get(\"summary\")\n                outline = data.get(\"event_content\").get(\"outline\")\n                prompt_message = data.get(\"event_content\").get(\n                    \"message\", \"Please review the outline.\"\n                )\n\n                # display the content for user input\n                st.markdown(\"## Original Summary:\")\n                st.text_area(\"Summary\", summary, disabled=True, height=400)\n                st.divider()\n                st.markdown(\"## Generated Slide Outline:\")\n                st.json(outline)\n                st.write(prompt_message)\n\n                # Define unique keys for widgets\n                current_prompt = st.session_state.prompt_counter\n                approval_key = f\"approval_state_{current_prompt}\"\n                feedback_key = f\"user_feedback_{current_prompt}\"\n\n                # Display the approval feedback widget\n                approval = st.feedback(\"thumbs\", key=approval_key)\n                st.write(f\"Current Approval state is: {approval}\")\n                logging.info(f\"Current Approval state is: {approval}\")\n\n                # Display the feedback text area\n                feedback = st.text_area(\n                    \"Please provide feedback if you have any:\", key=feedback_key\n                )\n\n                # Handle the submission of user response\n                if st.button(\n                    \"Submit Feedback\", key=f\"submit_response_{current_prompt}\"\n                ):\n                    if not st.session_state.user_response_submitted:\n                        # Retrieve approval and feedback using unique keys\n                        approval_state = st.session_state.get(approval_key)\n                        user_feedback = st.session_state.get(feedback_key, \"\")\n\n                        # Ensure approval_state is valid\n                        if approval_state not in [0, 1]:\n                            st.error(\"Please select an approval option.\")\n                            return\n\n                        user_response = {\n                            \"approval\": (\n                                \":material/thumb_down:\"\n                                if approval_state == 0\n                                else \":material/thumb_up:\"\n                            ),\n                            \"feedback\": user_feedback,\n                        }\n                        # Send the user's response to the backend\n\n                        try:\n                            response = requests.post(\n                                \"http://backend:80/submit_user_input\",\n                                json={\n                                    \"workflow_id\": st.session_state.workflow_id,\n                                    \"user_input\": json.dumps(user_response),\n                                },\n                            )\n                            response.raise_for_status()\n                            logging.info(\n                                f\"Backend response for submitting approval: {response.status_code}\"\n                            )\n                        except requests.RequestException as e:\n                            st.error(f\"Failed to submit user input: {str(e)}\")\n                            return\n\n     ...\n```", "```py\n if \"download_url_pdf\" in st.session_state and st.session_state.download_url_pdf:\n      download_url_pdf = st.session_state.download_url_pdf\n      try:\n          # Fetch the PDF content\n          pdf_response = requests.get(download_url_pdf)\n          pdf_response.raise_for_status()\n          st.session_state.pdf_data = pdf_response.content\n\n          st.markdown(\"### Generated Slide Deck:\")\n          # Display the PDF using an iframe\n          st.markdown(\n              f'<iframe src=\"data:application/pdf;base64,{base64.b64encode(st.session_state.pdf_data).decode()}\" width=\"100%\" height=\"600px\" type=\"application/pdf\"></iframe>',\n              unsafe_allow_html=True,\n          )\n      except Exception as e:\n          st.error(f\"Failed to load the PDF file: {str(e)}\")\n\n  # Provide the download button for PPTX if available\n  if (\n      \"download_url_pptx\" in st.session_state\n      and st.session_state.download_url_pptx\n  ):\n      download_url_pptx = st.session_state.download_url_pptx\n      try:\n          # Fetch the PPTX content\n          pptx_response = requests.get(download_url_pptx)\n          pptx_response.raise_for_status()\n          pptx_data = pptx_response.content\n\n          st.download_button(\n              label=\"Download Generated PPTX\",\n              data=pptx_data,\n              file_name=\"generated_slides.pptx\",\n              mime=\"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n          )\n      except Exception as e:\n          st.error(f\"Failed to load the PPTX file: {str(e)}\")\n```", "```py\nversion: '3.8'\n\nservices:\n  backend:\n    build:\n      context: ./backend\n      args:\n        - --no-cache\n    ports:\n      - \"8000:80\"\n    networks:\n      - app-network\n    volumes:\n      - .env:/app/.env\n      - ./data:/app/data\n      - ./workflow_artifacts:/app/workflow_artifacts\n      - ~/.azure:/root/.azure\n\n  frontend:\n    build:\n      context: ./frontend\n      args:\n        - --no-cache\n    ports:\n      - \"8501:8501\"\n    networks:\n      - app-network\n\nnetworks:\n  app-network:\n```"]
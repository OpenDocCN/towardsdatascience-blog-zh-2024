# 排名基础：点对、成对、列表

> 原文：[`towardsdatascience.com/ranking-basics-pointwise-pairwise-listwise-cd5318f86e1b?source=collection_archive---------3-----------------------#2024-12-14`](https://towardsdatascience.com/ranking-basics-pointwise-pairwise-listwise-cd5318f86e1b?source=collection_archive---------3-----------------------#2024-12-14)

## 因为邻近的对象很重要

[](https://medium.com/@kunals726?source=post_page---byline--cd5318f86e1b--------------------------------)![Kunal Santosh Sawant](https://medium.com/@kunals726?source=post_page---byline--cd5318f86e1b--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--cd5318f86e1b--------------------------------)![Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--cd5318f86e1b--------------------------------) [Kunal Santosh Sawant](https://medium.com/@kunals726?source=post_page---byline--cd5318f86e1b--------------------------------)

·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--cd5318f86e1b--------------------------------) ·6 分钟阅读·2024 年 12 月 14 日

--

![](img/54cb29c9cdd0f38ae586510bb08af75b.png)

图片来自 unsplash.com

首先，让我们讨论排名的作用。排名在电子商务和搜索应用中非常重要——基本上是任何需要根据查询来组织文档的场景。这与经典的分类或回归问题有些不同。例如，在泰坦尼克号数据集中，你预测乘客是否幸存，在房价预测中，你估计房子的价格。但在排名中，情况不同。你不是在预测单一的值或类别，而是在尝试根据相关性对文档进行排序。

举个例子：你在像亚马逊这样的电子商务网站上搜索“纱丽”。你不想要一个随机的纱丽列表；你希望最相关的产品出现在顶部，对吧？这就是学习排序（LTR）的作用——它根据文档（或产品）与查询的匹配程度来对它们进行排名。

现在我们已经了解了排名的作用，让我们深入探讨不同的排名方法和技术。

学习排序（LTR）有三种主要方法：

1.  **点对（Pointwise）**

1.  **成对（Pairwise）**

1.  **列表（Listwise）**

为了更容易理解，让我们先定义一些符号，用于解释这些方法。

我们将处理一组查询 ***q1, q2, …, qn***，每个查询都有对应的一组文档 ***d1, d2, d3, …, dm***。例如：

+   查询 ***q1*** 与文档 ***d1***, ***d2***, ***d3*** 相关联。

+   查询 ***q2*** 与文档 ***d4***, ***d5*** 相关联。

既然我们已经了解了排名的定位，让我们深入分析每种方法及其如何解决排名问题。

# 点对（Pointwise）

在**点对点方法**中，我们将排名问题视为一个简单的分类任务。对于每个查询-文档对，我们分配一个目标标签，表示文档与查询的相关性。例如：

+   标签 `1` 表示文档相关。

+   标签 `0` 表示文档不相关。

以我们之前的例子为例，数据看起来是这样的：

+   ***q1,d1***→标签: 1

+   ***q1,d2***→标签: 0

+   ***q1,d3***→标签: 1

+   ***q2,d4***→标签: 0

+   ***q2,d5***→标签: 1

我们使用这些标注数据训练模型，利用查询和文档中的特征来预测标签。训练完成后，模型会预测每个文档与给定查询的相关性作为一个概率值（范围从 0 到 1）。这个概率值可以解释为相关性分数。

例如，训练后，模型可能会生成以下分数：

+   ***q1​,d1***​→分数: 0.6

+   ***q1,d2***→分数: 0.1

+   ***q1,d3***→分数: 0.4

使用这些分数，我们将文档按相关性降序重新排序：***d1,d3,d2***。然后将这个新的排序呈现给用户，确保最相关的文档出现在最前面。

# **成对比**

**点对点方法**的主要缺点是它忽略了用户与文档互动时的**上下文**。当用户点击或认为某个文档相关时，往往有多个因素在起作用——其中一个最重要的因素就是**邻近项**。

例如，如果用户点击了某个文档，这并不一定意味着该文档非常相关。可能只是因为展示的其他文档质量较差。类似地，如果你为相同的查询展示了一组不同的文档，用户的互动可能会完全不同。

想象一下，对于查询***q1***，我们展示了***d4***​。如果***d4***​比***d1***​更相关，用户可能会点击***d4***​而不是***d1***。在点对点方法中，这种文档之间的比较完全被忽视。

为了捕捉这种**相对相关性**，我们转向了**成对比方法**。

在成对比方法中，我们不是单独看查询-文档对，而是聚焦于同一查询下的**文档对**，并尝试预测哪个文档更相关。这有助于结合文档之间的比较上下文。

我们现在会类似地生成数据，但我们使用它的方式会稍微复杂一些。接下来我们将分解它。

想象一下，**成对比方法**的训练数据结构如下：

+   ***q1,(d1,d2)***→标签: 1（表示***d1***​比***d2***​更相关）

+   ***q1,(d2,d3)***→标签: 0（表示***d2***​比***d3***​不太相关）

+   ***q1,(d1,d3)***→标签: 1（表示***d1***比***d3***​更相关）

+   ***q2,(d4,d5)***→标签: 0（表示***d4***比***d5***​不太相关）

在这里，我们根据用户的互动分配标签。例如，***d1*** 和 ***d3*** 都被点击表示它们相关，因此我们保持它们的顺序，便于在此解释。

## 模型训练过程：

尽管训练数据是成对的，但模型并不会直接处理这些对。相反，我们将其类似于分类问题处理，每个**查询-文档对**都会单独传递给模型。

例如：

+   ***s1 = f(q1,d1)***

+   ***s2 = f(q1,d2)***

+   ***s3 = f(q1,d3)***

模型为文档生成评分 ***s1,s2,s3***。这些评分用于比较文档对的相关性。

**惩罚模型：**

如果模型预测的评分违反了真实的相关性顺序，那么它会受到惩罚。例如：

+   如果 ***s1<s2***，但训练数据表明 ***d1>d2***，则模型会受到惩罚，因为它未能将 ***d1*** 排在 ***d2*** 之前。

+   如果 ***s2<s3***，并且训练数据表明 ***d2<d3***，那么模型做对了，因此不需要惩罚。

**这种成对比较帮助模型学习文档的相对顺序，而不是像点对点方法那样仅预测独立的相关性评分。**

**挑战：**

实现成对模型的主要挑战之一是**计算复杂度**——因为我们需要比较所有可能的文档对，这一过程的规模是 O(n²)。此外，成对方法并不考虑文档的**全局排序**；它们仅在比较过程中关注个别对，这可能导致整体排序的不一致。

# Listwise

在 Listwise 排序中，目标是基于文档与查询的相关性来优化整个文档列表。与其单独处理每个文档，不如专注于它们在列表中出现的顺序。

以下是 ListNet 和 LambdaRank 中工作原理的分解：

**NDCG（归一化折扣累积增益）**：我将在另一篇博客中深入探讨 NDCG，但现在可以把它看作一种衡量项目排序与其相关性匹配程度的方式。它奖励相关项目出现在列表顶部，并对评分进行归一化，以便更容易进行比较。

在 Listwise 排序中，如果你有一个文档列表（d1, d2, d3），模型会考虑这些文档的所有可能排列：

+   ***(d1, d2, d3)***

+   ***(d1, d3, d2)***

+   ***(d2, d1, d3)***

+   ***(d2, d3, d1)***

+   ***(d3, d1, d2)***

+   ***(d3, d2, d1)***

**训练过程：**

1.  **评分预测**：模型为列表中的每个文档预测一个评分，文档将根据这些评分进行排序。例如： ***s1 = f(q1,d1), s2 = f(q1,d2)***

1.  **理想排序**：理想排序是通过根据文档的**真实相关性**对其进行排序来计算的。例如，***d1*** 可能是最相关的，其次是 ***d2***，然后是 ***d3***。

1.  **NDCG 计算**：NDCG 是针对每个文档列表的排列进行计算的。它检查预测排序与理想排序的接近程度，同时考虑到文档的相关性和位置。

1.  **惩罚错误排序**：如果预测排序与理想排序不同，NDCG 分数将下降。例如，如果理想排序是***(d1, d3, d2)***，而模型排序为***(d2, d1, d3)***，那么 NDCG 分数会较低，因为最相关的文档（***d1***)没有排在最前面。

1.  **梯度计算**：模型根据如果调整文档顺序，NDCG 分数会发生的变化来计算梯度。这些梯度指引模型如何改进预测。

这个过程帮助模型学习如何优化整个排序列表，提高呈现给用户的文档的相关性。

# **总结**

在学习排序（Learning to Rank）中，并没有一种通用的解决方案。基于点的模型非常容易设置和更新，但它们并不总是考虑到文档之间的相互关系。也就是说，如果你需要一个简单且快速的方法，它们是一个很好的选择。

另一方面，***成对排序（pairwise）***和***列表排序（listwise）***方法更为强大，因为它们考虑了文档之间的相互比较。但是，这种**力量带来了更多的复杂性**😛，而且列表排序由于训练的高复杂度，可能会成为一个真正的挑战。

就我个人而言，我认为***成对排序（pairwise）***方法是一个很好的平衡点。它在复杂性和性能之间达到了良好的平衡，使其在许多情况下都很理想。

最终，你选择的方法确实取决于你的具体情况。你的数据集有多大且多复杂？了解每种方法的优缺点将帮助你选择最适合你需求的方法。

今天的内容就到这里！敬请期待下一部分，在那之前祝你排序愉快！😊

## 参考文献：

[从 RankNet 到 LambdaRank 再到 LambdaMART：概述](https://www.microsoft.com/en-us/research/uploads/prod/2016/02/MSR-TR-2010-82.pdf)

[学习排序：从成对排序方法到列表排序方法](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2007-40.pdf)

[学习排序简介](https://everdark.github.io/k9/notebooks/ml/learning_to_rank/learning_to_rank.html)

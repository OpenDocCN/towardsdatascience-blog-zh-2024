["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndef rbf(v1, v2, sigma=0.5):\n  return np.exp(-(v2 - v1) ** 2/(2 * sigma**0.5))\n\ndef comp_wit_fn(x, d1, d2):\n  return 1/len(d1) * sum([rbf(x, dp) for dp in d1]) - 1/len(d2) * sum([rbf(x, dp) for dp in d2])\n\nlow1, high1 = -0.5, 0.5  # Range for the first uniform distribution\nlow2, high2 = -1, 1  # Range for the second uniform distribution\n\n# Generate data for the uniform distributions\ndata1 = np.random.uniform(low1, high1, 10000)\ndata2 = np.random.uniform(low2, high2, 10000)\n\n# Generate a range of x values for which to compute comp_wit_fn\nx_values = np.linspace(min(low1 * 2, low2 * 2), max(high1 * 2, high2 * 2), 100)\n\ncomp_wit_values = [comp_wit_fn(x, data1, data2) for x in x_values]\nsns.kdeplot(data1, label=f'Uniform({low1}, {high1})', color='blue', fill=True)\nsns.kdeplot(data2, label=f'Uniform({low2}, {high2})', color='red', fill=True)\nplt.plot(x_values, comp_wit_values, label='Witness Function', color='green')\n\nplt.xlabel('Value')\nplt.ylabel('Density / Wit Fn')\nplt.legend()\nplt.show()\n```", "```py\nimport math\nimport itertools\n\ndef euc_distance(p1, p2):\n    return math.sqrt(sum((x - y) ** 2 for x, y in zip(p1, p2)))\n\ndef rbf(v1, v2, sigma=0.5):\n  return math.exp(-euc_distance(v1, v2) ** 2/(2 * sigma**0.5))\n\ndef mmd_sq(X, Y, sigma=0.5):\n  sm_xx = 0\n  for x in X:\n    for x2 in X:\n      sm_xx += rbf(x, x2, sigma)\n\n  sm_xy = 0\n  for x in X:\n    for y in Y:\n      sm_xy += rbf(x, y, sigma)\n\n  sm_yy = 0\n  for y in Y:\n    for y2 in Y:\n      sm_yy += rbf(y, y2, sigma)\n\n  return 1/(len(X) ** 2) * sm_xx \\\n          - 2/(len(X) * len(Y)) * sm_xy \\\n          + 1/(len(Y) ** 2) * sm_yy\n\ndef select_protos(X, n, sigma=0.5):\n  min_score, min_sub = math.inf, None\n  for subset in itertools.combinations(X, n):\n    new_mmd = mmd_sq(X, subset, sigma)\n    if new_mmd < min_score:\n      min_score = new_mmd\n      min_sub = subset\n  return min_sub\n\ndef criticism_score(criticism, prototypes, X, sigma=0.5):\n  return abs(1/len(X) * sum([rbf(criticism, x, sigma) for x in X])\\\n             - 1/len(prototypes) * sum([rbf(criticism, p, sigma) for p in prototypes]))\n\ndef select_criticisms(X, P, n, sigma=0.5):\n  candidates = [c for c in X if c not in P]\n  max_score, crits = -math.inf, []\n  for subset in itertools.combinations(candidates, n):\n    new_score = sum([criticism_score(c, P, X, sigma) for c in subset])\n    if new_score > max_score:\n      max_score = new_score\n      crits = subset\n\n  return crits\n```", "```py\ndef select_protos(X, n, sigma=0.5):\n  protos = []\n  for _ in range(n):\n    min_score, min_proto = math.inf, None\n    for cand in X:\n      if cand in protos:\n        continue\n      new_score = mmd_sq(X, protos + [cand], sigma)\n      if new_score < min_score:\n        min_score = new_score\n        min_proto = cand\n    protos.append(min_proto)\n  return protos\n```", "```py\npip install mmd-critic\n```", "```py\nfrom sklearn.datasets import make_blobs\nfrom mmd_critic import MMDCritic\nfrom mmd_critic.kernels import RBFKernel\n\nn_samples = 50  # Total number of samples\ncenters = 4       # Number of clusters\ncluster_std = 1 # Standard deviation of the clusters\n\nX, _ = make_blobs(n_samples=n_samples, centers=centers, cluster_std=cluster_std, n_features=2, random_state=42)\nX = X.tolist()\n\n# MMD critic with the kernel used for the prototypes being an RBF with sigma=1,\n# for the criticisms one with sigma=0.025\ncritic = MMDCritic(X, RBFKernel(1), RBFKernel(0.025))\nprotos, _ = critic.select_prototypes(centers)\ncriticisms, _ = critic.select_criticisms(10, protos)\n```", "```py\nfrom sklearn.datasets import fetch_openml\nimport numpy as np\nfrom mmd_critic import MMDCritic\nfrom mmd_critic.kernels import RBFKernel\n\n# Load MNIST data\nmnist = fetch_openml('mnist_784', version=1)\nimages = (mnist['data'].astype(np.float32)).to_numpy() / 255.0\nlabels = mnist['target'].astype(np.int64)\n\ncritic = MMDCritic(images[:15000], RBFKernel(2.5), RBFKernel(0.025))\nprotos, _ = critic.select_prototypes(40)\ncriticisms, _ = critic.select_criticisms(40, protos)\n```"]
- en: Algorithmic Alchemy with The Fast Fourier Transform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速傅里叶变换的算法炼金术
- en: 原文：[https://towardsdatascience.com/algorithmic-alchemy-with-the-fast-fourier-transform-9d52a5b6d94a?source=collection_archive---------4-----------------------#2024-01-07](https://towardsdatascience.com/algorithmic-alchemy-with-the-fast-fourier-transform-9d52a5b6d94a?source=collection_archive---------4-----------------------#2024-01-07)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/algorithmic-alchemy-with-the-fast-fourier-transform-9d52a5b6d94a?source=collection_archive---------4-----------------------#2024-01-07](https://towardsdatascience.com/algorithmic-alchemy-with-the-fast-fourier-transform-9d52a5b6d94a?source=collection_archive---------4-----------------------#2024-01-07)
- en: The Ultimate Guide to Mechanics of the FFT Algorithm
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FFT算法的终极指南
- en: with Applications in Signal Processing
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号处理中的应用
- en: '[](https://namanagr03.medium.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)[![Naman
    Agrawal](../Images/6bb885397aec17f5029cfac7f01edad9.png)](https://namanagr03.medium.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)
    [Naman Agrawal](https://namanagr03.medium.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://namanagr03.medium.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)[![Naman
    Agrawal](../Images/6bb885397aec17f5029cfac7f01edad9.png)](https://namanagr03.medium.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)
    [Naman Agrawal](https://namanagr03.medium.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)
    ·20 min read·Jan 7, 2024
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--9d52a5b6d94a--------------------------------)
    ·20分钟阅读·2024年1月7日
- en: --
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/2e440a307dfe2736c835abb923c47bc7.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2e440a307dfe2736c835abb923c47bc7.png)'
- en: 'Photo by Stephen Niemeier: [https://www.pexels.com/photo/black-and-silver-mixing-board-63703/](https://www.pexels.com/photo/black-and-silver-mixing-board-63703/)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由Stephen Niemeier拍摄：[https://www.pexels.com/photo/black-and-silver-mixing-board-63703/](https://www.pexels.com/photo/black-and-silver-mixing-board-63703/)
- en: Contents
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引言
- en: What is the Fourier Transform?
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是傅里叶变换？
- en: 2.1 Time Domain
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.1 时域
- en: 2.2 Frequency Domain
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.2 频域
- en: '2.3 The Fourier Transform: A Mathematical Perspective'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.3 傅里叶变换：数学视角
- en: The Limitation of the Traditional Discrete Fourier Transformation Calculation
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传统离散傅里叶变换计算的局限性
- en: The FFT Algorithm
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FFT算法
- en: The Matrix View
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵视角
- en: The Bottom Line
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终总结
- en: '**Note:** The entire code file used in this article is available at the following
    repository: [https://github.com/namanlab/FFT_Algorithm_Code](https://github.com/namanlab/FFT_Algorithm_Code)'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 本文中使用的完整代码文件可以在以下仓库找到：[https://github.com/namanlab/FFT_Algorithm_Code](https://github.com/namanlab/FFT_Algorithm_Code)'
- en: Introduction
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引言
- en: The very foundations of the world around us, from the behavior of quantum particles
    to the movement of large celestials are probably governed by algorithms. As the
    silent architects of our digital cosmos, they are like the gods of the modern
    era sculpting the contours of our technological reality. Algorithms are omnipotent,
    as they command the intricacies of reality with unmatched precision and understanding.
    They manifest an omnipresence, quietly shaping our experiences, guiding all of
    technology, and influencing the very fabric of our interconnected world. Finally,
    they also exhibit an omniscient prowess as they help mankind decipher complex
    patterns and navigate the vast realms of data buried within our nature.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们周围世界的基础，从量子粒子的行为到巨大天体的运动，可能都由算法支配。作为我们数字宇宙的无声建筑师，它们像现代时代的神明，雕刻着我们技术现实的轮廓。算法是无所不能的，它们以无与伦比的精确度和理解力指挥着现实的复杂性。它们表现出一种无所不在的存在，悄悄塑造我们的体验，指引所有技术，并影响我们互联世界的基本结构。最终，它们还展现出一种无所不知的能力，帮助人类解码复杂的模式，导航我们大自然中埋藏的数据浩瀚领域。
- en: 'An algorithm isn’t just a method or a technique of doing something, it’s also
    about doing it efficiently in a way that saves us time and space, the two constraints
    that basically led to the entire field of their study. In this article, we will
    explore one of the most brilliant algorithms of the century: the Fast Fourier
    Transform (FFT) algorithm. The FFT algorithm helped us solve one of the biggest
    challenges in audio signal processing, namely computing the discrete Fourier transform
    of a signal in a way that is not only time efficient but also extremely beautiful.
    I hope that by the end of this article, you will be able to appreciate the sheer
    elegance of this revolutionary algorithm. Let’s begin!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 算法不仅仅是做某件事的方法或技巧，它还关乎如何高效地完成任务，节省时间和空间——这两个约束实际上促成了整个研究领域的诞生。本文将探讨本世纪最出色的算法之一：快速傅里叶变换（FFT）算法。FFT算法帮助我们解决了音频信号处理中最具挑战性的问题之一，即以既高效又极其优美的方式计算信号的离散傅里叶变换。我希望通过本文的阅读，你能够欣赏到这一革命性算法的优雅之处。让我们开始吧！
- en: What is the Fourier Transform?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是傅里叶变换？
- en: '**Note:** If you’re already familiar with the concept of a Fourier transform,
    you may skip this section and proceed to the next one, where I’ll talk about the
    need for the FFT algorithm and how it works.'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 如果你已经熟悉傅里叶变换的概念，你可以跳过这一部分，直接进入下一部分，我将在那里讨论FFT算法的需求以及它是如何工作的。'
- en: 'The Fourier transformation is essentially a mathematical technique that allows
    us to convert a signal from its time domain to its frequency domain. But what
    do you even mean by time and frequency domain? To understand this, first let us
    think about the fundamental question: what is a signal?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶变换本质上是一种数学技巧，它可以将信号从时间域转换到频域。那么，什么是时间域和频域呢？为了理解这一点，我们首先需要思考一个基本问题：什么是信号？
- en: 'In the simplest sense, a signal is just a variation in a physical quantity.
    This physical quantity could be anything measurable: speed, voltage, current,
    pressure, energy, you name it. Signals can be broadly categorized into two domains:
    time domain and frequency domain.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从最简单的角度来看，信号仅仅是物理量的变化。这个物理量可以是任何可以测量的东西：速度、电压、电流、压力、能量等等。信号大致可以分为两种领域：时间域和频域。
- en: Time Domain
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间域
- en: In the time domain, a signal is represented as a function of time. In other
    words, this means that we can plot/represent the signal’s behavior with respect
    to time, and you observe how it changes over a specific time interval.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间域中，信号被表示为时间的函数。换句话说，这意味着我们可以绘制/表示信号相对于时间的行为，并观察它在特定时间间隔内如何变化。
- en: 'For example, if you are measuring the voltage across a resistor in an electrical
    circuit, the signal in the time domain would show you how the voltage varies at
    different points in time. Similarly, the time domain representation of a sound
    just shows how the amplitude of the sound wave (which is just the extent of air
    pressure) varies over time. The signal could be represented mathematically as
    a function:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你在测量电路中一个电阻上的电压，时间域中的信号将展示电压在不同时间点的变化情况。同样，声音的时间域表示仅展示声波的幅度（即空气压力的变化程度）随时间的变化。信号可以用一个函数来数学表示：
- en: x(t) = 2t² + 2t − 1
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: x(t) = 2t² + 2t − 1
- en: 'This is the continuous representation of the signal x as a direct function
    of time, t (in seconds). However, for most practical applications, we don’t know
    the true functional form of the signal. All we have is a discrete sample of the
    signal (at different points of time) that could be represented as a simple vector
    such as this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是信号x作为时间t（单位：秒）的直接函数的连续表示。然而，对于大多数实际应用，我们并不知道信号的真实函数形式。我们所拥有的只是信号的离散样本（在不同时间点的样本），可以表示为一个简单的向量，如下所示：
- en: '![](../Images/6475e3f9f0b0d1ad717d23714bc9d893.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6475e3f9f0b0d1ad717d23714bc9d893.png)'
- en: The vector just shows the value of x at 8 different (equally spaced) intervals
    of time. The spacing between the time intervals is called the time period, T of
    the signal. So, if the signal was sampled at intervals of 2 seconds each, the
    time period would be T = 2 seconds.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 该向量仅展示x在8个不同（等间隔）时间点的值。这些时间间隔之间的间距称为信号的时间周期T。因此，如果信号在每2秒的间隔处进行采样，那么时间周期就是T =
    2秒。
- en: Frequency Domain
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 频域
- en: In the frequency domain, a signal is represented as a function of frequency.
    Instead of analyzing how a signal changes over time, the focus is on its frequency
    components or the different frequencies present in the signal. This may be a bit
    more difficult to understand, so let’s spend some more time talking about this
    with an example of sound waves. Imagine you’re listening to a piece of music on
    the radio. In the time domain, you experience the music unfolding over time —
    how the melody progresses, the rhythm of the beats, and the duration of each note.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在频域中，信号表示为频率的函数。与分析信号如何随时间变化不同，重点在于信号的频率成分或信号中存在的不同频率。这可能有点难以理解，因此让我们通过一个声音波的例子来多讨论一下。假设你在收音机上听一段音乐。在时域中，你体验到音乐随时间展开——旋律的进展、节奏的变化以及每个音符的时长。
- en: 'Now, let’s switch to the frequency domain. Think of the frequency domain as
    if you’re looking at the music from a different perspective. Instead of focusing
    on how the music evolves over time, you’re interested in the individual tones
    or pitches that make up the overall sound. Imagine you can isolate the specific
    musical notes, such as the deep bass, the mid-range tones, and the high-pitched
    elements. How cool would that be? Think about what constitutes the music: the
    individual instruments and the singers. Each instrument and voice present in the
    music has a unique signature in the frequency domain. The bass guitar might dominate
    in the lower frequencies, the vocals may cover a broad range, and the cymbals
    and high hats contribute to the higher frequencies. That’s where the frequency
    domain steps in as a superhero of sorts; it allows you to break down the complex
    mixture of sounds into its constituent parts. In essence, it provides a different
    viewpoint, focusing on the building blocks of a signal’s sound rather than its
    progression over time.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到频域。把频域想象成你从不同的角度来观察音乐。你不再关注音乐如何随时间发展，而是关注构成整体声音的各个音调或音高。想象一下你能分离出特定的音乐音符，比如深沉的低音、中频音调和高音元素。这岂不是很酷吗？想想构成音乐的元素：每个乐器和歌手。音乐中每个乐器和声音在频域中都有独特的特征。低音吉他可能主导低频范围，歌声可能覆盖广泛的频率范围，而钹和高帽则贡献了高频部分。这就是频域作为某种“超级英雄”发挥作用的地方；它让你能够将复杂的声音混合拆解为其组成部分。从本质上讲，它提供了一种不同的视角，专注于信号声音的构建块，而不是它随时间的变化过程。
- en: 'In its frequency domain, the signal could be represented as a function (continuous)
    like y(f) = 2f² + 3 or as a simple vector (akin to the time domain) such as this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在其频域中，信号可以表示为一个函数（连续函数）如 y(f) = 2f² + 3，或者像这样表示为一个简单的向量（类似于时域）：
- en: '![](../Images/65d2fe194171bf5a3f3186e8695bd11d.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/65d2fe194171bf5a3f3186e8695bd11d.png)'
- en: The vector just shows the amplitude/extent of the presence of the different
    frequency components. The first element (1) could represent the amplitude of the
    lowest frequency component (say 1 Hz, Hz is the unit of frequency). Likewise,
    the second element (2) could represent the amplitude of the next frequency component,
    and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个向量仅表示不同频率成分的幅度/存在程度。第一个元素（1）可能代表最低频率成分（比如1 Hz，Hz是频率的单位）的幅度。同样，第二个元素（2）可能代表下一个频率成分的幅度，依此类推。
- en: 'The Fourier Transform: A Mathematical Perspective'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 傅里叶变换：一种数学视角
- en: Now that we have some idea of how the signal can be represented, visualize the
    Fourier Transformation as a magical lens that allows you to switch your view between
    the two representations of signals. . It acts as a bridge between the time and
    frequency domains, allowing us to analyze and understand signals in both time
    and frequency perspectives.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对信号如何表示有了一些了解，想象一下傅里叶变换就像一个神奇的镜头，允许你在信号的两种表示方式之间切换。它充当时域和频域之间的桥梁，让我们可以从时域和频域的角度分析和理解信号。
- en: 'Now, we analyze what I just said using some math. The Fourier transformation
    is a function that takes the signal in its time domain as input and decomposes
    it into a sum of sine and cosine waves of varying frequencies having their amplitude
    and phase. The resulting representation is nothing but the frequency domain (or
    what we also call the spectrum) of the signal. Mathematically, the Fourier transform
    of a continuous signal in its time domain x(t) is defined as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用一些数学来分析我刚才所说的。傅里叶变换是一个函数，它将信号的时域表示作为输入，并将其分解为不同频率的正弦波和余弦波的和，每个波有其幅度和相位。得到的表示就是信号的频域（或我们通常称之为谱）表示。数学上，连续信号在时域上的傅里叶变换定义如下：
- en: '![](../Images/c6ce6618794aa48077be11dc5659614d.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c6ce6618794aa48077be11dc5659614d.png)'
- en: 'where i = √(-1) is the imaginary number. Yes, the Fourier transformation yields
    a complex output as a result that includes both a complex phase and magnitude.
    Nevertheless, in many practical scenarios, our focus is primarily on the magnitude
    of the transformation, and we often disregard the accompanying phase. Given that
    digitally processed signal is discrete, we can establish the discrete Fourier
    transform (DFT) as its analogous counterpart:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 i = √(-1) 是虚数。是的，傅里叶变换会产生一个包含复相位和幅度的复数输出。然而，在许多实际场景中，我们的关注点主要是变换的幅度，通常忽略伴随的相位。由于数字处理信号是离散的，我们可以建立离散傅里叶变换（DFT）作为其对应的类比形式：
- en: '![](../Images/93abde6bdfe38486e2e319f0ea4c2c75.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/93abde6bdfe38486e2e319f0ea4c2c75.png)'
- en: 'Here we have simply replaced the integral with sum as we may only have discrete
    time samples and the true functional form of the signal may be unknown to us.
    Instead of an infinite number of samples, suppose we have a finite number of samples,
    call it N: the number of time samples or the length of the vector representing
    the signal. Then we get the so-called short-term Fourier transform of the signal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是简单地将积分替换为求和，因为我们可能只有离散的时间样本，而且信号的真实函数形式对我们来说可能是未知的。假设我们有有限数量的样本，称之为
    N：即时间样本的数量或表示信号的向量的长度。那么我们得到信号的所谓短时傅里叶变换：
- en: '![](../Images/50b314314b60546639d5fbdc9a15b829.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/50b314314b60546639d5fbdc9a15b829.png)'
- en: 'where T is the time period. The above function can be computed for any value
    of f and its magnitude just shows us the extent to which that particular frequency
    component is present / power of that frequency component. For instance, given
    the following vector representation, we may compute the Fourier transform at f
    = 0.5 and f = 0.25:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 T 是时间周期。上述函数可以针对任何 f 值进行计算，其幅度仅显示该特定频率成分的存在程度/该频率成分的功率。例如，给定以下向量表示，我们可以计算
    f = 0.5 和 f = 0.25 时的傅里叶变换：
- en: '![](../Images/a643a1ff59192a4251ba69f18ee5f6fa.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a643a1ff59192a4251ba69f18ee5f6fa.png)'
- en: Suppose the values of x are measured in intervals of T = 1 second each. Then,
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 x 的值是以 T = 1 秒的间隔进行测量的。那么，
- en: '![](../Images/52853bcf2a5f85511c54a3c5da8d20cf.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/52853bcf2a5f85511c54a3c5da8d20cf.png)'
- en: 'The above calculation requires the use of some basic complex number properties,
    mostly the Euler’s identity: exp{πi} = −1\. The output, essentially allows us
    to compare the presence of different frequency components. This leads us to the
    next question: what values of f do we consider? Theoretically, we could obtain
    the value of the Fourier transform for any value of f, thus it becomes imperative
    to find the right range of values of f, for which the Fourier Transform gives
    a good picture of the underlying signal and is also interchangeable i.e., it can
    be used to obtain the time domain back. For most practical applications, we only
    consider frequency bins that are an integral multiple of 1/(TN) where TN is the
    total duration of the signal (the number of samples N times the duration of each
    sample, T) we have. The reason for this is closely related to the concept of sampling
    and the Nyquist-Shannon sampling theorem, an idea that is not particularly relevant
    to this article. But if you’re curious about it, feel free to refer to this [page](https://www.techtarget.com/whatis/definition/Nyquist-Theorem).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上述计算需要使用一些基本的复数性质，主要是欧拉公式：exp{πi} = −1。输出本质上允许我们比较不同频率成分的存在。这引出了下一个问题：我们考虑哪些f值？理论上，我们可以为任何f值计算傅里叶变换的值，因此必须找到合适的f值范围，使得傅里叶变换能够很好地描述底层信号，并且具有可交换性，即它可以用于恢复时域。对于大多数实际应用，我们只考虑1/(TN)的整数倍的频率区间，其中TN是信号的总持续时间（即样本数N乘以每个样本的持续时间T）。之所以如此，是因为这一点与采样和奈奎斯特-香农采样定理的概念密切相关，虽然这个概念与本文不特别相关。如果你对此感兴趣，可以参考这[页](https://www.techtarget.com/whatis/definition/Nyquist-Theorem)。
- en: 'Before moving forward, let’s take a moment to summarise everything we’ve covered
    so far: a signal is just a variation in a physical quantity that can be expressed
    as a function of time (time domain) or as a function of frequency (frequency domain).
    Both these representations are equivalent (i.e., one can give us the other) and
    the Fourier transform is the method for converting one representation to another.
    The Fourier Transform of a continuous signal is represented as a continuous function
    in the frequency domain. However, when we work with digital signals (discrete-time
    signals), we sample the continuous signal at discrete points. This gives us the
    following formula for computing the short-term discrete Fourier transform of a
    signal:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们稍作总结一下迄今为止我们所覆盖的内容：信号只是一个物理量的变化，可以表示为时间的函数（时域）或频率的函数（频域）。这两种表示方式是等价的（即其中一种可以转换为另一种），而傅里叶变换就是将一种表示方式转换为另一种表示方式的方法。连续信号的傅里叶变换表示为频域中的一个连续函数。然而，当我们处理数字信号（离散时间信号）时，我们会在离散点上对连续信号进行采样。这为我们提供了计算信号短时离散傅里叶变换的公式：
- en: '![](../Images/6e3e93ac5a2de1d8cdcc9be6cae6ee82.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6e3e93ac5a2de1d8cdcc9be6cae6ee82.png)'
- en: 'Since we only consider frequencies that are an integral multiple of 1/N, we
    get the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只考虑是1/N的整数倍的频率，我们得到如下结果：
- en: '![](../Images/5f3e01b397b4e064237d125190336a9b.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5f3e01b397b4e064237d125190336a9b.png)'
- en: 'where i is the complex number √(-1), j is the index of the sample in the signal
    and k is the index of the frequency bin for which we’re computing the power. Since
    it’s cumbersome to write y(k/(NT)) again, we simply define a new function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 其中i是复数√(-1)，j是信号中样本的索引，k是我们计算功率的频率区间的索引。由于重复写y(k/(NT))较为繁琐，我们干脆定义一个新函数：
- en: '![](../Images/6fa7b142bf65ede66080a5e128709712.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6fa7b142bf65ede66080a5e128709712.png)'
- en: 'And that my friends, is the equation for the Fourier Transform that we commonly
    encounter in textbooks. If you’re still unsure about how and why this works, here’s
    an excellent explanation of Fourier transforms. For the next section of this article,
    we will put in some real data to calculate the complete Fourier Transform of a
    signal, write up some code, and discover the limitations of the traditional approach
    to computing the Fourier Transform of a signal. This will eventually lead us to
    the core of this article: the FFT algorithm.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是朋友们，我们在教科书中常遇到的傅里叶变换公式。如果你仍然不确定它如何工作以及为什么这么做，下面是一个关于傅里叶变换的极好解释。在本文的下一部分，我们将用一些实际数据计算信号的完整傅里叶变换，编写代码，并发现传统计算傅里叶变换的方法的局限性。这最终将引导我们进入本文的核心内容：FFT算法。
- en: The Limitation of the Traditional Discrete Fourier Transformation Calculation
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统离散傅里叶变换计算的局限性
- en: 'Let’s start this section by calculating the Fourier Transformation of a simple
    signal consisting of just 8 samples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从计算一个简单信号的傅里叶变换开始，这个信号只包含8个样本：
- en: '![](../Images/56977a1b1e5aafffeca430eca7c6f792.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/56977a1b1e5aafffeca430eca7c6f792.png)'
- en: 'As we can see from the formula, we don’t care about the time period i.e., the
    intervals at which the quantity is measured as long as it is sampled uniformly.
    Now, we may proceed to find the Fourier transform by plugging in the values into
    the formula for different values of k (ranging from k = 0 to k = N — 1 = 7). Consequently,
    we need to calculate the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从公式中可以看出，我们不关心时间周期，也就是说，我们不在乎测量该量的间隔，只要它是均匀采样的。现在，我们可以通过将值代入公式，计算不同k值（从k=0到k=N-1=7）的傅里叶变换。因此，我们需要计算以下内容：
- en: '![](../Images/2a4fe2948d3d6c359adf3a45c3e9439d.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2a4fe2948d3d6c359adf3a45c3e9439d.png)'
- en: 'Let us simplify the calculations by taking α = exp{-2πi/N}. Thus, all we need
    is:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过取α = exp{-2πi/N}来简化计算。因此，我们只需要：
- en: '![](../Images/14546f3b8bc0ec19a83bdf35bbce4a75.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/14546f3b8bc0ec19a83bdf35bbce4a75.png)'
- en: 'and so on for all 8 values of k. This is quite a lengthy calculation. Can we
    do better? Of course, we can use a simple Python program to do the job for us.
    Here’s a traditional (referred to as the brute force) approach that essentially
    goes through every every element in the vector and computes the required term
    for all values of k from 0 to N — 1:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有8个k值依次进行计算。这个计算过程相当繁琐。我们能做得更好吗？当然，我们可以用一个简单的Python程序来为我们完成这项工作。下面是一个传统的（称为暴力法）方法，它本质上是遍历向量中的每个元素，并计算从k=0到k=N-1的所有k值所需的项：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using this function, we easily get the 8 DFT coefficients required. We can
    also verify our calculations using the fft function provided by numpy:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，我们可以轻松得到所需的8个DFT系数。我们还可以使用numpy提供的fft函数验证我们的计算：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Cool, we can get the result correctly! But, is the method of calculating really
    efficient? What do you think is the time complexity of this function? It involves
    two nested for loops each iterating over the entire range of values from 0 to
    N — 1\. Thus, the time complexity is of the order O(N²). This may not seem too
    bad, but for most practical applications, an O(N²) time complexity could mean
    extremely slow time to get the results. Let’s put this to numbers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，我们可以正确地得到结果！但是，计算方法真的高效吗？你认为这个函数的时间复杂度是多少？它涉及两个嵌套的for循环，每个循环都遍历从0到N-1的整个值域。因此，时间复杂度是O(N²)。这看起来似乎还不错，但对于大多数实际应用来说，O(N²)的时间复杂度可能意味着获取结果的速度非常慢。让我们用数字来验证这一点。
- en: 'Suppose we are computing the Fourier transform of an audio sample that’s just
    10 minutes long. For most traditional applications, we often sample at a rate
    of 22050 i.e., we measure 22050 samples at every second (this may seem a lot,
    but it really isn’t, this is the sampling rate that’s most commonly used to maintain
    the quality of the audio sample). This means that we have about 10*60*22050 =
    13230000 samples. To take the DFT of this sample, we will therefore need at least
    N² = 13230000² = 175032900000000 number of computations, and that’s a lot! If
    you’re using something like C++ (which is one of the most efficient programming
    languages), the max you can do is possibly 2 × 108 computations per second. This
    means, that calculating the DFT of a short 10-minute audio would take 175032900000000/200000000
    = 2875164.5 seconds or about 10 days! This would make it practically impossible
    to compute the DFT of large signals, rendering the application of the Fourier
    transform quite limited. But fear not! Enter the Fast Fourier Transform (FFT),
    the magical algorithm that swoops in, making DFT computations lightning-fast.
    It helps reduce the time complexity of DFT calculation from O(N²) to mere O(N
    log N). For the 10-minute sample, we would now require only 13230000*log(13230000)
    = 216945507 floating point operations. This translates to a mere 1.08 seconds,
    much more efficient than the traditional DFT algorithm. This means we’re not just
    limited to small signals — FFT unleashes the power of Fourier Transforms on massive
    datasets. Cool, right? But how does the algorithm even work and what makes it
    so efficient? This leads us to the next section of this article: the FFT algorithm!'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在计算一个仅有10分钟长的音频样本的傅里叶变换。对于大多数传统应用，我们通常的采样率是22050，即每秒钟测量22050个样本（这看起来可能很多，但实际上并不算多，这是保持音频样本质量时最常用的采样率）。这意味着我们大约有10*60*22050
    = 13230000个样本。为了计算这个样本的DFT，我们需要至少N² = 13230000² = 175032900000000次计算，这真是太多了！如果你使用的是像C++这样的编程语言（它是最有效率的编程语言之一），最大每秒可以进行的计算次数可能是2
    × 10⁸次。这意味着，计算一个简短的10分钟音频样本的DFT需要175032900000000/200000000 = 2875164.5秒，约为10天！这使得计算大信号的DFT几乎不可能，从而使傅里叶变换的应用受到极大的限制。但是别担心！快傅里叶变换（FFT）来啦，这个神奇的算法一出现，DFT计算变得飞快。它将DFT计算的时间复杂度从O(N²)降低到O(N
    log N)。对于这个10分钟的样本，现在我们只需要进行13230000*log(13230000) = 216945507次浮点运算。这个计算只需要约1.08秒，比传统的DFT算法高效得多。这意味着我们不仅仅局限于小信号——FFT解放了傅里叶变换在海量数据集上的应用。酷吧？但是这个算法是如何工作的，是什么让它如此高效呢？接下来我们将进入本文的下一部分：FFT算法！
- en: The FFT Algorithm
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FFT算法
- en: 'The core idea of FFT lies in the inherent symmetry of the Fourier Transformation
    that helps us reduce some of the redundant calculations. FFT works by harnessing
    the symmetry of the DFT computation and feeding it into an elegant recursive divide
    and conquer model effectively reducing time complexity from O(N²) to O(N log N).
    But, what is this symmetry we are talking about? Recall the formula for the DFT
    computation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: FFT的核心思想在于傅里叶变换固有的对称性，它帮助我们减少一些冗余的计算。FFT通过利用离散傅里叶变换（DFT）计算的对称性，并将其输入到一个优雅的递归分治模型中，有效地将时间复杂度从O(N²)降低到O(N
    log N)。但是，我们说的这个对称性到底是什么呢？回顾一下DFT计算的公式：
- en: '![](../Images/925a42546b1f2abd94421c71e83bc445.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/925a42546b1f2abd94421c71e83bc445.png)'
- en: 'What happens if we use this formula for N + k instead of k? Let’s see:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对N + k使用这个公式，而不是k，会发生什么呢？让我们来看一下：
- en: '![](../Images/53d1776e1f5a8fe7790b9435a76d7757.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/53d1776e1f5a8fe7790b9435a76d7757.png)'
- en: By the properties of complex numbers, e−2πij = 1 for any value of j. Thus,
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据复数的性质，对于任何值的j，e−2πij = 1。因此，
- en: '![](../Images/72cca2f740eff357bf89cd9c8982985d.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/72cca2f740eff357bf89cd9c8982985d.png)'
- en: In other words, the value simply repeats itself after k = N. Thus, F(1) = F(N
    + 1); F(2) = F(N + 2) and so on. This is the reason, why we only compute the Fourier
    transform as k ranges from 0 to N — 1\. The values simply keep on repeating afterward.
    More generally by simple induction, we have that for any nonnegative integer s
    ∈ Z≥0,
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，值在k = N后会重复。因此，F(1) = F(N + 1); F(2) = F(N + 2)，以此类推。这就是为什么我们只计算傅里叶变换，k的范围是从0到N
    - 1的原因——之后的值会不断重复。更一般地，通过简单的归纳法，我们可以得到对于任何非负整数s ∈ Z≥0，
- en: '![](../Images/a363ef3670e88e30c5e4850a4f41346f.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a363ef3670e88e30c5e4850a4f41346f.png)'
- en: 'This is the symmetric property that we are going to use to come up with the
    much faster (as is said in its name), the FFT algorithm. But how do we come up
    with a divide-and-conquer strategy that uses this symmetry? The idea is to split
    up the terms into odd and even terms and look at the DFT for each of them separately:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将要使用的对称性，它使得FFT算法变得更快（正如它的名字所示）。但是，如何设计一个使用这种对称性的分治策略呢？思路是将项分为奇数项和偶数项，并分别计算每个的DFT：
- en: '![](../Images/febae90b040379bc069c0b81e0c0483c.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/febae90b040379bc069c0b81e0c0483c.png)'
- en: 'In the above formulation, we’ve split the DFT terms into two groups: one with
    even indices (j = 2m) and the other with odd indices (j = 2m + 1). As you can
    see, this gives us two separate DFTs, one computed only on the even terms of the
    signal, while the other computed on the odd terms. But, does this help us reduce
    the number of operations? Not yet, as we still need to evaluate all N/2 terms
    for all values of k from 0 to N — 1 for both odd and even terms i.e., still 2*N*(N/2).
    Or do we need to? Here’s when we use the symmetric property of FFT! Suppose we
    can evaluate the above expression for some integral value a that lies between
    0 and N/2–1\. Thus,'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的公式中，我们将DFT项分为两组：一组是偶数索引（j = 2m），另一组是奇数索引（j = 2m + 1）。正如你所看到的，这为我们提供了两个独立的DFT，一个仅计算信号的偶数项，另一个计算信号的奇数项。但，这能帮助我们减少运算次数吗？还不能，因为我们仍然需要对从0到N-1的所有k值计算所有的N/2项，既偶数项也奇数项，即仍然是2*N*(N/2)。或者我们真的需要这样做吗？这时我们就可以利用FFT的对称性！假设我们可以计算出介于0和N/2-1之间某个整数值a的上述表达式。那么，
- en: '![](../Images/889867d073854882ece317c2309c0237.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/889867d073854882ece317c2309c0237.png)'
- en: 'Using just the value of F₁(a) and F₂(a) (and the symmetric property shown earlier),
    we can easily calculate the value of F(a + b) = F(c) for some integral value c
    that lies between N/2 and N — 1:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用F₁(a)和F₂(a)的值（以及前面展示的对称性），我们可以轻松地计算出F(a + b) = F(c)的值，其中c是介于N/2和N-1之间的某个整数值：
- en: '![](../Images/9b83ec13028cf2cab7322d282336363d.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9b83ec13028cf2cab7322d282336363d.png)'
- en: Here’s the key idea! We don’t need to calculate F(c) all over again, this saves
    us about N/2*N operations every time. All we need to do is calculate F1(a) and
    F2(a) for every integral value a between 0 and N/2–1 (which takes a total of (N/2)*(N/2)
    = N²/4 operations for both the even and odd terms. Doing this and applying some
    simple symmetric logic will allow us to calculate the value of F(k) for all integral
    values of k between 0 and N — 1, effectively reducing the number of operations
    from N² to 2 × (N/2) × (N/2) = N²/2 i.e, a factor of half. Isn’t it just amazing?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关键思想！我们不需要重新计算F(c)，这样每次可以节省大约 N/2*N 次运算。我们需要做的就是计算从0到N/2-1之间每个整数值a的F1(a)和F2(a)（这对于偶数项和奇数项总共需要(N/2)*(N/2)
    = N²/4次运算）。这样做并应用一些简单的对称逻辑，就能帮助我们计算出所有从0到N-1之间k的整数值的F(k)，有效地将运算次数从N²减少到2 × (N/2)
    × (N/2) = N²/2，也就是说减少了一半。是不是很神奇？
- en: 'Now, it may seem that we just reduced the time complexity by half, isn’t it
    still O(N²) at the end of the day? That’s true only if we split up the signal
    once. But, nothing stops us from splitting it further! We can continue this chain:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看起来我们似乎已经将时间复杂度减少了一半，难道最终的复杂度仍然是O(N²)吗？如果我们只分割一次，确实是这样。但没有什么能阻止我们进一步分割！我们可以继续这个链条：
- en: '![](../Images/cde10681a591a6eb4594361f29c40965.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cde10681a591a6eb4594361f29c40965.png)'
- en: 'If we assume, that N is a power of 2, we can repeat this process for a total
    r times such that:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设N是2的幂，那么我们可以重复这一过程r次，使得：
- en: '![](../Images/0c6a9977079c1ad9a1df94f63f45159d.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0c6a9977079c1ad9a1df94f63f45159d.png)'
- en: 'Each individual evaluation takes O(N) time to compute, and we do this for r
    = log2(N) times, giving us a time complexity of O(Nr) = O(N log N) (we can ignore
    the base of the logarithm when describing time complexities). For those of you
    who’d like to see this in terms of the recurrence relation, it is given by:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每次单独的评估需要O(N)时间计算，我们这样做r = log2(N)次，给我们一个时间复杂度为O(Nr) = O(N log N)（在描述时间复杂度时，我们可以忽略对数的底数）。对于那些希望看到递归关系形式的人，公式为：
- en: '![](../Images/a9c3f21c06973f41685ff887ee515e61.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a9c3f21c06973f41685ff887ee515e61.png)'
- en: Here, T(N) represents the time complexity of solving a problem of size n. In
    the case of FFT, it is the number of elements in the input signal, and O(N) represents
    the time required for combining the results of smaller sub-problems.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，T(N)表示解决一个大小为n的问题的时间复杂度。在FFT的情况下，它是输入信号中的元素数量，而O(N)表示合并较小子问题结果所需的时间。
- en: The recurrence relation indicates that to solve a problem of size N, the FFT
    algorithm recursively divides the problem into two sub-problems of size N/2 (one
    for the odd terms, and the other for the even terms), computes the solutions for
    these sub-problems in a total of 2T(N/2) time, and then combines the results in
    O(N) time. Solving this recurrence relation also leads us to the O(N log N) time
    complexity shown earlier.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 递推关系表明，为了解决一个大小为N的问题，FFT算法递归地将问题分成两个子问题，每个子问题的大小为N/2（一个用于奇数项，另一个用于偶数项），在2T(N/2)的时间内计算这些子问题的解，然后在O(N)的时间内合并结果。解决这个递推关系也使我们得出了前面提到的O(N
    log N)的时间复杂度。
- en: 'Everything looks good in theory! But does this even work? Let’s test it out
    by writing a simple Python function that calculates the DFT using the FFT algorithm
    instead. Here’s the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上看一切都很好！但是这真有效吗？让我们通过编写一个简单的Python函数，使用FFT算法来计算DFT，来验证一下。以下是代码：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And it gives the same results as before, but much faster! The above code follows
    a recursive approach based on the divide-and-conquer strategy discussed. Note
    that this code works only for signals whose length is a power of 2 for simplicity.
    For signals with a length that is not a power of two, we can simply append 0s
    at the start or the end to get the desired result. To test our two functions (simple
    dft and nice fft), we can try to generate a random array of a size corresponding
    to a large power of 2 and measure the time taken:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它给出的结果与之前相同，但速度快得多！上述代码遵循了基于分治策略的递归方法。请注意，为了简化起见，这段代码仅适用于长度是2的幂的信号。对于长度不是2的幂的信号，我们可以简单地在开始或结束处附加0以获得所需的结果。为了测试我们的两个函数（简单的DFT和优化的FFT），我们可以尝试生成一个大小对应于较大2的幂的随机数组，并测量所花费的时间：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That’s a massive improvement. To get a better view of the time differences,
    we can also make a line plot (log scale) showing the difference in the amount
    of time taken for arrays of different sizes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一次巨大的改进。为了更好地了解时间差异，我们还可以绘制一个线性图（对数刻度），显示不同大小数组所花费的时间差异：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](../Images/7a074cc8094107861e13d6d372c6c709.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7a074cc8094107861e13d6d372c6c709.png)'
- en: FFT vs Direct DFT (Time, Log scale)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: FFT与直接DFT（时间，对数刻度）
- en: Isn’t it cool how a simple idea of symmetry nested within the elegant framework
    of divide and conquer produced such a wonderful algorithm?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这不酷吗？一个简单的对称性想法嵌入在优雅的分治框架中，竟然产生了如此出色的算法！
- en: The Matrix View
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵视图
- en: 'In this article, we started with the formulation of the Fourier Transform and
    simply manipulated the expression by splitting the odd and even terms to arrive
    at the FFT algorithm. There’s another way to view it: through the lens of matrix
    manipulation. The idea is to think of the Fourier transform as simply multiplying
    the input signal with a matrix (called the Fourier matrix). Recall the definition
    of the Fourier transform:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们从傅里叶变换的公式出发，通过将奇数项和偶数项分开来推导出FFT算法。还有另一种方式来看待它：通过矩阵操作的视角。这个想法是将傅里叶变换看作是简单地将输入信号与一个矩阵（称为傅里叶矩阵）相乘。回想傅里叶变换的定义：
- en: '![](../Images/35a0b724df982ef027068d2e74793dfe.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/35a0b724df982ef027068d2e74793dfe.png)'
- en: 'As you can see, each of the individual DFT is calculated by simply taking a
    linear combination of the signal measurements. We can take α = exp{-2πi/N}, and
    we get:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个单独的DFT是通过简单地对信号测量值进行线性组合来计算的。我们可以取α = exp{-2πi/N}，我们得到：
- en: '![](../Images/6d7312967d162c3e78b2f0113c3ab1e7.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6d7312967d162c3e78b2f0113c3ab1e7.png)'
- en: 'This allows us to represent the signal and the transformation using a simple
    notation of vectors and matrices:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用向量和矩阵的简单符号表示信号及其变换：
- en: '![](../Images/5524de1c5e29f2c682416db4b5e77f41.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5524de1c5e29f2c682416db4b5e77f41.png)'
- en: 'The whole of DFT boils down to finding that big N × N matrix F (called the
    Fourier matrix) and multiplying it with the input signal. Using the FFT algorithm,
    we can decompose the Fourier matrix as a product of 3 sparse matrices:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 整个DFT归结为找到那个大的N × N矩阵F（称为傅里叶矩阵），并将其与输入信号相乘。使用FFT算法，我们可以将傅里叶矩阵分解为3个稀疏矩阵的乘积：
- en: '![](../Images/8872442bc44d14f474b9e9246240a83d.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8872442bc44d14f474b9e9246240a83d.png)'
- en: Now it may seem overwhelming, but at the root, it’s just expressing our earlier
    divide and conquer using matrices. The I_{N/2} is just the identity matrix of
    N/2 rows/columns, known to us. D_{N/2} is simply the diagonal entries of the first
    N/2 × N/2 partition of the N × N Fourier matrix F . This can be calculated easily
    in O(N) as it only requires us to calculate the values of 1, α, α⁴, …., α^{(N/2–1)²},
    which just corresponds to the multiplier term in our original formulation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这看起来可能有些令人难以应付，但从根本上讲，它仅仅是在使用矩阵表达我们之前提到的分治法。I_{N/2} 只是已知的 N/2 行/列的单位矩阵。D_{N/2}
    仅仅是 N × N 傅里叶矩阵 F 的前 N/2 × N/2 部分的对角线元素。这可以通过 O(N) 时间轻松计算，因为它只需要我们计算 1, α, α⁴,
    …, α^{(N/2–1)²} 的值，这些值正好对应于我们原始公式中的乘法项。
- en: The F_{N/2} corresponds to the recursive sub-problem, the Fourier matrix of
    size N/2 × N/2\. Finally, P is a permutation matrix (a matrix filled with all
    0s except for just one 1 in every row/column). The purpose of P is to segregate
    the odd and even terms of the input signal, by bringing the even terms to the
    top and the odd terms to the bottom. The rest of the matrix manipulation follows
    as before. We can keep repeating this process again and again, breaking the Fourier
    matrix F_{N/2} continuously until we reach the base case when N = 1\. As before
    the time complexity remains O(N log N), it’s just a more elegant way to write
    down the equations without the messy summations!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: F_{N/2} 对应递归子问题，即 N/2 × N/2 的傅里叶矩阵。最后，P 是一个置换矩阵（一个填充了 0，且每一行/列中只有一个 1 的矩阵）。P
    的作用是通过将偶数项移动到上面，将奇数项移动到底部，从而将输入信号的奇偶项区分开来。矩阵的其余部分操作如之前所示。我们可以不断重复这个过程，一次次地将傅里叶矩阵
    F_{N/2} 分解，直到我们到达基本情况，即 N = 1。和之前一样，时间复杂度仍然是 O(N log N)，这只是以更优雅的方式写出方程，而不需要繁琐的求和！
- en: The Bottom Line
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: The Fast Fourier Transform (FFT) stands as a testament to the beauty of simplicity
    and elegance in algorithmic design. It has revolutionized signal processing, data
    analysis, and various scientific disciplines and its importance lies not only
    in its computational efficiency, as evidenced by the remarkable speed gains over
    na ̈ıve approaches, but also in its versatility, enabling breakthroughs in diverse
    fields such as telecommunications, image processing, and quantum computing. From
    audio compression algorithms to medical imaging techniques, the FFT underpins
    a myriad of applications that have become integral to our daily lives.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 快速傅里叶变换（FFT）是算法设计中简单性与优雅性的典范。它彻底改变了信号处理、数据分析和各个科学领域的重要性，FFT的价值不仅体现在其计算效率上，这一点通过与朴素方法相比获得的显著速度提升得到了证明，还体现在它的多功能性，推动了电信、图像处理和量子计算等多个领域的突破。从音频压缩算法到医学影像技术，FFT支撑着无数已经成为我们日常生活不可或缺的应用。
- en: As we reflect on the journey from a simple idea to a groundbreaking algorithm,
    it’s awe-inspiring to appreciate how a fundamental understanding of symmetry,
    coupled with innovative algorithmic design, can yield solutions of profound significance.
    The FFT, with its elegance and efficiency, encapsulates the essence of ingenuity
    in computer science. So, next time you marvel at the clarity of a digital image
    or enjoy the fidelity of a music stream, just remember that behind these technological
    marvels stands the remarkable FFT — a true testament to the power of simple yet
    ingenious ideas.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾从一个简单的想法到开创性算法的过程时，令人敬畏的是，我们能体会到对对称性的基础理解，再加上创新的算法设计，如何能带来具有深远意义的解决方案。FFT
    以其优雅与高效，概括了计算机科学中独创性的精髓。因此，下次当你惊叹于数字图像的清晰度，或享受音乐流媒体的音质时，记得背后支撑这些技术奇迹的，正是那个非凡的
    FFT —— 这是真正简单而巧妙的创意力量的见证。
- en: Hope you enjoyed reading this article! In case you have any doubts or suggestions,
    do reply in the comment box. Please feel free to contact me via [mail](mailto:naman.agr03@gmail.com).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢这篇文章！如果你有任何疑问或建议，请在评论区留言。你也可以通过[邮件](mailto:naman.agr03@gmail.com)与我联系。
- en: If you liked my article and want to read more of them, please follow me.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢我的文章并想阅读更多，请关注我。
- en: '**Note:** All images (except for the cover image) have been made by the author.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 所有图片（封面图片除外）均由作者制作。'
- en: References
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: cs.cornell.edu. [https://www.cs.cornell.edu/~bindel/class/cs5220-s10/slides/FFT.pdf.](https://www.cs.cornell.edu/~bindel/class/cs5220-s10/slides/FFT.pdf.)
    [Accessed 05–01- 2024].
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: cs.cornell.edu. [https://www.cs.cornell.edu/~bindel/class/cs5220-s10/slides/FFT.pdf](https://www.cs.cornell.edu/~bindel/class/cs5220-s10/slides/FFT.pdf)。
    [访问时间：2024年1月5日]。
- en: 'The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever? — youtube.com.
    [https://www.youtube.com/](https://www.youtube.com/)watch?v=h7apO7q16V0\. [Accessed
    05–01–2024].'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 快速傅里叶变换（FFT）：有史以来最巧妙的算法？ — youtube.com. [https://www.youtube.com/](https://www.youtube.com/)watch?v=h7apO7q16V0\.
    [访问时间：2024年1月5日]。
- en: Shaw Talebi. The Fast-Fourier Transform (FFT) — medium.com. [https://medium.com/swlh/](https://medium.com/swlh/)
    the-fast-fourier-transform-fft-5e96cf637c38#:~:text=The%20FFT%20is%20an%20efficient,the%
    20Permutation%20matrix%2C%20used%20above. [Accessed 05–01–2024].
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shaw Talebi. 快速傅里叶变换（FFT） — medium.com. [https://medium.com/swlh/](https://medium.com/swlh/)the-fast-fourier-transform-fft-5e96cf637c38#:~:text=The%20FFT%20is%20an%20efficient,the%20Permutation%20matrix%2C%20used%20above.
    [访问时间：2024年1月5日]。
- en: 'Jake VanderPlas. Understanding the FFT Algorithm — Pythonic Perambulations
    — jakevdp.github.io. https: //jakevdp.github.io/blog/2013/08/28/understanding-the-fft/.
    [Accessed 05–01–2024].'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jake VanderPlas. 理解FFT算法 — Pythonic Perambulations — jakevdp.github.io. https://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/.
    [访问时间：2024年1月5日]。

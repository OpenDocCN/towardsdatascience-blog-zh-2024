["```py\n df = pl.DataFrame(\n   {\"date\": [\n      # -- may 24th is a Friday, weekday\n      '2024-05-24 00:00:00',  # < 6 am, should remove\n      '2024-05-24 06:00:00',  # not < 6 am, should keep\n      '2024-05-24 06:30:00',  # not < 6 am, should keep\n      '2024-05-24 20:00:00',  # >= 8 pm, should remove\n\n      # -- may 25th is a Saturday, weekend\n      '2024-05-25 00:00:00',  # < 8 am, should remove\n      '2024-05-25 06:00:00',  # < 8 am, should remove\n      '2024-05-25 06:30:00',  # < 8 am, should remove\n      '2024-05-25 20:00:00',  # not >= 10 pm, should keep\n\n      ]\n   }\n).with_columns(pl.col(\"date\").str.strptime(pl.Datetime, \"%Y-%m-%d %H:%M:%S\"))\n```", "```py\ndf.filter(   \n    pl.Expr.not_(\n        (\n            (pl.col(\"date\").dt.weekday() < 6)\n            .and_(\n                (pl.col(\"date\").dt.hour() < 6)\n                .or_(pl.col(\"date\").dt.hour() >= 20)\n            )\n        )\n        .or_(\n            (pl.col(\"date\").dt.weekday() >= 6)\n            .and_(\n                (pl.col(\"date\").dt.hour() < 8)\n                .or_(pl.col(\"date\").dt.hour() >= 22)\n            )\n        )\n    )\n)\n```", "```py\nprocessor = FilterDataBasedOnTime(\n    \"date\", time_patterns=[\n        \"<6wd<6h\",\n        \"<6wd>=20h\",\n        \">=6wd<8h\",\n        \">=6wd>=22h\",\n    ]\n)\nprocessor.transform(df)\n```", "```py\n# -- remove values between 6 am (inclusive) and 2 pm (exclusive)\npattern = '>=06:00,<14:00'\n```", "```py\n# cronlike pattern\npattern = ‘>=X-X-X 06:00:X, <X-X-X 20:00:X’\n```", "```py\n# -- remove values in [6am, 2pm) on Saturday\npattern = 'day==6,time>=06:00,time<14:00'\n```", "```py\n# -- remove values in [6am, 2pm) on Saturday\npattern = 'day==6,hour>=6,hour<14'\n```", "```py\n# -- remove values in [6am, 2pm) on Saturday\npattern = '==6wd,>=6h,<14h'\n```", "```py\n# -- remove values in (-inf, 6am], and (2pm, inf)\npattern = '<=6h,>14h'\n```", "```py\n# -- remove values in (-inf, 6am], and (2pm, inf)\npatterns = ['<=6h', '>14h']\n```", "```py\n# -- pattern to remove values > 06:00\npattern = '>6h'\n```", "```py\n# -- pattern to remove values > 06:00\npattern = '>6h*'\n```", "```py\n# -- code for parsing a time pattern, e.g. \"==7d<7h\"\npattern = pattern.replace(\" \", \"\")\noperator = \"\"\noperators = []\nduration_string = \"\"\nduration_strings = []\nfor char in pattern:\n    if char in {\">\", \"<\", \"=\", \"!\"}:\n        operator += char\n        if duration_string:\n            duration_strings.append(duration_string)\n            duration_string = \"\"\n    else:\n        duration_string += char\n        if operator:\n            operators.append(operator)\n            operator = \"\"\nduration_strings.append(duration_string)\n```", "```py\n# -- code for extracting metadata from a parsed pattern\n\n# -- mapping to convert each operator to the Polars method\nOPERATOR_TO_POLARS_METHOD_MAPPING = {\n    \"==\": \"eq\",\n    \"!=\": \"ne\",\n    \"<=\": \"le\",\n    \"<\": \"lt\",\n    \">\": \"gt\",\n    \">=\": \"ge\",\n}\n\noperator_method = (\n    OPERATOR_TO_POLARS_METHOD_MAPPING[operator]\n)\n\n# -- identify cascade operations\nif duration_string.endswith(\"*\"):\n    duration_string = duration_string[:-1]\n    how = \"cascade\"\nelse:\n    how = \"simple\"\n\n# -- extract a polars duration, e.g. 7d7h into it's components: [(7, \"d\"), (7, \"h\")]\npolars_duration = PolarsDuration(duration=duration_string)\ndecomposed_duration = polars_duration.decomposed_duration\n\n# -- ensure that cascade operator only applied to durations that accept it\nif how == \"cascade\" and any(\n    unit not in POLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING\n    for _, unit in decomposed_duration\n):\n    raise ValueError(\n        (\n            \"You requested a cascade condition on an invalid \"\n            \"duration. Durations supporting cascade: \"\n            f\"{list(POLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING.keys())}\"\n        )\n    )\n\nrule_metadata = {\n    \"operator\": operator_method,\n    \"decomposed_duration\": decomposed_duration,\n    \"how\": how,\n}\n```", "```py\npattern = '==1m>6d6h' # remove if month = Jan, and day > 6 and hour > 6\n\n# parsed pattern\n\n[\n   [\n      {\n         \"operator\": \"eq\",\n         \"decomposed_duration\": [(1, \"m\")],\n         \"how\": \"simple\"\n      },\n      { \n         \"operator\": \"gt\",\n         \"decomposed_duration\": [(6, \"d\"), (6, \"h\")],\n         \"how\": \"simple\"\n      }\n   ]\n]\n```", "```py\n# -- dictionary to contain each unit along with the polars method to extract it's value\nUNIT_TO_POLARS_METHOD_MAPPING = {\n        \"d\": \"day\",\n        \"h\": \"hour\",\n        \"m\": \"minute\",\n        \"s\": \"second\",\n        \"ms\": \"millisecond\",\n        \"us\": \"microsecond\",\n        \"ns\": \"nanosecond\",\n        \"wd\": \"weekday\",\n}\n\npatterns = [\"==6d<6h6s\"]\npatterns_metadata = get_rule_metadata_from_patterns(patterns)\n\n# -- create an expression for the rule pattern\npattern_metadata = patterns_metadata[0]  # list of length two\n\n# -- let's consider the condition for ==6d\ncondition = pattern_metadata[0]\n\ndecomposed_duration = condition[\"decomposed_duration\"]  # [(6, 'd')]\noperator = condition[\"operator\"]  # eq\nconditions = [\n    getattr(  # apply the operator method, e.g. pl.col(\"date\").dt.hour().eq(value)\n        getattr(  # get the value of the unit, e.g. pl.col(\"date\").dt.hour()\n            pl.col(time_column).dt,  \n            UNIT_TO_POLARS_METHOD_MAPPING[unit], \n        )(),\n        operator,\n    )(value) for value, unit in decomposed_duration  # for each unit separately\n]\n\n# -- finally, we aggregate the separate conditions using an AND condition\nfinal_expression = conditions.pop()\nfor expression in conditions:\n    final_expression = getattr(final_expression, 'and_')(expression)\n```", "```py\nrules = []  # list to store expressions for each time pattern\nfor rule_metadata in patterns_metadata:\n    rule_expressions = []\n    for condition in rule_metadata:\n        how = condition[\"how\"]\n        decomposed_duration = condition[\"decomposed_duration\"]\n        operator = condition[\"operator\"]\n        if how == \"simple\":\n            expression = generate_polars_condition(  # function to do the final combination of expressions\n                [\n                    self._generate_simple_condition(\n                        unit, value, operator\n                    )  # this is the complex \"getattr\" code\n                    for value, unit in decomposed_duration\n                ],\n                \"and_\",\n            )\n        rule_expressions.append(expression)\n\n    rule_expression = generate_polars_condition(\n        rule_expressions, \"and_\"\n    )\n    rules.append(rule_expression)\n\noverall_rule_expression = generate_polars_condition(\n    rules, \"or_\"\n).not_()  # we must negate because we're filtering!\n```", "```py\nPOLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING = {\n    \"y\": {\"next\": \"mo\", \"start\": 1},\n    \"mo\": {\"next\": \"d\", \"start\": 1},\n    \"d\": {\"next\": \"h\", \"start\": 0},\n    \"wd\": {\"next\": \"h\", \"start\": 0},\n    \"h\": {\"next\": \"m\", \"start\": 0},\n    \"m\": {\"next\": \"s\", \"start\": 0},\n    \"s\": {\"next\": \"ms\", \"start\": 0},\n    \"ms\": {\"next\": \"us\", \"start\": 0},\n    \"us\": {\"next\": \"ns\", \"start\": 0},\n}\n```", "```py\n# -- pattern example: >6h* cascade\nsimple_condition = self._generate_simple_condition(\n    unit, value, operator\n)  # generate the simple condition, e.g. hour>6\nall_conditions = [simple_condition]\nif operator == \"gt\":  # cascade only affects > operator\n    equality_condition = self._generate_simple_condition(\n        unit, value, \"eq\"\n    )  # generate hour==6\n    child_unit_conditions = []\n    child_unit_metadata = (\n        POLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING.get(unit, None)\n    )  # get the next smallest unit, e.g. minute\n    while child_unit_metadata is not None:\n        start_value = child_unit_metadata[\"start\"]\n        child_unit = child_unit_metadata[\"next\"]\n        child_unit_condition = self._generate_simple_condition(\n            child_unit, start_value, \"gt\"\n        )  # generate minute > 0\n        child_unit_conditions.append(child_unit_condition)\n        child_unit_metadata = (\n            POLARS_DURATIONS_TO_IMMEDIATE_CHILD_MAPPING.get(\n                child_unit, None\n            )\n        )  # now go on to seconds, and so on...\n\n    cascase_condition = generate_polars_condition(\n        [\n            equality_condition,  # and condition for the hour unit\n            generate_polars_condition(child_unit_conditions, \"or_\"),  # any condition for all the child units\n        ],\n        \"and_\",\n    )\n\n    all_conditions.append(cascase_condition)\n\n# -- final condition is hour>6 AND the cascade condition\noverall_condition = generate_polars_condition(all_conditions, \"or_\")\n```"]
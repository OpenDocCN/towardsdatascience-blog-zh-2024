["```py\nimport numpy as np\n# Load data directly into a numpy array\ndata = np.loadtxt(spiked_spectrum.asc, delimiter=',', skiprows=1)\n\n# Extract Raman shift from the first column (index)\nramanshift = data[:, 0]\n\n# Extract intensity from the second column (index 1in Python)\nintensity = data[:, 1]\n\n# Plot the data\nimport matplotlib.pyplot as plt\nfig = plt.figure(figsize = (5,3))\nplt.plot(ramanshift, intensity)\nplt.xlabel('Raman shift (cm$^{-1}$)')\nplt.ylabel('Intensity (a.u.)')\nplt.show()\n```", "```py\nfrom scipy.signal import find_peaks\n# Find the peaks in the spectrum (with and without prominence threshold)\npeaks_wo_p, _ = find_peaks(intensity) # Peaks found without a prominence threshold\npeaks_w_p, _ = find_peaks(intensity, prominence = 20) # Peaks found without a prominence threshold\n\nfig, ax = plt.subplots(1, 2, figsize = (10,3))\nax[0].plot(ramanshift, intensity, zorder=0, label='Raw spectrum')\nax[0].scatter(ramanshift[peaks_wo_p], intensity[peaks_wo_p], marker ='.', color = 'red',label='Found peaks')\nax[1].plot(ramanshift, intensity, zorder=0, label='Raw spectrum')\nax[1].scatter(ramanshift[peaks_w_p], intensity[peaks_w_p], marker ='.', color = 'red',label='Found peaks')\nplt.show()\n```", "```py\nfrom scipy.signal import peak_widths\nwidths = peak_widths(intensity, peaks_w_p)[0]\n\nfig, ax = plt.subplots(figsize = (5,3))\nax.plot(ramanshift, intensity, zorder=0, label='Raw spectrum')\nax2 = ax.twinx()\nax2.scatter(ramanshift[peaks_w_p], widths, marker ='+', color = 'red',label='Peak widths')\nplt.show()\n```", "```py\n# Let's set the parameters:\nwidth_param_rel = 0.8\nwidth_threshold = 10 # Estimation of the width of the narrowest Raman band\n\n# Calculation of the range where the spectral points are asumed to be corrupted\nwidths_ext_a = peak_widths(intensity, peaks_w_p, rel_height=width_param_rel)[2]\nwidths_ext_b = peak_widths(intensity, peaks_w_p, rel_height=width_param_rel)[3]\n\n# Create a vector where spikes will be flag: no spike = 0, spike = 1.\nspikes = np.zeros(len(intensity))\n\n# Flagging the area previously defined if the peak is considered a spike (width below width_threshold)\nfor a, width, ext_a, ext_b in zip(range(len(widths)), widths, widths_ext_a, widths_ext_b):\n    if width < width_threshold:\n        spikes[int(ext_a) - 1: int(ext_b) + 2] = 1 \n\nfig = plt.figure(figsize = (5,3))\nplt.plot(ramanshift, intensity, zorder=0,label='Raw spectrum')\na=1\nplt.scatter(ramanshift[int(widths_ext_a[a])-1 : int(widths_ext_b[a])+1], \n            intensity[int(widths_ext_a[a])-1 : int(widths_ext_b[a])+1], \n            color ='red', label = 'corrupted points')\nplt.axvline(x = ramanshift[int(widths_ext_a[a]) -1], linestyle = '--', color = 'red')\nplt.axvline(x = ramanshift[int(widths_ext_b[a]) + 1], linestyle = '--', color = 'red')  \nplt.show()\n```", "```py\nfrom scipy import interpolate\n# Let's set the parameter:\nmoving_average_window = 10\n\nintensity_out = intensity.copy()\n\n# Interpolation of corrupted points\nfor i, spike in enumerate(spikes):\n    if spike != 0: # If we have an spike in position i\n        window = np.arange(i - moving_average_window, i + moving_average_window + 1) # we select 2 ma + 1 points around our spike\n        window_exclude_spikes = window[spikes[window] == 0] # From such interval, we choose the ones which are not spikes\n        interpolator = interpolate.interp1d(window_exclude_spikes, intensity[window_exclude_spikes], kind='linear') # We use the not corrupted points around the spike to calculate the interpolation\n        intensity_out[i] = interpolator(i) # The corrupted point is exchanged by the interpolated value.\n\nfig = plt.figure(figsize = (5,3))\nplt.plot(ramanshift, intensity, zorder=0, color ='red',label='Raw spectrum')\nplt.plot(ramanshift, intensity_out, zorder=0, label='Corrected spectrum')\nplt.show()\n```", "```py\nimport numpy as np\nfrom scipy.signal import find_peaks, peak_widths, peak_prominences\nfrom scipy import interpolate\n\ndef spike_removal(y, \n                  width_threshold, \n                  prominence_threshold=None, \n                  moving_average_window=10, \n                  width_param_rel=0.8, \n                  interp_type='linear'):\n    \"\"\"\n    Detects and replaces spikes in the input spectrum with interpolated values. Algorithm first \n    published by N. Coca-Lopez in Analytica Chimica Acta. https://doi.org/10.1016/j.aca.2024.342312\n\n    Parameters:\n    y (numpy.ndarray): Input spectrum intensity.\n    width_threshold (float): Threshold for peak width.\n    prominence_threshold (float): Threshold for peak prominence.\n    moving_average_window (int): Number of points in moving average window.\n    width_param_rel (float): Relative height parameter for peak width.\n    tipo: type of interpolation (linear, quadratic, cubic)\n\n    Returns:\n    numpy.ndarray: Signal with spikes replaced by interpolated values.\n    \"\"\"\n\n    # First, we find all peaks showing a prominence above prominence_threshold on the spectra\n    peaks, _ = find_peaks(y, prominence=prominence_threshold)\n\n    # Create a vector where spikes will be flag: no spike = 0, spike = 1.\n    spikes = np.zeros(len(y))\n\n    # Calculation of the widths of the found peaks\n    widths = peak_widths(y, peaks)[0]\n\n    # Calculation of the range where the spectral points are asumed to be corrupted\n    widths_ext_a = peak_widths(y, peaks, rel_height=width_param_rel)[2]\n    widths_ext_b = peak_widths(y, peaks, rel_height=width_param_rel)[3]\n\n    # Flagging the area previously defined if the peak is considered a spike (width below width_threshold)\n    for a, width, ext_a, ext_b in zip(range(len(widths)), widths, widths_ext_a, widths_ext_b):\n        if width < width_threshold:\n            spikes[int(ext_a) - 1: int(ext_b) + 2] = 1 \n\n    y_out = y.copy()\n\n    # Interpolation of corrupted points\n    for i, spike in enumerate(spikes):\n        if spike != 0: # If we have an spike in position i\n            window = np.arange(i - moving_average_window, i + moving_average_window + 1) # we select 2 ma + 1 points around our spike\n            window_exclude_spikes = window[spikes[window] == 0] # From such interval, we choose the ones which are not spikes\n            interpolator = interpolate.interp1d(window_exclude_spikes, y[window_exclude_spikes], kind=interp_type) # We use the not corrupted points around the spike to calculate the interpolation\n            y_out[i] = interpolator(i) # The corrupted point is exchanged by the interpolated value.\n\n    return y_out\n```", "```py\nintensity_despiked = spike_removal(intensity, \n                                     width_threshold = 3, \n                                     prominence_threshold = 20, \n                                     moving_average_window=10, \n                                     width_param_rel=0.8, \n                                     interp_type='linear')\n\nfig, ax = plt.subplots(1, 2, figsize = (2*5,3))\nax[0].plot(ramanshift, intensity, label = 'spike', color ='red', linewidth = 0.9)\nax[0].plot(ramanshift, intensity_despiked)\nax[1].plot(ramanshift, intensity_despiked)\nplt.show()\n```"]
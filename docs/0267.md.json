["```py\nchatgpt_categories_prompt = f\"\"\"\nYou are an experienced and useful Python and Neo4j/Cypher developer.\n\nI have a knowledge graph for which I would like to generate \ninteresting questions which span 12 categories (or types) about the graph. \nThey should cover single nodes questions,\ntwo or three more nodes, relationships and paths. Please suggest 12\ncategories together with their short descriptions. \nHere is the graph schema:\n{schema}\n \"\"\"\n```", "```py\n'''Authorship and Collaboration: Questions about co-authorship and collaboration patterns.\nFor example, \"Which authors have co-authored articles the most?\"''',\n'''Article-Author Connections: Questions about the relationships between articles and authors,\nsuch as finding articles written by a specific author or authors of a particular article.\nFor example, \"Find all the authors of the article with tile 'Explorations of manifolds'\"''',\n'''Pathfinding and Connectivity: Questions that involve paths between multiple nodes,\nsuch as tracing the relationship path from an article to a topic through keywords, \nor from an author to a journal through their articles.\nFor example, \"How is the author 'John Doe' connected to the journal 'Nature'?\"'''\n```", "```py\ndef create_prompt(schema, category):\n    \"\"\"Build and format the prompt.\"\"\"\n    formatted_prompt = [\n        {\"role\": \"system\",\n        \"content\": \"You are an experienced Cypher developer and a \nhelpful assistant designed to output JSON!\"},\n        {\"role\": \"user\",\n         \"content\": f\"\"\"Generate 40 questions and their corresponding \nCypher statements about the Neo4j graph database with \nthe following schema:\n        {schema}\n        The questions should cover {category} and should be phrased \nin a natural conversational manner. Make the questions diverse \nand interesting.\n        Make sure to use the latest Cypher version and that all\n the queries are working Cypher queries for the provided graph. \nYou may add values for the node attributes as needed. \nDo not add any comments, do not label or number the questions.\n        \"\"\"}]\n    return formatted_prompt\n```", "```py\ndef prompt_model(messages):\n    \"\"\"Function to produce and extract model's generation.\"\"\"\n    response = client.chat.completions.create(\n        model=\"gpt-4-1106-preview\", # work with gpt-4-turbo\n        response_format={\"type\": \"json_object\"},\n        messages=messages)\n    return response.choices[0].message.content\n```", "```py\ndef build_synthetic_data(schema, categories):\n    \"\"\"Function to loop through the categories and generate data.\"\"\"\n\n    # List to collect all outputs\n    full_output=[]\n    for category in categories:\n        # Prompt the model and retrieve the generated answer\n        output = [prompt_model(create_prompt(schema, category))]\n        # Store all the outputs in a list\n        full_output += output\n    return full_output\n\n# Generate 40 pairs for each of the categories\nfull_output = build_synthetic_data(schema, categories)\n\n# Save the outputs to a file\nwrite_json(full_output, data_path + synthetic_data_file)\n```", "```py\n{\"Question\": \"What articles have been written by 'John Doe'?\",\n\"Cypher\": \"MATCH (a:Author {first_name:'John', last_name:'Doe'})-\n[:WRITTEN_BY]-(article:Article) RETURN article.title, article.article_id;\"}\n```", "```py\n'MATCH (author:Author)-[:WRITTEN_BY]-(article:Article)-[:UPDATED]-\n(updateDate:UpdateDate) \nWHERE article.creation_date = updateDate.update_date \nRETURN DISTINCT author.first_name, author.last_name;\"\n```", "```py\n# Initialize the Neo4j connector\ngraph = Neo4jGraph(url=URI, username=USER, password=PWD)\n# Initialize the schema extractor module\ngutils = Neo4jSchema(url=URI, username=USER, password=PWD)\n\n# Build the schema as a JSON object\njschema = gutils.get_structured_schema\n# Retrieve the list of nodes in the graph\nnodes = get_nodes_list(jschema)\n# Read the nodes with their properties and their datatypes\nnode_props_types = jschema['node_props']\n\n# Check the output\nprint(f\"The properties of the node Report are:\\n{node_props_types['Report']}\")\n\n>>>The properties of the node Report are:\n   [{'property': 'report_id', 'datatype': 'STRING'}, {'property': 'report_no', 'datatype': 'STRING'}]\n\n# Extract a list of relationships\nrelationships = jschema['relationships']\n\n# Check the output\nrelationships[:1]\n\n>>>[{'start': 'Article', 'type': 'HAS_KEY', 'end': 'Keyword'},\n {'start': 'Article', 'type': 'HAS_DOI', 'end': 'DOI'}]\n```", "```py\n# Extract node samples from the graph - 4 sets of node samples\nnode_instances = gutils.extract_node_instances(\n                  nodes, # list of nodes to extract labels\n                  4)  # how many instances to extract for each node\n```", "```py\n# Extract relationship instances\nrels_instances = gutils.extract_multiple_relationships_instances(\n                relationships, # list of relationships to extract instances for\n                8)  # how many instances to extract for each relationship\n```", "```py\ndtypes = retrieve_datatypes(jschema)\ndtypes\n\n>>>{'DATE', 'INTEGER', 'STRING'}\n```", "```py\nq = \"Find the Topic whose description contains 'Jordan normal form'!\"\ncq = \"MATCH (n:Topic) WHERE n.description CONTAINS 'Jordan normal form' RETURN n\"\n```", "```py\nf(x, y, z) = f\"Find the {x} whose {y} contains {z}!\"\nq = f('Topic', 'description', 'Jordan normal form')\n\ng(x, y, z) = f\"MATCH (n:{x}) WHERE n.{y} CONTAINS {z} RETURN n\"\nqc = g('Topic', 'description', 'Jordan normal form')\n```", "```py\ndef find_nodes_connected_to_node_via_relation():\n    def prompter(label_1, prop_1, rel_1, label_2):\n        subschema = get_subgraph_schema(jschema, [label_1, label_2], 2, True)\n        message = {\"Prompt\": \"Convert the following question into a Cypher query using the provided graph schema!\",\n                   \"Question\": f\"\"\"For each {label_1}, find the number of {label_2} linked via {rel_1} and retrieve the {prop_1} of the {label_1} and the {label_2} counts in ascending order!\"\"\",\n                   \"Schema\": f\"Graph schema: {subschema}\",\n                   \"Cypher\": f\"MATCH (n:{label_1}) -[:{rel_1}]->(m:{label_2}) WITH DISTINCT n, m RETURN n.{prop_1} AS {prop_1}, count(m) AS {label_2.lower()}_count ORDER BY {label_2.lower()}_count\"\n        }\n        return message\n\n    sampler=[]\n    for e in all_rels:\n        for k, v in e[1].items():\n            temp_dict = prompter(e[0], k, e[2], e[3])\n            sampler.append(temp_dict)\n\n    return sampler\n```", "```py\n['Keyword',\n {'name': 'logarithms', 'key_id': '720452e14ca2e4e07b76fa5a9bc0b5f6'},\n 'HAS_TOPIC',\n 'Topic',\n {'cluster': 0}]\n```", "```py\nQuestion: Which articles were written by the author whose last name is Doe?\nCypher: \"MATCH (a:Article) -[:WRITTEN_BY]-> (:Author {last_name: 'Doe') RETURN a\"\n```"]
- en: Linear Optimisations in Product Analytics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/linear-optimisations-in-product-analytics-ace19e925677?source=collection_archive---------2-----------------------#2024-12-18](https://towardsdatascience.com/linear-optimisations-in-product-analytics-ace19e925677?source=collection_archive---------2-----------------------#2024-12-18)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Solving the knapsack problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://miptgirl.medium.com/?source=post_page---byline--ace19e925677--------------------------------)[![Mariya
    Mansurova](../Images/b1dd377b0a1887db900cc5108bca8ea8.png)](https://miptgirl.medium.com/?source=post_page---byline--ace19e925677--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--ace19e925677--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--ace19e925677--------------------------------)
    [Mariya Mansurova](https://miptgirl.medium.com/?source=post_page---byline--ace19e925677--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--ace19e925677--------------------------------)
    ·11 min read·Dec 18, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c6f2f51099b2b5f7cfd3ee32ce1429e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Image generated by DALL-E 3
  prefs: []
  type: TYPE_NORMAL
- en: 'It might be surprising, but in this article, I would like to talk about the
    knapsack problem, the classic optimisation problem that has been studied for over
    a century. According to [Wikipedia](https://en.wikipedia.org/wiki/Knapsack_problem),
    the problem is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Given a set of items, each with a weight and a value, determine which items
    to include in the collection so that the total weight is less than or equal to
    a given limit and the total value is as large as possible.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'While product analysts may not physically pack knapsacks, the underlying mathematical
    model is highly relevant to many of our tasks. There are numerous real-world applications
    of the knapsack problem in product analytics. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Marketing Campaigns:** The marketing team has a limited budget and capacity
    to run campaigns across different channels and regions. Their goal is to maximize
    a KPI, such as the number of new users or revenue, all while adhering to existing
    constraints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Retail Space Optimization:** A retailer with limited physical space in their
    stores seeks to optimize product placement to maximize revenue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product Launch Prioritization:** When launching a new product, the operations
    team’s capacity might be limited, requiring prioritization of specific markets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such and similar tasks are quite common, and many analysts encounter them regularly.
    So, in this article, I’ll explore different approaches to solving it, ranging
    from naive, simple techniques to more advanced methods such as linear programming.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason I chose this topic is that linear programming is one of the most
    powerful and popular tools in prescriptive analytics — a type of analysis that
    focuses on providing stakeholders with actionable options to make informed decisions.
    As such, I believe it is an essential skill for any analyst to have in their toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s dive straight into the case we’ll be exploring. Imagine we’re part of
    a marketing team planning activities for the upcoming month. Our objective is
    to maximize key performance indicators (KPIs), such as the number of acquired
    users and revenue while operating within a limited marketing budget.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve estimated the expected outcomes of various marketing activities across
    different countries and channels. Here is the data we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`country` — the market where we can do some promotional activities;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`channel` — the acquisition method, such as social networks or influencer campaigns;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users` — the expected number of users acquired within a month of the promo
    campaign;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cs_contacts` — the incremental Customer Support contacts generated by the
    new users;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`marketing_spending` — the investment required for the activity;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`revenue` — the first-year LTV generated from acquired customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/b047bf0905f1fde49ac919e1fbc9ce87.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the dataset is synthetic and randomly generated, so don’t try to infer
    any market-related insights from it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First, I’ve calculated the high-level statistics to get a view of the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/eb3aa6704cff645dd793a2c778ce7d88.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s determine the optimal set of marketing activities that maximizes revenue
    while staying within the $30M marketing budget.
  prefs: []
  type: TYPE_NORMAL
- en: Brute force approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At first glance, the problem may seem straightforward: we could calculate all
    possible combinations of marketing activities and select the optimal one. However,
    it might be a challenging task.'
  prefs: []
  type: TYPE_NORMAL
- en: With 62 segments, there are 2⁶² possible combinations, as each segment can either
    be included or excluded. This results in approximately 4.6*10¹⁸ combinations —
    an astronomical number.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the computational feasibility, let’s consider a smaller
    subset of 15 segments and estimate the time required for one iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It took approximately 4 seconds to process 15 segments, allowing us to handle
    around 7,000 iterations per second. Using this estimate, let’s calculate the execution
    time for the full set of 62 segments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using brute force, it would take around 20.9 million years to get the answer
    to our question — clearly not a feasible option.
  prefs: []
  type: TYPE_NORMAL
- en: Execution time is entirely determined by the number of segments. Removing just
    one segment can reduce time twice. With this in mind, let’s explore possible ways
    to merge segments.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, there are more small-sized segments than bigger ones, so merging them
    is a logical step. However, it’s important to note that this approach may reduce
    accuracy since multiple segments are aggregated into one. Despite this, it could
    still yield a solution that is “good enough.”
  prefs: []
  type: TYPE_NORMAL
- en: To simplify, let’s merge all segments that contribute less than 0.1% of revenue.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, we will merge ten segments into one, representing 0.53%
    of the total revenue (the potential margin of error). With 52 segments remaining,
    we can obtain the solution in just 20.4K years. While this is a significant improvement,
    it’s still not sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: You may consider other heuristics tailored to your specific task. For instance,
    if your constraint is a ratio (e.g., contact rate = CS contacts / users ≤ 5%),
    you could group all segments where the constraint holds true, as the optimal solution
    will include all of them. In our case, however, I don’t see any additional strategies
    to reduce the number of segments, so brute force seems impractical.
  prefs: []
  type: TYPE_NORMAL
- en: That said, if the number of combinations is relatively small and brute force
    can be executed within a reasonable time, it can be an ideal approach. It’s simple
    to develop and provides accurate results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Naive approach: looking at top-performing segments'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since brute force is not feasible for calculating all combinations, let’s consider
    a simpler algorithm to address this problem.
  prefs: []
  type: TYPE_NORMAL
- en: One possible approach is to focus on the top-performing segments. We can evaluate
    segment performance by calculating revenue per dollar spent, then sort all activities
    based on this ratio and select the top performers that fit within the marketing
    budget. Let’s implement it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this approach, we selected 48 activities and got $107.92M in revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, although the logic seems reasonable, it is not the optimal solution
    for maximizing revenue. Let’s look at a simple example with just three marketing
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5a45bbcb23204b349ee62ca17f855fd1.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the top markets approach, we would select France and achieve $68M in revenue.
    However, by choosing two other markets, we could achieve significantly better
    results — $97.5M. The key point is that our algorithm optimizes not only for maximum
    revenue but also for minimizing the number of selected segments. Therefore, this
    approach will not yield the best results, especially considering its inability
    to account for multiple constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Linear Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since all simple approaches have failed, we must return to the fundamentals
    and explore the theory behind this problem. Fortunately, the knapsack problem
    has been studied for many years, and we can apply optimization techniques to solve
    it in seconds rather than years.
  prefs: []
  type: TYPE_NORMAL
- en: The problem we’re trying to solve is an example of Integer Programming, which
    is actually a subdomain of Linear Programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll discuss this shortly, but first, let’s align on the key concepts of the
    optimization process. Each optimisation problem consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decision variables**: Parameters that can be adjusted in the model, typically
    representing the levers or decisions we want to make.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objective function**: The target variable we aim to maximize or minimize.
    It goes without saying that it must depend on the decision variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constraints**: Conditions placed on the decision variables that define their
    possible values. For example, ensuring the team cannot work a negative number
    of hours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these basic concepts in mind, we can define Linear Programming as a scenario
    where the following conditions hold:'
  prefs: []
  type: TYPE_NORMAL
- en: The objective function is linear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All constraints are linear.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision variables are real-valued.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Integer Programming is very similar to Linear Programming, with one key difference:
    some or all decision variables must be integers. While this may seem like a minor
    change, it significantly impacts the solution approach, requiring more complex
    methods than those used in Linear Programming. One common technique is [branch-and-bound](https://en.wikipedia.org/wiki/Branch_and_bound).
    We won’t dive deeper into the theory here, but you can always find more detailed
    explanations online.'
  prefs: []
  type: TYPE_NORMAL
- en: For linear optimization, I prefer the widely used Python package [PuLP](https://coin-or.github.io/pulp/).
    However, there are other options available, such as [Python MIP](https://pypi.org/project/mip/)
    or [Pyomo](https://github.com/Pyomo/pyomo). Let’s install PuLP via pip.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it’s time to define our task as a mathematical optimisation problem. There
    are the following steps for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define the set of decision variables** (levers we can adjust).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Align on the objective function (**a variable that we will be optimising
    for).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Formulate constraints** (the conditions that must hold true during optimisations).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through the steps one by one. But first, we need to create the problem
    object and set the objective — maximization in our case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The next step is defining the decision variables — parameters that we can change
    during optimisation. Our main decision is either to run a marketing campaign or
    not. So, we can model it as a set of binary variables (0 or 1) for each segment.
    Let’s do it with the PuLP library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After that, it’s time to align on the objective function. As discussed, we want
    to maximise the revenue. The total revenue will be a sum of revenue from all the
    selected segments (where `decision_variable = 1` ). Therefore, we can define this
    formula as the sum of the expected revenue for each segment multiplied by the
    decision binary variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to add constraints. Let’s start with a simple constraint:
    our marketing spending must be below $30M.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Hint**: you can print `problem` to double check the objective function and
    constraints.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that we’ve defined everything, we can run the optimization and analyze the
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It takes less than a second to run the optimization, a significant improvement
    compared to the thousands of years that brute force would require.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let’s save the results of the model execution — the decision variables indicating
    whether each segment was selected or not — into our dataframe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It works like magic, allowing you to obtain the solution quickly. Additionally,
    note that we achieved higher revenue compared to our naive approach: $110.16M
    versus $107.92M.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve tested integer programming with a simple example featuring just one constraint,
    but we can extend it further. For instance, we can add additional constraints
    for our CS contacts to ensure that our Operations team can handle the demand in
    a healthy way:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of additional CS contacts ≤ 5K
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact rate (CS contacts/users) ≤ 0.042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code is straightforward, with the only tricky part being the transformation
    of the ratio constraint into a simpler linear form.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential constraint you might consider is limiting the number of selected
    options, for example, to 10\. This constraint could be pretty helpful in prescriptive
    analytics, for example, when you need to select the top-N most impactful focus
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Another possible option to tweak our problem is to change the objective function.
    We’ve been optimising for the revenue, but imagine we want to maximise both revenue
    and new users at the same time. For that, we can slightly change our objective
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider the best approach. We could calculate the sum of revenue and
    new users and aim to maximize it. However, since revenue is, on average, 1000
    times higher, the results might be skewed toward maximizing revenue. To make the
    metrics more comparable, we can normalize both revenue and users based on their
    total sums. Then, we can define the objective function as a weighted sum of these
    ratios. I would use equal weights (0.5) for both metrics, but you can adjust the
    weights to give more value to one of them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We obtained the optimal objective function value of 0.6131, with revenue at
    $104.36M and 136.37K new users.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! We’ve learned how to use integer programming to solve various optimisation
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the full code on [GitHub](https://github.com/miptgirl/miptgirl_medium/blob/main/discrete_optimisations/discrete_optimisation.ipynb).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this article, we explored different methods for solving the knapsack problem
    and its analogues in product analytics.
  prefs: []
  type: TYPE_NORMAL
- en: We began with a brute-force approach but quickly realized it would take an unreasonable
    amount of time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we tried using common sense by naively selecting the top-performing segments,
    but this approach yielded incorrect results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we turned to Integer Programming, learning how to translate our product
    tasks into optimization models and solve them effectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, I hope you’ve gained another valuable analytical tool for your toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you a lot for reading this article. I hope this article was insightful
    for you. If you have any follow-up questions or comments, please leave them in
    the comments section.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*All the images are produced by the author unless otherwise stated.*'
  prefs: []
  type: TYPE_NORMAL

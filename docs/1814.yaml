- en: Unit Disk and 2D Bounded KDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/unit-disk-and-2d-bounded-kde-2cb5c3544f1c?source=collection_archive---------8-----------------------#2024-07-25](https://towardsdatascience.com/unit-disk-and-2d-bounded-kde-2cb5c3544f1c?source=collection_archive---------8-----------------------#2024-07-25)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How to extend Bounded Kernel Density Estimation to the 2D case? Let’s explore
    how to fix boundary bias around the unit disk.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@thom01.rouch?source=post_page---byline--2cb5c3544f1c--------------------------------)[![Thomas
    Rouch](../Images/a8440bbed59cd8d9cdd752cf1fea2831.png)](https://medium.com/@thom01.rouch?source=post_page---byline--2cb5c3544f1c--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--2cb5c3544f1c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--2cb5c3544f1c--------------------------------)
    [Thomas Rouch](https://medium.com/@thom01.rouch?source=post_page---byline--2cb5c3544f1c--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--2cb5c3544f1c--------------------------------)
    ·12 min read·Jul 25, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ec9b89e02ffca87b6de3078ca825c636.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Leo_Visions](https://unsplash.com/@leo_visions_?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 0\. Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MonteCarlo Integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numerical methods become essential when closed-form solutions for integrals
    are unavailable. While traditional numerical integration techniques like trapezoidal
    integration are highly effective for low-dimensional and smooth integrals, their
    efficiency diminishes rapidly, becoming clearly intractable as the dimensionality
    of the integrand increases.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional techniques, the convergence rate of Monte Carlo methods,
    which leverage randomness to evaluate integrals, does not depend on the dimensionality
    of the integrand. It depends solely on the number of random samples drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As described in the equation below, the Monte Carlo estimates the integral by
    a weighted mean of the operand evaluated at samples drawn from a given distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6d160d6f1e82e716632aebce4d6465d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Monte Carlo Integration thus requires to be able to sample from arbitrary distributions
    across arbitrary dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: With `n` samples, these methods converge to the correct result at a rate of
    `O(1/sqrt(n))`. To halve the error, you need four times as many samples. Therefore,
    optimizing the sampling process to make the most of each sample is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform sampling helps ensuring that all regions of the integrand are equally
    likely to be sampled, avoiding the redundancy of closely spaced samples that provide
    little additional information.
  prefs: []
  type: TYPE_NORMAL
- en: Other techniques like importance sampling for instance aims at reducing the
    variance by prioritizing the sampling of more significant regions of the integrand.
  prefs: []
  type: TYPE_NORMAL
- en: Visualize 2D Disk Sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The book [*PBRT (Physically Based Rendering: From Theory To Implementation)*](https://pbrt.org/)
    does a great job at explaining methods to sample from different geometries like
    disks, triangles or hemispheres to compute solutions to the integral equations
    that describe light scattering.'
  prefs: []
  type: TYPE_NORMAL
- en: I was excited by the variety of methods I discovered for sampling a disk and
    intrigued by their underlying principles. To better understand and visually compare
    these 2D distributions, I decided to plot a density map for each method.
  prefs: []
  type: TYPE_NORMAL
- en: However, a boundary bias occurs when running kernel density estimation (KDE)
    on a disk because the kernel function extends beyond the boundary of the disk,
    leading to an underestimation of the density near the edges.
  prefs: []
  type: TYPE_NORMAL
- en: This article aims at providing a way to visualize an unbiased density map of
    the 2D unit disk.
  prefs: []
  type: TYPE_NORMAL
- en: Article Outline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building upon my previous article [*Bounded Kernel Density Estimation*](https://medium.com/towards-data-science/bounded-kernel-density-estimation-2082dff3f47f),
    where I explored various methods used to address the boundary bias in the 1D context,
    we’ll test the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reflection*: Reflect points with respect to the circle’s edge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transform*: Map bounded disk to an unbounded space to perform KDE'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Weighting*: Cut and normalize the kernels spreading outside the disk'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/b9ef2f835f1665dd3581a0c8ba5c5944.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Nathan Shipps](https://unsplash.com/@nateshipps?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Boundary Bias around the disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boundary bias
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As As discussed in the introduction, conventional Kernel Density Estimations
    (KDE) struggle to effectively manage distributions with compact support, such
    as points within a disk.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, as illustrated in the figure below with a square domain, kernel span
    tends to leak beyond the boundary, artificially lowering the density near the
    edges.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9f37564088b91ec08ce16c5e5d9ccd74.png)'
  prefs: []
  type: TYPE_IMG
- en: Kernel leaking beyond the boundaries of a square — Figure by the author
  prefs: []
  type: TYPE_NORMAL
- en: Vanilla Gaussian KDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code below samples points on a grid at regular intervals across the unit
    square, retaining only those within the disk to input into a vanilla Gaussian
    KDE. Predicted densities are then set to zero outside the disk after the KDE evaluation
    to keep the boundary constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the density is normalized by multiplying it by the disk area (π), ensuring
    an expected density of 1.0 throughout the interior of the disk.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the input points are not lying on a regular grid, and thus we need
    to sample a grid at display resolution to evaluate the estimated KDE.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The left figure below has been obtained by running the code above. A noticeable
    density decrease can be observed around the disk’s edge. To better illustrate
    the falloff near the edge, I have also extracted the density profile along the
    diagonal, which ideally should be a perfect step function.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3e6859b460524a0397a5bd55438960df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Left: Base KDE on samples drawn uniformly within the unit disk. Right: Corresponding
    1D density profile along the diagonal of the density map — Figure by the author'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a451c14e76bf8026d821782d91e85316.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Михаил Секацкий](https://unsplash.com/@sekatsky?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Reflection Trick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 1D, the trick consists in augmenting the set of samples by reflecting them
    across the left and right boundaries. It helps compensating the lack of neighbors
    on the other side of the boundary. This is equivalent to reflecting the tails
    of the local kernels to keep them in the bounded domain. The formula below is
    used to reflect positive 1D values.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it works best when the density derivative is zero at the boundary.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/98530866e0af243fd41b016f0e38e7e5.png)'
  prefs: []
  type: TYPE_IMG
- en: However, in 2D, there isn’t a universal reflection formula; it depends on the
    boundary shape. Intuitively, the reflection should align with the boundary normals.
    Therefore, for a disk, it makes sense to reflect points along the radial direction,
    which means that the reflection only modifies the radius.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ddcf038f7fde1be4df50505f03c5a337.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that handling boundary reflections of the unit square is more challenging
    than the disk due to the non-differentiability of its boundary line at the corners.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Intuitive Disk Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intuitively, we can mimic the 1D case by reflecting the point symmetrically
    across the boundary. A point at radius `r` is at a distance of `1-r` from the
    edge. By adding this distance beyond the boundary, we get `2-r`. The equation
    and figure below demonstrate how points are reflected across the edge of the unit
    disk using this symmetry.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c43146ac1fac68bc6df51db91490fe1f.png)![](../Images/978bb2781e207ce52a903fd5cc3d4cdc.png)'
  prefs: []
  type: TYPE_IMG
- en: Colored points reflected symmetrically across the unit disk edge using f(r)=2-r.
    Circles at radius r=1 and r=2\. — Figure by the author
  prefs: []
  type: TYPE_NORMAL
- en: However, when this method is applied to correct the density map, a slight falloff
    around the edge is still noticeable, although it significantly improves upon the
    standard KDE.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/b884385683ef61bf3bf280acaa30518f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Left: Reflection KDE on samples drawn uniformly within the unit disk. Right:
    Corresponding 1D density profile along the diagonal of the density map — Figure
    by the author'
  prefs: []
  type: TYPE_NORMAL
- en: Optimized Disk Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s see how we can improve this reflection function to better suit the disk
    boundary. Unlike the 1D case, the `f(r)=2-r` reflection distorts the space and
    maps the unit disk of area π to a larger ring of area 3π.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally we’d like that the area of each differential surface inside the disk
    remains invariant during the reflection mapping. As illustrated in the figure
    below, we consider differential variations dr and dθ around a point at radius
    r.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/607de0ee48e70824896038fb61d2c310.png)'
  prefs: []
  type: TYPE_IMG
- en: Differential surface before (r, dr, dθ) and after the reflection — Figure by
    the author
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3720ba80ee5feeef4ebad68f7c0fee6f.png)'
  prefs: []
  type: TYPE_IMG
- en: The conservation of area results in a differential equation that the reflection
    function must satisfy. Note that the minus sign arises because the function f
    is necessarily decreasing due to its reflective nature.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ce8684a6bdcce66d55a294d7c1a33ea1.png)'
  prefs: []
  type: TYPE_IMG
- en: Given the boundary condition `f(1)=1` , there’s a single solution to the differential
    equation `-x=yy'`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c11701f3d19077d43ee4f32d22b606e8.png)'
  prefs: []
  type: TYPE_IMG
- en: We just have to update our code with the new reflection formula. Reflected points
    are now contained within the ring between radii 1 and √2\. As we can see, reflected
    points are not too distorted and keep a similar local density.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5713b62b40d16b0e1158ed018bf357da.png)'
  prefs: []
  type: TYPE_IMG
- en: Colored points reflected across the unit disk edge using f(r)=sqrt(2-r²). Circles
    at radius r=1, r=sqrt(2) and r=2\. — Figure by the author
  prefs: []
  type: TYPE_NORMAL
- en: This time, the resulting density estimate looks nearly perfect!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d18de7cdf9572a7a9f18ba3c79502412.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Left: Optimized reflection KDE on samples drawn uniformly within the unit disk.
    Right: Corresponding 1D density profile along the diagonal of the density map
    — Figure by the author'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/03232e5fa3a128665deea8c6fe3bb939.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [SpaceX](https://unsplash.com/@spacex?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Transformation Trick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: KDE in transformed space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The transformation trick maps the bounded data to an unbounded space, where
    the vanilla KDE can be safely applied. This results in using a different kernel
    function for each input sample.
  prefs: []
  type: TYPE_NORMAL
- en: However, as seen in previous article [*Bounded Kernel Density Estimation*](https://medium.com/towards-data-science/bounded-kernel-density-estimation-2082dff3f47f),
    , when the density is non-zero at the boundary and does not tend to infinity,
    it often results in unwanted artifacts.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Transformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building upon our approach from the previous section, we will again use central
    symmetry and choose a transformation `f` that alters only the radius. Transformed
    variables will be indicated with a tilde `~`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5b4f6a1a2a188469ad2b463c870c6ed2.png)'
  prefs: []
  type: TYPE_IMG
- en: However, unlike the reflection case, where we preserved the unit disk and used
    the transformation solely to add new points, here we directly transform and use
    the points from within the unit disk.
  prefs: []
  type: TYPE_NORMAL
- en: Thus the boundary conditions are different and enforce instead to left the origin
    untouched and to dilate the disk to infinity.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/955be14ee2706712da691cf257bfd8ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Density Transformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When applying a transformation T to a multi-dimensional random variable U, the
    resulting density is found by dividing by the absolute value of the determinant
    of the Jacobian matrix of T.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/198b30a69bbf3e6710e4b3f31a971c8d.png)'
  prefs: []
  type: TYPE_IMG
- en: For instance, the polar transformation gives us the following density.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d67aab7843e4c3b8a8829d0c4d9da02e.png)'
  prefs: []
  type: TYPE_IMG
- en: Based on the two previous properties, we can derive the relationship between
    the density before and after the transformation. This will enable us to recover
    the true density from the density estimated on the transformed points.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8647eca330ee2cb37f89ee21b4bb4579.png)'
  prefs: []
  type: TYPE_IMG
- en: Which transformation to choose? Log, Inverse ?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are plenty of functions that start from zero and increase to infinity
    as they approach 1\. There is no one-size-fits-all answer.
  prefs: []
  type: TYPE_NORMAL
- en: The figure below showcases potential candidate functions created using logarithmic
    and inverse transformations to introduce a singularity at `r=-1` and `r=1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7cb4fa038b8fdca1a34f48f27ca9ffce.png)'
  prefs: []
  type: TYPE_IMG
- en: Examples of functions that equal zero at the origin and tend to infinity as
    they approach +/-1 — Figure by the author
  prefs: []
  type: TYPE_NORMAL
- en: Based on the equation describing the transformed density, we aim to find a transformation
    that maps the uniform distribution to a form easily estimable by vanilla KDE.
    If we have a uniform distribution `p(x,y)`, the density in transformed space is
    thus proportional to the function `g` below.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/cda78ca4d98f029d2cf455cc0c8c9da8.png)'
  prefs: []
  type: TYPE_IMG
- en: Logarithmic and inverse candidates give the following `g` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/42e89020c8d230eb49779cafba117417.png)![](../Images/39c366866c1df22882164b364a735321.png)'
  prefs: []
  type: TYPE_IMG
- en: They’re both equivalent when `r` approaches zero and only converge to a meaningful
    value when α is equal to one.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f7d4637b486fd2ea9d5c7ef4c8f4b641.png)'
  prefs: []
  type: TYPE_IMG
- en: The figure below illustrates the three cases, with each column corresponding
    to the log transform with alpha values of 0.5, 1 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: The first row shows the transformed space, comparing the density along the diagonal
    as estimated by the KDE on the transformed points (blue) against the expected
    density profile corresponding to the uniform distribution in the original space
    (red). The second row displays these same curves, but mapped back to the original
    space.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the transformation and KDE are still performed in 2D on the
    disk. The one-dimensional curves shown below are extracted from the 2D results.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/d74c925d22997679fcec81e4e6300eac.png)'
  prefs: []
  type: TYPE_IMG
- en: Density along the diagonal in transformed and original domain (first and second
    row). The columns correspond to the log-based transformation with alpha equal
    to 0.5 / 1 / 2 — Figure by the author
  prefs: []
  type: TYPE_NORMAL
- en: Both **α<1** and **α>1** introduce singularities near the origin, which completely
    ruin the interior density estimate. As for **α=1**, the expected density in transformed
    space is highly non-differentiable at the origin, resembling a pointed hat shape,
    which is impossible to fit with gaussian kernels.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the tail density is highly sensible to noise, which can produce high-frequency
    artifacts near the boundaries. In my opinion, this issue is more problematic than
    the original bias we are trying to address.
  prefs: []
  type: TYPE_NORMAL
- en: Try with another Kernel?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To achieve more accurate fit for the expected pointed shape when **α=1**, I
    estimated the density using a triangular kernel instead of a Gaussian one, as
    shown in the code below.
  prefs: []
  type: TYPE_NORMAL
- en: Although the fit is slightly better, it remains highly biased at the origin.
    Additionally, the boundary becomes completely unstable, oscillating at high frequency
    due to the low bandwidth required to fit the very steep pointed shape at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2d3763d0cec90680876ade34c66beb03.png)'
  prefs: []
  type: TYPE_IMG
- en: Density along the diagonal in transformed and original domain (first and second
    row), for the log-based transformation with alpha equal 1, using a triangle filter
    — Figure by the author
  prefs: []
  type: TYPE_NORMAL
- en: Try with the tangent function?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tangent function also proves to be a suitable candidate to introduce a singularity
    at `r=1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c518663356641f0e3a3a74fa5f30ace8.png)![](../Images/d8d5c736e87d89e16ee3aa2e47569a0d.png)'
  prefs: []
  type: TYPE_IMG
- en: Tangent function modified to tend to infinity as the radius approaches +/-1
    — Figure by the author
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, its corresponding `g` function turns out to be differentiable at
    the origin, which should make it much easier to fit.
  prefs: []
  type: TYPE_NORMAL
- en: To maintain readability and avoid redundancy, I will not include the mathematical
    details that led to these results.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../Images/83026a897d26229483f8e6ce6dd3b7a9.png)'
  prefs: []
  type: TYPE_IMG
- en: However, as illustrated in the figure below, we’re still subject to the same
    instability around the boundary.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f9637ffbd11644ad0df22aafb2107245.png)'
  prefs: []
  type: TYPE_IMG
- en: Density along the diagonal in transformed and original domain (first and second
    row), for the tan-based transformation — Figure by the author
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The transformation method appears unsuitable for our uniform distribution within
    the 2D disk. It introduces excessive variance near the boundaries and significantly
    disrupts the interior, which was already perfectly unbiased.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the poor performance, I’ve also generated the resulting 2D density map
    obtained with the Transform KDE using the log and tangent transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/de437992636891765c692b65831f8da1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Left: Log Transform KDE on samples drawn uniformly within the unit disk. Right:
    Corresponding 1D density profile along the diagonal of the density map — Figure
    by the author'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6469a37826922a1ce11469f73cf0b55a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Left: Tangent Transform KDE on samples drawn uniformly within the unit disk.
    Right: Corresponding 1D density profile along the diagonal of the density map
    — Figure by the author'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/d05eb760e26f8b70089908e9aae880ee.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Piret Ilver](https://unsplash.com/@saltsup?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Cut-and-Normalize Trick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Weighting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the density is artificially lower around he boundary because of the lack
    of neighbors, we could compute how much of our local kernel has been lost outside
    the bounded domain and leverage it to correct the bias.
  prefs: []
  type: TYPE_NORMAL
- en: In 1D, this involves computing the integral of a Gaussian over an interval.
    It’s straightforward, as it can be done by estimating the Cumulative Density Function
    at both ends of the interval and subtracting the values.
  prefs: []
  type: TYPE_NORMAL
- en: However, in 2D, this requires computing the integral of a 2D Gaussian over a
    disk. Since there is no analytical solution for this, it must be numerically approximated,
    making it more computationally expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Numerical Approximation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It would be too expensive to perform numerical integration for each single predicted
    density. Since we are essentially computing the convolution between a binary disk
    and a Gaussian kernel, I propose discretizing the unit square to perform numerical
    convolution.
  prefs: []
  type: TYPE_NORMAL
- en: In the code below, we assume an isotropic Gaussian and retrieve the kernel standard
    deviation. Subsequently, we perform the convolution on the binary disk mask using
    OpenCV, resulting in the array shown in the figure below. Notice how closely it
    approximates the biased vanilla KDE.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a580a9450e42692374802764e4dedbf7.png)'
  prefs: []
  type: TYPE_IMG
- en: Gaussian Blur applied on the binary image of the Unit Disk. Circle at radius
    1— Figure by the author
  prefs: []
  type: TYPE_NORMAL
- en: Result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the correction weight map has been computed, we can apply it to the biased
    predicted density. The corrected density map is then almost perfect.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/927a7a7233330a6f97e6a3a168970531.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Left: Cut-and-Normalize KDE on samples drawn uniformly within the unit disk.
    Right: Corresponding 1D density profile along the diagonal of the density map
    — Figure by the author'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9fb00bbf65647ea62f693c37a2f9672e.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Florian Schmetz](https://unsplash.com/@floschmaezz?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Reflection** and **Cut-and-Normalize** methods are very easy to use and
    effectively mitigate the boundary bias. In contrast, the **Transform** method
    shows poor performance on the uniform 2D disk, despite testing various singular
    functions and kernel types.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Reflection** method transforms the input of the KDE, whereas the **Cut-and-Normalize**
    method transforms its output.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Gaussian KDE has a time complexity that is quadratic in the number
    of samples, i.e. O(n²), **Reflection** is approximately four times slower than
    **Cut-and-Normalize** because it requires twice as many samples.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the **Cut-and-Normalize** method seems to be the easiest and fastest way
    to compensate the boundary bias on the 2D uniform Disk distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Visualize 2D Disk Sampling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now simulate different disk sampling strategies and compare them based
    on their density map, without having to worry about the boundary bias.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you enjoyed reading this article and that it gave you more insights on
    how to perform bounded Kernel Density Estimation in the 2D case.
  prefs: []
  type: TYPE_NORMAL

- en: Real-Time Twitch Chat Sentiment Analysis with Apache Flink
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时Twitch聊天情感分析与Apache Flink
- en: 原文：[https://towardsdatascience.com/real-time-twitch-chat-sentiment-analysis-with-apache-flink-e165ac1a8dcf?source=collection_archive---------5-----------------------#2024-03-27](https://towardsdatascience.com/real-time-twitch-chat-sentiment-analysis-with-apache-flink-e165ac1a8dcf?source=collection_archive---------5-----------------------#2024-03-27)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/real-time-twitch-chat-sentiment-analysis-with-apache-flink-e165ac1a8dcf?source=collection_archive---------5-----------------------#2024-03-27](https://towardsdatascience.com/real-time-twitch-chat-sentiment-analysis-with-apache-flink-e165ac1a8dcf?source=collection_archive---------5-----------------------#2024-03-27)
- en: Learn how to empower creators by real-time sentiment analysis with Apache Flink
    to decipher audience emotions to steer content for viewer satisfaction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习如何通过实时情感分析与Apache Flink赋能创作者，解读观众情绪，调整内容以提高观众满意度
- en: '[](https://vojay.medium.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)[![Volker
    Janz](../Images/0825160d6d521f4152948f0187cf354b.png)](https://vojay.medium.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)
    [Volker Janz](https://vojay.medium.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://vojay.medium.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)[![Volker
    Janz](../Images/0825160d6d521f4152948f0187cf354b.png)](https://vojay.medium.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)
    [Volker Janz](https://vojay.medium.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)
    ·22 min read·Mar 27, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e165ac1a8dcf--------------------------------)
    ·22分钟阅读·2024年3月27日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/e55f68a621ce60805ded66c172ab01cb.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e55f68a621ce60805ded66c172ab01cb.png)'
- en: Photo by [Joey kwok](https://unsplash.com/@spideyjoey?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [Joey kwok](https://unsplash.com/@spideyjoey?utm_source=medium&utm_medium=referral)
    提供的照片，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: 🚀 Let’s learn about Apache Flink and sentiment analysis by building a real-time
    sentiment analysis streaming application for the Twitch chat.
  id: totrans-8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 🚀 让我们通过构建一个实时情感分析流应用程序，学习Apache Flink和情感分析，为Twitch聊天提供支持。
- en: – [Introduction and demo](#cbac)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: – [介绍与演示](#cbac)
- en: – [Apache Flink](#590a)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: – [Apache Flink](#590a)
- en: – [NLP and sentiment analysis](#0d10)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: – [NLP与情感分析](#0d10)
- en: – [Setting up a Flink project](#138d)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: – [设置Flink项目](#138d)
- en: – [Prepare the project](#acf0)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: – [准备项目](#acf0)
- en: −− [Project settings in IntelliJ](#d36b)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: −− [IntelliJ中的项目设置](#d36b)
- en: −− [Rename and reduce main class](#5b50)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: −− [重命名并简化主类](#5b50)
- en: −− [pom.xml project settings](#9c6a)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: −− [pom.xml项目设置](#9c6a)
- en: −− [Run configuration](#88d6)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: −− [运行配置](#88d6)
- en: −− [Local Flink Web UI](#d646)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: −− [本地Flink Web UI](#d646)
- en: – [Read the Twitch chat](#cc63)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: – [读取Twitch聊天](#cc63)
- en: −− [Add Twitch4J dependency](#db06)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: −− [添加Twitch4J依赖](#db06)
- en: −− [Create POJO for Twitch chat messages](#9ce2)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: −− [为Twitch聊天消息创建POJO](#9ce2)
- en: −− [Create custom Twitch source function for Flink](#b69b)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: −− [为Flink创建自定义Twitch源函数](#b69b)
- en: −− [Use source function](#78d2)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: −− [使用source函数](#78d2)
- en: – [Twitch chat sentiment analysis](#b566)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: – [Twitch聊天情感分析](#b566)
- en: −− [Add Stanford CoreNLP dependencies](#600f)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: −− [添加Stanford CoreNLP依赖](#600f)
- en: −− [Create sentiment analysis map function](#eea7)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: −− [创建情感分析map函数](#eea7)
- en: −− [Use map function](#75ee)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: −− [使用map函数](#75ee)
- en: – [Conclusion](#35a9)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: – [结论](#35a9)
- en: '***Disclaimer****: Within this article and demo, I am only analyzing my own
    chat messages, without storing data or processing other users messages. Please
    be advised to consult the Twitch* [*Terms of Service*](https://www.twitch.tv/p/en/legal/terms-of-service/)
    *and* [*Developer Services Agreement*](https://www.twitch.tv/p/en/legal/developer-agreement/)*,
    as well as the official* [*Twitch API documentation*](https://dev.twitch.tv/docs/api/)
    *before using it for other purposes.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '***免责声明***：在本文和演示中，我仅分析我自己的聊天消息，未存储数据或处理其他用户的消息。在将其用于其他目的之前，请咨询Twitch的[*服务条款*](https://www.twitch.tv/p/en/legal/terms-of-service/)和[*开发者服务协议*](https://www.twitch.tv/p/en/legal/developer-agreement/)，以及官方的[*Twitch
    API文档*](https://dev.twitch.tv/docs/api/)。'
- en: Introduction and demo
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍与演示
- en: In this blog post, I will guide you through building a real-time sentiment analysis
    application for Twitch chat using [Apache Flink](https://flink.apache.org/). This
    application will be able to process live messages from a Twitch channel and determine
    the overall sentiment of the chat.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇博客文章中，我将指导你如何使用[Apache Flink](https://flink.apache.org/)构建一个实时情感分析应用程序，用于分析
    Twitch 聊天。该应用程序能够处理来自 Twitch 频道的实时消息，并判断聊天的整体情感。
- en: 'The project was built with the following environment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目构建使用了以下环境：
- en: '**OS**: macOS Sonoma'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：macOS Sonoma'
- en: '**Java**: 11'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java**：11'
- en: '**Flink**: 1.17.2'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flink**：1.17.2'
- en: '![](../Images/e46b1477e09e4b3e113640ed6cebc535.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e46b1477e09e4b3e113640ed6cebc535.png)'
- en: Real-time Twitch chat sentiment analysis with Apache Flink (by author)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实时 Twitch 聊天情感分析与 Apache Flink（作者）
- en: 'The underlying idea of this article is: to further educate ourselves in the
    field of Data Engineering, we should follow our passion and grow through actual
    projects.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本文的基本思路是：为了在数据工程领域进一步提升自己，我们应该跟随自己的热情，通过实际项目来成长。
- en: Find a problem that interests and motivates you, and try to solve it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 找到一个让你感兴趣并激励你的问题，并尝试解决它。
- en: By the end of this blog post, you will have a working application that can be
    used to track the sentiment of a Twitch chat in real-time. It can be used with
    one ore more Twitch channels. You will also learn the basics of [Apache Flink](https://flink.apache.org/)
    and sentiment analysis in Java.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 到这篇博客文章结束时，你将拥有一个可以实时跟踪 Twitch 聊天情感的工作应用程序。它可以用于一个或多个 Twitch 频道。你还将学习 [Apache
    Flink](https://flink.apache.org/) 和 Java 中的情感分析基础。
- en: '**You can find the final result also on Github** 🪄: [https://github.com/vojay-dev/flitch](https://github.com/vojay-dev/flitch)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**你还可以在 Github 上找到最终结果** 🪄：[https://github.com/vojay-dev/flitch](https://github.com/vojay-dev/flitch)'
- en: Apache Flink
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Flink
- en: Streams of data are everywhere. Almost all data that is generated is generated
    as a stream of data naturally, even if we mostly process data in batches. This
    can be GPS data, interaction tracking for apps or websites, sensor data or messages
    in a Twitch chat.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流无处不在。几乎所有生成的数据本质上都是作为数据流生成的，即使我们通常处理的是批量数据。这些数据可以是 GPS 数据、应用程序或网站的交互跟踪、传感器数据或
    Twitch 聊天中的消息。
- en: '***Stream processing means to process data in motion***'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***流处理意味着处理动态数据***'
- en: A stream processing application usually consists of data sources, which generate
    streams of data, operators to process the data and sinks. These days, there are
    many frameworks and services that allow to implement stream processing applications
    and often concepts are similar. One of them is [Apache Flink](https://flink.apache.org/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流处理应用程序通常由数据源、生成数据流、操作符用于处理数据和接收端组成。如今，有许多框架和服务可以用来实现流处理应用程序，并且概念上往往是类似的。其中之一是[Apache
    Flink](https://flink.apache.org/)。
- en: '[Apache Flink](https://flink.apache.org/) is not only a framework but also
    a distributed process engine. It allows to create and run **stateful** computations
    on **unbounded** and **bounded** data streams. **Ubounded** streams have a defined
    start, but no defined end while **bounded** data streams have a defined start
    and end. This might sound familiar, since that can also be seen as a batch of
    data but represented as a stream.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[Apache Flink](https://flink.apache.org/) 不仅是一个框架，还是一个分布式处理引擎。它允许在**有状态**的计算中对**无界**和**有界**数据流进行创建和执行。**无界**数据流有一个明确的开始，但没有明确的结束，而**有界**数据流则有明确的开始和结束。这个概念可能听起来有点熟悉，因为这也可以被视为一个数据批次，只不过它是以流的形式呈现的。'
- en: '![](../Images/c65239a997c588ae867dcc6bfa8a2beb.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c65239a997c588ae867dcc6bfa8a2beb.png)'
- en: Flink concepts (by author)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Flink 概念（作者）
- en: Flink offers APIs to define streaming applications. With those you can control
    data sources, transformations and data sinks. With the SQL / Table API you can
    define streaming applications using SQL, which is an amazing feature but please
    keep in mind that streaming SQL behaves differently from batch SQL, which might
    require a shift in how to approach problems. Then, there is the DataStream API
    which can be used to compose your streaming pipeline with predefined functions.
    This can be used in Python, Java and Scala. If you need full control over events,
    state and time, the ProcessFunction layer is the way to go.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Flink 提供了定义流应用程序的 API。通过这些 API，你可以控制数据源、数据转换和数据接收端。通过 SQL / Table API，你可以使用
    SQL 定义流应用程序，这是一个非常棒的功能，但请记住，流 SQL 与批处理 SQL 行为不同，这可能要求你改变解决问题的方法。接下来，还有 DataStream
    API，可以用来通过预定义的函数组合你的流管道。它可以在 Python、Java 和 Scala 中使用。如果你需要完全控制事件、状态和时间，那么 ProcessFunction
    层是你的最佳选择。
- en: '![](../Images/d485c1cf66873673c44c2b23823c9f90.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d485c1cf66873673c44c2b23823c9f90.png)'
- en: Flink APIs (by author)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Flink API（作者）
- en: For this use-case, we will use the DataStream API in Java to define a custom
    source to read the Twitch chat as a stream of data. Futhermore, we will define
    a custom map function, which takes each Twitch message as input, performs the
    sentiment analysis on it and returns a tuple with the message and the analysis
    result. Finally, we simply use a pre-defined sink to print the result. In this
    particular case, we only look at one invdividual event at a time, this is called
    **stateless stream processing**. Bare in mind that one of the key features of
    Flink is to remember information across multiple events, e.g. in form of windowing
    functions. This is called **stateful stream processing**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个用例，我们将在Java中使用DataStream API来定义一个自定义源，以便将Twitch聊天作为数据流读取。此外，我们还将定义一个自定义的map函数，它将每条Twitch消息作为输入，对其进行情感分析，并返回一个包含消息和分析结果的元组。最后，我们仅使用一个预定义的sink来打印结果。在这个特定的案例中，我们一次只查看一个事件，这被称为**无状态流处理**。请记住，Flink的一个关键特性是能够跨多个事件记住信息，例如通过窗口函数的形式。这被称为**有状态流处理**。
- en: '![](../Images/b08d47365c06f9e10a96bd63298dfe55.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b08d47365c06f9e10a96bd63298dfe55.png)'
- en: Flink state (by author)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Flink状态（作者）
- en: 'If you are interested in a more advanced Flink use-case including state and
    other advanced techniques like the Broadcast State Pattern, have a look at my
    talk at the Big Data Conference Europe 2023:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对更高级的Flink用例感兴趣，包括状态管理和其他高级技术（如广播状态模式），可以看看我在2023年欧洲大数据大会上的演讲：
- en: 📼 [Real-time Customer Engagement in Gaming Using Kafka and Flink](https://www.youtube.com/watch?v=djikIGOm90U)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 📼 [使用Kafka和Flink实现游戏中的实时客户互动](https://www.youtube.com/watch?v=djikIGOm90U)
- en: NLP and sentiment analysis
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NLP和情感分析
- en: Imagine Natural Language Processing (NLP) as your super-powered translator for
    computer brains. It lets them understand the nuances of human language, just like
    you can tell the difference between a sarcastic “good job” and a genuine one.
    This goes beyond simple keyword matching and delves into the complexities of grammar,
    syntax, and semantics.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，自然语言处理（NLP）就像是你电脑大脑的超级翻译器。它让计算机能够理解人类语言的细微差别，就像你能分辨出讽刺的“好工作”和真诚的“好工作”之间的不同。这不仅仅是简单的关键词匹配，而是深入探讨语法、句法和语义的复杂性。
- en: 'Here are some NLP applications you might encounter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的一些NLP应用包括：
- en: '**Spam filtering**: NLP can identify suspicious patterns in emails, separating
    legitimate messages from spam.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾邮件过滤**：NLP可以识别电子邮件中的可疑模式，帮助将合法邮件与垃圾邮件区分开来。'
- en: '**Machine translation**: NLP helps bridge the language gap by analyzing the
    structure and meaning of sentences for accurate translation.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器翻译**：NLP通过分析句子的结构和意义来帮助弥合语言鸿沟，确保翻译的准确性。'
- en: '**Voice assistants**: Siri, Alexa, and Google Assistant all leverage NLP to
    understand your voice commands and respond intelligently.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语音助手**：Siri、Alexa和Google Assistant都利用NLP来理解你的语音命令并智能回应。'
- en: One other application of NLP is sentiment analysis. Think of it like an emotional
    compass for text. It assigns a sentiment score (positive, negative, or neutral)
    to a piece of text, helping us gauge the overall feeling behind it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: NLP的另一个应用是情感分析。可以把它想象成文本的情感指南针。它为一段文本分配一个情感分数（积极、消极或中性），帮助我们衡量文本背后的整体情感。
- en: 'There are two main approaches to sentiment analysis:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 情感分析有两种主要方法：
- en: '**Lexicon-based**: This approach relies on pre-built dictionaries containing
    words with predefined sentiment scores. The sentiment score of a text is calculated
    based on the scores of the identified words.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于词典**：这种方法依赖于预先构建的字典，字典中包含具有预定义情感分数的单词。文本的情感分数是根据所识别单词的情感分数计算的。'
- en: '**Machine Learning-based**: This method utilizes machine learning algorithms
    trained on massive datasets of text labeled with sentiment. These algorithms can
    learn complex relationships between words and their emotional connotations, leading
    to more nuanced sentiment analysis.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于机器学习**：这种方法利用在大量标注情感的文本数据集上训练的机器学习算法。这些算法能够学习单词之间及其情感内涵的复杂关系，从而实现更细致的情感分析。'
- en: '![](../Images/4e822594adf58749fb9ba3ba5ef4470e.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4e822594adf58749fb9ba3ba5ef4470e.png)'
- en: Sentiment analysis example (by author)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 情感分析示例（作者）
- en: This is perfect for deciphering those Twitch chat vibes!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于解读Twitch聊天中的氛围非常有用！
- en: In our Twitch chat example, we can use sentiment analysis to see if the chat
    is overflowing with happiness or tilting over a missed play. This can be fascinating
    for streamers to understand their audience’s real-time reaction and maybe even
    adjust their content accordingly! It could be used for real-time monitoring of
    the communities mood.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Twitch 聊天示例中，我们可以使用情感分析来查看聊天是否充满了快乐，或者是否因为错过一局而情绪低落。这对于主播来说，可以帮助他们了解观众的实时反应，甚至根据反馈调整内容！它可以用于实时监控社区的情绪。
- en: Setting up a Flink project
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Flink 项目
- en: A simple and fast way to setup a Flink project is Maven. Maven is a tool that
    can be used for building and managing primarily Java-based projects. Maven can
    support you as a developer by addressing the aspects of how your project is buil
    and how its dependencies are managed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Flink 项目的简单快捷方法是 Maven。Maven 是一个用于构建和管理主要是基于 Java 的项目的工具。Maven 能够帮助开发者处理项目构建的各个方面，并管理其依赖关系。
- en: Maven also includes a project templating toolkit called Archetype. With Archetype
    you can quickly generate a new project based on an existing template.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 还包括一个名为 Archetype 的项目模板工具。使用 Archetype，你可以根据现有模板快速生成一个新项目。
- en: There are Archetypes for all kinds of projects, from a simple Java project (`maven-archetype-quickstart`)
    to framework specific project skeletons, for example to create Flink based projects
    (`flink-quickstart-java`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类型的项目都有原型可供选择，从简单的 Java 项目（`maven-archetype-quickstart`）到框架特定的项目骨架，例如创建基于
    Flink 的项目（`flink-quickstart-java`）。
- en: 'We will use this to create the demo application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个来创建演示应用程序：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most of the parameters are optional, if you don’t add them, the CLI tool will
    ask you to enter the details while it is creating your project. With `-q` we reduce
    the output. After executing the above command, we will get the following output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数参数是可选的，如果你不添加它们，CLI 工具会在创建项目时要求你输入相关细节。使用 `-q` 可以减少输出。执行上述命令后，我们将得到以下输出：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Press `enter` to confirm and you will get a folder named after your `artifactId`
    with the generated project boilerplate.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 按 `enter` 确认，你将得到一个以 `artifactId` 命名的文件夹，里面包含生成的项目模板。
- en: '![](../Images/145bdd5fb2440c1c8d0e5dae9add44da.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/145bdd5fb2440c1c8d0e5dae9add44da.png)'
- en: Maven Archetype for Flink (by author)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Flink 的 Maven 原型（由作者提供）
- en: From here, you can use the Java IDE of your choice. However, I recommend using
    [IntelliJ](https://www.jetbrains.com/idea). There is a completely free to use
    [IntelliJ IDEA Community Edition](https://www.jetbrains.com/idea/download).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以使用你选择的 Java IDE。不过，我推荐使用 [IntelliJ](https://www.jetbrains.com/idea)。你可以免费使用
    [IntelliJ IDEA Community Edition](https://www.jetbrains.com/idea/download)。
- en: Prepare the project
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备项目
- en: Before we get to the actual implementation, we will prepare the generated project
    a bit for our use-case.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际实现之前，我们将稍微准备一下生成的项目，以适应我们的用例。
- en: Project settings in IntelliJ
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IntelliJ 中的项目设置
- en: If you are using IntelliJ, we now have to adjust the module and project settings,
    to ensure we are using the right Java version and also have the correct language
    level.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 IntelliJ，现在需要调整模块和项目设置，确保我们使用的是正确的 Java 版本，并且设置了正确的语言级别。
- en: With the project opened in IntelliJ, click on *File* → *Project Structure*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IntelliJ 中打开项目后，点击 *File* → *Project Structure*。
- en: Within the *Project Structure* window, navigate to *Project* and ensure to use
    the **Java 11 SDK**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Project Structure* 窗口中，进入 *Project* 并确保使用 **Java 11 SDK**。
- en: '![](../Images/a5b31219b3207121e668789a569e111a.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a5b31219b3207121e668789a569e111a.png)'
- en: Project settings (by author)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设置（由作者提供）
- en: Finally, navigate to *Modules* and change the language level to **11**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，进入 *Modules* 并将语言级别更改为 **11**。
- en: '![](../Images/cb22316ceadf7e852814bf460bb8b45b.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cb22316ceadf7e852814bf460bb8b45b.png)'
- en: Module settings (by author)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 模块设置（由作者提供）
- en: Rename and reduce main class
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名并减少主类
- en: Rename the generated class `DataStreamJob` simply to `App`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的类 `DataStreamJob` 简单地重命名为 `App`。
- en: '![](../Images/276f020259185a0efb176433f7c80f0e.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/276f020259185a0efb176433f7c80f0e.png)'
- en: Rename class (by author)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名类（由作者提供）
- en: 'Then replace the code with the following content:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用以下内容替换代码：
- en: '[PRE2]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this, we create a execution environment, read data from a bounded stream
    with two elements (“Hello” and “World”), print the elements to STDOUT and execute
    the application with the name “Flitch”.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们创建一个执行环境，从一个包含两个元素（“Hello”和“World”）的有界流中读取数据，将元素打印到 STDOUT，并以“Flitch”作为名称执行应用程序。
- en: '**But for now, let’s not start the application since more adjustments are necessary.**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**但现在，让我们先不启动应用程序，因为还需要做更多的调整。**'
- en: '`pom.xml` project settings'
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`pom.xml` 项目设置'
- en: The `pom.xml` file in Maven is a configuration file that serves as the project’s
    blueprint. It stands for “Project Object Model” and contains information and configurations
    for the project, such as project dependencies, project version, build plugins,
    and goals, among others. Maven uses this file to understand the project structure,
    manage dependencies, and perform various tasks during the build process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 中的 `pom.xml` 文件是一个配置文件，作为项目的蓝图。它代表了“项目对象模型”（Project Object Model），并包含了项目的相关信息和配置，如项目依赖项、项目版本、构建插件和目标等。Maven
    使用这个文件来理解项目结构、管理依赖项，并在构建过程中执行各种任务。
- en: Let’s change the following aspects, so that we use the desired Java version,
    have a proper name and adjust the main class of the demo.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改以下几个方面，以便使用所需的 Java 版本，拥有一个合适的名称，并调整示例的主类。
- en: '**Set target Java version to 11 (LTS):**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**将目标 Java 版本设置为 11（LTS）：**'
- en: '[PRE3]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Change name:**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**更改名称：**'
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Change main class:**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**更改主类：**'
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run configuration
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行配置
- en: Run configurations in IntelliJ are settings that specify how to launch and debug
    your project. They allow you to customize aspects like the main class to run,
    program arguments, and environment variables. You can create multiple configurations
    to easily switch between different running or debugging scenarios, streamlining
    your development process.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ 中的运行配置是指定如何启动和调试项目的设置。它们允许你自定义主类、程序参数和环境变量等方面。你可以创建多个配置，轻松在不同的运行或调试场景之间切换，从而简化开发过程。
- en: But before we create one, let’s see what happens if we run our application.
    So without further ado, let’s start our main class `App` by simply clicking the
    play button.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但在创建之前，我们先看看运行应用程序时会发生什么。所以，不再多说，让我们通过简单地点击播放按钮来启动主类 `App`。
- en: '**The application will fail, this is on purpose.**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序将失败，这是故意的。**'
- en: '![](../Images/fa265b3c95e57d588ad77d2be842ab5e.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fa265b3c95e57d588ad77d2be842ab5e.png)'
- en: Run the app (by author)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序（作者）
- en: 'The reason it failed is a `java.lang.NoClassDefFoundError`. This is, because
    we have dependencies defined in our `pom.xml`, which are not in the classpath
    of Java when running the application:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败的原因是 `java.lang.NoClassDefFoundError`。这是因为我们在 `pom.xml` 中定义了依赖项，而在运行应用程序时，Java
    的类路径中没有这些依赖项：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The relevant part is the **scope**. In Maven, the scope of a dependency specifies
    the visibility and the lifecycle of the dependency in relation to the project.
    It determines how and when a dependency is included in your project, affecting
    classpath and module builds.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相关部分是 **范围**。在 Maven 中，依赖项的范围指定了依赖项相对于项目的可见性和生命周期。它决定了依赖项如何以及何时被包含到项目中，从而影响类路径和模块构建。
- en: Scope `provided` means that the dependencies are expected to be provided by
    the JDK or the runtime environment when executing or deploying your project, thus
    not packaged.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`provided` 范围意味着在执行或部署项目时，期望由 JDK 或运行时环境提供依赖项，因此不进行打包。'
- en: When using Flink in a production environment, you will have a running Flink
    cluster somewhere, either on-premises or in the cloud. This environment already
    has the required dependencies in the classpath per default and we submit our application
    JAR to this production cluster. Thus, we do not need to package these dependencies
    with the JAR.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当在生产环境中使用 Flink 时，你会在某处（无论是本地还是云端）运行 Flink 集群。这个环境默认已经将所需的依赖项包含在类路径中，并且我们将应用程序
    JAR 提交到这个生产集群。因此，我们不需要将这些依赖项与 JAR 一起打包。
- en: However, that also means when we run the application locally, these are not
    in the classpath. And since we have a plain Java setup, we get the `java.lang.NoClassDefFoundError`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着当我们在本地运行应用程序时，这些依赖项不在类路径中。而由于我们使用的是纯 Java 环境，因此会出现 `java.lang.NoClassDefFoundError`。
- en: There are multiple solutions for this problem. We could define different profiles
    with different scopes in Maven, so that the scope is different in our local environment.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有多种解决方案。我们可以在 Maven 中定义不同的构建配置文件（profile），为不同的环境设置不同的范围，以便在本地环境中使用不同的范围。
- en: But since we are using IntelliJ, there is also a way to solve it with the run
    configuration. Click on *Run* → *Edit Configurations…* and then click on the **+**
    or *Add new* to create a new run configuration. From the list, select “Application”
    and name it “Flitch”.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于我们使用的是 IntelliJ，也有一种方法可以通过运行配置来解决此问题。点击 *Run* → *Edit Configurations…*，然后点击
    **+** 或 *Add new* 创建一个新的运行配置。在列表中选择“Application”并将其命名为“Flitch”。
- en: Ensure to select Java 11 and enter `de.vojay.flitch.App` as your main class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择 Java 11，并输入 `de.vojay.flitch.App` 作为主类。
- en: To solve the `java.lang.NoClassDefFoundError`, we now have to enable the option
    *Add dependencies with “provided” scope to classpath*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决`java.lang.NoClassDefFoundError`，我们现在需要启用选项*将“provided”范围的依赖项添加到类路径*。
- en: '![](../Images/341fbe9ef1b6dd2e3f33420ce528f6bd.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/341fbe9ef1b6dd2e3f33420ce528f6bd.png)'
- en: Run configuration (by author)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行配置（作者）
- en: Your run configuration is ready, lets click “Run” and enjoy our first streaming
    application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你的运行配置已准备好，让我们点击“运行”并享受我们的第一个流应用程序。
- en: It works 🎉. The streaming application will run until the bounded stream is processed.
    You will also find the output of the two elements of your stream in the logs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行了🎉。该流应用程序将在处理完边界流之前一直运行。你还将在日志中找到你流中的两个元素的输出。
- en: '![](../Images/0718a522b627323d624d088c065c7b98.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0718a522b627323d624d088c065c7b98.png)'
- en: First successful run (by author)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次成功运行（作者）
- en: Local Flink Web UI
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地Flink Web UI
- en: There’s still one thing before we turn our attention to the fun part. The Flink
    Web UI is a user-friendly interface that allows developers and administrators
    to monitor and manage their Apache Flink applications. It provides a real-time
    overview of running or completed jobs, displays metrics such as throughput and
    latency, and offers detailed insights into the job’s execution plan. Essentially,
    it’s a convenient dashboard where you can visualize the performance and status
    of your Flink applications, making the process of debugging, optimizing, and managing
    your streaming or batch processing jobs much easier and more intuitive.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将注意力转向有趣的部分之前，还有一件事需要做。Flink Web UI是一个用户友好的界面，允许开发人员和管理员监控和管理他们的Apache Flink应用程序。它提供了正在运行或已完成作业的实时概览，显示了吞吐量和延迟等度量指标，并提供了作业执行计划的详细洞察。基本上，它是一个方便的仪表盘，你可以在其中可视化Flink应用程序的性能和状态，使得调试、优化和管理流处理或批处理作业的过程变得更加简单和直观。
- en: When you run a Flink application locally like in this example, you usually do
    not have the Flink Web UI enabled. However, there is a way to also get the Flink
    Web UI in a local execution environment. I find this useful, especially to get
    an idea of the execution plan before running streaming applications in production.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像本例中那样在本地运行Flink应用程序时，通常没有启用Flink Web UI。然而，有一种方法可以在本地执行环境中也获得Flink Web UI。我觉得这很有用，特别是在运行生产环境中的流应用程序之前，能够了解执行计划。
- en: 'Let’s start by adding a dependency to the `pom.xml`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加依赖项到`pom.xml`开始：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And slightly change the code in our main class `App.java`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 并稍微修改我们主类`App.java`中的代码：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The streaming application will now process a sequence of numbers, so that it
    will not finish immediately. Also with `createLocalEnvironmentWithWebUI` we will
    have the Flink Web UI available locally on port `8081` while the application is
    running.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，流应用程序将处理一系列数字，因此它不会立即完成。此外，使用`createLocalEnvironmentWithWebUI`，我们将在应用程序运行时通过端口`8081`在本地提供Flink
    Web UI。
- en: Start again and open [http://localhost:8081/](http://localhost:8081/) in your
    browser. Apart from various metrics, you can also see the execution plan of your
    Flink application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动并在浏览器中打开[http://localhost:8081/](http://localhost:8081/)。除了各种度量指标，你还可以看到你的Flink应用程序的执行计划。
- en: '![](../Images/d241e32e3d4e642fcb33f54117488f69.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d241e32e3d4e642fcb33f54117488f69.png)'
- en: Flink Web UI (by author)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Flink Web UI（作者）
- en: Now we have a proper local setup and can get started connecting our application
    to Twitch and run sentiment analysis on chat messages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个合适的本地设置，可以开始将我们的应用程序连接到Twitch并对聊天消息进行情感分析。
- en: Read the Twitch chat
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读Twitch聊天
- en: '[Twitch](https://www.twitch.tv/), the leading live streaming platform for gamers,
    offers a comprehensive API and a chat feature that’s deeply integrated with the
    Internet Relay Chat (IRC) protocol.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[Twitch](https://www.twitch.tv/)，领先的游戏玩家直播平台，提供全面的API和一个与互联网中继聊天（IRC）协议深度集成的聊天功能。'
- en: '![](../Images/31fb16b46f763b431e6eb957b698c3f5.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/31fb16b46f763b431e6eb957b698c3f5.png)'
- en: Photo by [Caspar Camille Rubin](https://unsplash.com/@casparrubin?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来自[Caspar Camille Rubin](https://unsplash.com/@casparrubin?utm_source=medium&utm_medium=referral)于[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: At its core, the Twitch API allows applications to interact with Twitch’s data.
    This includes retrieving information about live streams, VODs (Video on Demand),
    users, and game details. The API is RESTful, meaning it follows the architectural
    style of the web, making it straightforward to use with common HTTP requests.
    Developers can use this API to create custom experiences, such as displaying live
    stream stats, searching for channels, or even automating stream setups.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Twitch API 的核心功能是允许应用程序与 Twitch 的数据进行交互。这包括获取关于直播、点播视频（VOD）、用户和游戏详情的信息。API 是
    RESTful 的，意味着它遵循 Web 的架构风格，使用常见的 HTTP 请求非常简单。开发人员可以使用此 API 创建自定义体验，例如显示直播统计信息、搜索频道，甚至自动化流设置。
- en: The Twitch chat is a vital aspect of the Twitch experience, allowing viewers
    to interact with streamers and other viewers in real-time. Underneath the modern
    interface of Twitch Chat lies the Internet Relay Chat (IRC) protocol, a staple
    of online communication since the late 80s. This reliance on IRC allows for a
    wide range of possibilities when it comes to reading and interacting with chat
    through custom applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Twitch 聊天是 Twitch 体验的一个重要方面，它允许观众与主播和其他观众实时互动。在 Twitch 聊天的现代界面背后是互联网中继聊天（IRC）协议，自
    80 年代末以来一直是在线通信的一个重要组成部分。对 IRC 的依赖使得通过自定义应用程序读取和与聊天互动时，拥有了广泛的可能性。
- en: For our purpose, we simply want to read the chat, without writing messages ourselves.
    Fortunately, Twitch allows anonymous connections to the chat for read-only application
    use-cases.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们只需要读取聊天内容，而不需要自己发送消息。幸运的是，Twitch 允许匿名连接到聊天，以供只读应用场景使用。
- en: 'To reduce the implementation effort, we will use an existing library to interact
    with Twitch: Twitch4J. Twitch4J is a modern Java library designed to simplify
    the integration with Twitch’s features, including its API, Chat (via IRC), PubSub
    (for real-time notifications), and Webhooks. Essentially, it’s a powerful toolkit
    for Java developers looking to interact with Twitch services without having to
    directly manage low-level details like HTTP requests or IRC protocol handling.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少实现工作量，我们将使用现有的库与 Twitch 进行交互：Twitch4J。Twitch4J 是一个现代 Java 库，旨在简化与 Twitch
    特性（包括其 API、聊天（通过 IRC）、PubSub（实时通知）和 Webhooks）的集成。本质上，它是一个强大的工具包，供 Java 开发人员与 Twitch
    服务进行交互，而无需直接管理像 HTTP 请求或 IRC 协议处理这样的低级细节。
- en: Add Twitch4J dependency
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加 Twitch4J 依赖
- en: 'The first step is to add Twitch4J as a dependency to the `pom.xml`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将 Twitch4J 作为依赖添加到 `pom.xml` 中：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create POJO for Twitch chat messages
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Twitch 聊天消息创建 POJO
- en: We would like to have a lightweight, serializable Plain Old Java Object (POJO)
    in order to represent Twitch chat messages within our application. We are interested
    in the channel where the message was written, the user and the content itself.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个轻量级、可序列化的普通 Java 对象（POJO），用来在我们的应用中表示 Twitch 聊天消息。我们感兴趣的是消息发布的频道、用户以及消息内容本身。
- en: 'Create a new class `TwitchMessage` with the following implementation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类 `TwitchMessage`，并实现以下内容：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As a side note: You do not have to write basic functions like `toString()`
    on your own, you can use IntelliJ to generate it for you. Simply click on *Code*
    → *Generate…* → `toString()` to get the result above.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 旁白：你不必自己编写像 `toString()` 这样的基本函数，你可以使用 IntelliJ 让它为你生成。只需点击 *代码* → *生成…* → `toString()`
    即可得到上面的结果。
- en: '![](../Images/b3202075c87edca8319d6db7ae8379d1.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b3202075c87edca8319d6db7ae8379d1.png)'
- en: Generate toString (by author)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 toString（由作者提供）
- en: Create custom Twitch source function for Flink
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Flink 创建自定义的 Twitch 源函数
- en: We will now use Twitch4J to implement a custom Twitch source function for Flink.
    The source function will generate an unbounded stream of data, in this case Twitch
    chat messages. That also means, the application will not terminate until we explicitly
    stop it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用 Twitch4J 来为 Flink 实现一个自定义的 Twitch 源函数。该源函数将生成一个无界的数据流，在本例中是 Twitch 聊天消息。这也意味着，直到我们明确停止它，应用程序将不会终止。
- en: 'The Twitch client can be built like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Twitch 客户端可以这样构建：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this example we get a `client` that joins the Twitch channel called *vojay*.
    **Yes, I once was an active streamer myself**. Fun fact: I teached people game
    development and general software development in my streams. I also enjoyed playing
    retro games live on stream 🎮. But that is a different topic, let’s focus on the
    project 😉.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将获得一个 `client`，它加入名为 *vojay* 的 Twitch 频道。**是的，我曾经也是一位活跃的主播**。有趣的是：我在我的直播中教人们游戏开发和一般的软件开发。我还喜欢在直播中玩复古游戏
    🎮。但那是另一个话题，让我们专注于这个项目 😉。
- en: You should also notice, that there is no authentication in the example above.
    As said before, since we only want to read the chat, no authentication is needed.
    In fact, we simply join an IRC chat anonymously and read the messages.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意到，在上面的示例中没有进行身份验证。正如前面所说，由于我们只想读取聊天，因此不需要身份验证。实际上，我们只是匿名加入 IRC 聊天并读取消息。
- en: Since we want to establish the connection to the Twitch chat only once per source
    instance, we have to extend the abstract `RichSourceFunction` class, in order
    to be able to override the `open` function, which allows to add code for initialization.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望每个源实例只与 Twitch 聊天建立一次连接，因此我们必须扩展抽象类 `RichSourceFunction`，以便能够重写 `open`
    函数，允许在此处添加初始化代码。
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We also use our `TwitchMessage` POJO for the generic parameter to tell Flink
    that this source generates elements of type `TwitchMessage`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `TwitchMessage` POJO 作为通用参数，告诉 Flink 这个源会生成 `TwitchMessage` 类型的元素。
- en: Furthermore, want to be able to pass an array of Twitch channels we want to
    listen on in the constructor of the source function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望能够在源函数的构造函数中传递一个我们想要监听的 Twitch 频道数组。
- en: To control the state of our source function, we use a `boolean` variable called
    `running`, which we set to `true` in the `open` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制我们源函数的状态，我们使用一个名为 `running` 的 `boolean` 变量，并在 `open` 函数中将其设置为 `true`。
- en: 'Based on this, the constructor and `open` function look like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，构造函数和 `open` 函数看起来如下：
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With that, we have all we need to consume messages and emit them for further
    processing as a stream of data.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就拥有了所需的一切，可以消费消息并将其作为数据流进行进一步处理。
- en: The `run` function of a source function is where the magic happens. Here we
    generate the data and with a given `SourceContext`, we can emit data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 源函数的 `run` 函数是魔法发生的地方。在这里，我们生成数据，并通过给定的 `SourceContext`，我们可以发射数据。
- en: The `SimpleEventHandler` provided by Twitch4J can be used to react on specific
    messages.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Twitch4J 提供的 `SimpleEventHandler` 可以用来响应特定的消息。
- en: Whenever we get an event of type `IRCMessageEvent`, which is a message in the
    Twitch chat, we generate an instance of our POJO and emit it to the stream via
    the context.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们接收到 `IRCMessageEvent` 类型的事件，也就是一条 Twitch 聊天消息时，我们就会生成我们的 POJO 实例，并通过上下文将其发射到流中。
- en: To ensure our source function does not terminate, we will add a loop with an
    artificial delay, which will run until our `boolean` variable `running` is set
    to `false`. This will be done in the `cancel` function, which is called by the
    Flink environment on shutdown.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的源函数不会终止，我们将添加一个带有人工延迟的循环，直到我们的 `boolean` 变量 `running` 被设置为 `false`。这将在
    `cancel` 函数中完成，该函数在 Flink 环境关闭时被调用。
- en: '[PRE14]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Putting it all together, this is the full implementation of our custom Twitch
    source function for Flink `TwitchSource.java`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起，这是我们自定义的 Twitch 源函数在 Flink 中的完整实现 `TwitchSource.java`：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Use source function
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用源函数
- en: 'With this custom source function, we can already extend our streaming pipeline
    in `App.java` to simply print each chat message written to the chat:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个自定义源函数，我们已经可以扩展 `App.java` 中的流处理管道，简单地打印每条写入聊天的消息：
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With `addSource` we can add our source function. The elements are then processed
    by the next step in the stream, which is `print()`. With this sink, we will again
    output each element to STDOUT.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `addSource` 我们可以添加我们的源函数。元素随后将由流中的下一个步骤进行处理，该步骤是 `print()`。通过这个接收器，我们将再次将每个元素输出到
    STDOUT。
- en: When running the application now and writing to the chat at [https://twitch.tv/vojay](https://www.twitch.tv/popout/vojay/chat),
    the messages will be processed and printed by our streaming application 🎉.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序并在[https://twitch.tv/vojay](https://www.twitch.tv/popout/vojay/chat)的聊天室中发送消息时，这些消息将由我们的流媒体应用程序处理并打印出来🎉。
- en: '![](../Images/a308cbba3475c4b7ba1ab2b77ef0178c.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a308cbba3475c4b7ba1ab2b77ef0178c.png)'
- en: Twitch source for Flink (by author)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Flink 的 Twitch 源（作者提供）
- en: Twitch chat sentiment analysis
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitch 聊天情感分析
- en: 'Now that we can read the Twitch chat as a stream of data, it is time to process
    each message. The basic idea is: for each Twitch message, we detect the individual
    sentences of the message and calculate the sentiment for each of the sentences.
    The output will be a structure like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将 Twitch 聊天作为数据流读取，是时候处理每条消息了。基本思路是：对于每条 Twitch 消息，我们检测消息中的各个句子，并计算每个句子的情感。输出将是像这样的结构：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s break it down: the result contains the original POJO of the Twitch chat
    message together with another tuple with 2 elements:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下：结果包含 Twitch 聊天消息的原始 POJO，以及另一个包含 2 个元素的元组：
- en: A list of **sentiment scores** (`List<Integer>`) containing the score for each
    sentence in the message, from 0 (very negative) to 4 (very positive) and
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**情感分数列表**（`List<Integer>`），包含消息中每个句子的分数，范围从0（非常负面）到4（非常积极）。
- en: 'a list of **sentiment classes** (`List<String>`) containing the readable class
    for each sentence in the message, for example: Neutral or Negative.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**情感类别列表**（`List<String>`），包含消息中每个句子的可读类别，例如：中性或负面。
- en: '![](../Images/370607a498f8c196cf9fb7a621cec6e0.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/370607a498f8c196cf9fb7a621cec6e0.png)'
- en: Sentiment map function (by author)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 情感映射函数（作者提供）
- en: Add Stanford CoreNLP dependencies
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Stanford CoreNLP依赖项
- en: To perform the sentiment analysis, we will use the [CoreNLP library](https://stanfordnlp.github.io/CoreNLP/)
    by the [Stanford NLP Group](https://nlp.stanford.edu/). There are alternatives
    like [Apache OpenNLP](https://opennlp.apache.org/) or the [Deep Java Library](https://djl.ai/).
    In this project, we will focus on CoreNLP but feel free to create alternative
    versions using one of the other libraries, which can be a great way to learn more
    about it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行情感分析，我们将使用[CoreNLP库](https://stanfordnlp.github.io/CoreNLP/)由[斯坦福NLP组](https://nlp.stanford.edu/)提供。也有像[Apache
    OpenNLP](https://opennlp.apache.org/)或[Deep Java Library](https://djl.ai/)这样的替代方案。在这个项目中，我们将专注于CoreNLP，但也可以随意使用其他库创建替代版本，这也是学习更多相关内容的好方法。
- en: CoreNLP is a comprehensive tool for NLP in Java, supporting multiple languages
    including Arabic, Chinese, English, French, German, Hungarian, Italian, and Spanish.
    It processes text to provide linguistic annotations such as sentence boundaries,
    parts of speech, named entities, and more through a **pipeline system** that generates
    **CoreDocuments**. These documents hold all annotation information, which can
    be accessed easily or exported.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: CoreNLP是一个全面的Java NLP工具，支持多种语言，包括阿拉伯语、中文、英语、法语、德语、匈牙利语、意大利语和西班牙语。它通过一个**管道系统**处理文本，提供语言学标注，如句子边界、词性、命名实体等，并生成**CoreDocuments**。这些文档包含所有的标注信息，可以轻松访问或导出。
- en: In the context of CoreNLP, a **pipeline** is essentially a sequence of processing
    steps designed to analyze text. When you input raw text into CoreNLP, the pipeline
    passes the text through various **annotators** (*processing units*), each responsible
    for a different aspect of NLP. These annotators might identify sentence boundaries,
    recognize parts of speech, detect named entities, parse sentence structures, and
    more, depending on the specific tasks you want to perform.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在CoreNLP的上下文中，**管道**本质上是一系列用于分析文本的处理步骤。当你将原始文本输入到CoreNLP时，管道会将文本通过不同的**标注器**（*处理单元*）传递，每个标注器负责NLP的不同方面。这些标注器可能会识别句子边界、识别词性、检测命名实体、解析句子结构等，具体取决于你想要执行的任务。
- en: 'In our case, we will use the **sentences annotation** to split the Twitch message
    into sentences and then use the **sentiment core annotations** on each sentence
    to get the sentiment of it. But first, we need to add the required dependencies
    to the `pom.xml` of our project:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用**句子标注**将Twitch消息拆分成句子，然后对每个句子使用**情感核心标注**以获取其情感。但首先，我们需要将所需的依赖项添加到我们项目的`pom.xml`中：
- en: '[PRE18]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first dependency represents the library itself while the second dependency
    will fetch all the related pre-trained models into your local `.m2` folder. Don’t
    be surprised, the first time Maven resolves the dependencies will take a while
    due to the download of the models.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个依赖项代表库本身，而第二个依赖项将把所有相关的预训练模型拉取到你的本地`.m2`文件夹中。不要惊讶，第一次Maven解析依赖项时需要一些时间，因为它需要下载模型。
- en: Create sentiment analysis map function
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建情感分析映射函数
- en: For the map function, we will use the abstract class `RichMapFunction` as a
    basis, so that we can again override the `open` function in order to initialize
    the pipeline for sentiment analysis only once per instance. When extending the
    `RichMapFunction`, we need to specify to generics, one for the type of input and
    another one for the type of output. The input will be one Twitch message POJO,
    so `TwitchMessage` and the output will be the message again together with its
    sentiment in form of a list of scores and another list of classes, as described
    before.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于map函数，我们将使用抽象类`RichMapFunction`作为基础，以便我们可以重写`open`函数，只在每个实例中初始化一次情感分析管道。在扩展`RichMapFunction`时，我们需要指定两个泛型，一个用于输入类型，另一个用于输出类型。输入将是一个Twitch消息的POJO，即`TwitchMessage`，输出将是包含情感分数列表和类别列表的消息，正如之前所述。
- en: 'Let’s start by creating a new class called `AnalyzeSentiment` and extend the
    `RichMapFunction`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个名为 `AnalyzeSentiment` 的新类，并扩展 `RichMapFunction`：
- en: '[PRE19]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When initializing the Stanford CoreNLP pipeline, we have to specify the types
    of annotators we want to use in our pipeline, so that the library only loads the
    required models. This can be achieved via a `Properties` object, passed to the
    constructor of `StanfordCoreNLP`. This is how we initialize the pipeline for our
    use-case:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 Stanford CoreNLP 管道时，我们必须指定要在管道中使用的标注器类型，以便库仅加载所需的模型。这可以通过传递给 `StanfordCoreNLP`
    构造函数的 `Properties` 对象来实现。以下是我们为这个用例初始化管道的方式：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To make our map operator more readable, we extract the core logic to get the
    sentiment to a dedicated function. We start by processing the message with the
    pipeline:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 map 操作符更具可读性，我们将获取情感的核心逻辑提取到一个专用函数中。我们从通过管道处理消息开始：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we process each individual sentence:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们处理每个单独的句子：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Get the score of the sentence and add it to a list of scores:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 获取句子的分数并将其添加到分数列表中：
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And get the class of the sentence and add it to a list of classes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 获取句子的类别并将其添加到类别列表中：
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With that, the full function to get the sentiment tuple with the scores and
    classes looks like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，获取情感元组（包括分数和类别）的完整函数看起来是这样的：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The map function itself simply calls this function and puts everything together
    into a tuple to emit it to the stream.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: map 函数本身只是调用这个函数，并将所有内容组合成一个元组，发送到流中。
- en: 'Putting everything together, this is the full implementation of our custom
    map function `AnalyzeSentiment.java`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 把所有内容放在一起，这是我们自定义 map 函数 `AnalyzeSentiment.java` 的完整实现：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Use map function
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 map 函数
- en: We now have all ingredients for our real-time sentiment analysis streaming application
    🚀. That means, we can switch back to our `App` class, where we define how the
    streaming application looks like.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了实时情感分析流应用所需的所有元素 🚀。这意味着我们可以切换回我们的 `App` 类，在这里定义流应用的具体样子。
- en: 'Here, we will also introduce another useful Apache Flink feature, which is
    the `ParameterTool`. A generic helper class allowing to parameterize your application
    in different ways. We will use it to add a program argument `--twitchChannels`
    that allows to pass a comma-separated list of Twitch channels we want to use in
    our `TwitchSource`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还将介绍 Apache Flink 的另一个有用特性，即 `ParameterTool`。这是一个通用的辅助类，允许以不同的方式对应用程序进行参数化。我们将使用它来添加程序参数
    `--twitchChannels`，允许传递一个逗号分隔的 Twitch 频道列表，我们希望在 `TwitchSource` 中使用这些频道：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also we will include our new map function in the pipeline:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在管道中包括我们新的 map 函数：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is how our `App` class looks in the end:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是最终我们的 `App` 类的样子：
- en: '[PRE29]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Before we run it again, we need to adjust our run configuration again by adding
    the new `--twitchChannels` parameter. As we marked it as **required**, the application
    would fail otherwise. Navigate to *Run* → *Edit Configurations…* and add:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们再次运行之前，我们需要通过添加新的 `--twitchChannels` 参数来调整我们的运行配置。如我们所标记的，**该参数是必需的**，否则应用程序将会失败。前往
    *Run* → *Edit Configurations…* 并添加：
- en: '`--twitchChannels vojay,valorant`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`--twitchChannels vojay,valorant`'
- en: as program arguments. **You can use any Twitch channel here, feel free to browse
    Twitch for bigger channels and see what happens.**
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序参数。**你可以在这里使用任何 Twitch 频道，随时浏览 Twitch 查看更大的频道并观察发生的情况。**
- en: '![](../Images/1af0e4eb58a9d5447c2310ac491f19a0.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1af0e4eb58a9d5447c2310ac491f19a0.png)'
- en: Run configuration with twitchChannels parameter (by author)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有 twitchChannels 参数的运行配置（作者）
- en: Now it is time to run your streaming application again and enjoy the show!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候再次运行你的流应用并享受整个过程了！
- en: '![](../Images/9fa3cbde399e5bc2d238f4b3919a2d84.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9fa3cbde399e5bc2d238f4b3919a2d84.png)'
- en: Photo by [Stanley Li](https://unsplash.com/@djravine?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 摄影：由 [Stanley Li](https://unsplash.com/@djravine?utm_source=medium&utm_medium=referral)
    拍摄，来源：[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Conclusion
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: And there you have it! We’ve built a real-time sentiment analysis application
    for Twitch chat using Apache Flink. Now you can not only see the chat flow by,
    but also understand the emotional pulse of the audience. This might be the boilerplate
    for a more advanced version. Track the sentiment throughout a stream, see how
    the viewers react to big plays or funny moments, and use that knowledge to create
    even more engaging content.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经构建了一个实时情感分析应用，适用于Twitch聊天，使用的是Apache Flink。现在你不仅可以看到聊天流，还能理解观众的情感脉动。这可能是更高级版本的基础。追踪整个直播过程中的情感，看看观众如何反应于重大操作或有趣时刻，并利用这些知识创造更具吸引力的内容。
- en: 'Some inspiration to turn this prototype into a valuable, production-ready project:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些灵感，帮助你将这个原型转化为一个有价值的、可投入生产的项目：
- en: ⚙️ **Adjust model**
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ⚙️ **调整模型**
- en: Use a model that is trained specifically on social media data (e.g., [RoBERTa](https://huggingface.co/cardiffnlp/twitter-roberta-base-sentiment))
    or even better, train a model directly with historical Twitch chat data to incorporate
    Twitch-specific communication aspects like specific emoji codes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专门针对社交媒体数据训练的模型（例如，[RoBERTa](https://huggingface.co/cardiffnlp/twitter-roberta-base-sentiment)），或者更好的方式是，直接用历史的Twitch聊天数据训练模型，来融入Twitch特有的交流元素，如特定的表情符号代码。
- en: 🧮 **Apply windowing**
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 🧮 **应用窗口函数**
- en: Extend the Flink pipeline with a window function, for example, a tumbling window
    per minute, and aggregate the sentiment score as an average per minute.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过窗口函数扩展Flink管道，例如每分钟的滚动窗口，并计算每分钟的情感分数平均值。
- en: 📦 **Persist results**
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 📦 **持久化结果**
- en: Persist the resulting stream with an aggregate per minute in Kafka or a Time
    Series Database (TSDB).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果流以每分钟聚合的形式持久化到Kafka或时间序列数据库（TSDB）中。
- en: 📊 **Create dashboard**
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 📊 **创建仪表盘**
- en: Create a dashboard on the aggregated data, visualizing the average sentiment
    per minute in a graph.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇总数据上创建一个仪表盘，绘制每分钟的平均情感图表。
- en: With these suggestions, you can combine the result with other metadata, like
    the actual category/game played of the stream or the time of the day, to create
    sophisticated recommendations about what content results in a positive Twitch
    chat experience.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些建议，你可以将结果与其他元数据结合起来，比如流媒体的实际分类/游戏类型或时间，以此来创建更复杂的推荐系统，帮助你了解哪些内容能带来积极的Twitch聊天体验。
- en: So, the next time you tune into your favorite streamer, keep an eye out for
    that sentiment analysis running in the background. It might just reveal some fascinating
    insights about the passionate world of the Twitch chat!
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所以下次当你观看你最喜欢的主播时，不妨留意一下后台运行的情感分析。它可能会揭示关于Twitch聊天这个充满激情的世界的一些有趣见解！
- en: 'But the most important thing about this article is: get inspired, learn and
    inspire others. The cool thing about Data Engineering and related fields:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但这篇文章最重要的一点是：获取灵感，学习并启发他人。数据工程及相关领域最酷的地方在于：
- en: '***data is everywhere***'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '***数据无处不在***'
- en: so there is always the next interesting question around the corner that can
    be used to learn and ideally share your inspiration with others.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总会有下一个有趣的问题等待你去探索，并可以用来学习，理想情况下将你的灵感与他人分享。
- en: '![](../Images/258f31d4a003728a74203f1bdb1d1f6f.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/258f31d4a003728a74203f1bdb1d1f6f.png)'
- en: Photo by [Alexander Sinn](https://unsplash.com/@swimstaralex?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由[Alexander Sinn](https://unsplash.com/@swimstaralex?utm_source=medium&utm_medium=referral)提供，来自[Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: Enjoy and let me know about your experiences in the comments ✌️.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 享受这个过程，并在评论中告诉我你的体验 ✌️。

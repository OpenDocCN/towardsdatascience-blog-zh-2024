["```py\nCustomer 1 (Young, Urban): Social → Video → Purchase\nCustomer 2 (Older, Rural): Print → Email → Purchase\n```", "```py\ndef beam_search_step(\n        model: JourneyLSTM, \n        X: torch.Tensor, \n        pos: int, \n        num_channels: int, \n        max_length: int, \n        constraints:dict[int, int], \n        beam_width: int = 3\n    ):\n    if pos > max_length:\n        return X\n\n    if pos in constraints:\n        return beam_search_step(model, X, pos + 1, num_channels, max_length, constraints, beam_width)\n\n    candidates = []  # List to store (sequence, score) tuples\n\n    for sequence_idx in range(min(beam_width, len(X))):\n        X_current = X[sequence_idx:sequence_idx+1].clone()\n\n        # Try each possible channel\n        for channel in range(num_channels):\n            X_candidate = X_current.clone()\n            X_candidate[0, extra_dim + pos] = channel\n\n            # Get prediction score\n            pred = model(X_candidate)[0].item()\n            candidates.append((X_candidate, pred))\n\n    candidates.sort(key=lambda x: x[1], reverse=True)\n    best_candidates = candidates[:beam_width]\n\n    X_next = torch.cat([cand[0] for cand in best_candidates], dim=0)\n\n    # Recurse with best candidates\n    return beam_search_step(model, X_next, pos + 1, num_channels, max_length, constraints, beam_width)\n```"]
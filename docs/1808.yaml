- en: 'Applied Python Chronicles: A Gentle Intro to Pydantic'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/applied-python-chronicles-a-gentle-intro-to-pydantic-a630f797e933?source=collection_archive---------2-----------------------#2024-07-25](https://towardsdatascience.com/applied-python-chronicles-a-gentle-intro-to-pydantic-a630f797e933?source=collection_archive---------2-----------------------#2024-07-25)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whether you are a Data Engineer, Machine Learning Engineer or Web developer,
    you ought to get used to this tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@ilija.lazarevic?source=post_page---byline--a630f797e933--------------------------------)[![Ilija
    Lazarevic](../Images/4a0d84af6d8fa97705ee35444d319b07.png)](https://medium.com/@ilija.lazarevic?source=post_page---byline--a630f797e933--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--a630f797e933--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--a630f797e933--------------------------------)
    [Ilija Lazarevic](https://medium.com/@ilija.lazarevic?source=post_page---byline--a630f797e933--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--a630f797e933--------------------------------)
    ·11 min read·Jul 25, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/63778e7e341a0790bc2b994ab5b0ebc3.png)'
  prefs: []
  type: TYPE_IMG
- en: How the antic sun shines upon PydAntic users. Image by [Vladimir Timofeev](https://www.istockphoto.com/photo/sunset-above-acropolis-of-lindos-doric-columns-the-ancient-temple-athena-lindia-the-gm1009651096-272195895?clarity=false)
    under license to Ilija Lazarevic.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few use cases where Pydantic fits almost seamlessly. Data
    processing, among others, benefits from using Pydantic as well. However, it can
    be used in web development for parsing and structuring data in expected formats.
  prefs: []
  type: TYPE_NORMAL
- en: Today’s idea is to define a couple of pain points and show how Pydantic can
    be used. Let’s start with the most familiar use case, and that is data parsing
    and processing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we have a CSV file with a dozen columns and thousands of rows. The
    usual scenario in data analysis is to load this CSV into Pandas DataFrame and
    start fiddling with it. Often you start inspecting the data and types of columns,
    drop some of them, and create new ones. This process is based on your previous
    knowledge of what is in the dataset. Yet, this is not always transparent to the
    others. They either have to go and open a CSV file (or any other source of data)
    or skim through the code to figure out what columns are being used and created.
    This is all good for the initial steps of data analysis and research. However,
    once the data set is analyzed and we are ready to go into creating a data pipeline
    that will load, transform, and use data for analytics or machine learning purposes,
    we need a standardized way of making sure datasets and data types are in expected
    format. This is why we want a library that will give us the ability to declare
    or define this. There are few libraries for this, most of them are open source
    as well, but Pydantic, being open source as well, found its way into different
    frameworks and is universally accepted in different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s start.
  prefs: []
  type: TYPE_NORMAL
- en: Python — Type hinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the example I have previously mentioned, I’d like to start
    with some basics in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Through its versions, Python introduced type hinting. What is type hinting,
    and why do we need it? Well, as we all know, Python is a dynamically typed scripting
    language. This means that data types are inferred in runtime. This has its benefits
    in engineers being able to write code faster. The bad part is that you will not
    be alarmed about type mismatches until you run your code. At that time, it may
    be a bit late to fix your error quickly. Because Python still remains a dynamically
    typed language, there was an intent to bridge this gap by introducing so-called
    “type hinting” that engineers can use to notify both readers and IDEs about expected
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a short example of how a defined function may be used in multiple use
    cases, some of which were not envisioned by its writer. For someone persistent
    enough, you will have to introduce many hoops so you can be assured your code
    is used in the intended way.
  prefs: []
  type: TYPE_NORMAL
- en: How does type hinting look?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This one works as well! Why? Well, this is still called “type hinting,” not
    “type enforcing”. As already mentioned, it is used as a way to “notify” readers
    and “users” about the intended way of use. One of the code “users” are IDEs, and
    your IDE of choice should be able to figure out and raise alerts in case you try
    to bypass the data type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Why did we go to describe something like this? Well, it is because Pydantic
    is built on top of this type of hinting. It uses type hinting to define data types
    and structures and validate them as well.
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic — First steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I already mentioned, Pydantic is used to validate data structures and data
    types. There are four ways in which you can use it. Today I will go through the
    two most important:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate_call` to validate function calls based on type hinting and annotations,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseModel` to define and validate models through class definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pydantic — validate_call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, there is no better way to start with something new than to immerse yourself
    right away. This is how we shall start learning Pydantic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you are able to use it, you have to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of clarity, let me note both Python and pydantic versions here
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you want to create a new Python project, create your first Python script,
    import Pydantic, and start using it. The first example will be to revise our previous
    function and use Pydantic to make sure it is used in the intended way. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of things to clarify:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate_call` is used as a decorator. This is basically a wrapper around
    the function declared that introduces additional logic that can be run at the
    time the function is defined as well as when you call the function. Here, it is
    used to make sure the data you pass to the function call conforms to the expected
    data types (hints).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A validated function call raises `ValidationError` in a case you start using
    your function in an unintended way. This error is verbose and says a lot about
    why it was raised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By principle of charity, Pydantic tries to figure out what you meant and tries
    to use type coercion. This can result in string values passed to a function call
    being implicitly converted to the expected type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type coercion is not always possible, and in that case, `ValidationError` is
    raised.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don’t know what Python *decorator* function is? Read one of my previous articles
    on this subject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[](/advanced-python-functions-3be6810f92d1?source=post_page-----a630f797e933--------------------------------)
    [## Advanced Python: Functions'
  prefs: []
  type: TYPE_NORMAL
- en: After reading the title, you probably ask yourself something along the lines
    of, “Functions in Python are an advanced…
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/advanced-python-functions-3be6810f92d1?source=post_page-----a630f797e933--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: What about default values and argument extractions?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Takeaways from this example:'
  prefs: []
  type: TYPE_NORMAL
- en: You can annotate the type of the variable number of arguments declaration (*args).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default values are still an option, even if you are annotating variable data
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate_call` accepts `validate_return` argument, which makes function return
    value validation as well. Data type coercion is also applied in this case. `validate_return`
    is set to `False` by default. If it is left as it is, the function may not return
    what is declared in type hinting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What about if you want to validate the data type but also constrain the values
    that variable can take? Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `Annotated` and `pydantic.Field` to not only validate data type
    but also add metadata that Pydantic uses to constrain variable values and formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ValidationError` is yet again very verbose about what was wrong with our function
    call. This can be really helpful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is one more example of how you can both validate and constrain variable
    values. We will simulate a payload (dictionary) that you want to process in your
    function after it has been validated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This was the basics of how to validate function arguments and their return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will go to the second most important way Pydantic can be used to validate
    and process data: through defining models.'
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic — BaseModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part is more interesting for the purposes of data processing, as you will
    see.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used `validate_call` to decorate functions and specified function
    arguments and their corresponding types and constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we define models by defining model classes, where we specify fields, their
    types, and constraints. This is very similar to what we did previously. By defining
    a model class that inherits from Pydantic `BaseModel`, we use a hidden mechanism
    that does the data validation, parsing, and serialization. What this gives us
    is the ability to create objects that conform to model specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use annotation here as well, and you can also specify default values
    for fields. Let’s see another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Things get very interesting when your use case gets a bit complex. Remember
    the `payload` that we defined? I will define another, more complex structure that
    we will go through and validate. To make it more interesting, let’s create a payload
    that we will use to query a service that acts as an intermediary between us and
    LLM providers. Then we will validate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the important insights from this elaborated example are:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use Enums or `Literal` to define a list of specific values that are
    expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case you want to name a model’s field differently from the field name in
    the validated data, you can use `validation_alias`. It specifies the field name
    in the data being validated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`serialization_alias` is used when the model''s internal field name is not
    necessarily the same name you want to use when you serialize the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field can be excluded from serialization with `exclude=True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model fields can be Pydantic models as well. The process of validation in that
    case is done recursively. This part is really awesome, since Pydantic does the
    job of going into depth while validating nested structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields that are not taken into account in the model definition are not parsed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pydantic — Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here I will show you the snippets of code that show where and how you can use
    Pydantic in your day-to-day tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Data processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say you have data you need to validate and process. It can be stored in CSV,
    Parquet files, or, for example, in a NoSQL database in the form of a document.
    Let’s take the example of a CSV file, and let’s say you want to process its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the CSV file (`test.csv`) example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is how it is validated and parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: FastAPI request validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FastAPI is already integrated with Pydantic, so this one is going to be very
    brief. The way FastAPI handles requests is by passing them to a function that
    handles the route. By passing this request to a function, validation is performed
    automatically. Something similar to validate_call that we mentioned at the beginning
    of this article.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of `app.py` that is used to run FastAPI-based service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pydantic is a really powerful library and has a lot of mechanisms for a multitude
    of different use cases and edge cases as well. Today, I explained the most basic
    parts of how you should use it, and I’ll provide references below for those who
    are not faint-hearted.
  prefs: []
  type: TYPE_NORMAL
- en: Go and explore. I’m sure it will serve you well on different fronts.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Python type hinting](https://docs.python.org/3/library/typing.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pydantic models](https://docs.pydantic.dev/latest/concepts/models/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Validate call decorator](https://docs.pydantic.dev/latest/concepts/validation_decorator/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pydantic fields](https://docs.pydantic.dev/latest/concepts/fields/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pydantic validators](https://docs.pydantic.dev/latest/concepts/validators/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

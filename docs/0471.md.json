["```py\n# will only time the first line\n%time print(\"hello\")\nprint(\"world\")\n```", "```py\n# will time the entire cell\n%%timeit\nprint(\"hello\")\nprint(\"world\")\n```", "```py\n%%cell_to_module -m my_module --display --rebuild-drivers\n\ndef my_func(some_input: str) -> str:\n  \"\"\"Some logic\"\"\"\n  return ...\n```", "```py\n# my_magic.py\n\nfrom IPython.core import magic\nfrom IPython.core.magic_arguments import argument, magic_arguments, parse_argstring\n@magic.magics_class\nclass MyMagic(magic.Magics):\n   \"\"\"Custom class you write\"\"\"\n   @magic_arguments() # needs to be on top to enable parsing\n   @argument(...)   \n   @magic.cell_magic\n   def a_cell_magic_command(self, line, cell):\n      ...\n   @magic_arguments() # needs to be on top to enable parsing\n   @argument(...)   \n   @magic.line_magic\n   def a_line_magic_command(self, line):\n     ...\n```", "```py\nfrom IPython.core import magic\nfrom IPython.core.magic_arguments import argument, magic_arguments, parse_argstring\n\n@magic.magics_class\nclass HamiltonMagics(magic.Magics):\n    \"\"\"Magics to facilitate Hamilton development in Jupyter notebooks\"\"\"\n  @magic_arguments()  # needed on top to enable parsing\n  @arguments(...)\n  @magics.cell_magic\n  def cell_to_module(self, line, cell):\n    ...\n```", "```py\n@magic_arguments() # needs to be on top to enable parsing\n# flag, long form, default value, help string.\n@argument(\"-a\", \"--argument\", default=\"some_value\", help=\"Some optional line argument\")   \n@magic.cell_magic\ndef a_cell_magic_command(self, line, cell):\n   args = parse_argstring(self.a_cell_magic_command, line)\n   if args.argument:\n      # do stuff -- place your utility functions here\n```", "```py\n@magic_arguments()  # needed on top to enable parsing\n@argument(\n    \"-m\", \"--module_name\", help=\"Module name to provide. Default is jupyter_module.\"\n)  # keyword / optional arg\n@argument(\n    \"-c\", \"--config\", help=\"JSON config, or variable name containing config to use.\"\n)  # keyword / optional arg\n@argument(\n    \"-r\", \"--rebuild-drivers\", action=\"store_true\", help=\"Flag to rebuild drivers\"\n)  # Flag / optional arg\n@argument(\n    \"-d\", \"--display\", action=\"store_true\", help=\"Flag to visualize dataflow.\"\n)  # Flag / optional arg\n@argument(\n    \"-v\", \"--verbosity\", type=int, default=1, help=\"0 to hide. 1 is normal, default\"\n)  # keyword / optional arg\n@magics.cell_magic\ndef cell_to_module(self, line, cell):\n    \"\"\"Execute the cell and dynamically create a Python module from its content.\n\n     A Hamilton Driver is automatically instantiated with that module for variable `{MODULE_NAME}_dr`.\n        > %%cell_to_module -m MODULE_NAME --display --rebuild-drivers\n    Type in ?%%cell_to_module to see the arugments to this magic.\n    \"\"\"\n    # specify how to parse by passing \n    args = parse_argstring(self.cell_to_module, line)  \n    # now use args for logic ...\n```", "```py\n# we're in the bowels of def cell_to_module(self, line, cell):\n# and we remove an indentation for readability\n...\n# specify how to parse by passing this method to the function \nargs = parse_argstring(self.cell_to_module, line)\n# we set a default value, else use the passed in value \n# for the module name.\nif args.module_name is None:\n    module_name = \"jupyter_module\"\nelse:\n    module_name = args.module_name\n# we determine whether the configuration is a variable\n# in the notebook environment\n# or if it's a JSON string that needs to be parsed.\ndisplay_config = {}\nif args.config:\n    if args.config in self.shell.user_ns:\n        display_config = self.shell.user_ns[args.config]\nelse:\n    if args.config.startswith(\"'\") or args.config.startswith('\"'):\n        # strip quotes if present\n        args.config = args.config[1:-1]\n    try:\n        display_config = json.loads(args.config)\n    except json.JSONDecodeError:\n        print(\"Failed to parse config as JSON. \"\n              \"Please ensure it's a valid JSON string:\")\n        print(args.config)\n# we create the python module (using a custom function)\nmodule_object = create_module(cell, module_name)\n# shell.push() assign a variable in the notebook. \n# The dictionary keys are the variable name\nself.shell.push({module_name: module_object})\n# Note: self.shell.user_ns is a dict of all variables in the notebook\n# -- we pass that down via self.shell.\nif args.rebuild_drivers:\n    # rebuild drivers that use this module (custom function)\n    rebuilt_drivers = rebuild_drivers(\n        self.shell, module_name, module_object, \n        verbosity=args.verbosity\n    )\n    self.shell.user_ns.update(rebuilt_drivers)\n# create a driver to display things for every cell with %%cell_to_module\ndr = (\n    driver.Builder()\n    .with_modules(module_object)\n    .with_config(display_config)\n    .build()\n)\nself.shell.push({f\"{module_name}_dr\": dr})\nif args.display:\n    # return will go to the output cell. \n    # To display multiple elements, use IPython.display.display(\n    # print(\"hello\"), dr.display_all_functions(), ... )\n    return dr.display_all_functions()\n```", "```py\ndef load_ipython_extension(ipython: InteractiveShell):\n  \"\"\"\n  Any module file that define a function named `load_ipython_extension`\n  can be loaded via `%load_ext module.path` or be configured to be\n  autoloaded by IPython at startup time.\n  \"\"\"\n  ipython.register_magics(MyMagic)\n  ipython.register_magics(HamiltonMagics)\n```"]
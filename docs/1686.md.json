["```py\n## 1.1 Load libraries\n\n# If you need to install any library, run below:\n# pip install library1 library2 library3 ...\n\n# Basic Libraries\nimport os  # For file operations\nimport gc  # For garbage collection, it avoids RAM memory issues\nimport numpy as np  # For dealing with matrices\nimport pandas as pd  # For dealing with dataframes\nimport janitor  # For data cleaning (mainly column names)\nimport numexpr  # For fast pd.query() manipulation\nimport inflection  # For string manipulation\nimport unidecode  # For string manipulation\n\n# Geospatial Libraries\nimport geopandas as gpd  # For dealing with shapefiles\nimport pyogrio  # For fast .gpkg file manipulation\nimport ee  # For Google Earth Engine API\nimport contextily as ctx  # For basemaps\nimport folium  # For interactive maps\n\n# Shapely Objects and Geometry Manipulation\nfrom shapely.geometry import mapping, Polygon, Point, MultiPolygon, LineString  # For geometry manipulation\n\n# Raster Data Manipulation and Visualization\nimport rasterio  # For raster manipulation\nfrom rasterio.mask import mask  # For raster data manipulation\nfrom rasterio.plot import show  # For raster data visualization\n\n# Plotting and Visualization\nimport matplotlib.pyplot as plt  # For plotting and data visualization\nfrom matplotlib.colors import ListedColormap, Normalize  # For color manipulation\nimport matplotlib.colors as colors  # For color manipulation\nimport matplotlib.patches as mpatches  # For creating patch objects\nimport matplotlib.cm as cm  # For colormaps\n\n# Data Storage and Manipulation\nimport pyarrow  # For efficient data storage and manipulation\n\n# Video Making\nfrom moviepy.editor import ImageSequenceClip # For creating videos (section 4.7 only) - check this if you have issues: https://github.com/kkroening/ffmpeg-python\n```", "```py\n# 1.2 Set working directory \nproject_path = 'path_to_your_project_folder' # Where you will save all outcomes and resources must be in\nos.chdir(project_path) # All resources on the project are relative to this path\n\n# 1.3 Further settings\npd.set_option('compute.use_numexpr', True) # Use numexpr for fast pd.query() manipulation\n```", "```py\n## 1.4 Set function to plot geometries over an OSM \ndef plot_geometries_on_osm(geometries, zoom_start=10):\n\n    # Calculate the centroid of all geometries to center the map\n    centroids = [geometry.centroid for geometry in geometries]\n    avg_x = sum(centroid.x for centroid in centroids) / len(centroids)\n    avg_y = sum(centroid.y for centroid in centroids) / len(centroids)\n\n    # Create a folium map centered around the average centroid\n    map = folium.Map(location=[avg_y, avg_x], zoom_start=zoom_start)\n\n    # Add each geometry to the map\n    for geometry in geometries:\n        geojson = mapping(geometry) # Convert the geometry to GeoJSON\n        folium.GeoJson(geojson).add_to(map)\n\n    return map\n```", "```py\n## 2.1 Get the geometry of the area of interest (Acrelândia, AC)\nbrazilian_municipalities = gpd.read_file('municipios/file.shp', engine='pyogrio', use_arrow=True) # Read the shapefile - you can use any other shapefile here. Shapefiles must be in your project folder, as set in 1.2\nbrazilian_municipalities = brazilian_municipalities.clean_names() # Clean the column names (remove special characters, spaces, etc.)\nbrazilian_municipalities.crs = 'EPSG:4326' # Set the CRS to WGS84 (MapBiomas uses this CRS)\nbrazilian_municipalities\n```", "```py\n## 2.2 Get geometry for Acrelândia, AC\ncity = brazilian_municipalities.query('nm_mun == \"Acrelândia\"') # Filter the geometry for Acrelândia, AC (can be any other city or set of cities)\ncity_geom = city.geometry.iloc[0] # Get the geometry of Acrelândia, AC\ncity_geom # See the geometry shape\n```", "```py\n## 2.3 Set the bounding box (bbox) for the area of interest\nbbox = city_geom.bounds # Get the bounding box of the geometry\nbbox = Polygon([(bbox[0], bbox[1]), (bbox[0], bbox[3]), (bbox[2], bbox[3]), (bbox[2], bbox[1])]) # Convert the bounding box to a Polygon\n\nbbox_xmin = bbox.bounds[0] # Get the minimum x coordinate of the bounding box\nbbox_ymin = bbox.bounds[1] # Get the minimum y coordinate of the bounding box\nbbox_xmax = bbox.bounds[2] # Get the maximum x coordinate of the bounding box\nbbox_ymax = bbox.bounds[3] # Get the maximum y coordinate of the bounding box\n\nbbox # See bbox around Acrelândia shape\n```", "```py\n# Plot the bounding box and the geometry of Acrelandia over an OSM map\nplot_geometries_on_osm([bbox, city_geom], zoom_start=10) \n```", "```py\n## 2.4 Acess MapBiomas Collection 8.0 using GEE API\n# import ee - already imported at 1.1\n\nee.Authenticate() # Only for the first time \nee.Initialize() # Run it every time you start a new session\n\n# Define the MapBiomas Collection 8.0 asset ID - retrieved from https://brasil.mapbiomas.org/en/colecoes-mapbiomas/\nmapbiomas_asset = 'projects/mapbiomas-workspace/public/collection8/mapbiomas_collection80_integration_v1'\n\nasset_properties = ee.data.getAsset(mapbiomas_asset) # Check the asset's properties\nasset_properties # See properties\n```", "```py\n## 2.5 Filter the collection for 2022 and crop the collection to a bbox around Acrelândia, AC\nyear = 2022\nband_id = f'classification_{year}' # bands (or yearly rasters) are named as classification_1985, classification_1986, ..., classification_2022\n\nmapbiomas_image = ee.Image(mapbiomas_asset) # Get the images of MapBiomas Collection 8.0 \nmapbiomas2022 = mapbiomas_image.select(band_id) # Select the image for 2022\n\nroi = ee.Geometry.Rectangle([bbox_xmin, bbox_ymin, bbox_xmax, bbox_ymax]) # Set the Region of Interest (ROI) to the bbox around Acrelândia, AC - set in 2.3\nimage_roi = mapbiomas2022.clip(roi) # Crop the image to the ROI\n```", "```py\n## 2.6 Export it to your Google Drive (ensure you have space there and that it is properly set up)\n\n# Obs 1: Recall you need to authenticate the session, as it was done on 2.4\n# Obs 2: Ensure you have enough space on Google Drive. Free version only gives 15 Gb of storage.\n\nexport_task = ee.batch.Export.image.toDrive(\n    image=image_roi, # Image to export to Google Drive as a GeoTIFF \n    description='clipped_mapbiomas_collection8_acrelandia_ac_2022', # Task description\n    folder='tutorial_mapbiomas_gee', # Change this to the folder in your Google Drive where you want to save the file\n    fileNamePrefix='acrelandia_ac_2022', # File name (change it if you want to)\n    region=roi.getInfo()['coordinates'], # Region to export the image\n    scale=30,\n    fileFormat='GeoTIFF'\n)\n\n# Start the export task\nexport_task.start()\n```", "```py\n## 3.1 Plot the orginal raster over a OSM \nfile_path = 'path_of_exported_file_at_google_drive.tif' # Change this to the path of the exported file\n\n# Plot data\nwith rasterio.open(file_path) as src:\n    data = src.read(1)\n    print(src.meta)\n    print(src.crs)\n    show(data)\n```", "```py\n## 3.2 See unique values \nunique_values = np.unique(data)\nunique_values # Returns unique pixels values in the raster\n\n# 0 = no data, parts of the image outside Brazil\n```", "```py\n## 3.3 See the frequency of each class (except 0 - no data)\nunique_values, counts = np.unique(data[data != 0], return_counts=True) # Get the unique values and their counts (except zero)\npixel_counts = pd.DataFrame({'value': unique_values, 'count': counts})\npixel_counts['share'] = (pixel_counts['count'] / pixel_counts['count'].sum())*100\npixel_counts \n```", "```py\n## 3.4 See the actual raster (a matrix in which each element represents a pixel value - land use code in this case)\ndata \n```", "```py\nmapbiomas_categories = {\n    # Forest (= 3)\n    1:3, 3:3, 4:3, 5:3, 6:3, 49:3, # That is, values 1, 3, 4, 5, 6, and 49 will be reassigned to 3 (Forest)\n    # Other Non-Forest Natural Vegetation (= 10)\n    10:10, 11:10, 12:10, 32:10, 29:10, 50:10, 13:10, # That is, values 10, 11, 12, 32, 29, 50, and 13 will be reassigned to 10 (Other Non-Forest Natural Vegetation)\n    # Pasture (= 15)\n    15:15, \n    # Agriculture (= 18)\n    18:18, 19:18, 39:18, 20:18, 40:18, 62:18, 41:18, 36:18, 46:18, 47:18, 35:18, 48:18, 21:18, 14:18, 9:18, # That is, values 18, 19, 39, 20, 40, 62, 41, 36, 46, 47, 35, 48, 21, 14, and 9 will be reassigned to 18 (Agriculture)\n    # Water ( = 26)\n    26:26, 33:26, 31:26, # That is, values 26, 33, and 31 will be reassigned to 26 (Water)\n    # Other (= 22)\n    22:22, 23:22, 24:22, 30:22, 25:22, 27:22, # That is, values 22, 23, 24, 30, 25, and 27 will be reassigned to 22 (Other)\n    # No data (= 255)\n    0:255 # That is, values 0 will be reassigned to 255 (No data)\n}\n```", "```py\n## 3.5 Reassing pixels values to the MapBiomas custom general categories and crop it to Acrelandia, AC limits\noriginal_raster_path = 'path_to_your_google_drive/tutorial_mapbiomas_gee/acrelandia_ac_2022.tif' \nreassigned_raster_path = 'path_to_reassigned_raster_at_project_folder' # Somewhere in the project folder set at 1.2\n\nwith rasterio.open(original_raster_path) as src:\n    raster_array = src.read(1)\n    out_meta = src.meta.copy() # Get metadata from the original raster\n\n    # 3.5.1\\. Crop (or mask) the raster to the geometry of city_geom (in this case, Acrelandia, AC) and thus remove pixels outside the city limits (will be assigned to no data = 255)\n    out_image, out_transform = rasterio.mask.mask(src, [city_geom], crop=True) \n    out_meta.update({\n        \"height\": out_image.shape[1],\n        \"width\": out_image.shape[2],\n        \"transform\": out_transform\n    }) # Update metadata to the new raster\n    raster_array = out_image[0] # Get the masked raster\n\n    modified_raster = np.zeros_like(raster_array) # Base raster full of zeros to be modified\n\n    # 3.5.2\\. Reassign each pixel based on the mapbiomas_categories dictionary\n    for original_value, new_value in mapbiomas_categories.items():\n        mask = (raster_array == original_value) # Create a boolean mask for the original value (True = Replace, False = Don't replace)\n        modified_raster[mask] = new_value # Replace the original values with the new values, when needed (that is, when the mask is True)\n\n    out_meta = src.meta.copy() # Get metadata from the original raster\n\nout_meta.update(dtype=rasterio.uint8, count=1) # Update metadata to the new raster\n\nwith rasterio.open(reassigned_raster_path, 'w', **out_meta) as dst: # Write the modified raster to a new file at the reassigned_raster_path\n    dst.write(modified_raster.astype(rasterio.uint8), 1)\n```", "```py\n## 3.6 See the frequency of pixels in the reassigned raster\nwith rasterio.open(reassigned_raster_path) as src:\n    raster_data = src.read(1)\n    unique_values = np.unique(raster_data)\n    total_non_zero = np.sum(raster_data != 255) # Count the total number of non-zero pixels\n\n    for value in unique_values:\n        if value != 255:  # Exclude no data (= 255)\n            count = np.sum(raster_data == value) # Count the number of pixels with the value\n            share = count / total_non_zero # Calculate the share of the value\n            share = share.round(3) # Round to 3 decimal places\n            print(f\"Value: {value}, Count: {count}, Share: {share}\") \n```", "```py\n## 3.7 Plot the reassigned raster with generic colors\nwith rasterio.open(reassigned_raster_path) as src:\n    data = src.read(1) # Read the raster data\n    unique_values = np.unique(data) # Get the unique values in the raster\n\n    plt.figure(figsize=(10, 8)) # Set the figure size\n\n    cmap = plt.cm.viridis  # Using Viridis colormap\n    norm = Normalize(vmin=data.min(), vmax=26) # Normalize the data to the range of the colormap (max = 26, water)\n\n    masked_data = np.ma.masked_where(data == 255, data) # Mask no data values (255)\n    plt.imshow(masked_data, cmap=cmap, norm=norm) # Plot the data with the colormap\n\n    plt.colorbar(label='Value') # Add a colorbar with the values\n\n    plt.show()\n```", "```py\n## 3.8 Plot the reassigned raster with custom colors\n\n# Define the colors for each class - notice you need to follow the same order as the values and must be numerically increasing or decreasing (still need to find out how to solve it)\nvalues = [3, 10, 15, 18, 22, 26, 255] # Values to be colored\ncolors_list = ['#6a994e', '#a7c957', '#c32f27', '#dda15e', '#6c757d', '#0077b6','#FFFFFF'] # HEX codes of the colors used\nlabels = ['Natural Forest', 'Other Natural Vegetation', 'Pasture', 'Agriculture', 'Others', 'Water', 'No data'] # Labels displayed on the legend\n\ncmap = colors.ListedColormap(colors_list) # Create a colormap (cmap) with the colors\nbounds = values + [256] # Add a value to the end of the list to include the last color\nnorm = colors.BoundaryNorm(bounds, cmap.N) # Normalize the colormap to the values\n\nimg = plt.imshow(raster_data, interpolation='nearest', cmap=cmap, norm=norm) # Plot the data with the colormap\n\nlegend_patches = [mpatches.Patch(color=colors_list[i], label=labels[i]) for i in range(len(values)-1)] # Create the legend patches withou the last one (255 = no data)\n\n# Create the legend\nplt.legend(handles = legend_patches, # Add the legend patches\n          bbox_to_anchor = (0.5, -0.02), # Place the legend below the plot\n          loc = 'upper center', # Place the legend in the upper center\n          ncol = 3, # Number of columns\n          fontsize = 9, # Font size\n          handlelength=1,# Length of the legend handles\n          frameon=False) # Remove the frame around the legend\n\nplt.axis('off') # Remove the axis\nplt.title('Land Use in Acrelândia, AC (2022)', fontsize=20) # Add title\n\nplt.savefig('figures/acrelandia_ac_2022.pdf', format='pdf', dpi=1800) # Save it as a PDF at the figures folder\nplt.show()\n```", "```py\n## 4.1 For a generic geometry in any year, save a bbox around the geometry to Google Drive\n\ndef get_mapbiomas_lulc_raster(geom, geom_name, year, folder_in_google_drive):\n    ee.Authenticate() # Only for the first time\n    ee.Initialize() # Run it every time you start a new session\n\n    my_geom = geom\n\n    bbox = my_geom.bounds # Get the bounding box of the geometry\n    bbox = Polygon([(bbox[0], bbox[1]), (bbox[0], bbox[3]), (bbox[2], bbox[3]), (bbox[2], bbox[1])]) # Convert the bounding box to a Polygon\n\n    bbox_xmin = bbox.bounds[0] # Get the minimum x coordinate of the bounding box\n    bbox_ymin = bbox.bounds[1] # Get the minimum y coordinate of the bounding box\n    bbox_xmax = bbox.bounds[2] # Get the maximum x coordinate of the bounding box\n    bbox_ymax = bbox.bounds[3] # Get the maximum y coordinate of the bounding box\n\n    mapbiomas_asset = 'projects/mapbiomas-workspace/public/collection8/mapbiomas_collection80_integration_v1'\n    band_id = f'classification_{year}'\n\n    mapbiomas_image = ee.Image(mapbiomas_asset) # Get the images of MapBiomas Collection 8.0 \n    mapbiomas_data = mapbiomas_image.select(band_id) # Select the image for 2022\n\n    roi = ee.Geometry.Rectangle([bbox_xmin, bbox_ymin, bbox_xmax, bbox_ymax]) # Set the Region of Interest (ROI) to the bbox around the desired geometry\n    image_roi = mapbiomas_data.clip(roi) # Crop the image to the ROI\n\n    export_task = ee.batch.Export.image.toDrive(\n        image=image_roi, # Image to export to Google Drive as a GeoTIFF\n        description=f\"save_bbox_around_{geom_name}_in_{year}\", # Task description\n        folder=folder_in_google_drive, # Change this to the folder in your Google Drive where you want to save the file\n        fileNamePrefix=f\"{geom_name}_{year}\", # File name\n        region=roi.getInfo()['coordinates'], # Region to export the image\n        scale=30,\n        fileFormat='GeoTIFF'\n    )\n    export_task.start()  # Notice that uploading those rasters to Google Drive may take a while, specially for large areas\n```", "```py\n# Test it using Rio de Janeiro in 2022\nfolder_in_google_drive = 'tutorial_mapbiomas_gee'\nrio_de_janeiro = brazilian_municipalities.query('nm_mun == \"Rio de Janeiro\"') \nrio_de_janeiro.crs = 'EPSG:4326' # Set the CRS to WGS84 (this project default one, change if needed)\nrio_de_janeiro_geom = rio_de_janeiro.geometry.iloc[0] # Get the geometry of Rio de Janeiro, RJ\n\nteste1 = get_mapbiomas_lulc_raster(rio_de_janeiro_geom, 'rio_de_janeiro', 2022, folder_in_google_drive)\n```", "```py\n## 4.2 Crop the raster for the desired geometry\ndef crop_mapbiomas_lulc_raster(geom, geom_name, year, folder_in_google_drive):\n    original_raster_path = f'path_to_your_google_drive/{folder_in_google_drive}/{geom_name}_{year}.tif'\n    reassigned_raster_path = f'path_to_your_google_drive/{folder_in_google_drive}/cropped_{geom_name}_{year}.tif'\n\n    my_geom = geom\n\n    mapbiomas_categories = {\n    # Forest (= 3)\n    1:3, 3:3, 4:3, 5:3, 6:3, 49:3,\n    # Other Non-Forest Natural Vegetation (= 10)\n    10:10, 11:10, 12:10, 32:10, 29:10, 50:10, 13:10,\n    # Pasture (= 15)\n    15:15,\n    # Agriculture (= 18)\n    18:18, 19:18, 39:18, 20:18, 40:18, 62:18, 41:18, 36:18, 46:18, 47:18, 35:18, 48:18, 21:18, 14:18, 9:18,\n    # Water ( = 26)\n    26:26, 33:26, 31:26,\n    # Other (= 22)\n    22:22, 23:22, 24:22, 30:22, 25:22, 27:22,\n    # No data (= 255)\n    0:255\n    } # You can change this to whatever categorization you want, but just remember to adapt the colors and labels in the plot\n\n    with rasterio.open(original_raster_path) as src:\n        raster_array = src.read(1)\n        out_meta = src.meta.copy() # Get metadata from the original raster\n\n        # Crop the raster to the geometry of my_geom and thus remove pixels outside the city limits (will be assigned to no data = 0)\n        out_image, out_transform = rasterio.mask.mask(src, [my_geom], crop=True) \n        out_meta.update({\n            \"height\": out_image.shape[1],\n            \"width\": out_image.shape[2],\n            \"transform\": out_transform\n        }) # Update metadata to the new raster\n        raster_array = out_image[0] # Get the masked raster\n\n        modified_raster = np.zeros_like(raster_array) # Base raster full of zeros to be modified\n\n        # Reassign each pixel based on the mapbiomas_categories dictionary\n        for original_value, new_value in mapbiomas_categories.items():\n            mask = (raster_array == original_value) # Create a boolean mask for the original value (True = Replace, False = Don't replace)\n            modified_raster[mask] = new_value # Replace the original values with the new values, when needed (that is, when the mask is True)\n\n        out_meta = src.meta.copy() # Get metadata from the original raster\n\n        out_meta.update(dtype=rasterio.uint8, count=1) # Update metadata to the new raster\n\n    with rasterio.open(reassigned_raster_path, 'w', **out_meta) as dst: # Write the modified raster to a new file at the reassigned_raster_path\n        dst.write(modified_raster.astype(rasterio.uint8), 1)\n```", "```py\nteste2 = crop_mapbiomas_lulc_raster(rio_de_janeiro_geom, 'rio_de_janeiro', 2022, folder_in_google_drive)\n```", "```py\n## 4.3 Plot the cropped raster\ndef pixel_freq_mapbiomas_lulc_raster(geom_name, year, folder_in_google_drive):\n    reassigned_raster_path = f'path_to_your_google_drive/{folder_in_google_drive}/cropped_{geom_name}_{year}.tif'\n\n    with rasterio.open(reassigned_raster_path) as src:\n        raster_data = src.read(1)\n        unique_values = np.unique(raster_data)\n        total_non_zero = np.sum(raster_data != 255) # Count the total number of non-zero pixels\n\n    for value in unique_values:\n        if value != 255:  # Exclude no data (= 255)\n            count = np.sum(raster_data == value) # Count the number of pixels with the value\n            share = count / total_non_zero # Calculate the share of the value\n            share = share.round(3)\n            print(f\"Value: {value}, Count: {count}, Share: {share}\") \n```", "```py\nteste3 = pixel_freq_mapbiomas_lulc_raster('rio_de_janeiro', 2022, folder_in_google_drive)\n```", "```py\n## 4.4 Plot the cropped raster\ndef plot_mapbiomas_lulc_raster(geom_name, year, folder_in_google_drive,driver):\n    reassigned_raster_path = f'/Users/vhpf/Library/CloudStorage/GoogleDrive-vh.pires03@gmail.com/My Drive/{folder_in_google_drive}/cropped_{geom_name}_{year}.tif'\n    with rasterio.open(reassigned_raster_path) as src:\n        raster_data = src.read(1)\n\n    # Define the colors for each class - notice you need to follow the same order as the values\n    values = [3, 10, 15, 18, 22, 26, 255] # Must be the same of the mapbiomas_categories dictionary\n    colors_list = ['#6a994e', '#a7c957', '#c32f27', '#dda15e', '#6c757d', '#0077b6','#FFFFFF'] # Set your colors\n    labels = ['Natural Forest', 'Other Natural Vegetation', 'Pasture', 'Agriculture', 'Others', 'Water', 'No data'] # Set your labels\n\n    cmap = colors.ListedColormap(colors_list) # Create a colormap (cmap) with the colors\n    bounds = values + [256] # Add a value to the end of the list to include the last color\n    norm = colors.BoundaryNorm(bounds, cmap.N) # Normalize the colormap to the values\n\n    img = plt.imshow(raster_data, interpolation='nearest', cmap=cmap, norm=norm) # Plot the data with the colormap\n\n    legend_patches = [mpatches.Patch(color=colors_list[i], label=labels[i]) for i in range(len(values)-1)] # Create the legend patches without the last one (255 = no data)\n\n    # Create the legend\n    plt.legend(handles = legend_patches, # Add the legend patches\n               bbox_to_anchor = (0.5, -0.02), # Place the legend below the plot\n               loc = 'upper center', # Place the legend in the upper center\n               ncol = 3, # Number of columns\n               fontsize = 9, # Font size\n               handlelength=1.5,# Length of the legend handles\n               frameon=False) # Remove the frame around the legend\n\n    plt.axis('off') # Remove the axis\n    geom_name_title = inflection.titleize(geom_name)\n    plt.title(f'Land Use in {geom_name_title} ({year})', fontsize=20) # Add title\n\n    saving_path = f'figures/{geom_name}_{year}.{driver}'\n\n    plt.savefig(saving_path, format=driver, dpi=1800) # Save it as a .pdf or .png at the figures folder of your project\n    plt.show()\n```", "```py\nteste4 = plot_mapbiomas_lulc_raster('rio_de_janeiro', 2022, folder_in_google_drive, 'png')\n```", "```py\n## 4.5 Do it in just one function - recall to save rasters (4.1) before\ndef clean_mapbiomas_lulc_raster(geom, geom_name, year, folder_in_google_drive,driver):\n    crop_mapbiomas_lulc_raster(geom, geom_name, year, folder_in_google_drive)\n    plot_mapbiomas_lulc_raster(geom_name, year, folder_in_google_drive,driver)\n    print(f\"MapBiomas LULC raster for {geom_name} in {year} cropped and plotted!\")\n```", "```py\n## 4.6 Run it for multiple geometries for multiple years\n\n### 4.6.1 First, save rasters for multiple geometries and years\ncities_list = ['Porto Acre'] # Cities to be analyzed - check whether there are two cities in Brazil with the same name\nyears = range(1985,2023) # Years to be analyzed (first year in MapBiomas LULC == 1985)\n\nbrazilian_municipalities = gpd.read_file('municipios/file.shp', engine='pyogrio', use_arrow=True) # Read the shapefile - you can use any other shapefile here\nbrazilian_municipalities = brazilian_municipalities.clean_names()\nbrazilian_municipalities.crs = 'EPSG:4326' # Set the CRS to WGS84 (this project default one, change if needed)\nselected_cities = brazilian_municipalities.query('nm_mun in @cities_list') # Filter the geometry for the selected cities\nselected_cities = selected_cities.reset_index(drop=True) # Reset the index\n\ncities_ufs = [] # Create list to append the full names of the cities with their UF (state abbreviation, in portuguese)\nnrows = len(selected_cities)\nfor i in range(nrows):\n    city = selected_cities.iloc[i]\n    city_name = city['nm_mun']\n    city_uf = city['sigla_uf']\n    cities_ufs.append(f\"{city_name} - {city_uf}\")\n```", "```py\nfolder_in_google_drive = 'tutorial_mapbiomas_gee' # Folder in Google Drive to save the rasters\nfor city in cities_list:\n    for year in years:\n        city_geom = selected_cities.query(f'nm_mun == \"{city}\"').geometry.iloc[0] # Get the geometry of the city\n        geom_name = unidecode.unidecode(city) # Remove latin-1 characters from the city name - GEE doesn`t allow them\n        get_mapbiomas_lulc_raster(city_geom, geom_name, year, folder_in_google_drive) # Run the function for each city and year\n```", "```py\n### 4.6.2 Second, crop and plot the rasters for multiple geometries and years - Make sure you have enough space in your Google Drive and all rasters are there\nfor city in cities_list:\n    for year in years:\n        city_geom = selected_cities.query(f'nm_mun == \"{city}\"').geometry.iloc[0]\n        geom_name = unidecode.unidecode(city)\n        clean_mapbiomas_lulc_raster(city_geom, geom_name, year, folder_in_google_drive,'png') # Run the function for each city and year\n        gc.collect()\n```", "```py\n## 4.7 Make a clip with LULC evolution\nimg_folder = 'figures/porto_acre_lulc' # I created a folder to save the images of the LULC evolution for Porto Acre inside project_path/figures\nimg_files = sorted([os.path.join(img_folder, f) for f in os.listdir(img_folder) if f.endswith('.png')]) # Gets all the images in the folder that  end with .png - make sure you only have the desired images in the folder\n\nclip = ImageSequenceClip(img_files, fps=2)  # 2 FPS, 0.5 second between frames\noutput_file = 'figures/clips/porto_acre_lulc.mp4' # Save clip at the clips folder\nclip.write_videofile(output_file, codec='libx264') # It takes a while to create the video (3m30s in my pc)\n```"]
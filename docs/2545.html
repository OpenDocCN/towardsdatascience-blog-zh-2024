<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>A Graph Too Far: Graph RAG Doesn’t Require Every Graph Tool</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>A Graph Too Far: Graph RAG Doesn’t Require Every Graph Tool</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-graph-too-far-graph-rag-doesnt-require-every-graph-tool-5f9adb227bdf?source=collection_archive---------2-----------------------#2024-10-18">https://towardsdatascience.com/a-graph-too-far-graph-rag-doesnt-require-every-graph-tool-5f9adb227bdf?source=collection_archive---------2-----------------------#2024-10-18</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="d3f5" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">Don’t complicate things with graph DBs, QLs, or graph analytics.</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@briangodsey?source=post_page---byline--5f9adb227bdf--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Brian Godsey" class="l ep by dd de cx" src="../Images/1a657e68741618b79bf470f34f9f3b26.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*JKqfHf0hYYkJJWWBkS3r7A.png"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--5f9adb227bdf--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@briangodsey?source=post_page---byline--5f9adb227bdf--------------------------------" rel="noopener follow">Brian Godsey</a></p></div></div></div><div class="hz ia l"><div class="ab ib"><div class="ab"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewbox="0 0 16 16"><path fill="#437AFF" d="M15.163 8c0 .65-.459 1.144-.863 1.575-.232.244-.471.5-.563.719s-.086.543-.092.875c-.006.606-.018 1.3-.49 1.781-.47.481-1.15.494-1.744.5-.324.006-.655.013-.857.094s-.465.337-.704.575c-.422.412-.906.881-1.542.881-.637 0-1.12-.469-1.543-.881-.239-.238-.49-.482-.704-.575-.214-.094-.532-.088-.857-.094-.593-.006-1.273-.019-1.744-.5s-.484-1.175-.49-1.781c-.006-.332-.012-.669-.092-.875-.08-.207-.33-.475-.563-.719-.404-.431-.863-.925-.863-1.575s.46-1.144.863-1.575c.233-.244.472-.5.563-.719.092-.219.086-.544.092-.875.006-.606.019-1.3.49-1.781s1.15-.494 1.744-.5c.325-.006.655-.012.857-.094.202-.081.465-.337.704-.575C7.188 1.47 7.671 1 8.308 1s1.12.469 1.542.881c.239.238.49.481.704.575s.533.088.857.094c.594.006 1.273.019 1.745.5.47.481.483 1.175.49 1.781.005.331.011.669.091.875s.33.475.563.719c.404.431.863.925.863 1.575"/><path fill="#fff" d="M7.328 10.5c.195 0 .381.08.519.22.137.141.215.331.216.53 0 .066.026.13.072.177a.24.24 0 0 0 .346 0 .25.25 0 0 0 .071-.177c.001-.199.079-.389.216-.53a.73.73 0 0 1 .519-.22h1.959c.13 0 .254-.053.346-.146a.5.5 0 0 0 .143-.354V6a.5.5 0 0 0-.143-.354.49.49 0 0 0-.346-.146h-1.47c-.324 0-.635.132-.865.366-.23.235-.359.552-.359.884v2.5c0 .066-.025.13-.071.177a.24.24 0 0 1-.346 0 .25.25 0 0 1-.072-.177v-2.5c0-.332-.13-.65-.359-.884A1.21 1.21 0 0 0 6.84 5.5h-1.47a.49.49 0 0 0-.346.146A.5.5 0 0 0 4.88 6v4c0 .133.051.26.143.354a.49.49 0 0 0 .347.146z"/></svg></div></div></div><span class="ic id" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ie if ah ai aj ak al am an ao ap aq ar ig ih ii" disabled="">Follow</button></p></div></div></span></div></div><div class="l ij"><span class="bf b bg z dx"><div class="ab cn ik il im"><div class="in io ab"><div class="bf b bg z dx ab ip"><span class="iq l ij">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--5f9adb227bdf--------------------------------" rel="noopener follow"><p class="bf b bg z ir is it iu iv iw ix iy bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="ic id" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">12 min read</span><div class="iz ja l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Oct 18, 2024</span></div></span></div></span></div></div></div><div class="ab cp jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq"><div class="h k w ea eb q"><div class="kg l"><div class="ab q kh ki"><div class="pw-multi-vote-icon ed iq kj kk kl"><div class=""><div class="km kn ko kp kq kr ks am kt ku kv kl"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kw kx ky kz la lb lc"><p class="bf b dy z dx"><span class="kn">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao km lf lg ab q ee lh li" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="le"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count ld le">2</span></p></button></div></div></div><div class="ab q jr js jt ju jv jw jx jy jz ka kb kc kd ke kf"><div class="lj k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lk an ao ap ig ll lm ln" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lo cn"><div class="l ae"><div class="ab cb"><div class="lp lq lr ls lt lu ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lk an ao ap ig lv lw li lx ly lz ma mb s mc md me mf mg mh mi u mj mk ml"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lk an ao ap ig lv lw li lx ly lz ma mb s mc md me mf mg mh mi u mj mk ml"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lk an ao ap ig lv lw li lx ly lz ma mb s mc md me mf mg mh mi u mj mk ml"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div></div></div><div class="mm"><div class="ab cb"><div class="lp mn lq mo lr mp cf mq cg mr ci bh"><figure class="mv mw mx my mz mm na nb paragraph-image"><div role="button" tabindex="0" class="nc nd ed ne bh nf"><div class="ms mt mu"><img src="../Images/fbb333412bda0047d5d7d41a8c08eb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*AgjmP-C1DKWrP6JOvtGCJg.png"/></div></div><figcaption class="nh ni nj ms mt nk nl bf b bg z dx">Adventures in the Knowledge Graph: Lost in Endless Documents. Generated by Brian Godsey using DALL-E.</figcaption></figure></div></div></div><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="6cb8" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">When RAG developers decide to try graph RAG — that is, to build a knowledge graph and integrate it into their RAG (retrieval-augmented generation) system — they have a lot of options and choices to make, according to the internet. There are lots of articles, guides, and how-to’s presenting different tools for working with graph RAG and graphs in general. So some developers dive right in, thinking they need to integrate and configure a laundry list of graph tools and techniques in order to do graph RAG properly. When searching how to get started, you would typically find articles suggesting that you need some or all of the following:</p><ol class=""><li id="c68d" class="nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bk"><strong class="no fr">knowledge graphs</strong> — to connect key terms and concepts that semantic search doesn’t capture</li><li id="9669" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh oi oj ok bk"><strong class="no fr">keyword and entity extraction tools</strong> — for building the knowledge graph</li><li id="320f" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh oi oj ok bk"><strong class="no fr">graph traversal algorithms</strong> — for exploring connections in the graph</li><li id="4fcb" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh oi oj ok bk"><strong class="no fr">property graph implementations</strong> — for enriching graph structure and traversal methods</li><li id="5eeb" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh oi oj ok bk"><strong class="no fr">graph databases (DBs)</strong> — for storing and interacting with graphs, and advanced graph analytics</li><li id="641c" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh oi oj ok bk"><strong class="no fr">graph query languages (QLs)</strong> — for sophisticated querying of graph nodes and edges</li><li id="8421" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh oi oj ok bk"><strong class="no fr">graph node embedding algorithms</strong> — for embedding graph objects into searchable vector spaces</li><li id="592a" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh oi oj ok bk"><strong class="no fr">vector stores</strong> — for storing and searching documents embedded in semantic vector space</li></ol><p id="581e" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">Certainly, a case can be made that each of these tools and implementations can be very helpful for specific graph use cases. But for any developer starting a typical graph RAG use case, the simple fact remains: <strong class="no fr">most “graph” tools were designed and built long before the generative AI revolution.</strong> GenAI use cases are fundamentally different from traditional graph use cases, and requires a different approach, even if some tools can be shared between the two.</p><p id="d9e4" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">The above list of suggested tools for graph RAG includes some that are generally unnecessary for typical GenAI use cases. And, beyond being unnecessary, adding some of these tools can over-complicate things — leading to increased development time, higher costs, and additional maintenance overhead that could have been avoided. Keeping the tech stack simple by focusing on the essentials enhances efficiency and lets you leverage the power of graph RAG without the bloat.</p><p id="6d35" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk"><strong class="no fr">One popular misconception is that you need a graph DB to do graph RAG.</strong> Graph DBs and graph query languages (graph QLs) are powerful tools for graph analytics and deep graph algorithms, but graph RAG and GenAI applications don’t typically benefit from these types of traditional graph analytics. Graph DBs can support graph RAG, but they also add unnecessary complexity to the stack. We dive into this topic more below.</p><p id="7db9" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">In this article, we discuss the software needs of various use cases involving graphs, focusing on GenAI use cases and applications, and minimizing additional effort and complexity when moving from plain RAG to graph RAG. In most cases, we don’t need an extensive list of tools; adopting a few key technologies aligned with our goals not only simplifies our work but often achieves better results.</p><h1 id="7498" class="oq or fq bf os ot ou gq ov ow ox gt oy oz pa pb pc pd pe pf pg ph pi pj pk pl bk">GenAI use cases for graphs</h1><p id="02f6" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">Semantic vector search is powerful for finding documents that are contextually similar to a query. However, there are situations where this method falls short, especially when the required information is non-semantic or when deeper insights into the data are necessary. Graph RAG technologies can complement the capabilities of vector search by leveraging non-semantic information — such as in the following common use cases:</p><h2 id="80f4" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Leveraging non-semantic information in documents</h2><p id="8b65" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">While semantic search excels in identifying documents based on contextual similarity, it often misses non-semantic cues crucial for comprehensive data analysis. Graphs can <a class="af qi" href="https://thenewstack.io/boost-llm-results-when-to-use-knowledge-graph-rag/" rel="noopener ugc nofollow" target="_blank">incorporate and utilize non-semantic information such as metadata</a>, which can include links, specialized terms and definitions, cross-references, glossaries, and document structure such as titles, headings, and sub-section content.. Additionally, graphs can connect entities, keywords, and concepts that have been extracted or inferred from texts.</p><h2 id="1751" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Community summarization</h2><p id="1152" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">When the goal is to summarize the content from a community or a specific group of interconnected entities, graph-based approaches can be indispensable. Graphs can identify clusters or communities within the data, summarizing prevalent themes or discussions across multiple documents or contributors.</p><h2 id="a86b" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Neighborhood exploration</h2><p id="63de" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">Exploring the “neighborhood” or immediate connections of a particular node or query in a graph can reveal relationships and insights that are not evident through semantic search alone. Contextual exploration allows for traversing from a starting node to explore adjacent nodes (documents, terms, or concepts) to discover related information that adds depth to the initial query.</p><figure class="mv mw mx my mz mm ms mt paragraph-image"><div role="button" tabindex="0" class="nc nd ed ne bh nf"><div class="ms mt qj"><img src="../Images/66b59f0da4f47b226a9647b5bc919d1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_w9xYy7u3V5T6SXSr1jycg.png"/></div></div><figcaption class="nh ni nj ms mt nk nl bf b bg z dx">Adventures in the Knowledge Graph: Graphs in Toyland. Generated by Brian Godsey using DALL-E.</figcaption></figure><h1 id="e7d9" class="oq or fq bf os ot ou gq ov ow ox gt oy oz pa pb pc pd pe pf pg ph pi pj pk pl bk">Why GenAI is different from traditional graph use cases</h1><p id="b1ba" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">Before there was generative AI, there were knowledge graphs and graph DBs. These graph tools pre-date GenAI by many years, and some associated technologies were designed for very different use cases. These technologies were primarily aimed at structured data exploration, not the unstructured text processing and semantic understanding that GenAI excels at.</p><p id="7b0e" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">The shift from traditional graph use cases to generative AI is a significant change in data handling techniques. Traditional graphs are excellent for clear, defined relationships, but they often lack the flexibility needed for the nuanced demands of generative AI.</p><h2 id="bff2" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Traditional graph tools were built for huge, complex graphs</h2><p id="77dc" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">Knowledge graphs are often the aggregation of large amounts of data from various sources, linking complex and interdependent relationships across a wide spectrum of data points. A huge number of nodes and edges, coupled with the complexity of their connections, can make data processing and analysis tasks computationally intensive and time-consuming.</p><p id="95b2" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">This is why graph databases (graph DBs) were originally created. They provide optimized storage solutions and processing capabilities designed to manage extensive networks of nodes and edges efficiently. Alongside graph DBs, graph query languages (graph QLs) have been designed to facilitate sophisticated query operations on these large graphs and their subgraphs. These tools excel at executing operations that involve deep traversals, pattern matching, and dynamic data aggregation, which are typical in graph analytics. Common use cases for graph DBs and graph analytics include social network analysis, recommendation systems, fraud detection, and complex network management. In these scenarios, the ability to quickly and efficiently analyze complex relationships within large sets of data is crucial.</p><p id="3ce3" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">Some canonical use cases for graph DBs and QLs:</p><ul class=""><li id="b31f" class="nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh qk oj ok bk"><strong class="no fr">Centrality analysis </strong>— Identify the most influential people within a social network. Involves centrality measures such as Degree Centrality, Betweenness Centrality, and Eigenvector Centrality</li><li id="4977" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">Community detection</strong> — Segment the network into communities or clusters where members are more densely connected internally than with the rest of the network. Involves graph clustering algorithms and edge-betweenness community detection.</li><li id="4e98" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">Pathfinding</strong> — Find the shortest path between two nodes to understand the degrees of separation between individuals. Involves algorithms like Dijkstra’s or A* (A-star) for shortest path calculations.</li></ul><p id="8933" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">Of course, there are many other use cases of sophisticated graph querying and graph analytics that traditional graph tools were designed for and excel at. But, the examples given here, as well as many others, are very different from the graph use cases we see today in GenAI applications.</p><p id="ed72" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">Knowing all of this, why would we start building a graph RAG system using a graph DB that added vector storage and search as a secondary feature… when modern vector stores are perfectly capable of supporting all of the graph operations that we need for graph RAG? We shouldn’t, and we dig more into how vector stores work with graph operations in the next section.</p><h2 id="b16b" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Both graph RAG and vector search operate locally</h2><p id="8e27" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">Previously, I listed “neighborhood exploration” as one application for graphs in GenAI use cases, but conceptually speaking, it can be considered a broad umbrella term under which you can find virtually all graph use cases within GenAI. In other words, when we use graphs with GenAI, we are almost certainly exploring only neighborhoods — and very rarely a whole graph or large parts of graphs. At most, we explore subgraphs that are quite small relative to the whole graph.</p><p id="b81f" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">In graph theory, a “neighborhood” refers to the set of nodes adjacent to a given node within a graph, as defined by direct links or edges. So, retrieving neighbors of a node in a knowledge graph should result in a set of items or concepts that are directly related to the starting node. Similarly, in vector search, standard implementations return “approximate nearest neighbors” (ANN) in semantic vector space, meaning that the documents in the results set are those most closely related to the query, in a semantic sense. (ANN is “approximate” because making it exact is much slower and more expensive.)</p><p id="ca00" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">So, both vector search and graph traversal a few steps from a starting node are both looking for “nearest neighbors”, where “nearest” has a different meaning in each of the two cases. Vector search finds the nearest semantic neighbors and graph traversal finds graph neighbors — which, if integrated well, can pull together documents that are related in both semantic ways and a wide variety of non-semantic ways that are limited only by how you construct your knowledge graph.</p><p id="e6d0" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">The important point here is to note that graph RAG is entirely concerned with exploring local neighborhoods, whether graph or vector — just like RAG always has on the purely vector side.The implication is that our graph RAG software stack should be built on a foundation that excels at local neighborhood search and retrieval, because all of our queries in GenAI apps are focused on specific areas of knowledge that do not require comprehensive explorations or analytics of the entire knowledge graph.</p><figure class="mv mw mx my mz mm ms mt paragraph-image"><div role="button" tabindex="0" class="nc nd ed ne bh nf"><div class="ms mt ql"><img src="../Images/d69c9cdab654149171a029bcaf575151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FJ884HcdtK2H4RcQuSTbDg.png"/></div></div><figcaption class="nh ni nj ms mt nk nl bf b bg z dx">Adventures in the Knowledge Graph: Graphs in Reality. Generated by Brian Godsey using DALL-E.</figcaption></figure><h1 id="d7be" class="oq or fq bf os ot ou gq ov ow ox gt oy oz pa pb pc pd pe pf pg ph pi pj pk pl bk">A-la-carte graph tools: adopt only what you need</h1><p id="9b85" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">Returning to the “laundry list” of graph tools from the beginning of this article, let’s have a closer look at when you might want to adopt them as part of your graph RAG stack, or not.</p><h2 id="5a9e" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Knowledge graphs</h2><ul class=""><li id="c6ec" class="nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh qk oj ok bk"><strong class="no fr">When to adopt </strong>— Always, in some form. A knowledge graph is a core part of graph RAG.</li><li id="3455" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">When to avoid — </strong>Never, unless getting rid of graph RAG in favor of plain RAG.</li></ul><h2 id="dcb6" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Entity and keyword extraction tools</h2><ul class=""><li id="1b3a" class="nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh qk oj ok bk"><strong class="no fr">When to adopt </strong>— When building a knowledge graph directly from textual content where automated extraction can efficiently populate your graph with relevant entities and keywords.</li><li id="83d1" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">When to avoid </strong>— If your data doesn’t lend itself well to automated extraction or when alternative methods like <a class="af qi" rel="noopener" target="_blank" href="/your-documents-are-trying-to-tell-you-whats-relevant-better-rag-using-links-386b7433d0f2">document linking</a>, manual curation, or specialized parsers better suit your data and use case.</li></ul><h2 id="e657" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Graph traversal algorithms</h2><ul class=""><li id="4998" class="nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh qk oj ok bk"><strong class="no fr">When to adopt </strong>— Always. A simple graph traversal algorithm is necessary for graph RAG, e.g. typically a simple walk of depth 1–3 from the starting node.</li><li id="fb41" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">When to avoid — </strong>While basic traversal is necessary, avoid overly complex algorithms unless your use case specifically demands advanced graph navigational capabilities.</li></ul><h2 id="f87d" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Property graph implementations</h2><ul class=""><li id="05ee" class="nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh qk oj ok bk"><strong class="no fr">When to adopt — </strong>When your project requires sophisticated modeling of complex relationships and properties within edges that go well beyond basic linkage.</li><li id="b406" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">When to avoid — </strong>For most standard graph RAG implementations where such complexity in relationship modeling isn’t required. Simpler graph models typically suffice.</li></ul><h2 id="f667" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Graph databases</h2><ul class=""><li id="d994" class="nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh qk oj ok bk"><strong class="no fr">When to adopt </strong>— When dealing with extensive, complex queries and needing to perform advanced graph analytics and traversals that surpass the capabilities of standard systems.</li><li id="597e" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">When to avoid </strong>— If your graph RAG system does not engage in complex, extensive, graph-specific operations. Adopting a graph database in such scenarios can lead to unnecessary system complexity and resource allocation.</li></ul><h2 id="0de0" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Graph query languages (Graph QLs)</h2><ul class=""><li id="23e0" class="nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh qk oj ok bk"><strong class="no fr">When to adopt </strong>— If adopting graph DBs. When complex querying of graph data is critical for your application, allowing sophisticated manipulation and retrieval of interconnected data.</li><li id="4cce" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">When to avoid </strong>— For simpler graph RAG setups where basic retrieval methods suffice, incorporating a graph QL might over-complicate the architecture.</li></ul><h2 id="5bfa" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Graph node embedding algorithms</h2><ul class=""><li id="02b2" class="nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh qk oj ok bk"><strong class="no fr">When to adopt </strong>— When you have a graph, and want to convert graph nodes into vectors. This is a specialized use case with advantages and disadvantages. See <a class="af qi" href="https://cs.stanford.edu/~jure/pubs/node2vec-kdd16.pdf" rel="noopener ugc nofollow" target="_blank">the popular algorithm node2vec</a>.</li><li id="d768" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">When to avoid </strong>— If your system does not require searching graph nodes as vectors.</li></ul><h2 id="0726" class="pr or fq bf os ps pt pu ov pv pw px oy nv py pz qa nz qb qc qd od qe qf qg qh bk">Vector stores</h2><ul class=""><li id="2b62" class="nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh qk oj ok bk"><strong class="no fr">When to adopt:</strong> Always. Necessary, as they serve as the foundation for storing and searching high-dimensional vector representations crucial for RAG systems.</li><li id="6b18" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">When to avoid </strong>— Never.</li></ul><p id="9372" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">Each component’s inclusion should align with the specific needs and complexities of your graph RAG system, ensuring that every adopted technology adds value and enhances system performance without unnecessary complexity.</p><figure class="mv mw mx my mz mm ms mt paragraph-image"><div role="button" tabindex="0" class="nc nd ed ne bh nf"><div class="ms mt qj"><img src="../Images/86e3d22e148e9530f7e28bfa58506c86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xF8NAfXUGMpni4AnR3eyyg.png"/></div></div><figcaption class="nh ni nj ms mt nk nl bf b bg z dx">Adventures in the Knowledge Graph: Pop-Art Traversal. Generated by Brian Godsey using DALL-E.</figcaption></figure><h1 id="6d6b" class="oq or fq bf os ot ou gq ov ow ox gt oy oz pa pb pc pd pe pf pg ph pi pj pk pl bk">Requirements of a minimal graph RAG system</h1><p id="c5e0" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">Considering the above notes on graph tools and techniques, these are the core components required for any graph RAG system:</p><ol class=""><li id="92b7" class="nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh oi oj ok bk"><strong class="no fr">Vector store</strong> — Essential for any RAG framework, the vector store is even more crucial in graph RAG for maintaining the scalability and efficiency of document retrieval. Vector stores provide the infrastructure for storing and searching through documents embedded in a semantic vector space, which is fundamental to the retrieval process in RAG systems.</li><li id="0819" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh oi oj ok bk"><strong class="no fr">Knowledge graph</strong> — The defining concept of graph RAG vs plain RAG, the knowledge graph links key terms and concepts that semantic vector search might miss. This graph is vital for expanding the context and enhancing the relational data available to the RAG system, thus justifying its central role in graph RAG.</li><li id="eb4a" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh oi oj ok bk"><strong class="no fr">Graph traversal</strong> — A simple graph traversal algorithm is necessary to navigate the knowledge graph. This component doesn’t need to be overly complex, as graph RAG primarily requires exploring local neighborhoods or small subgraphs directly related to the query, rather than deep or wide-ranging graph navigations.</li></ol><p id="6784" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">For specialized use cases, or if the minimal implementation isn’t performing well enough, more graph tools and capabilities can be added — some important considerations are outlined in the next section.</p><h1 id="bd56" class="oq or fq bf os ot ou gq ov ow ox gt oy oz pa pb pc pd pe pf pg ph pi pj pk pl bk">Start with vector, add “graph” as needed — not the other way around</h1><p id="0a58" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">When working with GenAI use cases, the foundations of knowledge are in vector space. We use vector-optimized tools like vector stores because they operate directly with the language of LLMs and other GenAI models — vectors. Our implementations of GenAI applications should be vector-first, because the most important vector operations (e.g. approximate nearest neighbor search) are expensive in both time and money, so we should optimize these for performance and efficiency. Adding graph to a GenAI application should be just that: adding graph capabilities to your existing vector-optimized infrastructure. Moving from vector-optimized to graph-native infrastructure may be needed in some specific use cases, but in the vast majority of cases it complicates the tech stack and makes deployment more challenging.</p><p id="0b56" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">When starting with a typical graph RAG implementation and considering the addition of more complex graph tools and capabilities, it is important to carefully evaluate the particular challenges and requirements of the use cases, rather than the common notion that more sophisticated or complex graph tools are inherently better for any graph use case.</p><p id="456d" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">Here some some key considerations:</p><ul class=""><li id="45fd" class="nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh qk oj ok bk"><strong class="no fr">Locality of graph operations</strong> — In graph RAG, graph operations are predominantly local, involving only simple traversals within immediate neighborhoods and small subgraphs. This approach typically does not benefit from complex graph algorithms that might overcomplicate the retrieval process.</li><li id="f615" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">Capability of vector stores for graph operations</strong> — Modern vector stores are quite capable of performing necessary graph operations, especially when the operations are not overly complex. This allows for a seamless integration where vector and graph technologies complement each other without the need for a separate graph database.</li><li id="b2f5" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">Scalability and efficiency of modern vector stores</strong> — Vector stores are designed to handle large-scale document data sets with high efficiency, making them ideal for the backbone of a RAG system where quick retrieval is paramount. Using graph capabilities directly within the vector store can also accommodate necessary graph operations without sacrificing performance.</li><li id="42c4" class="nm nn fq no b go ol nq nr gr om nt nu nv on nx ny nz oo ob oc od op of og oh qk oj ok bk"><strong class="no fr">Complexity of graph DBs, QLs, and analytics</strong> — Introducing a graph database into the stack can complicate the software architecture unnecessarily. Given that the graph requirements in graph RAG typically do not require sophisticated large-graph operations, leveraging the existing capabilities of vector stores to handle these needs can be more efficient and keeps the system architecture simpler.</li></ul><p id="fb10" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk">Each addition should be considered carefully to ensure it directly addresses a specific need without introducing undue complexity or overhead. This strategic approach ensures that enhancements are justified by tangible improvements in functionality or performance.</p><h1 id="f89e" class="oq or fq bf os ot ou gq ov ow ox gt oy oz pa pb pc pd pe pf pg ph pi pj pk pl bk">Simple ways to start doing graph RAG</h1><p id="ce1e" class="pw-post-body-paragraph nm nn fq no b go pm nq nr gr pn nt nu nv po nx ny nz pp ob oc od pq of og oh fj bk">For a straight-forward and illustrative example of how to do graph RAG without any specialized graph tools beyond an open-source graph vector store implementation in LangChain, <a class="af qi" href="https://bit.ly/3BKZAJv" rel="noopener ugc nofollow" target="_blank">see my previous article in Towards Data Science</a>. Or, for a broader view of how to get started, see the <a class="af qi" href="https://bit.ly/4862Lrl" rel="noopener ugc nofollow" target="_blank">this guide to graph RAG</a>.</p></div></div></div><div class="ab cb qm qn qo qp" role="separator"><span class="qq by bm qr qs qt"/><span class="qq by bm qr qs qt"/><span class="qq by bm qr qs"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><p id="b2ee" class="pw-post-body-paragraph nm nn fq no b go np nq nr gr ns nt nu nv nw nx ny nz oa ob oc od oe of og oh fj bk"><em class="qu">by Brian Godsey, Ph.D. (</em><a class="af qi" href="https://bit.ly/4enqFRa" rel="noopener ugc nofollow" target="_blank"><em class="qu">LinkedIn</em></a><em class="qu">) — mathematician, data scientist and engineer // AI and ML products at </em><a class="af qi" href="https://bit.ly/3NpPujA" rel="noopener ugc nofollow" target="_blank"><em class="qu">DataStax</em></a><em class="qu"> // Wrote the book </em><a class="af qi" href="https://bit.ly/4f5uVES" rel="noopener ugc nofollow" target="_blank"><em class="qu">Think Like a Data Scientist</em></a></p></div></div></div><div class="ab cb qm qn qo qp" role="separator"><span class="qq by bm qr qs qt"/><span class="qq by bm qr qs qt"/><span class="qq by bm qr qs"/></div><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><figure class="mv mw mx my mz mm ms mt paragraph-image"><div role="button" tabindex="0" class="nc nd ed ne bh nf"><div class="ms mt qv"><img src="../Images/5c21236700300010387ff37b6e2e4962.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PTRpHIjF-CYNlKyEEvLUzg.png"/></div></div><figcaption class="nh ni nj ms mt nk nl bf b bg z dx">Adventures in the Knowledge Graph: Exploring Impressionism. Generated by Brian Godsey using DALL-E.</figcaption></figure><figure class="mv mw mx my mz mm ms mt paragraph-image"><div role="button" tabindex="0" class="nc nd ed ne bh nf"><div class="ms mt qw"><img src="../Images/8eab316d73b764260438944967b6aaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ugIK6AFKMUUEhyZWkJogQ.png"/></div></div><figcaption class="nh ni nj ms mt nk nl bf b bg z dx">Adventures in the Knowledge Graph. Exploring Expressionism. Generated by Brian Godsey using DALL-E.</figcaption></figure></div></div></div></div>    
</body>
</html>
- en: 'From Data Scientist to AI Developer: Lessons Building a Generative AI Web App
    in 2023'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/from-data-scientist-to-ai-developer-lessons-building-an-generative-ai-web-app-in-2023-95959a00a474?source=collection_archive---------0-----------------------#2024-01-21](https://towardsdatascience.com/from-data-scientist-to-ai-developer-lessons-building-an-generative-ai-web-app-in-2023-95959a00a474?source=collection_archive---------0-----------------------#2024-01-21)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A guide of technical tips for any data science enthusiast wanting to build an
    AI web app serving thousands of users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://iztham.medium.com/?source=post_page---byline--95959a00a474--------------------------------)[![Isaac
    Tham](../Images/57f44f34adc534dbf09791a8cd54e7f3.png)](https://iztham.medium.com/?source=post_page---byline--95959a00a474--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--95959a00a474--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--95959a00a474--------------------------------)
    [Isaac Tham](https://iztham.medium.com/?source=post_page---byline--95959a00a474--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--95959a00a474--------------------------------)
    ·12 min read·Jan 21, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/eb97eaccbbe21c2af01f7cecb07ae29b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: DALLE-3'
  prefs: []
  type: TYPE_NORMAL
- en: If you, like me, ventured into the world of data science (be it through college
    or one of the countless online courses), you may have harbored the dream of creating
    an ML/AI software product that people can use. A product just like those our CS
    friends seem to code up effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: But if you ever tried your hand at full-stack web development, you’d soon face
    the seemingly insurmountable hurdles of configuration, deployment, terminal commands
    and servers and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/28ce8c12dd701b5e9e013af438fb3b77.png)'
  prefs: []
  type: TYPE_IMG
- en: Just one of the many frustrated convos with my college roommate during the initial
    stages coding my app. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: I know this all too well, having spent countless hours floundering helplessly,
    which only deepened my inferiority complex that I’d never manage to craft a functioning
    software app.
  prefs: []
  type: TYPE_NORMAL
- en: But exactly one year ago, on the 21st of January, a weekend unexpectedly made
    free by passport-troubles and a cancelled trip, I embarked on a journey to make
    an AI app. It was a journey that led me to unexpected places — teaming up with
    a co-founder halfway across the world, joining a [San Francisco startup accelerator](https://buildspace.so/s3/demoday/Podsmart),
    and eventually growing to thousands of users with a significant annual revenue
    (check out my app, [Podsmart](http://podsmartai.com)! we summarize podcasts).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ae887cfe6b631727d4e6ef557556600c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'My app’s demo page on the Buildspace startup accelerator. Source: [https://buildspace.so/s3/demoday/Podsmart](https://buildspace.so/s3/demoday/Podsmart)'
  prefs: []
  type: TYPE_NORMAL
- en: But most importantly, it was a journey full of frustrations, backtracking, mistakes
    and rework. It was about navigating the bewildering world of software development
    without a formal CS/SWE background.
  prefs: []
  type: TYPE_NORMAL
- en: So, looking back at the past year building my first software product, I’ve compiled
    a guide of some **technical tips** — this is for any **data science enthusiast**
    who wants to build a **functional web app serving thousands of users**.
  prefs: []
  type: TYPE_NORMAL
- en: This guide is born from my struggles and learnings over a year, and represents
    advice I would have loved to tell my one-year-younger self.
  prefs: []
  type: TYPE_NORMAL
- en: 'Disclaimer: These tips are from my specific personal experiences, and may work
    differently for others. I also do not have any relationship or affiliation with
    any of the tools recommended here.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table of Contents**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: · [What you want to build](#8680)
  prefs: []
  type: TYPE_NORMAL
- en: · [The dangers of YouTube web development tutorials](#d511)
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [Tip #1: Use Next.js instead of React](#5c6a)'
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [Tip #2: Opt for Tailwind CSS instead of Bootstrap for styling](#e5b3)'
  prefs: []
  type: TYPE_NORMAL
- en: · [The trappings of the data science mindset](#91d1)
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [Tip #3: Choose FastAPI over Flask for your backend, and rigorously define
    response models](#f335)'
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [Tip #4: Use TypeScript instead of JavaScript](#d98b)'
  prefs: []
  type: TYPE_NORMAL
- en: · [About deployment…](#2175)
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [Tip #5: Use Modal for GPU backend](#5631)'
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [Tip #6: Use AWS Lambda for backend deployment and Vercel for frontend](#c901)'
  prefs: []
  type: TYPE_NORMAL
- en: · [Making life easier](#858e)
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [Tip #7: don’t build your own landing page using React](#e97d)'
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [Tip #8: Firebase + Stripe for user authentication and payments](#1919)'
  prefs: []
  type: TYPE_NORMAL
- en: '∘ [Tip #9: Implement Sentry for error monitoring](#900c)'
  prefs: []
  type: TYPE_NORMAL
- en: · [Conclusion](#a25a)
  prefs: []
  type: TYPE_NORMAL
- en: '**What you want to build**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build said functional web app, you need a **web interface** (**frontend**
    or client) for users to interact with, as well as a **server** (**backend**) which
    does data processing, data storage, and calling the ML/AI models.
  prefs: []
  type: TYPE_NORMAL
- en: (You might have heard of [Streamlit](https://streamlit.io/). It’s great for
    the simplest demos, but it really lacks the customizability to make a viable production
    app)
  prefs: []
  type: TYPE_NORMAL
- en: '**The dangers of YouTube web development tutorials**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a data scientist, many aspects of software development fill me with trepidation,
    such as the prospect of wasting days on broken configuration. Nothing is more
    frustrating than seeing something break and not know why it broke and how to fix
    it.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, I relied desperately on **walkthrough-style tutorials,** especially
    on YouTube, that depicted the entire process, from start to end, of setting up
    a React project, deploying a backend or website etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking back, there are two main downsides to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, confusion at multiple **conflicting** and **potentially outdated tutorials**
    (for instance, as newer versions of React come out). This has often led to me
    following a tutorial until realizing it no longer works.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, most tutorials are aimed at building cool classroom demos which are
    beginner-friendly. Hence, they use frameworks and reinforce coding patterns which
    have a **low performance ceiling**, which will be **lacking for production and
    scaling**. On hindsight, I’ve picked up many bad coding habits from YouTube tutorials,
    that are now obstacles to further developing my app as a live product serving
    thousands of users.
  prefs: []
  type: TYPE_NORMAL
- en: Since you learn best from failures, this process, though frustrating, was a
    massive learning experience for me throughout the year. Hopefully you can save
    lots of time learning from my failures.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip #1: Use Next.js instead of React**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![](../Images/e83c69363b500db47cc3b2f3efda54e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Searching for ‘full stack app tutorial’ on YouTube gives you lots of React
    tutorials. Source: [https://www.youtube.com/results?search_query=full+stack+app+tutorial](https://www.youtube.com/results?search_query=full+stack+app+tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: Many YouTube tutorials advocate for React, and I initially followed suit.
  prefs: []
  type: TYPE_NORMAL
- en: However, eventually I wanted to improve my site’s SEO performance — which is
    crucial to gaining more users. React’s limitations, such as inability to change
    meta tags dynamically, and lack of server-side rendering, were frustrating, necessitating
    a tedious change to Next.js. After switching, the differences in performance were
    just night-and-day.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dff8497750428d823d3e7da9529dbe77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Vercel has lots of Next.js templates for you to jumpstart your web development.
    Source: [https://vercel.com/templates/next.js](https://vercel.com/templates/next.js)'
  prefs: []
  type: TYPE_NORMAL
- en: Some people say React is more beginner-friendly, but there are lots of Next.js
    templates online, for example by [Vercel (Next.js creators)](https://vercel.com/templates/next.js),
    especially AI applications. Next.js is really the modern web framework used for
    nearly every AI application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip #2: Opt for Tailwind CSS instead of Bootstrap for styling**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embarking on my front-end UI journey, I initially, and somewhat naively, followed
    the herd of frontend tutorials, towards Bootstrap. Its allure? The promise of
    ease with ready-made components like dropdowns and accordions.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/4d5a4c7e8e2b86bacdd91b84dfe7a537.png)'
  prefs: []
  type: TYPE_IMG
- en: The ‘Bootstrap look’ — how ugly my website looked on Feb 20, 2023\. Image by
    author.
  prefs: []
  type: TYPE_NORMAL
- en: However, after a while, I realized that my website just looked … really ugly,
    especially when compared to the sleek, modern AI demo pages out there. There was
    this unmistakable ‘Bootstrap look’ — a sort of aesthetic stubbornness that resisted
    customization, entangled in a web of confusingly named CSS classes. So eventually,
    I once again bit the bullet and redid my entire frontend with Tailwind CSS, taking
    3 whole days.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5221bef3add4cb446ac04a25742faf56.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This AI demo page was definitely not built by Bootstrap. Source: restorephotos.io'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve ever seen an AI demo page with a modern and clean UI, it’s highly
    likely they used [Tailwind CSS](https://tailwindcss.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3994a7cc9b25aaed300f897e34a92ee4.png)'
  prefs: []
  type: TYPE_IMG
- en: Tailwind CSS and its utility classes make customizing every component extremely
    easy. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, I was intimidated by Tailwind — its long component definitions brimming
    with what seemed like cryptic utility classes appeared anything but beginner-friendly...
    I thought that Tailwind lacked pre-built components and it would be onerous to
    memorize the utility classes. However, this couldn’t be more untrue! There are
    many great UI component libraries built on Tailwind CSS — I used [Flowbite React](https://www.flowbite-react.com/)
    (it has all the components I need!)
  prefs: []
  type: TYPE_NORMAL
- en: '**The trappings of the data science mindset**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a data science student, I’ve grown to love Python with its minimalist, powerful
    code syntax. Python’s type-inference spared me the tedium of defining types for
    every variable (a task I found cumbersome, especially in languages I encountered
    in intro CS classes like Java).
  prefs: []
  type: TYPE_NORMAL
- en: Hence, I used JavaScript for my frontend and Python for my backend, avoiding
    defining the types of my API endpoints unless necessary.
  prefs: []
  type: TYPE_NORMAL
- en: However, as my app grew in complexity, tons of unexpected type errors between
    my frontend and backend eroded my coding productivity. I’m finally understanding
    my CS friends’ insistence on the importance of explicit types. It turns out, the
    meticulous detail in **type definition** isn’t just pedantic — it’s **essential**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip #3: Choose FastAPI over Flask for your backend, and rigorously define
    response models**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you search for Python backend tutorials on YouTube, most videos would point
    you to Flask. Just like how a broken clock is right twice a day, I somehow happened
    to choose FastAPI as my Python backend, which was definitely correct decision
    on hindsight.
  prefs: []
  type: TYPE_NORMAL
- en: (Though hilariously, I had totally disregarded the benefit of FastAPI. Until
    only recently, I didn’t understand the need to define Pydantic classes for POST
    requests and thought it more of a hassle than a help.)
  prefs: []
  type: TYPE_NORMAL
- en: 'FastAPI has several game-changing benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**automatically-generated API documentatio**n — this will be very useful for
    future engineers you onboard (or your future self) to understand the backend structure!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**easier to write code** — since FastAPI is built on Json schema, defining
    routes is much easier and shorter using FastAPI than Flask — resultantly, there’s
    lower learning curve for newbies like me'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**better performance** — FastAPI is apparently much faster than Flask and consumes
    less memory — which is great as my app sends around large payloads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/2025eb6f59fc6cead298cb352aa26796.png)'
  prefs: []
  type: TYPE_IMG
- en: Use Pydantic to build data models, which you can use to define response types
    for your FastAPI routes. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: But the most important thing is FastAPI’s **type annotations**.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI is built on Pydantic, a data validation library allowing you to define
    the ‘shape’ of data as classes with attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With FastAPI, you can annotate the input and output types for each API route,
    using Python type hints and Pydantic-defined classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This ensures that each route has outputs of a consistent data structure. But
    to unleash the full power of this feature, we need to…
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip #4: Use TypeScript instead of JavaScript**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the longest time, I’ve manually written my frontend fetcher methods (once
    again learning from full-stack tutorials), hence adding new routes to my app was
    a long and error-prone process.
  prefs: []
  type: TYPE_NORMAL
- en: You can hence imagine my shock when my big-tech SWE friend told me that you
    can **auto-generate Typescript client code using your API specification. (**see
    [here](https://fastapi.tiangolo.com/advanced/generate-clients) for more FastAPI’s
    documentation, one such package is [openapi-typescript-codegen](https://github.com/ferdikoomen/openapi-typescript-codegen))
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7b720eb2bec8cddc3a2f2e7dd64e6a81.png)'
  prefs: []
  type: TYPE_IMG
- en: With auto-generated TypeScript client code, your fetcher methods have autocompletion
    and documentation based on your FastAPI endpoint response models. Image by author.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an instant, I realized that this would solve two major challenges simultaneously:
    removing my manual and error-prone client fetcher writing, and ensuring type consistency
    between my backend and frontend. This significantly reduced the persistent type
    errors that were undermining my app’s reliability.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, having type constraints for your backend routes only helps if your
    frontend enforces those type constraints — which naturally requires **TypeScript**.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, I’m currently undergoing the arduous process of defining response models
    for my FastAPI backend, and converting my frontend from JavaScript to TypeScript,
    a process that you can avoid if you start with FastAPI and TypeScript from the
    start!
  prefs: []
  type: TYPE_NORMAL
- en: '**About deployment…**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through my data science / ML classes, I’ve grown used to hopping onto Google
    Colab, pressing play, and voila, the code runs. So, it’s no surprise that the
    very thought of deployment fills me with dread. But as the founder of the Buildspace
    accelerator puts it, you need to “GTFOL” (Get The F Off Localhost) to make your
    software apps accessible to the world. Hence, I naturally wanted the deployment
    to be as painless as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip #5: Use Modal for GPU backend**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to deploy your own models (e.g. ML models, image recognition, Whisper
    for transcription, or more recently, open-source LLMs like Llama), you will need
    a GPU cloud provider to host your model.
  prefs: []
  type: TYPE_NORMAL
- en: My advice is to choose [Modal](https://modal.com/) and never look back.
  prefs: []
  type: TYPE_NORMAL
- en: Modal stands out with its superb documentation and learning resources, complete
    with up-to-date sample code for the latest applications — from fine-tuning open-source
    LLMs to serving LLM chatbots, and more.
  prefs: []
  type: TYPE_NORMAL
- en: I actually started my entire podcast-transcribing app forking Modal’s sample
    [audio-transcription code](https://modal.com/docs/examples/whisper-transcriber),
    and so it isn’t an exaggeration to say that without Modal I wouldn’t have built
    my app.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f819ee82a0792bb0b91397c0af79f527.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Modal’s dashboard is very user-friendly when monitoring and error tracking.
    Image by author. Source: modal.com'
  prefs: []
  type: TYPE_NORMAL
- en: Modal shines in its user-friendliness (and coming from someone who loathes deployment,
    that’s saying a lot). Just write cloud functions on my local code editor, and
    deploy it using one terminal command. Its dashboard is so user-friendly (especially
    compared to AWS), allowing me to track my app’s usage, analyze performance, and
    trace errors very easily.
  prefs: []
  type: TYPE_NORMAL
- en: Last of all, Modal serves as my escape valve when it comes to functionality
    that Lambda doesn’t have, or is tedious to implement, e.g. file storage (this
    will come in useful in the next point…) and scheduling functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip #6: Use AWS Lambda for backend deployment and Vercel for frontend**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When hosting my Python backend, I was confused over whether to use Amazon EC2
    or AWS Lambda. My app requires the storage of audio files (which could get big),
    and since Lambda’s serverless architecture isn’t meant to store files (it had
    2 GB of ephemeral storage, but it isn’t persistent), I had thought I had to use
    Amazon EC2\. However, EC2 was much more cumbersome to configure, and being an
    always-on dedicated instance, it would be much more expensive and difficult to
    scale.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Modal’s free file storage came into the rescue, and I was able
    to structure my backend to be compatible with Lambda, while downloading and storing
    files when needed on Modal.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, [this video](https://www.youtube.com/watch?v=VYk3lwZbHBU) was really
    good, and following their instructions exactly enabled me to successfully deploy
    my backend.
  prefs: []
  type: TYPE_NORMAL
- en: For my frontend, [Vercel](https://vercel.com/guides/deploying-react-with-vercel)
    was all I needed. The process was hassle-free and, aside from domain name costs,
    entirely free.
  prefs: []
  type: TYPE_NORMAL
- en: '**Making life easier**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last 3 miscellaneous tips that would save you from wasting massive amounts
    of time in development…
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip #7:** **don’t build your own landing page using React**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Yet another mistake I did because all those full-stack tutorials fooled me into
    thinking I had to code my own landing page with React. Sure, you can (and I did),
    but there’s a low ceiling of performance and aesthetics — precisely the important
    traits you need for a successful landing page.
  prefs: []
  type: TYPE_NORMAL
- en: React is only better for custom functionality like the actual AI app interface.
    For the landing page with purely static content, you should instead, use no-code
    site builders like [Webflow](https://webflow.com/) or [Framer](https://www.framer.com/)
    to rapidly build landing pages (and outsource landing page creation to your designer
    so you can work on other things!)
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip #8: Firebase + Stripe for user authentication and payments**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to user authentication, the number of options and tutorials out
    there can once again be overwhelming. I needed a solution that not only handled
    authentication but also integrated with a payment system to control access based
    on user subscription status.
  prefs: []
  type: TYPE_NORMAL
- en: After spending days trying and failing to use several different authentication
    solutions e.g. auth0, I found that Stripe + Firebase worked well. Firebase has
    a Stripe integration that updates users’ subscription status upon successful payment,
    and Firebase’s React client does client-side authentication, and Python client
    does server access control well. Following these two videos ([here](https://www.youtube.com/watch?v=P0Udy2Gi7n8)
    and [here](https://www.youtube.com/watch?v=UhrmPH3TLus)) enabled me to successfully
    implement this on my app.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip #9: Implement Sentry for error monitoring**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For months, I had no clue what bugs users encountered with my app in production.
    Only when myself or a user spots a bug, do I comb through AWS Cloudwatch interface
    to try to find the backend bug.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/bf6403d8b346f68bccfc0ff5d1e8a7d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sentry tracks errors in your apps in production (both frontend and backend).
    Image by author. Source: sentry.io.'
  prefs: []
  type: TYPE_NORMAL
- en: This continued until my co-founder introduced me to [Sentry](https://sentry.io),
    a tool for performance monitoring and error tracking of cloud apps. It’s really
    easy to initialize for your frontend and backend, and you can even integrate it
    with Slack to get instant error notifications. Just be careful not to deplete
    your free plan’s monthly error budget on a trivial but frequent error like authentication
    timeout. That’s what happened to me — and I had to subscribe to the paid plan
    to find logs for the important bugs I actually wanted to solve.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bonus Tip #10:** don’t try to build a web app using Spotify’s API! I wasted
    my app for 2 months assuming I could integrate Spotify’s API to allow users to
    load their saved podcasts. But to productionize this, you need to apply for a
    quota extension request, which takes more than a month for Spotify to review.
    And they’ll probably reject the application anyway if your app involves any AI/ML
    model (despite my app not actually using Spotify data to train any model, the
    wording that is prohibited in their Developer Policy).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope this technical guide demystifies some aspects of web app development
    for fellow data science enthusiasts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you found this post helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: 'do check out my other Medium articles: [how to summarize long texts using AI](/summarize-podcast-transcripts-and-long-texts-better-with-nlp-and-ai-e04c89d3b2cb),
    [generating music using deep learning](https://medium.com/towards-data-science/generating-music-using-deep-learning-cb5843a9d55e)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: try out my [app](http://podsmartai.com) — [Podsmart](http://podsmartai.com)
    transcribes and summarizes podcasts and YouTube videos, saving busy intellectuals
    hours of listening
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: follow me on [LinkedIn](https://www.linkedin.com/in/isaacthamhy/) or [Twitter/X](https://twitter.com/thamsuppp),
    and reach out via messages or comments! I’ve love to bounce ideas about all things
    data science and AI
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thanks for reading!
  prefs: []
  type: TYPE_NORMAL

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Algorithmic Alchemy with The Fast Fourier Transform</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Algorithmic Alchemy with The Fast Fourier Transform</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithmic-alchemy-with-the-fast-fourier-transform-9d52a5b6d94a?source=collection_archive---------4-----------------------#2024-01-07">https://towardsdatascience.com/algorithmic-alchemy-with-the-fast-fourier-transform-9d52a5b6d94a?source=collection_archive---------4-----------------------#2024-01-07</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="1b10" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">The Ultimate Guide to Mechanics of the FFT Algorithm<br/>with Applications in Signal Processing</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://namanagr03.medium.com/?source=post_page---byline--9d52a5b6d94a--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Naman Agrawal" class="l ep by dd de cx" src="../Images/6bb885397aec17f5029cfac7f01edad9.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*bK6r-T7HXs0aByFOGPsiOw.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--9d52a5b6d94a--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://namanagr03.medium.com/?source=post_page---byline--9d52a5b6d94a--------------------------------" rel="noopener follow">Naman Agrawal</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--9d52a5b6d94a--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">20 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Jan 7, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">3</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div></div></div><div class="mj bh"><figure class="mk ml mm mn mo mj bh paragraph-image"><img src="../Images/2e440a307dfe2736c835abb923c47bc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:4200/format:webp/1*Xmht-jv-n6L93F6X7xnc8g.jpeg"/><figcaption class="mq mr ms mt mu mv mw bf b bg z dx">Photo by Stephen Niemeier: <a class="af mx" href="https://www.pexels.com/photo/black-and-silver-mixing-board-63703/" rel="noopener ugc nofollow" target="_blank">https://www.pexels.com/photo/black-and-silver-mixing-board-63703/</a></figcaption></figure></div><div class="ab cb"><div class="ci bh ev ew ex ey"><h1 id="53e5" class="my mz fq bf na nb nc gq nd ne nf gt ng nh ni nj nk nl nm nn no np nq nr ns nt bk">Contents</h1><ol class=""><li id="0fb2" class="nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op oq or os bk">Introduction</li><li id="58e0" class="nu nv fq nw b go ot ny nz gr ou ob oc od ov of og oh ow oj ok ol ox on oo op oq or os bk">What is the Fourier Transform?<br/>2.1 Time Domain<br/>2.2 Frequency Domain<br/>2.3 The Fourier Transform: A Mathematical Perspective</li><li id="590b" class="nu nv fq nw b go ot ny nz gr ou ob oc od ov of og oh ow oj ok ol ox on oo op oq or os bk">The Limitation of the Traditional Discrete Fourier Transformation Calculation</li><li id="016d" class="nu nv fq nw b go ot ny nz gr ou ob oc od ov of og oh ow oj ok ol ox on oo op oq or os bk">The FFT Algorithm</li><li id="3016" class="nu nv fq nw b go ot ny nz gr ou ob oc od ov of og oh ow oj ok ol ox on oo op oq or os bk">The Matrix View</li><li id="1cec" class="nu nv fq nw b go ot ny nz gr ou ob oc od ov of og oh ow oj ok ol ox on oo op oq or os bk">The Bottom Line</li></ol><blockquote class="oy oz pa"><p id="43b8" class="nu nv pb nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk"><strong class="nw fr">Note:</strong> The entire code file used in this article is available at the following repository: <a class="af mx" href="https://github.com/namanlab/FFT_Algorithm_Code" rel="noopener ugc nofollow" target="_blank">https://github.com/namanlab/FFT_Algorithm_Code</a></p></blockquote><h1 id="6b47" class="my mz fq bf na nb nc gq nd ne nf gt ng nh ni nj nk nl nm nn no np nq nr ns nt bk">Introduction</h1><p id="d0af" class="pw-post-body-paragraph nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op fj bk ph"><span class="l pi pj pk bo pl pm pn po pp ed">T</span>he very foundations of the world around us, from the behavior of quantum particles to the movement of large celestials are probably governed by algorithms. As the silent architects of our digital cosmos, they are like the gods of the modern era sculpting the contours of our technological reality. Algorithms are omnipotent, as they command the intricacies of reality with unmatched precision and understanding. They manifest an omnipresence, quietly shaping our experiences, guiding all of technology, and influencing the very fabric of our interconnected world. Finally, they also exhibit an omniscient prowess as they help mankind decipher complex patterns and navigate the vast realms of data buried within our nature.</p><p id="854d" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">An algorithm isn’t just a method or a technique of doing something, it’s also about doing it efficiently in a way that saves us time and space, the two constraints that basically led to the entire field of their study. In this article, we will explore one of the most brilliant algorithms of the century: the Fast Fourier Transform (FFT) algorithm. The FFT algorithm helped us solve one of the biggest challenges in audio signal processing, namely computing the discrete Fourier transform of a signal in a way that is not only time efficient but also extremely beautiful. I hope that by the end of this article, you will be able to appreciate the sheer elegance of this revolutionary algorithm. Let’s begin!</p><h1 id="b9d1" class="my mz fq bf na nb nc gq nd ne nf gt ng nh ni nj nk nl nm nn no np nq nr ns nt bk">What is the Fourier Transform?</h1><blockquote class="oy oz pa"><p id="18c3" class="nu nv pb nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk"><strong class="nw fr">Note:</strong> If you’re already familiar with the concept of a Fourier transform, you may skip this section and proceed to the next one, where I’ll talk about the need for the FFT algorithm and how it works.</p></blockquote><p id="bfea" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">The Fourier transformation is essentially a mathematical technique that allows us to convert a signal from its time domain to its frequency domain. But what do you even mean by time and frequency domain? To understand this, first let us think about the fundamental question: what is a signal?</p><p id="1c7a" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">In the simplest sense, a signal is just a variation in a physical quantity. This physical quantity could be anything measurable: speed, voltage, current, pressure, energy, you name it. Signals can be broadly categorized into two domains: time domain and frequency domain.</p><h2 id="78ac" class="pq mz fq bf na pr ps pt nd pu pv pw ng od px py pz oh qa qb qc ol qd qe qf qg bk">Time Domain</h2><p id="21d3" class="pw-post-body-paragraph nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op fj bk">In the time domain, a signal is represented as a function of time. In other words, this means that we can plot/represent the signal’s behavior with respect to time, and you observe how it changes over a specific time interval.</p><p id="3614" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">For example, if you are measuring the voltage across a resistor in an electrical circuit, the signal in the time domain would show you how the voltage varies at different points in time. Similarly, the time domain representation of a sound just shows how the amplitude of the sound wave (which is just the extent of air pressure) varies over time. The signal could be represented mathematically as a function:</p><p id="5fa3" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">x(t) = 2t² + 2t − 1</p><p id="b188" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">This is the continuous representation of the signal x as a direct function of time, t (in seconds). However, for most practical applications, we don’t know the true functional form of the signal. All we have is a discrete sample of the signal (at different points of time) that could be represented as a simple vector such as this:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qh"><img src="../Images/6475e3f9f0b0d1ad717d23714bc9d893.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DN98SB2ns2xM_e80_GjxDA.png"/></div></div></figure><p id="d8c3" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">The vector just shows the value of x at 8 different (equally spaced) intervals of time. The spacing between the time intervals is called the time period, T of the signal. So, if the signal was sampled at intervals of 2 seconds each, the time period would be T = 2 seconds.</p><h2 id="7060" class="pq mz fq bf na pr ps pt nd pu pv pw ng od px py pz oh qa qb qc ol qd qe qf qg bk">Frequency Domain</h2><p id="d519" class="pw-post-body-paragraph nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op fj bk">In the frequency domain, a signal is represented as a function of frequency. Instead of analyzing how a signal changes over time, the focus is on its frequency components or the different frequencies present in the signal. This may be a bit more difficult to understand, so let’s spend some more time talking about this with an example of sound waves. Imagine you’re listening to a piece of music on the radio. In the time domain, you experience the music unfolding over time — how the melody progresses, the rhythm of the beats, and the duration of each note.</p><p id="e1a3" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Now, let’s switch to the frequency domain. Think of the frequency domain as if you’re looking at the music from a different perspective. Instead of focusing on how the music evolves over time, you’re interested in the individual tones or pitches that make up the overall sound. Imagine you can isolate the specific musical notes, such as the deep bass, the mid-range tones, and the high-pitched elements. How cool would that be? Think about what constitutes the music: the individual instruments and the singers. Each instrument and voice present in the music has a unique signature in the frequency domain. The bass guitar might dominate in the lower frequencies, the vocals may cover a broad range, and the cymbals and high hats contribute to the higher frequencies. That’s where the frequency domain steps in as a superhero of sorts; it allows you to break down the complex mixture of sounds into its constituent parts. In essence, it provides a different viewpoint, focusing on the building blocks of a signal’s sound rather than its progression over time.</p><p id="39e6" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">In its frequency domain, the signal could be represented as a function (continuous) like y(f) = 2f² + 3 or as a simple vector (akin to the time domain) such as this:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qm"><img src="../Images/65d2fe194171bf5a3f3186e8695bd11d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*us2C6MRzL-Mx-bcINR0lDQ.png"/></div></div></figure><p id="52c3" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">The vector just shows the amplitude/extent of the presence of the different frequency components. The first element (1) could represent the amplitude of the lowest frequency component (say 1 Hz, Hz is the unit of frequency). Likewise, the second element (2) could represent the amplitude of the next frequency component, and so on.</p><h2 id="ce8c" class="pq mz fq bf na pr ps pt nd pu pv pw ng od px py pz oh qa qb qc ol qd qe qf qg bk">The Fourier Transform: A Mathematical Perspective</h2><p id="e287" class="pw-post-body-paragraph nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op fj bk">Now that we have some idea of how the signal can be represented, visualize the Fourier Transformation as a magical lens that allows you to switch your view between the two representations of signals. . It acts as a bridge between the time and frequency domains, allowing us to analyze and understand signals in both time and frequency perspectives.</p><p id="152a" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Now, we analyze what I just said using some math. The Fourier transformation is a function that takes the signal in its time domain as input and decomposes it into a sum of sine and cosine waves of varying frequencies having their amplitude and phase. The resulting representation is nothing but the frequency domain (or what we also call the spectrum) of the signal. Mathematically, the Fourier transform of a continuous signal in its time domain x(t) is defined as follows:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qn"><img src="../Images/c6ce6618794aa48077be11dc5659614d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7oJXL8D3IC5dklgHSDOJNw.png"/></div></div></figure><p id="51f3" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">where i = √(-1) is the imaginary number. Yes, the Fourier transformation yields a complex output as a result that includes both a complex phase and magnitude. Nevertheless, in many practical scenarios, our focus is primarily on the magnitude of the transformation, and we often disregard the accompanying phase. Given that digitally processed signal is discrete, we can establish the discrete Fourier transform (DFT) as its analogous counterpart:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qo"><img src="../Images/93abde6bdfe38486e2e319f0ea4c2c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFjwCRwXBuI2sJogDG04vw.png"/></div></div></figure><p id="0a7f" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Here we have simply replaced the integral with sum as we may only have discrete time samples and the true functional form of the signal may be unknown to us. Instead of an infinite number of samples, suppose we have a finite number of samples, call it N: the number of time samples or the length of the vector representing the signal. Then we get the so-called short-term Fourier transform of the signal:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qp"><img src="../Images/50b314314b60546639d5fbdc9a15b829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*16FgGKeccwMS7qMcW81Bug.png"/></div></div></figure><p id="47e2" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">where T is the time period. The above function can be computed for any value of f and its magnitude just shows us the extent to which that particular frequency component is present / power of that frequency component. For instance, given the following vector representation, we may compute the Fourier transform at f = 0.5 and f = 0.25:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qq"><img src="../Images/a643a1ff59192a4251ba69f18ee5f6fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kpBa0uYzTxzFt-VNGGO7Gw.png"/></div></div></figure><p id="84f5" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Suppose the values of x are measured in intervals of T = 1 second each. Then,</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qr"><img src="../Images/52853bcf2a5f85511c54a3c5da8d20cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GB5_iYfG1xamBjpaS3XZ5Q.png"/></div></div></figure><p id="b723" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">The above calculation requires the use of some basic complex number properties, mostly the Euler’s identity: exp{πi} = −1. The output, essentially allows us to compare the presence of different frequency components. This leads us to the next question: what values of f do we consider? Theoretically, we could obtain the value of the Fourier transform for any value of f, thus it becomes imperative to find the right range of values of f, for which the Fourier Transform gives a good picture of the underlying signal and is also interchangeable i.e., it can be used to obtain the time domain back. For most practical applications, we only consider frequency bins that are an integral multiple of 1/(TN) where TN is the total duration of the signal (the number of samples N times the duration of each sample, T) we have. The reason for this is closely related to the concept of sampling and the Nyquist-Shannon sampling theorem, an idea that is not particularly relevant to this article. But if you’re curious about it, feel free to refer to this <a class="af mx" href="https://www.techtarget.com/whatis/definition/Nyquist-Theorem" rel="noopener ugc nofollow" target="_blank">page</a>.</p><p id="548b" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Before moving forward, let’s take a moment to summarise everything we’ve covered so far: a signal is just a variation in a physical quantity that can be expressed as a function of time (time domain) or as a function of frequency (frequency domain). Both these representations are equivalent (i.e., one can give us the other) and the Fourier transform is the method for converting one representation to another. The Fourier Transform of a continuous signal is represented as a continuous function in the frequency domain. However, when we work with digital signals (discrete-time signals), we sample the continuous signal at discrete points. This gives us the following formula for computing the short-term discrete Fourier transform of a signal:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qs"><img src="../Images/6e3e93ac5a2de1d8cdcc9be6cae6ee82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HtcKERjL2i8c6sJk-TWRg.png"/></div></div></figure><p id="4c02" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Since we only consider frequencies that are an integral multiple of 1/N, we get the following:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qt"><img src="../Images/5f3e01b397b4e064237d125190336a9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lvEaP3ll51aALhsqiqBOrA.png"/></div></div></figure><p id="16ba" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">where i is the complex number √(-1), j is the index of the sample in the signal and k is the index of the frequency bin for which we’re computing the power. Since it’s cumbersome to write y(k/(NT)) again, we simply define a new function:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qu"><img src="../Images/6fa7b142bf65ede66080a5e128709712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4EJhi0_-NPXNbgYA8h24Q.png"/></div></div></figure><p id="a8ec" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">And that my friends, is the equation for the Fourier Transform that we commonly encounter in textbooks. If you’re still unsure about how and why this works, <!-- -->here’s<!-- --> an excellent explanation of Fourier transforms. For the next section of this article, we will put in some real data to calculate the complete Fourier Transform of a signal, write up some code, and discover the limitations of the traditional approach to computing the Fourier Transform of a signal. This will eventually lead us to the core of this article: the FFT algorithm.</p><h1 id="6ca9" class="my mz fq bf na nb nc gq nd ne nf gt ng nh ni nj nk nl nm nn no np nq nr ns nt bk">The Limitation of the Traditional Discrete Fourier Transformation Calculation</h1><p id="8539" class="pw-post-body-paragraph nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op fj bk">Let’s start this section by calculating the Fourier Transformation of a simple signal consisting of just 8 samples:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qv"><img src="../Images/56977a1b1e5aafffeca430eca7c6f792.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6FTk8MdD4r2E9PxAz2d-RA.png"/></div></div></figure><p id="720a" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">As we can see from the formula, we don’t care about the time period i.e., the intervals at which the quantity is measured as long as it is sampled uniformly. Now, we may proceed to find the Fourier transform by plugging in the values into the formula for different values of k (ranging from k = 0 to k = N — 1 = 7). Consequently, we need to calculate the following:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qw"><img src="../Images/2a4fe2948d3d6c359adf3a45c3e9439d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7l8pQ5aU5y0ZnrnsCaidow.png"/></div></div></figure><p id="b71a" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Let us simplify the calculations by taking α = exp{-2πi/N}. Thus, all we need is:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qx"><img src="../Images/14546f3b8bc0ec19a83bdf35bbce4a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqgZnswwKWymcWj7rjXzxQ.png"/></div></div></figure><p id="90ff" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">and so on for all 8 values of k. This is quite a lengthy calculation. Can we do better? Of course, we can use a simple Python program to do the job for us. Here’s a traditional (referred to as the brute force) approach that essentially goes through every every element in the vector and computes the required term for all values of k from 0 to N — 1:</p><pre class="mk ml mm mn mo qy qz ra bp rb bb bk"><span id="8feb" class="rc mz fq qz b bg rd re l rf rg">import numpy as np<br/><br/>def simple_dft(signal):<br/>    # Get the number of samples in the signal<br/>    N = len(signal)<br/>    <br/>    # Initialize an empty list to store the result (DFT coefficients)<br/>    res = []<br/>    <br/>    # Iterate over each frequency bin (k)<br/>    for k in range(N):<br/>        # Initialize the current DFT coefficient for the given frequency bin<br/>        cur_value = 0<br/>        <br/>        # Iterate over each sample in the signal (j)<br/>        for j in range(N):<br/>            # Calculate the complex exponential term and accumulate<br/>            cur_value += signal[j] * np.exp(-2 * np.pi * 1j * j * k / N)<br/>        <br/>        # Append the result for the current frequency bin to the list<br/>        res.append(np.round(cur_value, 5))<br/>    <br/>    # Return the list of DFT coefficients<br/>    return res<br/><br/>simple_dft([1, 2, 0, 5, 9, 2, 0, 4])<br/># Output: [(23+0j), (-8.70711-0.70711j), (10+5j), (-7.29289-0.70711j), <br/># (-3-0j), (-7.29289+0.70711j), (10-5j), (-8.70711+0.70711j)]</span></pre><p id="14c1" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Using this function, we easily get the 8 DFT coefficients required. We can also verify our calculations using the fft function provided by numpy:</p><pre class="mk ml mm mn mo qy qz ra bp rb bb bk"><span id="f573" class="rc mz fq qz b bg rd re l rf rg"># Compute the FFT using NumPy's fft function<br/>a = np.fft.fft([1, 2, 0, 5, 9, 2, 0, 4])<br/><br/># Compute the DFT using our simple_dft function<br/>b = simple_dft([1, 2, 0, 5, 9, 2, 0, 4])<br/><br/># Check if the results are element-wise close within a tolerance<br/>print(np.allclose(a, b))<br/># Output: True</span></pre><p id="3989" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Cool, we can get the result correctly! But, is the method of calculating really efficient? What do you think is the time complexity of this function? It involves two nested for loops each iterating over the entire range of values from 0 to N — 1. Thus, the time complexity is of the order O(N²). This may not seem too bad, but for most practical applications, an O(N²) time complexity could mean extremely slow time to get the results. Let’s put this to numbers.</p><p id="972a" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Suppose we are computing the Fourier transform of an audio sample that’s just 10 minutes long. For most traditional applications, we often sample at a rate of 22050 i.e., we measure 22050 samples at every second (this may seem a lot, but it really isn’t, this is the sampling rate that’s most commonly used to maintain the quality of the audio sample). This means that we have about 10*60*22050 = 13230000 samples. To take the DFT of this sample, we will therefore need at least N² = 13230000² = 175032900000000 number of computations, and that’s a lot! If you’re using something like C++ (which is one of the most efficient programming languages), the max you can do is possibly 2 × 108 computations per second. This means, that calculating the DFT of a short 10-minute audio would take 175032900000000/200000000 = 2875164.5 seconds or about 10 days! This would make it practically impossible to compute the DFT of large signals, rendering the application of the Fourier transform quite limited. But fear not! Enter the Fast Fourier Transform (FFT), the magical algorithm that swoops in, making DFT computations lightning-fast. It helps reduce the time complexity of DFT calculation from O(N²) to mere O(N log N). For the 10-minute sample, we would now require only 13230000*log(13230000) = 216945507 floating point operations. This translates to a mere 1.08 seconds, much more efficient than the traditional DFT algorithm. This means we’re not just limited to small signals — FFT unleashes the power of Fourier Transforms on massive datasets. Cool, right? But how does the algorithm even work and what makes it so efficient? This leads us to the next section of this article: the FFT algorithm!</p><h1 id="e631" class="my mz fq bf na nb nc gq nd ne nf gt ng nh ni nj nk nl nm nn no np nq nr ns nt bk">The FFT Algorithm</h1><p id="44d3" class="pw-post-body-paragraph nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op fj bk">The core idea of FFT lies in the inherent symmetry of the Fourier Transformation that helps us reduce some of the redundant calculations. FFT works by harnessing the symmetry of the DFT computation and feeding it into an elegant recursive divide and conquer model effectively reducing time complexity from O(N²) to O(N log N). But, what is this symmetry we are talking about? Recall the formula for the DFT computation:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rh"><img src="../Images/925a42546b1f2abd94421c71e83bc445.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LzEOLAmUw8WsSik-4FV2Lw.png"/></div></div></figure><p id="3532" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">What happens if we use this formula for N + k instead of k? Let’s see:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu ri"><img src="../Images/53d1776e1f5a8fe7790b9435a76d7757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0wFoGvZEOQqZzGYY5CCe-Q.png"/></div></div></figure><p id="6a86" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">By the properties of complex numbers, e−2πij = 1 for any value of j. Thus,</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rj"><img src="../Images/72cca2f740eff357bf89cd9c8982985d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOuOInVcOPo-KyoIZvGwNQ.png"/></div></div></figure><p id="d9ee" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">In other words, the value simply repeats itself after k = N. Thus, F(1) = F(N + 1); F(2) = F(N + 2) and so on. This is the reason, why we only compute the Fourier transform as k ranges from 0 to N — 1. The values simply keep on repeating afterward. More generally by simple induction, we have that for any nonnegative integer s ∈ Z≥0,</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rk"><img src="../Images/a363ef3670e88e30c5e4850a4f41346f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gAJIRbJI2tsHG5vqtuiYQ.png"/></div></div></figure><p id="5c79" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">This is the symmetric property that we are going to use to come up with the much faster (as is said in its name), the FFT algorithm. But how do we come up with a divide-and-conquer strategy that uses this symmetry? The idea is to split up the terms into odd and even terms and look at the DFT for each of them separately:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rl"><img src="../Images/febae90b040379bc069c0b81e0c0483c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qoghpy-NOfA00fUtk_gshw.png"/></div></div></figure><p id="a1f8" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">In the above formulation, we’ve split the DFT terms into two groups: one with even indices (j = 2m) and the other with odd indices (j = 2m + 1). As you can see, this gives us two separate DFTs, one computed only on the even terms of the signal, while the other computed on the odd terms. But, does this help us reduce the number of operations? Not yet, as we still need to evaluate all N/2 terms for all values of k from 0 to N — 1 for both odd and even terms i.e., still 2*N*(N/2). Or do we need to? Here’s when we use the symmetric property of FFT! Suppose we can evaluate the above expression for some integral value a that lies between 0 and N/2–1. Thus,</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rm"><img src="../Images/889867d073854882ece317c2309c0237.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icyUEoz1-L7ueaiSUpVBFw.png"/></div></div></figure><p id="cf52" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Using just the value of F₁(a) and F₂(a) (and the symmetric property shown earlier), we can easily calculate the value of F(a + b) = F(c) for some integral value c that lies between N/2 and N — 1:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rn"><img src="../Images/9b83ec13028cf2cab7322d282336363d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FOs8dCHNnr69oEp2Aiz42w.png"/></div></div></figure><p id="6935" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Here’s the key idea! We don’t need to calculate F(c) all over again, this saves us about N/2*N operations every time. All we need to do is calculate F1(a) and F2(a) for every integral value a between 0 and N/2–1 (which takes a total of (N/2)*(N/2) = N²/4 operations for both the even and odd terms. Doing this and applying some simple symmetric logic will allow us to calculate the value of F(k) for all integral values of k between 0 and N — 1, effectively reducing the number of operations from N² to 2 × (N/2) × (N/2) = N²/2 i.e, a factor of half. Isn’t it just amazing?</p><p id="8ff6" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Now, it may seem that we just reduced the time complexity by half, isn’t it still O(N²) at the end of the day? That’s true only if we split up the signal once. But, nothing stops us from splitting it further! We can continue this chain:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu ro"><img src="../Images/cde10681a591a6eb4594361f29c40965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wd2NtUaDcgLZrpx5NhbQ4g.png"/></div></div></figure><p id="78c0" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">If we assume, that N is a power of 2, we can repeat this process for a total r times such that:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rp"><img src="../Images/0c6a9977079c1ad9a1df94f63f45159d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3F9MNewKFIpuvYbketTIw.png"/></div></div></figure><p id="1c07" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Each individual evaluation takes O(N) time to compute, and we do this for r = log2(N) times, giving us a time complexity of O(Nr) = O(N log N) (we can ignore the base of the logarithm when describing time complexities). For those of you who’d like to see this in terms of the recurrence relation, it is given by:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rq"><img src="../Images/a9c3f21c06973f41685ff887ee515e61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v0Ax3PD4Ec5rZ0WgBXU1Kw.png"/></div></div></figure><p id="6d19" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Here, T(N) represents the time complexity of solving a problem of size n. In the case of FFT, it is the number of elements in the input signal, and O(N) represents the time required for combining the results of smaller sub-problems.</p><p id="e026" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">The recurrence relation indicates that to solve a problem of size N, the FFT algorithm recursively divides the problem into two sub-problems of size N/2 (one for the odd terms, and the other for the even terms), computes the solutions for these sub-problems in a total of 2T(N/2) time, and then combines the results in O(N) time. Solving this recurrence relation also leads us to the O(N log N) time complexity shown earlier.</p><p id="d8a8" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Everything looks good in theory! But does this even work? Let’s test it out by writing a simple Python function that calculates the DFT using the FFT algorithm instead. Here’s the code:</p><pre class="mk ml mm mn mo qy qz ra bp rb bb bk"><span id="a14f" class="rc mz fq qz b bg rd re l rf rg">import numpy as np<br/><br/>def nice_fft(signal):<br/>    # Get the number of samples in the signal<br/>    N = len(signal)<br/>    <br/>    # Base case: if the signal has only 1 samples, use simple_dft<br/>    if N == 1:<br/>        return simple_dft(signal)<br/>    else:<br/>        # Initialize an empty list to store the result (DFT coefficients)<br/>        res = []<br/>        <br/>        # Separate the signal into even and odd terms<br/>        even_terms = signal[::2]<br/>        odd_terms = signal[1::2]<br/>        <br/>        # Recursively compute FFT for even and odd terms<br/>        f1 = nice_fft(even_terms)<br/>        f2 = nice_fft(odd_terms)<br/>        <br/>        # Combine the results using the Cooley-Tukey FFT algorithm<br/>        for k in range(N):<br/>            # Calculate the complex exponential term<br/>            mult = np.exp(-2 * np.pi * 1j * k / N)<br/>            # Determine the index for the even and odd terms<br/>            INDEX = (k % int(N / 2))<br/>            # Combine the results for the current frequency bin<br/>            dft_value = f1[INDEX] + mult * f2[INDEX]<br/>            # Append the result for the current frequency bin to the list<br/>            res.append(np.round(dft_value, 5))<br/>        <br/>        # Return the list of DFT coefficients<br/>        return res<br/><br/>nice_fft([1, 2, 0, 5, 9, 2, 0, 4])<br/># Output: [(23+0j), (-8.70711-0.70711j), (10+5j), (-7.29289-0.70711j), <br/># (-3-0j), (-7.29289+0.70711j), (10-5j), (-8.70711+0.70711j)]</span></pre><p id="5753" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">And it gives the same results as before, but much faster! The above code follows a recursive approach based on the divide-and-conquer strategy discussed. Note that this code works only for signals whose length is a power of 2 for simplicity. For signals with a length that is not a power of two, we can simply append 0s at the start or the end to get the desired result. To test our two functions (simple dft and nice fft), we can try to generate a random array of a size corresponding to a large power of 2 and measure the time taken:</p><pre class="mk ml mm mn mo qy qz ra bp rb bb bk"><span id="fd3e" class="rc mz fq qz b bg rd re l rf rg">import timeit<br/><br/># Generate a random array of size 2^14 (16384)<br/>random_array = np.random.rand(2**14)<br/><br/># Measure the execution time for simple_dft<br/>time_simple_dft = timeit.timeit(lambda: simple_dft(random_array), number=1)<br/><br/># Measure the execution time for nice_fft<br/>time_nice_fft = timeit.timeit(lambda: nice_fft(random_array), number=1)<br/><br/># Print the results<br/>print(f"Time taken for simple_dft: {time_simple_dft:.5f} seconds")<br/># Output: Time taken for simple_dft: 149.81244 secondss<br/>print(f"Time taken for nice_fft: {time_nice_fft:.5f} seconds")<br/># Output: Time taken for nice_fft: 1.28395 seconds</span></pre><p id="715d" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">That’s a massive improvement. To get a better view of the time differences, we can also make a line plot (log scale) showing the difference in the amount of time taken for arrays of different sizes:</p><pre class="mk ml mm mn mo qy qz ra bp rb bb bk"><span id="8532" class="rc mz fq qz b bg rd re l rf rg"># Define array sizes to test<br/>array_sizes = [2**n for n in range(5, 14)]  # Sizes from 2^5 to 2^14<br/><br/># Measure execution time for each array size<br/>time_simple_dft = []<br/>time_nice_fft = []<br/><br/>for size in array_sizes:<br/>    random_array = np.random.rand(size)<br/>    time_simple_dft.append(timeit.timeit(lambda: simple_dft(random_array), number=1))<br/>    time_nice_fft.append(timeit.timeit(lambda: nice_fft(random_array), number=1))<br/><br/># Plotting<br/>import matplotlib.pyplot as plt<br/>plt.figure(figsize=(10, 6))<br/>plt.plot(array_sizes, time_simple_dft, label='simple_dft')<br/>plt.plot(array_sizes, time_nice_fft, label='nice_fft')<br/>plt.xlabel('Array Size')<br/>plt.ylabel('Time (seconds)')<br/>plt.title('Execution Time for simple_dft and nice_fft')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rr"><img src="../Images/7a074cc8094107861e13d6d372c6c709.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nLAby9EucY8P0jsNKrdYug.png"/></div></div><figcaption class="mq mr ms mt mu mv mw bf b bg z dx">FFT vs Direct DFT (Time, Log scale)</figcaption></figure><p id="9574" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Isn’t it cool how a simple idea of symmetry nested within the elegant framework of divide and conquer produced such a wonderful algorithm?</p><h1 id="5e5c" class="my mz fq bf na nb nc gq nd ne nf gt ng nh ni nj nk nl nm nn no np nq nr ns nt bk">The Matrix View</h1><p id="14b0" class="pw-post-body-paragraph nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op fj bk">In this article, we started with the formulation of the Fourier Transform and simply manipulated the expression by splitting the odd and even terms to arrive at the FFT algorithm. There’s another way to view it: through the lens of matrix manipulation. The idea is to think of the Fourier transform as simply multiplying the input signal with a matrix (called the Fourier matrix). Recall the definition of the Fourier transform:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu qh"><img src="../Images/35a0b724df982ef027068d2e74793dfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C5zbo9_TSGenA9FkvJXENw.png"/></div></div></figure><p id="6f6a" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">As you can see, each of the individual DFT is calculated by simply taking a linear combination of the signal measurements. We can take α = exp{-2πi/N}, and we get:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rs"><img src="../Images/6d7312967d162c3e78b2f0113c3ab1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpQipBPIal4S0MEjR-dTBQ.png"/></div></div></figure><p id="9dc4" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">This allows us to represent the signal and the transformation using a simple notation of vectors and matrices:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu rt"><img src="../Images/5524de1c5e29f2c682416db4b5e77f41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7I-2C-OwXQrdZ9kWfeNDiw.png"/></div></div></figure><p id="60ad" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">The whole of DFT boils down to finding that big N × N matrix F (called the Fourier matrix) and multiplying it with the input signal. Using the FFT algorithm, we can decompose the Fourier matrix as a product of 3 sparse matrices:</p><figure class="mk ml mm mn mo mj mt mu paragraph-image"><div role="button" tabindex="0" class="qi qj ed qk bh ql"><div class="mt mu ru"><img src="../Images/8872442bc44d14f474b9e9246240a83d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FTR62cPRIB9rDCC9SHjb6g.png"/></div></div></figure><p id="0d1e" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Now it may seem overwhelming, but at the root, it’s just expressing our earlier divide and conquer using matrices. The I_{N/2} is just the identity matrix of N/2 rows/columns, known to us. D_{N/2} is simply the diagonal entries of the first N/2 × N/2 partition of the N × N Fourier matrix F . This can be calculated easily in O(N) as it only requires us to calculate the values of 1, α, α⁴, …., α^{(N/2–1)²}, which just corresponds to the multiplier term in our original formulation.</p><p id="5a12" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">The F_{N/2} corresponds to the recursive sub-problem, the Fourier matrix of size N/2 × N/2. Finally, P is a permutation matrix (a matrix filled with all 0s except for just one 1 in every row/column). The purpose of P is to segregate the odd and even terms of the input signal, by bringing the even terms to the top and the odd terms to the bottom. The rest of the matrix manipulation follows as before. We can keep repeating this process again and again, breaking the Fourier matrix F_{N/2} continuously until we reach the base case when N = 1. As before the time complexity remains O(N log N), it’s just a more elegant way to write down the equations without the messy summations!</p><h1 id="71c5" class="my mz fq bf na nb nc gq nd ne nf gt ng nh ni nj nk nl nm nn no np nq nr ns nt bk">The Bottom Line</h1><p id="44c8" class="pw-post-body-paragraph nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op fj bk">The Fast Fourier Transform (FFT) stands as a testament to the beauty of simplicity and elegance in algorithmic design. It has revolutionized signal processing, data analysis, and various scientific disciplines and its importance lies not only in its computational efficiency, as evidenced by the remarkable speed gains over na ̈ıve approaches, but also in its versatility, enabling breakthroughs in diverse fields such as telecommunications, image processing, and quantum computing. From audio compression algorithms to medical imaging techniques, the FFT underpins a myriad of applications that have become integral to our daily lives.</p><p id="8fcd" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">As we reflect on the journey from a simple idea to a groundbreaking algorithm, it’s awe-inspiring to appreciate how a fundamental understanding of symmetry, coupled with innovative algorithmic design, can yield solutions of profound significance. The FFT, with its elegance and efficiency, encapsulates the essence of ingenuity in computer science. So, next time you marvel at the clarity of a digital image or enjoy the fidelity of a music stream, just remember that behind these technological marvels stands the remarkable FFT — a true testament to the power of simple yet ingenious ideas.</p><p id="6a66" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">Hope you enjoyed reading this article! In case you have any doubts or suggestions, do reply in the comment box. Please feel free to contact me via <a class="af mx" href="mailto:naman.agr03@gmail.com" rel="noopener ugc nofollow" target="_blank">mail</a>.</p><p id="1d6d" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk">If you liked my article and want to read more of them, please follow me.</p><p id="8f01" class="pw-post-body-paragraph nu nv fq nw b go pc ny nz gr pd ob oc od pe of og oh pf oj ok ol pg on oo op fj bk"><strong class="nw fr">Note: </strong>All images (except for the cover image) have been made by the author.</p><h1 id="28a8" class="my mz fq bf na nb nc gq nd ne nf gt ng nh ni nj nk nl nm nn no np nq nr ns nt bk">References</h1><ol class=""><li id="70e6" class="nu nv fq nw b go nx ny nz gr oa ob oc od oe of og oh oi oj ok ol om on oo op oq or os bk">cs.cornell.edu. <a class="af mx" href="https://www.cs.cornell.edu/~bindel/class/cs5220-s10/slides/FFT.pdf." rel="noopener ugc nofollow" target="_blank">https://www.cs.cornell.edu/~bindel/class/cs5220-s10/slides/FFT.pdf.</a> [Accessed 05–01- 2024].</li><li id="342c" class="nu nv fq nw b go ot ny nz gr ou ob oc od ov of og oh ow oj ok ol ox on oo op oq or os bk">The Fast Fourier Transform (FFT): Most Ingenious Algorithm Ever? — youtube.com. <a class="af mx" href="https://www.youtube.com/" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/</a>watch?v=h7apO7q16V0. [Accessed 05–01–2024].</li><li id="0df0" class="nu nv fq nw b go ot ny nz gr ou ob oc od ov of og oh ow oj ok ol ox on oo op oq or os bk">Shaw Talebi. The Fast-Fourier Transform (FFT) — medium.com. <a class="af mx" href="https://medium.com/swlh/" rel="noopener">https://medium.com/swlh/</a> the-fast-fourier-transform-fft-5e96cf637c38#:~:text=The%20FFT%20is%20an%20efficient,the% 20Permutation%20matrix%2C%20used%20above. [Accessed 05–01–2024].</li><li id="7d79" class="nu nv fq nw b go ot ny nz gr ou ob oc od ov of og oh ow oj ok ol ox on oo op oq or os bk">Jake VanderPlas. Understanding the FFT Algorithm — Pythonic Perambulations — jakevdp.github.io. https: //jakevdp.github.io/blog/2013/08/28/understanding-the-fft/. [Accessed 05–01–2024].</li></ol></div></div></div></div>    
</body>
</html>
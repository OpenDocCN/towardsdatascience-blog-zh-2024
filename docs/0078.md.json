["```py\nimport hashlib\nfrom bitarray import bitarray\n\nclass BloomFilter:\n    def __init__(self, size, hash_functions):\n        \"\"\"\n        Initialize the Bloom Filter with a given size and number of hash functions.\n\n        :param size: Size of the Bloom Filter (number of bits in the bit array).\n        :param hash_functions: Number of hash functions to use.\n        \"\"\"\n        self.size = size\n        self.bit_array = bitarray(size)\n        self.bit_array.setall(0)\n        self.hash_functions = hash_functions\n\n    def add(self, item):\n        \"\"\"\n        Add an element to the Bloom Filter.\n\n        :param item: The item to be added to the Bloom Filter.\n        \"\"\"\n        for i in range(self.hash_functions):\n            # Calculate the index using the hash function and update the corresponding bit to 1.\n            index = self._hash_function(item, i) % self.size\n            self.bit_array[index] = 1\n\n    def contains(self, item):\n        \"\"\"\n        Check if an element is likely to be in the Bloom Filter.\n\n        :param item: The item to check for presence in the Bloom Filter.\n\n        :return: True if the element is likely present, False otherwise.\n        \"\"\"\n        for i in range(self.hash_functions):\n            # Calculate the index using the hash function.\n            index = self._hash_function(item, i) % self.size\n            # If any corresponding bit is 0, the item is definitely not in the set.\n            if not self.bit_array[index]:\n                return False\n        # If all corresponding bits are 1, the item is likely in the set.\n        return True\n\n    def _hash_function(self, item, index):\n        \"\"\"\n        To compute the hash function for a given item and index.\n\n        :param item: The item to be hashed.\n        :param index: The index used to vary the input to the hash function.\n\n        :return: An integer value obtained by hashing the concatenated string of item and index.\n        \"\"\"\n        hash_object = hashlib.sha256()\n        hash_object.update((str(item) + str(index)).encode('utf-8'))\n        return int.from_bytes(hash_object.digest(), byteorder='big')\n\n# Example usage:\nsize = 10  # Size of the Bloom Filter\nhash_functions = 3  # Number of hash functions\n\nbloom_filter = BloomFilter(size, hash_functions)\n\n# Add elements to the Bloom Filter\nbloom_filter.add(\"apple\")\nbloom_filter.add(\"banana\")\nbloom_filter.add(\"orange\")\n\n# Check if elements are present in the Bloom Filter\nprint(bloom_filter.contains(\"apple\"))    # True\nprint(bloom_filter.contains(\"grape\"))    # False (not added)\n```", "```py\nimport math\nimport hashlib\nfrom bitarray import bitarray\n\nclass OptimizedBloomFilter:\n    def __init__(self, n=10000, p=0.05):\n        \"\"\"\n        Initialize the Optimized Bloom Filter with dynamically calculated parameters.\n\n        :param n: Expected number of elements to be added.\n        :param p: Acceptable false positive rate.\n        \"\"\"\n        self.n = n\n        self.p = p\n        self.m, self.k = self._calculate_parameters(n, p)\n\n        self.bit_array = bitarray(self.m)\n        self.bit_array.setall(0)\n\n    def add(self, item):\n        \"\"\"\n        Add an element to the Optimized Bloom Filter.\n\n        :param item: The item to be added to the Bloom Filter.\n        \"\"\"\n        for i in range(self.k):\n            index = self._hash_function(item, i) % self.m\n            self.bit_array[index] = 1\n\n    def contains(self, item):\n        \"\"\"\n        Check if an element is likely to be in the Optimized Bloom Filter.\n\n        :param item: The item to check for presence in the Bloom Filter.\n\n        :return: True if the element is likely present, False otherwise.\n        \"\"\"\n        for i in range(self.k):\n            index = self._hash_function(item, i) % self.m\n            if not self.bit_array[index]:\n                return False\n        return True\n\n    def _calculate_parameters(self, n, p):\n        \"\"\"\n        To calculate the optimal parameters m and k based on n and p.\n\n        :param n: Expected number of elements.\n        :param p: Acceptable false positive rate.\n\n        :return: Tuple (m, k) representing the optimal parameters.\n        \"\"\"\n        m = - (n * math.log(p)) / (math.log(2) ** 2)\n        k = (m / n) * math.log(2)\n        return round(m), round(k)\n\n    def _hash_function(self, item, index):\n        \"\"\"\n        To compute the hash function for a given item and index.\n\n        :param item: The item to be hashed.\n        :param index: The index used to vary the input to the hash function.\n\n        :return: An integer value obtained by hashing the concatenated string of item and index.\n        \"\"\"\n        hash_object = hashlib.sha256()\n        hash_object.update((str(item) + str(index)).encode('utf-8'))\n        return int.from_bytes(hash_object.digest(), byteorder='big')\n\n# Example usage:\nexpected_elements = 2000000\nfalse_positive_rate = 0.01\n\noptimized_bloom_filter = OptimizedBloomFilter(expected_elements, false_positive_rate)\n\n# Add elements to the Optimized Bloom Filter\noptimized_bloom_filter.add(\"apple\")\noptimized_bloom_filter.add(\"banana\")\noptimized_bloom_filter.add(\"orange\")\n\n# Check if elements are present in the Optimized Bloom Filter\nprint(optimized_bloom_filter.contains(\"apple\"))    # True\nprint(optimized_bloom_filter.contains(\"grape\"))    # False (not added)\n```", "```py\nimport hashlib\n\nclass CountMinSketch:\n    def __init__(self, m, k):\n        \"\"\"\n        Initialize the Count-Min Sketch with specified width and depth.\n\n        :param width: Number of counters in each hash function's array.\n        :param depth: Number of hash functions.\n        \"\"\"\n        self.width = m\n        self.depth = k\n        self.counters = [[0] * m for _ in range(k)]\n\n    def update(self, item, count=1):\n        \"\"\"\n        Update the Count-Min Sketch with the occurrence of an item.\n\n        :param item: The item to be counted.\n        :param count: The count or frequency of the item (default is 1).\n        \"\"\"\n        for i in range(self.depth):\n            index = self._hash_function(item, i) % self.width\n            self.counters[i][index] += count\n\n    def estimate(self, item):\n        \"\"\"\n        Estimate the count or frequency of an item in the Count-Min Sketch.\n\n        :param item: The item to estimate the count for.\n\n        :return: The estimated count of the item.\n        \"\"\"\n        min_count = float('inf')\n        for i in range(self.depth):\n            index = self._hash_function(item, i) % self.width\n            min_count = min(min_count, self.counters[i][index])\n        return min_count\n\n    def _hash_function(self, item, index):\n        \"\"\"\n        To compute the hash function for a given item and index.\n\n        :param item: The item to be hashed.\n        :param index: The index used to vary the input to the hash function.\n\n        :return: An integer value obtained by hashing the concatenated string of item and index.\n        \"\"\"\n        hash_object = hashlib.sha256()\n        hash_object.update((str(item) + str(index)).encode('utf-8'))\n        return int.from_bytes(hash_object.digest(), byteorder='big')\n\n# Example usage:\nm = 100\nk = 5\n\ncount_min_sketch = CountMinSketch(m, k)\n\n# Update the sketch with occurrences of items\ncount_min_sketch.update(\"apple\", 3)\ncount_min_sketch.update(\"banana\", 5)\ncount_min_sketch.update(\"orange\", 2)\n\n# Estimate counts for items\nprint(count_min_sketch.estimate(\"apple\"))    # Estimated count for \"apple\"\nprint(count_min_sketch.estimate(\"grape\"))    # Estimated count for \"grape\" (not updated)\n```", "```py\nimport hashlib\nimport math\n\nclass OptimizedCountMinSketch:\n    def __init__(self, epsilon, delta):\n        \"\"\"\n        Initialize the Count-Min Sketch with specified width and depth.\n\n        :param epsilon: Quantifies the max deviation from true count (epsilon * n)\n        :param delta: To compute the probabilistic guarantee\n        \"\"\"\n        self.epsilon = epsilon\n        self.delta = delta\n        self.width, self.depth = self._calculate_parameters(epsilon, delta)\n        self.counters = [[0] * self.width for _ in range(self.depth)]\n\n    def update(self, item, count=1):\n        \"\"\"\n        Update the Count-Min Sketch with the occurrence of an item.\n\n        :param item: The item to be counted.\n        :param count: The count or frequency of the item (default is 1).\n        \"\"\"\n        for i in range(self.depth):\n            index = self._hash_function(item, i) % self.width\n            self.counters[i][index] += count\n\n    def estimate(self, item):\n        \"\"\"\n        Estimate the count or frequency of an item in the Count-Min Sketch.\n\n        :param item: The item to estimate the count for.\n\n        :return: The estimated count of the item.\n        \"\"\"\n        min_count = float('inf')\n        for i in range(self.depth):\n            index = self._hash_function(item, i) % self.width\n            min_count = min(min_count, self.counters[i][index])\n        return min_count\n\n    def _calculate_parameters(self, epsilon, delta):\n        \"\"\"\n        To calculate the optimal parameters m and k based on s and e.\n\n        :param epsilon: Quantifies the max deviation from true count (epsilon * n)\n        :param delta: To compute the probabilistic guarantee\n\n        :return: Tuple (m, k) representing the optimal parameters.\n        \"\"\"\n        m = math.ceil(math.e/epsilon)\n        k = math.ceil(math.log(1/delta))\n        return m, k\n\n    def _hash_function(self, item, index):\n        \"\"\"\n        To compute the hash function for a given item and index.\n\n        :param item: The item to be hashed.\n        :param index: The index used to vary the input to the hash function.\n\n        :return: An integer value obtained by hashing the concatenated string of item and index.\n        \"\"\"\n        hash_object = hashlib.sha256()\n        hash_object.update((str(item) + str(index)).encode('utf-8'))\n        return int.from_bytes(hash_object.digest(), byteorder='big')\n\n# Example usage:\neps = 0.01\ndelta = 0.05\n\noptimized_count_min_sketch = OptimizedCountMinSketch(eps, delta)\n\n# Update the sketch with occurrences of items\noptimized_count_min_sketch.update(\"apple\", 3)\noptimized_count_min_sketch.update(\"banana\", 5)\noptimized_count_min_sketch.update(\"orange\", 2)\n\n# Estimate counts for items\nprint(count_min_sketch.estimate(\"apple\"))    # Estimated count for \"apple\"\nprint(count_min_sketch.estimate(\"grape\"))    # Estimated count for \"grape\" (not updated)\n```"]
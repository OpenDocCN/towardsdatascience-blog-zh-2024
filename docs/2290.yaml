- en: Improving Code Quality with Array and DataFrame Type Hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/improving-code-quality-with-array-and-dataframe-type-hints-cac0fb75cc11?source=collection_archive---------5-----------------------#2024-09-19](https://towardsdatascience.com/improving-code-quality-with-array-and-dataframe-type-hints-cac0fb75cc11?source=collection_archive---------5-----------------------#2024-09-19)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How generic type specification permits powerful static analysis and runtime
    validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@flexatone?source=post_page---byline--cac0fb75cc11--------------------------------)[![Christopher
    Ariza](../Images/35208ace15080724e4cd6690e43d6502.png)](https://medium.com/@flexatone?source=post_page---byline--cac0fb75cc11--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--cac0fb75cc11--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--cac0fb75cc11--------------------------------)
    [Christopher Ariza](https://medium.com/@flexatone?source=post_page---byline--cac0fb75cc11--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--cac0fb75cc11--------------------------------)
    ·10 min read·Sep 19, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a75b36f65c66b95f33aea2faefea4dbb.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by Author
  prefs: []
  type: TYPE_NORMAL
- en: As tools for Python type annotations (or hints) have evolved, more complex data
    structures can be typed, improving maintainability and static analysis. Arrays
    and DataFrames, as complex containers, have only recently supported complete type
    annotations in Python. NumPy 1.22 introduced generic specification of arrays and
    dtypes. Building on NumPy’s foundation, [StaticFrame](https://github.com/static-frame/static-frame)
    2.0 introduced complete type specification of DataFrames, employing NumPy primitives
    and variadic generics. This article demonstrates practical approaches to fully
    type-hinting arrays and DataFrames, and shows how the same annotations can improve
    code quality with both static analysis and runtime validation.
  prefs: []
  type: TYPE_NORMAL
- en: '[StaticFrame](https://github.com/static-frame/static-frame) is an open-source
    DataFrame library of which I am an author.'
  prefs: []
  type: TYPE_NORMAL
- en: Type Hints Improve Code Quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type hints (see [PEP 484](https://peps.python.org/pep-0484/)) improve code quality
    in a number of ways. Instead of using variable names or comments to communicate
    types, Python-object-based type annotations provide maintainable and expressive
    tools for type specification. These type annotations can be tested with type checkers
    such as `mypy` or `pyright`, quickly discovering potential bugs without executing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The same annotations can be used for runtime validation. While reliance on duck-typing
    over runtime validation is common in Python, runtime validation is more often
    needed with complex data structures such as arrays and DataFrames. For example,
    an interface expecting a DataFrame argument, if given a Series, might not need
    explicit validation as usage of the wrong type will likely raise. However, an
    interface expecting a 2D array of floats, if given an array of Booleans, might
    benefit from validation as usage of the wrong type may not raise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many important typing utilities are only available with the most-recent versions
    of Python. Fortunately, the `typing-extensions` package back-ports standard library
    utilities for older versions of Python. A related challenge is that type checkers
    can take time to implement full support for new features: many of the examples
    shown here require at least `mypy` 1.9.0.'
  prefs: []
  type: TYPE_NORMAL
- en: Elemental Type Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without type annotations, a Python function signature gives no indication of
    the expected types. For example, the function below might take and return any
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding type annotations, the signature informs readers of the expected types.
    With modern Python, user-defined and built-in classes can be used to specify types,
    with additional resources (such as `Any`, `Iterator`, `cast()`, and `Annotated`)
    found in the standard library `typing` module. For example, the interface below
    improves the one above by making expected types explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When used with a type checker like `mypy`, code that violates the specifications
    of the type annotations will raise an error during static analysis (shown as comments,
    below). For example, providing an integer when a Boolean is required is an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Static analysis can only validate statically defined types. The full range of
    runtime inputs and outputs is often more diverse, suggesting some form of runtime
    validation. The best of both worlds is possible by reusing type annotations for
    runtime validation. While there are libraries that do this (e.g., `typeguard`
    and `beartype`), StaticFrame offers `CallGuard`, a tool specialized for comprehensive
    array and DataFrame type-annotation validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Python decorator is ideal for leveraging annotations for runtime validation.
    `CallGuard` offers two decorators: `[@CallGuard](http://twitter.com/CallGuard).check`,
    which raises an informative `Exception` on error, or `[@CallGuard](http://twitter.com/CallGuard).warn`,
    which issues a warning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further extending the `process0` function above with `[@CallGuard](http://twitter.com/CallGuard).check`,
    the same type annotations can be used to raise an `Exception` (shown again as
    comments) when runtime objects violate the requirements of the type annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'While type annotations must be valid Python, they are irrelevant at runtime
    and can be wrong: it is possible to have correctly verified types that do not
    reflect runtime reality. As shown above, reusing type annotations for runtime
    checks ensures annotations are valid.'
  prefs: []
  type: TYPE_NORMAL
- en: Array Type Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python classes that permit component type specification are “generic”. Component
    types are specified with positional “type variables”. A list of integers, for
    example, is annotated with `list[int]`; a dictionary of floats keyed by tuples
    of integers and strings is annotated `dict[tuple[int, str], float]`.
  prefs: []
  type: TYPE_NORMAL
- en: With NumPy 1.20, `ndarray` and `dtype` become generic. The generic `ndarray`
    requires two arguments, a shape and a `dtype`. As the usage of the first argument
    is still under development, `Any` is commonly used. The second argument, `dtype`,
    is itself a generic that requires a type variable for a NumPy type such as `np.int64`.
    NumPy also offers more general generic types such as `np.integer[Any]`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an array of Booleans is annotated `np.ndarray[Any, np.dtype[np.bool_]]`;
    an array of any type of integer is annotated `np.ndarray[Any, np.dtype[np.integer[Any]]]`.
  prefs: []
  type: TYPE_NORMAL
- en: As generic annotations with component type specifications can become verbose,
    it is practical to store them as type aliases (here prefixed with “T”). The following
    function specifies such aliases and then uses them in a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, when used with `mypy`, code that violates the type annotations will
    raise an error during static analysis. For example, providing an integer when
    a Boolean is required is an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface requires 8-bit signed integers (`np.int8`); attempting to use
    a different sized integer is also an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While some interfaces might benefit from such narrow numeric type specifications,
    broader specification is possible with NumPy’s generic types such as `np.integer[Any]`,
    `np.signedinteger[Any]`, `np.float[Any]`, etc. For example, we can define a new
    function that accepts any size signed integer. Static analysis now passes with
    both `TNDArrayInt8` and `TNDArrayInt64` arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as shown above with elements, generically specified NumPy arrays can be
    validated at runtime if decorated with `CallGuard.check`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'StaticFrame provides utilities to extend runtime validation beyond type checking.
    Using the `typing` module’s `Annotated` class (see [PEP 593](https://peps.python.org/pep-0593/)),
    we can extend the type specification with one or more StaticFrame `Require` objects.
    For example, to validate that an array has a 1D shape of `(24,)`, we can replace
    `TNDArrayIntAny` with `Annotated[TNDArrayIntAny, sf.Require.Shape(24)]`. To validate
    that a float array has no NaNs, we can replace `TNDArrayFloat64` with `Annotated[TNDArrayFloat64,
    sf.Require.Apply(lambda a: ~a.insna().any())]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a new function, we can require that all input and output arrays
    have the shape `(24,)`. Calling this function with the previously created arrays
    raises an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: DataFrame Type Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like a dictionary, a DataFrame is a complex data structure composed of
    many component types: the index labels, column labels, and the column values are
    all distinct types.'
  prefs: []
  type: TYPE_NORMAL
- en: A challenge of generically specifying a DataFrame is that a DataFrame has a
    variable number of columns, where each column might be a different type. The Python
    `TypeVarTuple` variadic generic specifier (see [PEP 646](https://peps.python.org/pep-0646/)),
    first released in Python 3.11, permits defining a variable number of column type
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: With StaticFrame 2.0, `Frame`, `Series`, `Index` and related containers become
    generic. Support for variable column type definitions is provided by `TypeVarTuple`,
    back-ported with the implementation in `typing-extensions` for compatibility down
    to Python 3.9.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generic `Frame` requires two or more type variables: the type of the index,
    the type of the columns, and zero or more specifications of columnar value types
    specified with NumPy types. A generic `Series` requires two type variables: the
    type of the index and a NumPy type for the values. The `Index` is itself generic,
    also requiring a NumPy type as a type variable.'
  prefs: []
  type: TYPE_NORMAL
- en: With generic specification, a `Series` of floats, indexed by dates, can be annotated
    with `sf.Series[sf.IndexDate, np.float64]`. A `Frame` with dates as index labels,
    strings as column labels, and column values of integers and floats can be annotated
    with `sf.Frame[sf.IndexDate, sf.Index[np.str_], np.int64, np.float64]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a complex `Frame`, deriving the annotation might be difficult. StaticFrame
    offers the `via_type_clinic` interface to provide a complete generic specification
    for any component at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As shown with arrays, storing annotations as type aliases permits reuse and
    more concise function signatures. Below, a new function is defined with generic
    `Frame` and `Series` arguments fully annotated. A `cast` is required as not all
    operations can statically resolve their return type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These more complex annotated interfaces can also be validated with `mypy`. Below,
    a `Frame` without the expected column value types is passed, causing `mypy` to
    error (shown as comments, below).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To use the same type hints for runtime validation, the `sf.CallGuard.check`
    decorator can be applied. Below, a `Frame` of three integer columns is provided
    where a `Frame` of two columns is expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It might not be practical to annotate every column of every `Frame`: it is
    common for interfaces to work with `Frame` of variable column sizes. `TypeVarTuple`
    supports this through the usage of `*tuple[]` expressions (introduced in Python
    3.11, back-ported with the `Unpack` annotation). For example, the function above
    could be defined to take any number of integer columns with that annotation `Frame[IndexDate,
    Index[np.str_], *tuple[np.int64, ...]]`, where `*tuple[np.int64, ...]]` means
    zero or more integer columns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same implementation can be annotated with a far more general specification
    of columnar types. Below, the column values are annotated with `np.number[Any]`
    (permitting any type of numeric NumPy type) and a `*tuple[]` expression (permitting
    any number of columns): `*tuple[np.number[Any], …]`. Now neither `mypy` nor `CallGuard`
    errors with either previously created `Frame`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As with NumPy arrays, `Frame` annotations can wrap `Require` specifications
    in `Annotated` generics, permitting the definition of additional run-time validations.
  prefs: []
  type: TYPE_NORMAL
- en: Type Annotations with Other Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While StaticFrame might be the first DataFrame library to offer complete generic
    specification and a unified solution for both static type analysis and run-time
    type validation, other array and DataFrame libraries offer related utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Neither the `Tensor` class in PyTorch (2.4.0), nor the `Tensor` class in TensorFlow
    (2.17.0) support generic type or shape specification. While both libraries offer
    a `TensorSpec` object that can be used to perform run-time type and shape validation,
    static type checking with tools like `mypy` is not supported.
  prefs: []
  type: TYPE_NORMAL
- en: As of Pandas 2.2.2, neither the Pandas `Series` nor `DataFrame` support generic
    type specifications. A number of third-party packages have offered partial solutions.
    The `pandas-stubs` library, for example, provides type annotations for the Pandas
    API, but does not make the `Series` or `DataFrame` classes generic. The Pandera
    library permits defining `DataFrameSchema` classes that can be used for run-time
    validation of Pandas DataFrames. For static-analysis with `mypy`, Pandera offers
    alternative `DataFrame` and `Series` subclasses that permit generic specification
    with the same `DataFrameSchema` classes. This approach does not permit the expressive
    opportunities of using generic NumPy types or the unpack operator for supplying
    variadic generic expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python type annotations can make static analysis of types a valuable check of
    code quality, discovering errors before code is even executed. Up until recently,
    an interface might take an array or a DataFrame, but no specification of the types
    contained in those containers was possible. Now, complete specification of component
    types is possible in NumPy and StaticFrame, permitting more powerful static analysis
    of types.
  prefs: []
  type: TYPE_NORMAL
- en: Providing correct type annotations is an investment. Reusing those annotations
    for runtime checks provides the best of both worlds. StaticFrame’s `CallGuard`
    runtime type checker is specialized to correctly evaluate fully specified generic
    NumPy types, as well as all generic StaticFrame containers.
  prefs: []
  type: TYPE_NORMAL

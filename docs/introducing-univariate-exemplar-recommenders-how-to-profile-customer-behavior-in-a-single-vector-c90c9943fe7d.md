# 介绍单变量样本推荐系统：如何在一个向量中描述客户行为

> 原文：[https://towardsdatascience.com/introducing-univariate-exemplar-recommenders-how-to-profile-customer-behavior-in-a-single-vector-c90c9943fe7d?source=collection_archive---------3-----------------------#2024-12-04](https://towardsdatascience.com/introducing-univariate-exemplar-recommenders-how-to-profile-customer-behavior-in-a-single-vector-c90c9943fe7d?source=collection_archive---------3-----------------------#2024-12-04)

## 客户画像

## 调查并改进当前的客户画像方法

[](https://medium.com/@ardito.bryan?source=post_page---byline--c90c9943fe7d--------------------------------)[![Michelangiolo Mazzeschi](../Images/9211748ac638d2ed07679ac73ea17296.png)](https://medium.com/@ardito.bryan?source=post_page---byline--c90c9943fe7d--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--c90c9943fe7d--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--c90c9943fe7d--------------------------------) [Michelangiolo Mazzeschi](https://medium.com/@ardito.bryan?source=post_page---byline--c90c9943fe7d--------------------------------)

·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--c90c9943fe7d--------------------------------) ·阅读时长17分钟·2024年12月4日

--

> ***要理解本文，需具备**嵌入、聚类和推荐系统**的相关知识。此算法的实现已发布在[GitHub](https://github.com/atlantis-nova/univariate-sequential-recommender)并完全开源。**我欢迎批评**，并**欢迎任何反馈**。

如今，大多数平台都意识到，为每个客户量身定制个人化选择会提高用户参与度。正因如此，**推荐系统领域一直在不断发展**，每年都会诞生新的算法。

![](../Images/d918db3f6c1275e082b084893edeb392.png)

层次聚类，**图像来源：作者**

不幸的是，**目前没有现有的分类体系在跟踪**该领域的所有算法。虽然大多数推荐算法，如矩阵分解，使用神经网络基于一系列选择进行推荐，但在本文中，我将专注于那些**采用基于向量的架构来跟踪用户偏好的算法**。

# 样本推荐系统

由于嵌入的简单性，每个可以推荐的样本（例如产品、内容等）都通过一个预训练的神经网络（例如矩阵分解）转化为一个向量：然后我们可以使用knn算法推荐相似的产品/客户。遵循这种范式的算法被称为**基于向量的推荐系统**。然而，当这些模型考虑到用户的先前选择时，**它们为基础架构增加了一个顺序层**，并在技术上被称为**基于向量的** **顺序推荐系统**。由于这些架构越来越难以记忆（和发音），我将它们称为**样本推荐系统**：它们从初始选择集中提取一组代表性向量来表示**用户向量**。

![](../Images/2791e63bf766ddfe1cf2da8d8b469e9a.png)

推荐系统的细分，**图片来源：作者**

基于该架构构建的第一个系统之一是**Pinterest**，它运行在[其Pinnersage推荐引擎](https://medium.com/pinterest-engineering/pinnersage-multi-modal-user-embedding-framework-for-recommendations-at-pinterest-bfd116b49475)之上：这个可扩展的引擎能够管理超过20亿个钉图，运行其特定架构并**对每个用户的选择进行聚类**。正如我们所想，这在扩展时代表了一个计算挑战。尤其是在发现**协变量编码**后，我想介绍四种互补的架构（其中两种，特别是文章中提到的名称），它们可以**减轻聚类算法的压力**，在尝试分析每个客户时。你可以参考以下图示来区分它们。

![](../Images/736be38c19281ee285c158b9b656dd4e.png)

样本推荐系统概述，**图片来源：作者**

请注意，以上所有方法都属于基于内容的过滤，而**非协同过滤**。关于样本架构，我们可以识别出**两个主要定义参数**：**堆栈内聚类实现**（我们可以在样本嵌入或用户嵌入上执行聚类），以及**用于存储用户偏好的向量数量**。

# 堆栈内聚类实现

再以Pinnersage为例，我们可以看到它是如何为每个用户执行**一个新颖的聚类迭代**。尽管从准确度的角度来看，这具有优势，但从计算角度而言，非常耗费资源。

## 后聚类

当聚类应用于用户嵌入时，我们可以将这种方法（在此特定堆栈中）称为**后聚类**。尽管这种方法看起来效率不高，但在数十亿个样本上应用非参数聚类算法几乎是不可能的，可能也不是最好的选择。

## 预聚类

在某些使用案例中，在样本数据上应用聚类可能是有利的：我们可以将这种方法（在这个特定的堆栈中）称为**预聚类**。例如，零售商店可能需要跟踪数百万用户的历史记录，这将需要与Pinnersage架构相同的计算资源。

然而，与Pinterest平台相比，零售商店的样本数量**不应超过10,000**，而后者则是惊人的**20亿**。在如此少量的样本下，对样本嵌入进行聚类**非常高效**，如果合理利用，这也将减轻对用户嵌入进行聚类的需求。

# 引入单变量架构

如前所述，创建这些架构时面临的最大挑战是可扩展性。每个用户有**数百个过去的选择记录**，需要为**示例提取**进行计算。

## 多变量架构

构建基于向量的推荐系统的最常见方式是将每个用户选择与现有的预计算向量绑定。然而，即使我们采用衰减函数来最小化在计算中需要考虑的向量数量，我们仍然需要**在计算时填充所有的向量缓存**。此外，在检索时，向量不能存储在执行计算的机器上，而需要从数据库中查询：这为可扩展性带来了额外的挑战。

这种方法的流程是推荐中的方差有限。推荐的样本将在空间上非常接近（样本方差最小化），并且仅属于同一类别（除非有更复杂的逻辑定义这种交互）。

![](../Images/309a8b6ba10a2d190222402b49ef26d0.png)

多变量示例推荐，**图片由作者提供**

何时使用：这种方法（我这里只考虑模型的行为，而非其计算需求）适用于那些**我们可以推荐一批来自同一类别的样本**的应用。艺术或社交媒体应用就是一个例子。

## 单变量架构

使用这种新方法，我们可以通过一个单一的向量来存储每个用户的选择，并随着时间推移不断更新。这应该是可扩展性的显著提升，最小化来自**knn**和**检索**的计算压力。

更复杂的是，我们有两个索引可以进行聚类。我们可以聚类**项目**或**类别**（两者都使用标签标注）。没有绝对优越的方法，我们必须根据使用案例选择其中一个。

## > 基于类别

本文完全基于构建基于类别的模型。在标记数据后，我们可以执行**聚类，将数据分组为类别层次结构**（如果我们的数据已经按类别组织，则无需应用层次聚类）。

这种方法的主要优点是，指示用户偏好的示例将与相似类别相关联（增加了产品的多样性）。

![](../Images/f0a97569cbae95f0f87036ceadefcc2b.png)

单变量基于类别的示例推荐，**图片由作者提供**

何时使用：有时，我们希望向客户推荐整个类别，而不是单个产品。例如，如果我们的用户喜欢购买衬衫（而且碰巧示例位于**红色衬衫**的潜在区域），我们更有利于推荐他整个服装类别，而不是**仅仅红色衬衫**。这种方法最适合零售和时尚公司。

## > 基于项目

使用基于项目的方法，我们是在对样本进行聚类。这将允许我们捕捉数据的更细粒度信息，而不是仅仅关注分开的类别：我们希望超越产品分类的限制，并跨现有类别推荐项目。

![](../Images/b0111b8cd5ace445e774e16f707bdb73.png)

单变量基于项目的示例推荐，**图片由作者提供**

何时使用：能够充分利用这种方法的最佳公司是人力资源公司和拥有跨类别产品的零售商（例如：视频游戏）。

# 单变量示例推荐系统

最后，我们可以深入解释基于类别方法背后的架构。该算法将通过**仅存储一个单一的向量**来执行示例提取：唯一能够管理它的技术是**协变量编码**，因此**我们将使用标签**来处理数据。由于它使用**预聚类**，它非常适合样本数量可管理但用户数量无限制的应用场景。

在这个例子中，我将使用开源的**Steam游戏库**集合（[可从Kaggle下载](https://www.kaggle.com/datasets/fronkongames/steam-games-dataset) — [MIT许可证](https://www.mit.edu/~amini/LICENSE.md)），这是一个完美的适用于大规模推荐系统的案例：Steam最多使用450个标签，并且该数量可能会随着时间的推移有所增加；然而，**它是可管理的**。这些标签可以很容易地进行聚类，**如果我们对聚类分配有疑问，甚至可以进行手动干预**。最后，它服务于数百万用户，证明它是**一个现实的应用案例**。

![](../Images/65304e7769ea6e3d06f49ac9958745e3.png)

Steam游戏数据集的示例，**图片由作者提供**

它的架构可以分为以下几个阶段：

***注意，当创建此架构的样本代码时，我使用LLM使整个过程**摆脱任何人为监督**。然而，**LLM仍然是可选的**，虽然它们可能会提高推荐系统的水平，但它们不是这个系统的核心部分。

1.  样本标注

    我们需要确保为每个样本分配标签。由于语义标签过滤，我们不需要依赖零样本，而是可以让LLM在没有任何监督的情况下管理此过程。

1.  预聚类

    我们将把标签嵌入分成不同的聚类。为了提高准确性，我们将使用**层次聚类**，深度为3。

1.  聚类标注

    一旦我们定义了聚类树，就需要为每个生成的超级聚类打上标签。我们仍然可以使用LLM来实现这一目的。如果你决定避免使用LLM，需要注意的是，聚类可以保持为数字形式（这可能只是改变了推荐系统用户的感知）。

1.  平衡非均匀标签频率

    从标签列表中挑选标签的第一个挑战是，出现频率最高的标签（并且被分配到一个聚类中）会严重偏向推荐系统**建议该聚类**。我们需要确保每个聚类有相同的推荐概率。我们可以通过添加一个自定义的倍增器来实现这一点，从而统一每个聚类被推荐的概率。

1.  单变量序列编码

    现在我们已经定义了编码权重，可以将用户历史编码为一个向量，并且可以随着时间的推移更新它（使用衰减函数来去除过时的用户偏好）。

1.  考虑可扩展性：剪枝机制

    因为我们的向量维度等于标签的数量，所以我们需要找到一种方法来限制向量的大小。PCA是一个有效的选择，但由于对向量的求和操作，特征剪枝已被证明更为高效。

1.  示例估算

    创新之处在于这里。我们可以将用户档案**编码为单一示例**，**并且仍然获得单独的聚类推荐**，而不会有因为将多个示例平均化而导致的信息丢失。这意味着之前的所有多变量方法都与此架构不兼容。

让我们从对单变量示例推荐系统的全面解释开始：

## 1\. 样本标注

在我们的参考数据集中，所有样本已经使用标签进行了标注。如果我们恰好正在处理带标签的数据，可以轻松使用LLM来完成这项工作，**通过提示请求为每个样本列出标签**。正如我在关于语义标签过滤的文章中所解释的那样，我们不需要使用零样本来指导标签选择，整个过程可以完全无监督。

![](../Images/23bfbf713c6524eaa34c3b854c8b5df8.png)

我们的样本数据截图，每个样本都标注了标签，**图像由作者提供**

## 2\. 预聚类

如前所述，该推荐系统背后的想法是首先将数据组织成簇，然后识别出最常见的簇（示例簇），这些簇定义了每个用户的偏好。由于数据理想情况下非常小（数千个标签对比数十亿个样本），因此聚类不再是一种负担，可以在标签嵌入上进行，而**不是在数百万个用户嵌入上**。

标签数量越多，使用层次结构来管理其复杂性就越有意义。理想情况下，我不仅希望跟踪每个用户的主要兴趣，还希望跟踪**他们的子兴趣**并据此进行推荐。通过使用树状图，我们可以通过**使用阈值水平**来定义不同层次的簇。

第一个超级簇（第一层）将是使用阈值11.4的结果，生成前81个簇。我们还可以看到它们的分布是不均匀的（一些簇比其他簇大），但总体来看，并不会过于偏斜。

![](../Images/1fb4156cb9e3ba2388e560fa57b2e64c.png)

层次聚类，第一层，阈值=11.4，**图像来源：作者**

![](../Images/09e6f67f767fc4b0b96b752b9da264f5.png)

第一层聚类的所有簇大小，**图像来源：作者**

下一个聚类层级将由一个较小的阈值（9）定义，它将数据组织成181个簇。同样，第一层聚类的大小分布不均匀，但只有两个大簇，因此这不应是一个大问题。

![](../Images/27ec7f451249f727f4b7667d98a6556a.png)

层次聚类，第二层，阈值=9，**图像来源：作者**

![](../Images/ebd50f4535567bb1b45eb9d06eeb0f5a.png)

第二层聚类的所有簇大小，**图像来源：作者**

这些阈值是随意选择的。尽管**有非参数聚类算法**可以在没有任何人工输入的情况下执行聚类过程，但它们管理起来相当具有挑战性，尤其是在大规模数据上，并且会出现一些副作用，比如**簇大小的分布不均匀**。如果我们的簇中有一些过大（例如，某个簇可能占据总体数据的20%），那么它们可能会包含大部分推荐内容，但并没有太多意义。

我们在执行聚类时的优先事项是**在最大化簇的数量的同时获得最均匀的分布**，以便尽可能多地划分数据并进行不同的表示。

## 3\. 聚类标记

因为我们选择在现有数据的基础上对两个层次的深度进行聚类，所以我们达到了总共三层。最后一层由单个标签构成，并且是唯一的标记层。其他两层则仅包含簇编号，没有适当的命名。

为了解决这个问题（请注意，这一步骤中的超级簇标记并非强制执行，但可以改善用户与我们推荐系统的交互方式），我们可以在超级簇之上使用大型语言模型（LLM）。

让我们尝试通过将每个组中的标签喂入来自动标记所有簇：

![](../Images/5cf71c6a898b38ca7d779b7921154232.png)

不同深度的簇标签，**图片来自作者**

现在，我们的簇也已经正确标记完毕，可以开始构建我们的序列推荐系统的基础了。

## 4. 平衡非均匀标签频率

到目前为止，我们已经完成了简单的部分。现在我们已经准备好了所有元素来创建推荐系统，但我们仍然需要调整不平衡。虽然展示这一步骤在推荐系统完成之后会更加直观，但不幸的是，它是推荐系统基础结构的一部分，你需要和我一起承担这个部分。

## 4.1 如果我们跳过平衡呢？

让我们稍微提前一点，展示完成的推荐系统的能力，简单地**跳过这个必要的步骤**。通过给每个标签分配1的得分，有些标签会非常常见，从而严重扭曲推荐得分。

以下是一个蒙特卡洛模拟**来自数据集的5000次随机标签选择**。我们所看到的是在加总得分后被随机选择的簇的分布。正如我们所见，分布高度倾斜，肯定会使推荐系统倾向于得分最高的簇。

![](../Images/18af5b555ed587667fe24d0fe67e92aa.png)

在10k次模拟中推荐的簇频率，**图片来自作者**

例如，簇**“黑暗北欧王国”**包含标签**独立游戏**，它出现在64%的所有样本中（基本上几乎不可能不反复选择）。

![](../Images/d9c04470b7d75d0810db6ee85642ea54.png)

推荐簇的示例，**图片来自作者**

为了更精确一些，让我们直接模拟100次不同的随机会话，每次选择**会话中的前3个簇**（我们跟踪的主要用户偏好），让我们模拟整个用户会话，以便数据更完整。尤其是在使用衰减函数时，分布不均匀且随时间不断变化是正常的。

![](../Images/1194c03cc13c07c59ea1bb2c4d06832a.png)

在10k次模拟中推荐的簇频率，**图片来自作者**

然而，如果倾斜过度，结果就是大多数用户**95%的时间将会推荐前5%的簇**（这不是精确的数字，只是为了证明我的观点）。

## 4.2 平衡概率分布

**相反**，让我们使用一个适当的频率调整公式。由于每个簇的概率不同，我们希望分配一个得分，在用它来平衡我们用户向量的权重时，**能够平衡簇的检索：**

![](../Images/3e1caf0f15a64ec7ed217ae81ea38b1d.png)

用于平衡概率非均匀性的得分函数，**图片来自作者**

让我们看一下为**4个不同的随机簇**分配的得分：

![](../Images/0135220f5fb5a238c79b7cfb8a1ef387.png)

推荐聚类的示例，**作者提供的图片**

如果我们将评分应用于随机选择（5000次选择，计数频率并调整上述**权重**），我们可以看到标签分布现在已经平衡（轮廓~“肾上腺素冲击”是由重复名称引起的）：

![](../Images/177ebdc4f83d3186500aa718391e901b.png)

10k次模拟中的聚类概率，**作者提供的图片**

事实上，通过查看波动的正态分布，我们可以看到，选择任何一个聚类的标准差大约是0.1，**这非常低**（尤其是与之前相比）。

![](../Images/96ba2f4a02e2a0f3f14b9119710dd98e.png)

10k次模拟中的波动分布，**作者提供的图片**

通过复制100次会话，我们可以看到，即使是伪均匀的概率分布，聚类也会随着时间的推移，遵循帕累托原则积累。

![](../Images/c26f6ebf20506d50f86549f157ceb8dc.png)

10k次模拟中的推荐聚类频率，**作者提供的图片**

## **5. 单变量顺序编码**

现在是构建顺序机制的时候，以跟踪用户的选择随时间的变化。我理想化的机制**基于两个独立的向量**（经过处理后最终合并成一个，因此是单变量的），分别是**历史向量**和**缓存向量**。

**历史向量**用于在现有聚类上执行k近邻算法。一旦会话结束，我们将使用新的用户选择更新历史向量。同时，我们会通过一个衰减函数调整现有的值，使得现有的权重随着时间的推移逐渐减少。通过这样做，我们确保跟上客户的趋势，并**给新选择赋予更多权重，而不是旧的选择**。

与其在每次用户做出选择时更新向量（这在计算上效率较低，此外，我们还可能会让较旧的选择过早衰减，因为每次用户交互都会触发衰减机制），**我们可以存储一个临时向量**，该向量仅对当前会话有效。每次用户交互转化为向量**并使用标签频率作为独热权重**，将被加到现有的缓存向量中。

![](../Images/c2b1254238d7ad8f05e0f56050143d74.png)

向量和流工作流程，**作者提供的图片**

一旦会话结束，我们将从数据库中检索历史向量，将其与缓存向量合并，并**应用调整机制**，例如衰减函数和修剪机制，正如我们稍后所见）。历史向量更新后，将替换旧的向量并存储在数据库中。

![](../Images/03b301f6696962b86a1f8eb98a594437.png)

会话推荐器工作流程，**作者提供的图片**

采用这种方法的两个原因是：最小化旧的和新的交互之间的权重差异，以及使整个过程具有可扩展性和计算效率。

## 6. 修剪机制

系统已经完成。然而，存在一个额外的问题：协变量编码有一个缺陷：其基础向量**是根据编码标签的数量按比例缩放的**。例如，如果我们的数据库达到10万标签，向量将具有等同数量的维度。

原始的协变量编码架构已经考虑到这个问题，提出了一种PCA压缩机制作为解决方案。然而，当应用到我们的推荐系统时，PCA在迭代求和向量时会导致信息丢失。因为每次用户选择都会将现有向量与新的向量相加，因此这种解决方案不建议使用。

然而，如果我们无法压缩向量，我们可以修剪掉得分最低的维度。系统将基于向量中最相关的得分执行kNN；这种直接的特征工程方法不会对最终推荐结果产生负面影响（更好的是，不会过度影响）。

![](../Images/46c1392526fd1dff0a09f0e42bbeef5e.png)

修剪机制，**图像由作者提供**

通过修剪我们的向量，我们可以任意设置向量的最大维度数。在不改变标签索引的情况下，我们可以开始操作稀疏向量，而不是密集向量，稀疏向量是一种只保存我们向量中活动索引的数据结构，能够实现无限扩展。我们可以将从完整向量（密集向量）获得的推荐与稀疏向量（修剪向量）进行比较。

![](../Images/b204cc738fbcbbf25a164ce6503df5d7.png)

使用**密集**向量与**稀疏**向量进行相同用户向量推荐，**图像由作者提供**

如我们所见，我们可以察觉到一些细微的差别，但向量的整体完整性保持了下来，**以换取可扩展性**。这种过程的一个非常直观的替代方法是，在标签级别进行聚类，保持向量大小固定。在这种情况下，标签将需要分配给语义上最接近的标签，并且不会占用其专有的维度。

## 7\. 示例估计

现在你已经完全掌握了这种新方法背后的理论，我们可以更清楚地进行比较。在多变量方法中，第一步是使用聚类识别出用户的主要偏好。如我们所见，这个过程需要我们存储尽可能多的向量，以作为示例。

![](../Images/55e9fe07679c0340a30f4bd9c6e2f76c.png)

示例提取，**图像由作者提供**

然而，在单变量方法中，**因为协变量编码作用于编码数据的转置版本**，我们可以**使用我们历史向量的部分**来存储用户偏好，从而只使用一个向量完成整个过程。使用**历史向量作为查询**在编码标签中进行搜索：其**来自kNN搜索的top-k结果**将等同于top-k偏好聚类。

![](../Images/5cf17d3e31b20326a241e4f55ab28ced.png)

多变量与单变量向量集的区别，**图像由作者提供**

## 8\. 推荐方法

既然我们已经捕捉到多个偏好，我们如何规划推荐项目？这是两个系统之间的主要区别。传统的多变量推荐系统将使用示例来**推荐k个项目**给用户。然而，我们的系统已经为客户分配了一个超级簇和其下的顶级子簇（根据我们的标签分割级别，我们可以增加层级数）。我们不会推荐前k个项目，而是**推荐前k个子簇**。

## 使用groupby代替向量搜索

到目前为止，我们一直使用向量来存储数据，但这**并不意味着我们需要依赖向量搜索**来执行推荐，因为它比SQL操作要慢得多。请注意，确实可以使用向量搜索在用户数组上获得完全相同的结果。

如果你在疑惑为什么要从基于向量的系统切换到基于计数的系统，这是一个合理的问题。简单的回答是**这是多变量系统最忠实的复制品**（如参考图像所示），但它具有更高的可扩展性（使用pandas在16个CPU核心上可以达到每秒3000个推荐）。最初，单变量推荐系统设计是使用向量搜索的，但正如所展示的，存在更简单、更好的搜索算法。

# 模拟

让我们进行一个完整的测试，我们可以监控它。我们可以使用示例笔记本中的代码：对于我们的简单示例，用户至少选择一个**带有相应标签的**游戏。

```py
# if no vector exists, the first choices are the historical vector
historical_vector = user_choices(5, tag_lists=[['Shooter', 'Fantasy']], tag_frequency=tag_frequency, display_tags=False)

# day1
cached_vector = user_choices(3, tag_lists=[['Puzzle-Platformer'], ['Dark Fantasy'], ['Fantasy']], tag_frequency=tag_frequency, display_tags=False)
historical_vector = update_vector(historical_vector, cached_vector, 1, 0.8)

# day2
cached_vector = user_choices(3, tag_lists=[['Puzzle'], ['Puzzle-Platformer']], tag_frequency=tag_frequency, display_tags=False)
historical_vector = update_vector(historical_vector, cached_vector, 1, 0.8)

# day3
cached_vector = user_choices(3, tag_lists=[['Adventure'], ['2D', 'Turn-Based']], tag_frequency=tag_frequency, display_tags=False)
historical_vector = update_vector(historical_vector, cached_vector, 1, 0.8)

compute_recommendation(historical_vector, label_1_max=3)
```

在三次会话结束时，这些是从我们的推荐系统**提取的前三个示例（label_1）**：

![](../Images/9ba1cb6df92b3ec947667c1b4c82be9e.png)

三次会话后的推荐，**图像由作者提供**

在这个笔记本中，你将找到执行蒙特卡洛模拟的选项，但验证它们的方式并不简单（主要是因为团队游戏没有被标记为最高准确度，而且我注意到大多数小型游戏列出了太多不相关或常见的标签）。

# 结论

最受欢迎的推荐系统架构仍然没有考虑会话历史，但随着新算法的发展和计算能力的提高，现在可以应对更高层次的复杂性。

这种新方法应该为市场上可用的**顺序推荐系统**提供一种全面的替代方案，但我相信总有改进的空间。为了进一步增强这一架构，可以考虑从**基于聚类**的方法切换到**基于网络**的方法。

需要注意的是，这个推荐系统只有在应用于有限数量的领域时才能表现出色，但在计算资源匮乏或需求极高的情况下，仍具有闪光的潜力。

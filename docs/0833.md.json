["```py\nconst messages: ChatCompletionMessageParam[] = [];\n\nconsole.log(StaticPrompts.welcome);\n\nmessages.push(SystemPrompts.context);\n\nconst userPrompt = await createUserMessage();\nmessages.push(userPrompt);\n```", "```py\nexport const StaticPrompts = {\n  welcome:\n    \"Welcome to the farm assistant! What can I help you with today? You can ask me what I can do.\",\n  fallback: \"I'm sorry, I don't understand.\",\n  end: \"I hope I was able to help you. Goodbye!\",\n} as const;\n```", "```py\nimport OpenAI from \"openai\";\ntype ChatCompletionUserMessageParam = OpenAI.ChatCompletionUserMessageParam;\n\ntype UserPromptKey = \"task\";\ntype UserPromptValue = (userInput?: string) => ChatCompletionUserMessageParam;\n\nexport const UserPrompts: Record<UserPromptKey, UserPromptValue> = {\n  task: (userInput) => ({\n    role: \"user\",\n    content: userInput || \"What can you do?\",\n  }),\n};\n```", "```py\nimport OpenAI from \"openai\";\ntype ChatCompletionSystemMessageParam = OpenAI.ChatCompletionSystemMessageParam;\n\ntype SystemPromptKey = \"context\";\n\nexport const SystemPrompts: Record<\n  SystemPromptKey,\n  ChatCompletionSystemMessageParam\n> = {\n  context: {\n    role: \"system\",\n    content:\n      \"You are an farm visit assistant. You are upbeat and friendly. You introduce yourself when first saying `Howdy!`. If you decide to call a function, you should retrieve the required fields for the function from the user. Your answer should be as precise as possible. If you have not yet retrieve the required fields of the function completely, you do not answer the question and inform the user you do not have enough information.\",\n  },\n};\n```", "```py\nimport OpenAI from \"openai\";\ntype ChatCompletionToolMessageParam = OpenAI.ChatCompletionToolMessageParam;\n\ntype FunctionPromptKey = \"function_response\";\n\ntype FunctionPromptValue = (\n  args: Omit<ChatCompletionToolMessageParam, \"role\">\n) => ChatCompletionToolMessageParam;\n\nexport const FunctionPrompts: Record<FunctionPromptKey, FunctionPromptValue> = {\n  function_response: (options) => ({\n    role: \"tool\",\n    ...options,\n  }),\n};\n```", "```py\nimport OpenAI from \"openai\";\nimport {\n  ConvertTypeNameStringLiteralToType,\n  JsonAcceptable,\n} from \"../utils/type-utils.js\";\n\ntype ChatCompletionTool = OpenAI.ChatCompletionTool;\ntype FunctionDefinition = OpenAI.FunctionDefinition;\n\n// An enum to define the names of the functions. This will be shared between the function descriptions and the actual functions\nexport enum DescribedFunctionName {\n  FileComplaint = \"file_complaint\",\n  getFarms = \"get_farms\",\n  getActivitiesPerFarm = \"get_activities_per_farm\",\n  bookActivity = \"book_activity\",\n}\n// This is a utility type to narrow down the `parameters` type in the `FunctionDefinition`.\n// It pairs with the keyword `satisfies` to ensure that the properties of parameters are correctly defined.\n// This is a workaround as the default type of `parameters` in `FunctionDefinition` is `type FunctionParameters = Record<string, unknown>` which is overly broad.\ntype FunctionParametersNarrowed<\n  T extends Record<string, PropBase<JsonAcceptable>>\n> = {\n  type: JsonAcceptable; // basically all the types that JSON can accept\n  properties: T;\n  required: (keyof T)[];\n};\n// This is a base type for each property of the parameters\ntype PropBase<T extends JsonAcceptable = \"string\"> = {\n  type: T;\n  description: string;\n};\n// This utility type transforms parameter property string literals into usable types for function parameters.\n// Example: { email: { type: \"string\" } } -> { email: string }\nexport type ConvertedFunctionParamProps<\n  Props extends Record<string, PropBase<JsonAcceptable>>\n> = {\n  [K in keyof Props]: ConvertTypeNameStringLiteralToType<Props[K][\"type\"]>;\n};\n// Define the parameters for each function\nexport type FileComplaintProps = {\n  name: PropBase;\n  email: PropBase;\n  text: PropBase;\n};\nexport type GetFarmsProps = {\n  location: PropBase;\n};\nexport type GetActivitiesPerFarmProps = {\n  farm_name: PropBase;\n};\nexport type BookActivityProps = {\n  farm_name: PropBase;\n  activity_name: PropBase;\n  datetime: PropBase;\n  name: PropBase;\n  email: PropBase;\n  number_of_people: PropBase<\"number\">;\n};\n\n// Define the function descriptions\nconst FunctionDescriptions: Record<\n  DescribedFunctionName,\n  FunctionDefinition\n> = {\n  [DescribedFunctionName.FileComplaint]: {\n    name: DescribedFunctionName.FileComplaint,\n    description: \"File a complaint as a customer\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        name: {\n          type: \"string\",\n          description: \"The name of the user, e.g. John Doe\",\n        },\n        email: {\n          type: \"string\",\n          description: \"The email address of the user, e.g. john@doe.com\",\n        },\n        text: {\n          type: \"string\",\n          description: \"Description of issue\",\n        },\n      },\n      required: [\"name\", \"email\", \"text\"],\n    } satisfies FunctionParametersNarrowed<FileComplaintProps>,\n  },\n  [DescribedFunctionName.getFarms]: {\n    name: DescribedFunctionName.getFarms,\n    description: \"Get the information of farms based on the location\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        location: {\n          type: \"string\",\n          description: \"The location of the farm, e.g. Melbourne VIC\",\n        },\n      },\n      required: [\"location\"],\n    } satisfies FunctionParametersNarrowed<GetFarmsProps>,\n  },\n  [DescribedFunctionName.getActivitiesPerFarm]: {\n    name: DescribedFunctionName.getActivitiesPerFarm,\n    description: \"Get the activities available on a farm\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        farm_name: {\n          type: \"string\",\n          description: \"The name of the farm, e.g. Collingwood Children's Farm\",\n        },\n      },\n      required: [\"farm_name\"],\n    } satisfies FunctionParametersNarrowed<GetActivitiesPerFarmProps>,\n  },\n  [DescribedFunctionName.bookActivity]: {\n    name: DescribedFunctionName.bookActivity,\n    description: \"Book an activity on a farm\",\n    parameters: {\n      type: \"object\",\n      properties: {\n        farm_name: {\n          type: \"string\",\n          description: \"The name of the farm, e.g. Collingwood Children's Farm\",\n        },\n        activity_name: {\n          type: \"string\",\n          description: \"The name of the activity, e.g. Goat Feeding\",\n        },\n        datetime: {\n          type: \"string\",\n          description: \"The date and time of the activity\",\n        },\n        name: {\n          type: \"string\",\n          description: \"The name of the user\",\n        },\n        email: {\n          type: \"string\",\n          description: \"The email address of the user\",\n        },\n        number_of_people: {\n          type: \"number\",\n          description: \"The number of people attending the activity\",\n        },\n      },\n      required: [\n        \"farm_name\",\n        \"activity_name\",\n        \"datetime\",\n        \"name\",\n        \"email\",\n        \"number_of_people\",\n      ],\n    } satisfies FunctionParametersNarrowed<BookActivityProps>,\n  },\n};\n// Format the function descriptions into tools and export them\nexport const tools = Object.values(\n  FunctionDescriptions\n).map<ChatCompletionTool>((description) => ({\n  type: \"function\",\n  function: description,\n}));\n```", "```py\nexport const startChat = async (messages: ChatCompletionMessageParam[]) => {\n  const response = await openai.chat.completions.create({\n    model: \"gpt-3.5-turbo\",\n    top_p: 0.95,\n    temperature: 0.5,\n    max_tokens: 1024,\n\n    messages, // The messages array we created earlier\n    tools, // The function descriptions we defined earlier\n    tool_choice: \"auto\", // The model will decide whether to call a function and which function to call\n  });\n  const { message } = response.choices[0] ?? {};\n  if (!message) {\n    throw new Error(\"Error: No response from the API.\");\n  }\n  messages.push(message);\n  return processMessage(message);\n};\n```", "```py\n{\n  \"role\": \"assistant\",\n  \"content\": null,\n  \"tool_calls\": [\n    {\n      \"id\": \"call_JWoPQYmdxNXdNu1wQ1iDqz2z\",\n      \"type\": \"function\",\n      \"function\": {\n        \"name\": \"get_farms\", // The function name to be called\n        \"arguments\": \"{\\\"location\\\":\\\"Melbourne\\\"}\" // The arguments required for the function\n      }\n    }\n    ... // multiple function calls can be present\n  ]\n}\n```", "```py\n{\n  \"role\": \"assistant\",\n  \"content\": {\n    \"text\": \"I can help you with that. What is your location?\"\n  }\n}\n```", "```py\ntype ChatCompletionMessageWithToolCalls = RequiredAll<\n  Omit<ChatCompletionMessage, \"function_call\">\n>;\n\n// If the message contains tool_calls, it extracts the function arguments. Otherwise, it returns the content of the message.\nexport function processMessage(message: ChatCompletionMessage) {\n  if (isMessageHasToolCalls(message)) {\n    return extractFunctionArguments(message);\n  } else {\n    return message.content;\n  }\n}\n// Check if the message has `tool calls`\nfunction isMessageHasToolCalls(\n  message: ChatCompletionMessage\n): message is ChatCompletionMessageWithToolCalls {\n  return isDefined(message.tool_calls) && message.tool_calls.length !== 0;\n}\n// Extract function name and arguments from the message\nfunction extractFunctionArguments(message: ChatCompletionMessageWithToolCalls) {\n  return message.tool_calls.map((toolCall) => {\n    if (!isDefined(toolCall.function)) {\n      throw new Error(\"No function found in the tool call\");\n    }\n    try {\n      return {\n        tool_call_id: toolCall.id,\n        function_name: toolCall.function.name,\n        arguments: JSON.parse(toolCall.function.arguments),\n      };\n    } catch (error) {\n      throw new Error(\"Invalid JSON in function arguments\");\n    }\n  });\n}\n```", "```py\nconst result = await startChat(messages);\n\nif (!result) {\n  // Fallback message if response is empty (e.g., network error)\n  console.log(StaticPrompts.fallback);\n} else if (isNonEmptyString(result)) {\n  // If the response is a string, log it and prompt the user for the next message\n  console.log(`Assistant: ${result}`);\n  const userPrompt = await createUserMessage();\n  messages.push(userPrompt);\n} else {\n  // If the response contains function calls, execute the functions and call the model again with the updated messages\n  for (const item of result) {\n    const { tool_call_id, function_name, arguments: function_arguments } = item;\n    // Execute the function and get the function return\n    const functionReturn = await AvailableFunctions[\n      function_name as keyof typeof AvailableFunctions\n    ](function_arguments);\n    // Add the function output back to the messages with a role of \"tool\", the id of the tool call, and the function return as the content\n    messages.push(\n      FunctionPrompts.function_response({\n        tool_call_id,\n        content: functionReturn,\n      })\n    );\n  }\n}\n```", "```py\nfor (const item of result) {\n  const { tool_call_id, function_name, arguments: function_arguments } = item;\n\n  console.log(\n    `Calling function \"${function_name}\" with ${JSON.stringify(\n      function_arguments\n    )}`\n  );\n  // Available functions are stored in an object for easy access\n  const functionReturn = await AvailableFunctions[\n    function_name as keyof typeof AvailableFunctions\n  ](function_arguments);\n}\n```", "```py\nfor (const item of result) {\n  const { tool_call_id, function_name, arguments: function_arguments } = item;\n\n  console.log(\n    `Calling function \"${function_name}\" with ${JSON.stringify(\n      function_arguments\n    )}`\n  );\n  const functionReturn = await AvailableFunctions[\n    function_name as keyof typeof AvailableFunctions\n  ](function_arguments);\n  // Add the function output back to the messages with a role of \"tool\", the id of the tool call, and the function return as the content\n  messages.push(\n    FunctionPrompts.function_response({\n      tool_call_id,\n      content: functionReturn,\n    })\n  );\n}\n```", "```py\n// Mocking getting farms based on location from a database\nexport async function get_farms(\n  args: ConvertedFunctionParamProps<GetFarmsProps>\n): Promise<string> {\n  const { location } = args;\n  return JSON.stringify({\n    location,\n    farms: [\n      {\n        name: \"Farm 1\",\n        location: \"Location 1\",\n        rating: 4.5,\n        products: [\"product 1\", \"product 2\"],\n        activities: [\"activity 1\", \"activity 2\"],\n      },\n      ...\n    ],\n  });\n}\n```", "```py\n{\n  \"role\": \"tool\",\n  \"tool_call_id\": \"call_JWoPQYmdxNXdNu1wQ1iDqz2z\",\n  \"content\": {\n    // Function return value\n    \"location\": \"Melbourne\",\n    \"farms\": [\n      {\n        \"name\": \"Farm 1\",\n        \"location\": \"Location 1\",\n        \"rating\": 4.5,\n        \"products\": [\n          \"product 1\",\n          \"product 2\"\n        ],\n        \"activities\": [\n          \"activity 1\",\n          \"activity 2\"\n        ]\n      },\n      ...\n    ]\n  }\n}\n```", "```py\nconst CHAT_END_SIGNALS = [\n  \"end\",\n  \"goodbye\",\n  ...\n];\n\nexport function isChatEnding(\n  message: ChatCompletionMessageParam | undefined | null\n) {\n  // If the message is not defined, log a fallback message\n  if (!isDefined(message)) {\n    throw new Error(\"Cannot find the message!\");\n  }\n  // Check if the message is from the user\n  if (!isUserMessage(message)) {\n    return false;\n  }\n  const { content } = message;\n  return CHAT_END_SIGNALS.some((signal) => {\n    if (typeof content === \"string\") {\n      return includeSignal(content, signal);\n    } else {\n      // content has a typeof ChatCompletionContentPart, which can be either ChatCompletionContentPartText or ChatCompletionContentPartImage\n      // If user attaches an image to the current message first, we assume they are not ending the chat\n      const contentPart = content.at(0);\n      if (contentPart?.type !== \"text\") {\n        return false;\n      } else {\n        return includeSignal(contentPart.text, signal);\n      }\n    }\n  });\n}\nfunction isUserMessage(\n  message: ChatCompletionMessageParam\n): message is ChatCompletionUserMessageParam {\n  return message.role === \"user\";\n}\nfunction includeSignal(content: string, signal: string) {\n  return content.toLowerCase().includes(signal);\n}\n```"]
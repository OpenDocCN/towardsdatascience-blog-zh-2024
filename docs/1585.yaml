- en: 'How Bend Works: A Parallel Programming Language That â€œFeels Like Python but
    Scales Like CUDAâ€'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bend å¦‚ä½•å·¥ä½œï¼šä¸€ç§â€œæ„Ÿè§‰åƒ Pythonï¼Œä½†æ‰©å±•æ€§åƒ CUDAâ€çš„å¹¶è¡Œç¼–ç¨‹è¯­è¨€
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/how-bend-works-a-parallel-programming-language-that-feels-like-python-but-scales-like-cuda-48be5bf0fc2c?source=collection_archive---------1-----------------------#2024-06-26](https://towardsdatascience.com/how-bend-works-a-parallel-programming-language-that-feels-like-python-but-scales-like-cuda-48be5bf0fc2c?source=collection_archive---------1-----------------------#2024-06-26)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/how-bend-works-a-parallel-programming-language-that-feels-like-python-but-scales-like-cuda-48be5bf0fc2c?source=collection_archive---------1-----------------------#2024-06-26](https://towardsdatascience.com/how-bend-works-a-parallel-programming-language-that-feels-like-python-but-scales-like-cuda-48be5bf0fc2c?source=collection_archive---------1-----------------------#2024-06-26)
- en: A brief introduction to Lambda Calculus, Interaction Combinators, and how they
    are used to parallelize operations on Bend / HVM.
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda æ¼”ç®—ã€äº¤äº’ç»„åˆå­ä»¥åŠå®ƒä»¬å¦‚ä½•ç”¨äºåœ¨ Bend / HVM ä¸Šå¹¶è¡ŒåŒ–æ“ä½œçš„ç®€è¦ä»‹ç»ã€‚
- en: '[](https://medium.com/@lucasdelimanogueira?source=post_page---byline--48be5bf0fc2c--------------------------------)[![Lucas
    de Lima Nogueira](../Images/76edd8ee4005d4c0b8bd476261eb06ae.png)](https://medium.com/@lucasdelimanogueira?source=post_page---byline--48be5bf0fc2c--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--48be5bf0fc2c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--48be5bf0fc2c--------------------------------)
    [Lucas de Lima Nogueira](https://medium.com/@lucasdelimanogueira?source=post_page---byline--48be5bf0fc2c--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@lucasdelimanogueira?source=post_page---byline--48be5bf0fc2c--------------------------------)[![Lucas
    de Lima Nogueira](../Images/76edd8ee4005d4c0b8bd476261eb06ae.png)](https://medium.com/@lucasdelimanogueira?source=post_page---byline--48be5bf0fc2c--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--48be5bf0fc2c--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--48be5bf0fc2c--------------------------------)
    [Lucas de Lima Nogueira](https://medium.com/@lucasdelimanogueira?source=post_page---byline--48be5bf0fc2c--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--48be5bf0fc2c--------------------------------)
    Â·22 min readÂ·Jun 26, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘è¡¨äº [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--48be5bf0fc2c--------------------------------)
    Â·é˜…è¯»æ—¶é—´ï¼š22 åˆ†é’ŸÂ·2024å¹´6æœˆ26æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/398ffec82c1dd32cf300f28b5c5ae933.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/398ffec82c1dd32cf300f28b5c5ae933.png)'
- en: Image by author
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥è‡ªä½œè€…
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å¼•è¨€
- en: If you are reading this article, you probably recently heard about Bend, a new
    programming language that aims to be massively parallel but without you worrying
    about things like threads creation, and other common parallel programming terms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æ­£åœ¨é˜…è¯»è¿™ç¯‡æ–‡ç« ï¼Œä½ å¯èƒ½æœ€è¿‘å¬è¯´è¿‡ Bendï¼Œä¸€ç§æ–°çš„ç¼–ç¨‹è¯­è¨€ï¼Œæ—¨åœ¨å®ç°å¤§è§„æ¨¡å¹¶è¡Œè®¡ç®—ï¼Œä½†ä½ æ— éœ€æ‹…å¿ƒåƒçº¿ç¨‹åˆ›å»ºç­‰å¸¸è§çš„å¹¶è¡Œç¼–ç¨‹æ¦‚å¿µã€‚
- en: 'If you do not know what I am talking about, watch the video below:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ ä¸çŸ¥é“æˆ‘åœ¨è¯´ä»€ä¹ˆï¼Œè¯·è§‚çœ‹ä¸‹é¢çš„è§†é¢‘ï¼š
- en: They claim â€œ***it feels like Python, but scales like CUDAâ€.*** As an enthusiast
    of parallel programming, it caught my attention immediately. After some reading,
    I found that Bend is powered by HVM (Higher-Order Virtual Machine), the runtime
    where the magic happens. That is, in a Bend program, the Bend code is compiled
    into HVM, which does some magic to run this program in an inherently parallel
    manner. In some way, all operations that can be parallelized are automatically
    parallelized by this runtime.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ä»–ä»¬å£°ç§°â€œ***å®ƒæ„Ÿè§‰åƒ Pythonï¼Œä½†æ‰©å±•æ€§åƒ CUDA***â€ã€‚ä½œä¸ºå¹¶è¡Œç¼–ç¨‹çš„çˆ±å¥½è€…ï¼Œè¿™ç«‹åˆ»å¼•èµ·äº†æˆ‘çš„æ³¨æ„ã€‚ç»è¿‡ä¸€ç•ªé˜…è¯»ï¼Œæˆ‘å‘ç° Bend æ˜¯ç”±
    HVMï¼ˆé«˜çº§è™šæ‹Ÿæœºï¼‰é©±åŠ¨çš„ï¼Œè¿™å°±æ˜¯æ‰€æœ‰é­”æ³•å‘ç”Ÿçš„è¿è¡Œæ—¶ç¯å¢ƒã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨ Bend ç¨‹åºä¸­ï¼ŒBend ä»£ç ä¼šè¢«ç¼–è¯‘æˆ HVMï¼ŒHVM é€šè¿‡ä¸€äº›é­”æ³•ä½¿å¾—ç¨‹åºä»¥æœ¬è´¨ä¸Šå¹¶è¡Œçš„æ–¹å¼è¿è¡Œã€‚ä»æŸç§æ„ä¹‰ä¸Šè¯´ï¼Œæ‰€æœ‰å¯ä»¥å¹¶è¡ŒåŒ–çš„æ“ä½œéƒ½è¢«è¿™ä¸ªè¿è¡Œæ—¶è‡ªåŠ¨å¹¶è¡ŒåŒ–äº†ã€‚
- en: 'Straight away, I wanted to learn how all of the HVM magic happens. How can
    all of this be possible? After some reading, I learned that the magic behind HVM
    is mostly based on Interaction Combinators, which is a model of computation based
    on graphs and graphical rules developed by Yves Lafont in the 1990s. So, I opened
    the Lafont [paper](https://core.ac.uk/download/pdf/81113716.pdf), rolled some
    pages and saw this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ç«‹åˆ»ï¼Œæˆ‘å°±æƒ³äº†è§£æ‰€æœ‰ HVM é­”æ³•æ˜¯å¦‚ä½•å‘ç”Ÿçš„ã€‚å¦‚ä½•æ‰èƒ½åšåˆ°è¿™ä¸€åˆ‡ï¼Ÿç»è¿‡ä¸€äº›é˜…è¯»ï¼Œæˆ‘äº†è§£åˆ° HVM èƒŒåçš„é­”æ³•ä¸»è¦åŸºäºäº¤äº’ç»„åˆå­ï¼ˆInteraction
    Combinatorsï¼‰ï¼Œè¿™æ˜¯ä¸€ç§åŸºäºå›¾å½¢å’Œå›¾å½¢è§„åˆ™çš„è®¡ç®—æ¨¡å‹ï¼Œç”± Yves Lafont åœ¨ 1990 å¹´ä»£å¼€å‘ã€‚å› æ­¤ï¼Œæˆ‘æ‰“å¼€äº† Lafont çš„[è®ºæ–‡](https://core.ac.uk/download/pdf/81113716.pdf)ï¼Œç¿»äº†å‡ é¡µï¼Œçœ‹åˆ°äº†è¿™ä¸€éƒ¨åˆ†ï¼š
- en: '![](../Images/8dd7792bc5d746abcd3c81f8bbbb06bf.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8dd7792bc5d746abcd3c81f8bbbb06bf.png)'
- en: ???? Interaction Combinators alien code. Image by author, inspired from [Lafont,
    1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ???? äº¤äº’ç»„åˆå­å¤–æ˜Ÿä»£ç ã€‚å›¾åƒæ¥æºäºä½œè€…ï¼Œçµæ„Ÿæ¥è‡ªäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: I felt like I was in that movie *Arrival*, where the aliens try to communicate
    with us using a strange symbolic language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æ„Ÿè§‰å°±åƒæ˜¯åœ¨ç”µå½± *é™ä¸´* ä¸­ï¼Œå¤–æ˜Ÿäººè¯•å›¾ç”¨ä¸€ç§å¥‡æ€ªçš„ç¬¦å·è¯­è¨€ä¸æˆ‘ä»¬äº¤æµã€‚
- en: Thatâ€™s when I closed the laptop and gave up on trying to understand that.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: å°±æ˜¯åœ¨é‚£æ—¶ï¼Œæˆ‘å…³é—­äº†ç¬”è®°æœ¬ç”µè„‘ï¼Œæ”¾å¼ƒäº†ç†è§£è¿™ä¸ªä¸œè¥¿çš„å°è¯•ã€‚
- en: A while later, when I turned on my machine again, those symbols were there,
    staring at me, as if they were asking me to be understood.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ®µæ—¶é—´åï¼Œå½“æˆ‘å†æ¬¡æ‰“å¼€è®¡ç®—æœºæ—¶ï¼Œé‚£äº›ç¬¦å·ä¾ç„¶åœ¨é‚£é‡Œï¼Œç›¯ç€æˆ‘çœ‹ï¼Œä»¿ä½›å®ƒä»¬åœ¨è¦æ±‚æˆ‘ç†è§£å®ƒä»¬ã€‚
- en: After a lot of reading, watching videos and alien help, I somehow started to
    understand this thing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ç»è¿‡å¤§é‡é˜…è¯»ã€è§‚çœ‹è§†é¢‘å’Œå¤–æ˜Ÿäººçš„å¸®åŠ©åï¼Œæˆ‘ä¸çŸ¥æ€çš„å¼€å§‹ç†è§£è¿™ä¸€ç‚¹ã€‚
- en: The purpose of this article is to briefly clarify how all the HVM magic happens
    and facilitate your further understanding by explaining some common terms you
    might find during your learning journey. In order to do that, we need to first
    learn some basic concepts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬æ–‡çš„ç›®çš„æ˜¯ç®€è¦é˜æ˜ HVM é­”æ³•æ˜¯å¦‚ä½•å‘ç”Ÿçš„ï¼Œå¹¶é€šè¿‡è§£é‡Šä¸€äº›ä½ åœ¨å­¦ä¹ è¿‡ç¨‹ä¸­å¯èƒ½é‡åˆ°çš„å¸¸è§æœ¯è¯­ï¼Œå¸®åŠ©ä½ è¿›ä¸€æ­¥ç†è§£ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å…ˆäº†è§£ä¸€äº›åŸºæœ¬æ¦‚å¿µã€‚
- en: Î»-Calculus (Lambda Calculus)
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Î»-è®¡ç®—ï¼ˆLambda è®¡ç®—ï¼‰
- en: 'The Lambda Calculus is a formal system in mathematical logic created by Alonzo
    Church in the 1930s. Its purpose was to investigate some aspects of logic theory
    from a purely mathematical point of view. Church was aiming to define what is
    computability in mathematical terms (what can be calculated using a set of fundamental
    rules). Letâ€™s start:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda è®¡ç®—æ˜¯ç”±é˜¿éš†ä½Â·ä¸˜å¥‡ï¼ˆAlonzo Churchï¼‰åœ¨ 1930 å¹´ä»£åˆ›å»ºçš„æ•°å­¦é€»è¾‘ä¸­çš„ä¸€ä¸ªå½¢å¼ç³»ç»Ÿã€‚å®ƒçš„ç›®çš„æ˜¯ä»çº¯æ•°å­¦çš„è§’åº¦ç ”ç©¶é€»è¾‘ç†è®ºçš„æŸäº›æ–¹é¢ã€‚ä¸˜å¥‡çš„ç›®æ ‡æ˜¯ç”¨æ•°å­¦æœ¯è¯­å®šä¹‰ä»€ä¹ˆæ˜¯å¯è®¡ç®—æ€§ï¼ˆå³ä»€ä¹ˆå¯ä»¥é€šè¿‡ä¸€ç»„åŸºæœ¬è§„åˆ™æ¥è®¡ç®—ï¼‰ã€‚è®©æˆ‘ä»¬å¼€å§‹ï¼š
- en: 'You probably have already used Lambda Calculus before. For example, imagine
    a function to multiply a number by two:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯èƒ½å·²ç»ä½¿ç”¨è¿‡ Lambda è®¡ç®—äº†ã€‚ä¾‹å¦‚ï¼Œå‡è®¾æœ‰ä¸€ä¸ªå°†æ•°å­—ä¹˜ä»¥äºŒçš„å‡½æ•°ï¼š
- en: f(x) = 2 * x
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: f(x) = 2 * x
- en: 'On Python, you can express a named function for that like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Python ä¸­ï¼Œä½ å¯ä»¥è¿™æ ·è¡¨ç¤ºä¸€ä¸ªå‘½åå‡½æ•°ï¼š
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But you can also express that using lambdas, which are basically an anonymous
    function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨ lambda æ¥è¡¨ç¤ºï¼Œå®ƒæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼š
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, letâ€™s go back to mathematics. In Lambda Calculus, you express this same
    function using the notation *Î»x.2x,* where *x* is the the *parameter* and *2x*
    the *body.*
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œè®©æˆ‘ä»¬å›åˆ°æ•°å­¦ã€‚åœ¨ Lambda è®¡ç®—ä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨ç¬¦å· *Î»x.2x* æ¥è¡¨ç¤ºç›¸åŒçš„å‡½æ•°ï¼Œå…¶ä¸­ *x* æ˜¯ *å‚æ•°*ï¼Œè€Œ *2x* æ˜¯ *ä¸»ä½“*ã€‚
- en: '*Î»<parameter>.<body>*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»<parameter>.<body>*'
- en: This is called an *abstraction.* An abstraction *Î»x.t* denotes an anonymous
    function that takes a single input variable *x* and returns *t.* For example,
    *Î»x.(xÂ²+2x)* is an abstraction representing the function f defined by f(x) = xÂ²+2x.
    So, an abstraction basically defines a function but does not invoke it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å«åš *æŠ½è±¡*ã€‚ä¸€ä¸ªæŠ½è±¡ *Î»x.t* è¡¨ç¤ºä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œè¯¥å‡½æ•°æ¥å—ä¸€ä¸ªè¾“å…¥å˜é‡ *x* å¹¶è¿”å› *t*ã€‚ä¾‹å¦‚ï¼Œ*Î»x.(xÂ²+2x)* æ˜¯ä¸€ä¸ªæŠ½è±¡ï¼Œè¡¨ç¤ºç”±
    f(x) = xÂ²+2x å®šä¹‰çš„å‡½æ•°ã€‚æ‰€ä»¥ï¼ŒæŠ½è±¡åŸºæœ¬ä¸Šå®šä¹‰äº†ä¸€ä¸ªå‡½æ•°ï¼Œä½†å¹¶æ²¡æœ‰è°ƒç”¨å®ƒã€‚
- en: You can also have a term like *Î»x.(x+y)*, which is the definition of f(x) =
    x+y. Here, *y* has not been defined yet. The expression *Î»x.(x+y)* is a valid
    abstraction and represents a function that adds its input to the yet-unknown *y.*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ä¹Ÿå¯ä»¥æœ‰ä¸€ä¸ªåƒ *Î»x.(x+y)* è¿™æ ·çš„é¡¹ï¼Œå®ƒæ˜¯ f(x) = x+y çš„å®šä¹‰ã€‚åœ¨è¿™é‡Œï¼Œ*y* è¿˜æ²¡æœ‰å®šä¹‰ã€‚è¡¨è¾¾å¼ *Î»x.(x+y)* æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æŠ½è±¡ï¼Œè¡¨ç¤ºä¸€ä¸ªå°†è¾“å…¥åŠ ä¸Šå°šæœªçŸ¥é“çš„
    *y* çš„å‡½æ•°ã€‚
- en: If using *Î»x.2x* defines a function, *(Î»x.2x)a â€œ*callsâ€ a function with argument
    â€œ*aâ€*. That is, we basically substitute the variable â€œxâ€ with â€œaâ€.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½¿ç”¨ *Î»x.2x* å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œ*(Î»x.2x)a* å°±æ˜¯â€œè°ƒç”¨â€ä¸€ä¸ªå¸¦æœ‰å‚æ•°â€œaâ€çš„å‡½æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬åŸºæœ¬ä¸Šæ˜¯å°†å˜é‡â€œxâ€æ›¿æ¢ä¸ºâ€œaâ€ã€‚
- en: f(x) = 2x
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: f(x) = 2x
- en: f(2) = 4
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: f(2) = 4
- en: 'This is the same as:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ä»¥ä¸‹ç­‰ä»·ï¼š
- en: '*Î»x.2x*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»x.2x*'
- en: '*(Î»x.2x)2 = 4*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»x.2x)2 = 4*'
- en: This is called an *application.* We are â€œapplyingâ€ the *abstraction (Î»x.2x)*
    to the number *2.*
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å«åš *åº”ç”¨*ã€‚æˆ‘ä»¬æ­£åœ¨å°† *æŠ½è±¡ (Î»x.2x)* åº”ç”¨åˆ°æ•°å­— *2* ä¸Šã€‚
- en: 'You can also apply a lambda expression to another lambda expression, such as
    nested functions:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ ä¹Ÿå¯ä»¥å°†ä¸€ä¸ª lambda è¡¨è¾¾å¼åº”ç”¨åˆ°å¦ä¸€ä¸ª lambda è¡¨è¾¾å¼ä¸­ï¼Œåƒæ˜¯åµŒå¥—å‡½æ•°ï¼š
- en: Take f(x) = 2x and g(x) = xÂ³
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: è®¾ f(x) = 2x å’Œ g(x) = xÂ³
- en: 'And you want g(f(x)):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åä½ æƒ³è¦ g(f(x))ï¼š
- en: 'You can express this using lambda expressions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ å¯ä»¥ä½¿ç”¨ Lambda è¡¨è¾¾å¼æ¥è¡¨ç¤ºå®ƒï¼š
- en: '*Î»x.2x*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»x.2x*'
- en: '*Î»x.xÂ³*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»x.xÂ³*'
- en: '*=> (Î»x.xÂ³)(Î»x.2x)*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*=> (Î»x.xÂ³)(Î»x.2x)*'
- en: Do not try to solve it for now, first understand the notation, and further I
    will show you how to solve it!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä¸è¦æ€¥ç€è§£å†³å®ƒï¼Œå…ˆç†è§£ç¬¦å·çš„å«ä¹‰ï¼Œç¨åæˆ‘ä¼šå±•ç¤ºå¦‚ä½•è§£å†³ï¼
- en: 'Itâ€™s important to not confuse the parenthesis. For example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: é‡è¦çš„æ˜¯ä¸è¦æ··æ·†æ‹¬å·ã€‚ä¾‹å¦‚ï¼š
- en: '*1 â€” Î»x.((Î»x.x)x)* is an *abstraction* (function definition).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*1 â€” Î»x.((Î»x.x)x)* æ˜¯ä¸€ä¸ª *æŠ½è±¡*ï¼ˆå‡½æ•°å®šä¹‰ï¼‰ã€‚'
- en: '*2 â€” (Î»x.(Î»x.x))x* is an *application* (funtion application)*.*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*2 â€” (Î»x.(Î»x.x))x* æ˜¯ä¸€ä¸ª *åº”ç”¨*ï¼ˆå‡½æ•°åº”ç”¨ï¼‰ã€‚'
- en: On the Example 1, we are defining a function *Î»x.B*, where B is the expression
    (*Î»x.x)x,* which is the anonymous function *Î»x.x* applied to the input x.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¤ºä¾‹ 1 ä¸­ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå‡½æ•° *Î»x.B*ï¼Œå…¶ä¸­ B æ˜¯è¡¨è¾¾å¼ (*Î»x.x)x*ï¼Œå³å°†åŒ¿åå‡½æ•° *Î»x.x* åº”ç”¨äºè¾“å…¥ xã€‚
- en: On Example 2, we are applying the anonymous function *Î»x.(Î»x.x)* to the input
    *x.*
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç¤ºä¾‹ 2 ä¸­ï¼Œæˆ‘ä»¬å°†åŒ¿åå‡½æ•° *Î»x.(Î»x.x)* åº”ç”¨åˆ°è¾“å…¥ *x*ã€‚
- en: '*Applications* can also be represented as *f* *x* (applying function *f* to
    the variable *x*).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*åº”ç”¨* ä¹Ÿå¯ä»¥è¡¨ç¤ºä¸º *f* *x*ï¼ˆå°†å‡½æ•° *f* åº”ç”¨åˆ°å˜é‡ *x*ï¼‰ã€‚'
- en: 'We can also represent functions with *n* parameters using Lambda Calculus.
    This can be done by using nested functions, each taking a single parameter: *f(x,y,z)
    â†’ Î»x.*Î»y.Î»z'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨ Lambda è®¡ç®—è¡¨ç¤ºå…·æœ‰ *n* ä¸ªå‚æ•°çš„å‡½æ•°ã€‚è¿™å¯ä»¥é€šè¿‡ä½¿ç”¨åµŒå¥—å‡½æ•°æ¥å®Œæˆï¼Œæ¯ä¸ªå‡½æ•°æ¥å—ä¸€ä¸ªå•ä¸€å‚æ•°ï¼š*f(x,y,z) â†’ Î»x.*Î»y.Î»z
- en: Thus, *f(x, y, z) = x + y + z* can be expressed by the *abstraction:*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œ*f(x, y, z) = x + y + z* å¯ä»¥é€šè¿‡ *æŠ½è±¡* è¡¨ç¤ºä¸ºï¼š
- en: '*Î»x.*Î»y.Î»z.(x + y + z).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»x.*Î»y.Î»z.(x + y + z)ã€‚'
- en: 'Using this *abstraction* we can construct *applications*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸ª *æŠ½è±¡* æˆ‘ä»¬å¯ä»¥æ„é€  *åº”ç”¨*ï¼š
- en: '*(Î»x.*Î»y.Î»z.(x + y + z))1 2 3 => 6'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»x.*Î»y.Î»z.(x + y + z))1 2 3 => 6'
- en: 'When studying Lambda Calculus, there are also two common terms you might find:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å­¦ä¹  Lambda è®¡ç®—æ—¶ï¼Œè¿˜æœ‰ä¸¤ä¸ªå¸¸è§çš„æœ¯è¯­ä½ å¯èƒ½ä¼šé‡åˆ°ï¼š
- en: Alpha conversion (**Î±-conversion**) and Beta reduction (**Î²-reduction)**
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha è½¬æ¢ï¼ˆ**Î±-è½¬æ¢**ï¼‰å’Œ Beta çº¦ç®€ï¼ˆ**Î²-çº¦ç®€**ï¼‰
- en: Alpha conversion
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Alpha è½¬æ¢
- en: 'When evaluating more complex lambda expressions, you may obtain some expression
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¯„ä¼°æ›´å¤æ‚çš„ Lambda è¡¨è¾¾å¼æ—¶ï¼Œä½ å¯èƒ½ä¼šå¾—åˆ°è¿™æ ·çš„è¡¨è¾¾å¼ï¼š
- en: '*(Î»x.(Î»x.x+x)x)*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»x.(Î»x.x+x)x)*'
- en: 'In this expression, the inner *x* could be mistakenly interpreted as the outer
    *x*. In order to avoid that, we can rename the inner variable x:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªè¡¨è¾¾å¼ä¸­ï¼Œå†…éƒ¨çš„ *x* å¯èƒ½ä¼šè¢«é”™è¯¯åœ°è§£é‡Šä¸ºå¤–éƒ¨çš„ *x*ã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥é‡å‘½åå†…éƒ¨å˜é‡ xï¼š
- en: '*(Î»x.(Î»y.y+y)x)*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»x.(Î»y.y+y)x)*'
- en: This process is what it is called *Î±-conversion,* the name seems something complex,
    but it is this simple renaming of a variable to avoid mistakes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ªè¿‡ç¨‹å°±æ˜¯æ‰€è°“çš„ *Î±-è½¬æ¢*ï¼Œè™½ç„¶åå­—çœ‹èµ·æ¥æœ‰ç‚¹å¤æ‚ï¼Œä½†å…¶å®å°±æ˜¯è¿™æ ·ç®€å•çš„é‡å‘½åå˜é‡ä»¥é¿å…é”™è¯¯ã€‚
- en: '*Î»x.x â†’ Î»y.y (Î±-conversion)*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»x.x â†’ Î»y.y (Î±-è½¬æ¢)*'
- en: Both expressions represents the same function. The *Î±-conversion* does not change
    the functionâ€™s behavior, just the variable name.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªè¡¨è¾¾å¼è¡¨ç¤ºç›¸åŒçš„å‡½æ•°ã€‚*Î±-è½¬æ¢* å¹¶ä¸ä¼šæ”¹å˜å‡½æ•°çš„è¡Œä¸ºï¼Œåªæ˜¯æ›´æ”¹äº†å˜é‡çš„åç§°ã€‚
- en: Beta reduction
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Beta çº¦ç®€
- en: '*Î²-reduction* is simply the process of calculating the result from an application
    of a function to an expression. For instance:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î²-çº¦ç®€* ä»…ä»…æ˜¯é€šè¿‡å°†å‡½æ•°åº”ç”¨äºè¡¨è¾¾å¼æ¥è®¡ç®—ç»“æœçš„è¿‡ç¨‹ã€‚ä¾‹å¦‚ï¼š'
- en: '*(Î»x.xy)z*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»x.xy)z*'
- en: On the output *xy,* substitute every occurrence of x by z
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¾“å‡º *xy* æ—¶ï¼Œå°†æ¯ä¸ªå‡ºç°çš„ x æ›¿æ¢ä¸º z
- en: = *zy*
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: = *zy*
- en: 'You also might found the following notation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ è¿˜å¯èƒ½ä¼šçœ‹åˆ°ä»¥ä¸‹è¡¨ç¤ºæ³•ï¼š
- en: '*(Î» param . output)input => output [param := input] => result*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î» param . output)input => output [param := input] => result*'
- en: 'This basically means that to get the result, you look at the *output* and substitute
    every occurrence of *param* by the *input.* In the previous expression:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åŸºæœ¬ä¸Šæ„å‘³ç€è¦å¾—åˆ°ç»“æœï¼Œä½ éœ€è¦æŸ¥çœ‹ *è¾“å‡º*ï¼Œå¹¶å°†æ¯ä¸ªå‡ºç°çš„ *param* æ›¿æ¢ä¸º *input*ã€‚åœ¨ä¹‹å‰çš„è¡¨è¾¾å¼ä¸­ï¼š
- en: '*(Î»x.xy)z => (xy)[x := z] => zy*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»x.xy)z => (xy)[x := z] => zy*'
- en: Example
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹
- en: Going back to our example f(x) = 2x; g(x) = xÂ³ and we want g(f(1)).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: å›åˆ°æˆ‘ä»¬çš„ä¾‹å­ f(x) = 2xï¼›g(x) = xÂ³ï¼Œæˆ‘ä»¬æƒ³è®¡ç®— g(f(1))ã€‚
- en: 'In order to not mix up terms incorrectly, we can rewrite:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†é¿å…é”™è¯¯æ··æ·†æœ¯è¯­ï¼Œæˆ‘ä»¬å¯ä»¥é‡å†™ï¼š
- en: f(x) = 2x and g(y) = yÂ³
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: f(x) = 2x å’Œ g(y) = yÂ³
- en: 'Then, we substitute f within g:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œæˆ‘ä»¬å°† f æ›¿æ¢åˆ° g ä¸­ï¼š
- en: g(f(1)) = (f(1))Â³
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: g(f(1)) = (f(1))Â³
- en: => g(f(1)) = (2*1)Â³
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: => g(f(1)) = (2*1)Â³
- en: => 8*x = 8.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: => 8*x = 8.
- en: 'Now with Lambda Calculus:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½¿ç”¨ Lambda è®¡ç®—ï¼š
- en: '*Î»x.2x*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»x.2x*'
- en: '*Î»x.xÂ³*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»x.xÂ³*'
- en: '*=> (Î»x.xÂ³)((Î»x.2x)1)*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*=> (Î»x.xÂ³)((Î»x.2x)1)*'
- en: 'First, apply *Î±-conversion* in order to not mix up things:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œåº”ç”¨ *Î±-è½¬æ¢* ä»¥é¿å…æ··æ·†ï¼š
- en: '*(Î»y.yÂ³)((Î»x.2x)1)*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»y.yÂ³)((Î»x.2x)1)*'
- en: Then, *Î²-reduction* on the inner most expression *(Î»x.2x)1:*
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œå¯¹æœ€å†…å±‚çš„è¡¨è¾¾å¼è¿›è¡Œ *Î²-çº¦ç®€* *(Î»x.2x)1*ï¼š
- en: '*(Î» param . output)input => output [param := input] => result*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î» param . output)input => output [param := input] => result*'
- en: '*(Î»x.2x)1 => 2x [x := 1] => 2*1 = 2.*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»x.2x)1 => 2x [x := 1] => 2*1 = 2.*'
- en: Then, *Î²-reduction* again on the resulting expression *(Î»y.yÂ³)2:*
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œå†æ¬¡å¯¹å¾—åˆ°çš„è¡¨è¾¾å¼ *(Î»y.yÂ³)2* è¿›è¡Œ *Î²-çº¦ç®€*ï¼š
- en: '*(Î» param . output)input => output [param := input] => result*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î» param . output)input => output [param := input] => result*'
- en: '*(Î»y.yÂ³)2 => yÂ³[y := 2] => 2Â³ => 8.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»y.yÂ³)2 => yÂ³[y := 2] => 2Â³ => 8.*'
- en: We got the same result! Thatâ€™s brilliant right?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¾—åˆ°äº†ç›¸åŒçš„ç»“æœï¼è¿™çœŸæ˜¯å¤ªæ£’äº†å§ï¼Ÿ
- en: _________________________________________________________________
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: _________________________________________________________________
- en: âš ï¸ If youâ€™re starting to feel confused at this point, please donâ€™t close the
    article!! I understand it can be challenging at first, but I promise you, when
    you sleep today, you will wake up with things more clear! So, keep reading and
    enjoy the rest of the article :)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: âš ï¸ å¦‚æœæ­¤æ—¶ä½ å¼€å§‹æ„Ÿåˆ°å›°æƒ‘ï¼Œè¯·ä¸è¦å…³é—­æ–‡ç« ï¼ï¼æˆ‘æ˜ç™½ä¸€å¼€å§‹å¯èƒ½ä¼šå¾ˆå…·æŒ‘æˆ˜æ€§ï¼Œä½†æˆ‘ä¿è¯ä½ ï¼Œä»Šå¤©æ™šä¸Šç¡è§‰æ—¶ï¼Œæ˜å¤©é†’æ¥æ—¶ï¼Œäº‹æƒ…ä¼šæ›´åŠ æ¸…æ™°ï¼æ‰€ä»¥ï¼Œè¯·ç»§ç»­é˜…è¯»ï¼Œäº«å—æ¥ä¸‹æ¥çš„å†…å®¹
    :)
- en: _________________________________________________________________
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: _________________________________________________________________
- en: Some years after the Lambda Calculus, Alan Turing introduced the concept of
    Turing machines, an abstract mathematical model of a computer capable of simulating
    any algorithmic process that can be described mathematically. Building on the
    work of both Church and Turing, it was established that there exists a theoretical
    equivalence between Lambda Calculus and Turing machines. This equivalence means
    that, despite not having numbers or booleans, any problem computable by a Turing
    machine can also be expressed in Lambda Calculus terms. Thus, we can express any
    computable algorithm using Lambda Calculus!! Letâ€™s understand how this can be
    done.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ Lambda è®¡ç®—ä¹‹åçš„å‡ å¹´ï¼Œè‰¾ä¼¦Â·å›¾çµæå‡ºäº†å›¾çµæœºçš„æ¦‚å¿µï¼Œè¿™æ˜¯ä¸€ç§èƒ½å¤Ÿæ¨¡æ‹Ÿä»»ä½•å¯ä»¥ç”¨æ•°å­¦æè¿°çš„ç®—æ³•è¿‡ç¨‹çš„è®¡ç®—æœºæŠ½è±¡æ•°å­¦æ¨¡å‹ã€‚åœ¨ Church å’Œ
    Turing çš„å·¥ä½œåŸºç¡€ä¸Šï¼Œå·²ç¡®å®š Lambda è®¡ç®—ä¸å›¾çµæœºä¹‹é—´å­˜åœ¨ç†è®ºç­‰ä»·æ€§ã€‚è¿™ç§ç­‰ä»·æ€§æ„å‘³ç€ï¼Œå°½ç®¡ Lambda è®¡ç®—æ²¡æœ‰æ•°å­—æˆ–å¸ƒå°”å€¼ï¼Œä½†ä»»ä½•å¯ä»¥ç”±å›¾çµæœºè®¡ç®—çš„é—®é¢˜ä¹Ÿå¯ä»¥ç”¨
    Lambda è®¡ç®—çš„æœ¯è¯­è¡¨è¾¾ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ Lambda è®¡ç®—æ¥è¡¨è¾¾ä»»ä½•å¯è®¡ç®—çš„ç®—æ³•ï¼è®©æˆ‘ä»¬äº†è§£ä¸€ä¸‹å¦‚ä½•å®ç°è¿™ä¸€ç‚¹ã€‚
- en: Numbers
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ•°å­—
- en: I mentioned that Lambda Calculus does not have numbers, only lambda expressions.
    But then how could I have written things like *Î»x.(x+2)* before?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¹‹å‰æåˆ°è¿‡ Lambda è®¡ç®—æ²¡æœ‰æ•°å­—ï¼Œåªæœ‰ Lambda è¡¨è¾¾å¼ã€‚ä½†é‚£ä¹ˆï¼Œæˆ‘æ€ä¹ˆèƒ½å†™å‡ºåƒ *Î»x.(x+2)* è¿™æ ·çš„ä¸œè¥¿å‘¢ï¼Ÿ
- en: Well, I lied to youâ€¦ ğŸ˜
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½å§ï¼Œæˆ‘éª—äº†ä½ â€¦â€¦ ğŸ˜
- en: But donâ€™t get angry, it was only to facilitate understanding ğŸ˜€
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ä½†åˆ«ç”Ÿæ°”ï¼Œè¿™åªæ˜¯ä¸ºäº†ä¾¿äºç†è§£ ğŸ˜€
- en: 'Now, letâ€™s understand how Church represented numbers using only lambda expressions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬äº†è§£ä¸€ä¸‹ Church å¦‚ä½•ä»…é€šè¿‡ Lambda è¡¨è¾¾å¼è¡¨ç¤ºæ•°å­—ï¼š
- en: The Church representation of numerals is a bit complicated to understand at
    the beginning but it will get clearer further.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Church æ•°å­—è¡¨ç¤ºæ³•ä¸€å¼€å§‹å¯èƒ½æœ‰ç‚¹å¤æ‚ï¼Œä½†éšç€æ·±å…¥ç†è§£ï¼Œå®ƒä¼šå˜å¾—æ›´æ¸…æ™°ã€‚
- en: The chuch numeral `n` is defined as a function that takes a function `f` and
    returns the application of `f` to its argument `n` times.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Church æ•°å­— `n` è¢«å®šä¹‰ä¸ºä¸€ä¸ªå‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªå‡½æ•° `f` å¹¶è¿”å›å°† `f` åº”ç”¨äºå…¶å‚æ•° `n` æ¬¡ã€‚
- en: '0: Î»f.Î»x.x (applies `f` to `x` 0 times)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '0: Î»f.Î»x.x ï¼ˆå°† `f` åº”ç”¨äº `x` 0 æ¬¡ï¼‰'
- en: '1: Î»f.Î»x.f x (applies `f` to `x` 1 time)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '1: Î»f.Î»x.f x ï¼ˆå°† `f` åº”ç”¨äº `x` 1 æ¬¡ï¼‰'
- en: '2: Î»f.Î»x.f(f x) (applies `f` to `x` 2 times)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '2: Î»f.Î»x.f(f x) ï¼ˆå°† `f` åº”ç”¨äº `x` 2 æ¬¡ï¼‰'
- en: '3: Î»f.Î»x.f(f(f x)) (applies `f` to `x` 3 times)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '3: Î»f.Î»x.f(f(f x)) ï¼ˆå°† `f` åº”ç”¨äº `x` 3 æ¬¡ï¼‰'
- en: and so onâ€¦
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾æ­¤ç±»æ¨â€¦â€¦
- en: It seems confusing, but after some though, it starts to make sense. The church
    numeral `n` simply means to do anything `n` times.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¼¼ä¹å¾ˆæ··ä¹±ï¼Œä½†ç¨å¾®æ€è€ƒä¸€ä¸‹åï¼Œä½ ä¼šå¼€å§‹ç†è§£çš„ã€‚Church æ•°å­— `n` åªæ˜¯æ„å‘³ç€åšæŸäº‹ `n` æ¬¡ã€‚
- en: 'A good way to illustrate this is to remember that the idea of numbers comes
    from the process of counting. For example, imagine that you have a stair with
    20 steps. When it is said that to climb the stairs you have to go up 20 steps,
    it means that you will climb one step 20 times, right? Thatâ€™s exactly the same
    idea of Church encoding: You have a function `f` that means â€˜go up one stepâ€™ and
    if you want to express the idea of 20 steps, you apply `f` `20` times.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€ç§å¾ˆå¥½çš„è¯´æ˜æ–¹å¼æ˜¯è®°ä½æ•°å­—çš„æ¦‚å¿µæ¥æºäºè®¡æ•°çš„è¿‡ç¨‹ã€‚ä¾‹å¦‚ï¼Œå‡è®¾ä½ æœ‰ä¸€ä¸ª 20 æ­¥çš„æ¥¼æ¢¯ã€‚å½“è¯´åˆ°çˆ¬æ¥¼æ¢¯æ—¶ï¼Œä½ éœ€è¦çˆ¬ 20 æ­¥ï¼Œè¿™æ„å‘³ç€ä½ è¦çˆ¬ 20 æ¬¡ï¼Œæ¯æ¬¡çˆ¬ä¸€æ­¥ï¼Œå¯¹å§ï¼Ÿè¿™æ­£æ˜¯
    Church ç¼–ç çš„æ¦‚å¿µï¼šä½ æœ‰ä¸€ä¸ªå‡½æ•° `f`ï¼Œå®ƒè¡¨ç¤ºâ€œçˆ¬ä¸€æ­¥â€ï¼Œå¦‚æœä½ æƒ³è¡¨è¾¾ 20 æ­¥çš„æ¦‚å¿µï¼Œä½ å°±å°† `f` åº”ç”¨ 20 æ¬¡ã€‚
- en: Numerical Operations
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ•°å€¼è¿ç®—
- en: After defining the Church numerals, we can define the numerical operations.
    The first one is to define a successor function ***s***. It is basically a function
    that increments a Church numeral by 1\. Thus, the successor is a function that
    takes a Church numeral representing the number `n` and returns a Church numerical
    representation of `n+1`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: å®šä¹‰äº† Church æ•°å­—ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰æ•°å€¼è¿ç®—ã€‚ç¬¬ä¸€ä¸ªæ˜¯å®šä¹‰ä¸€ä¸ªåç»§å‡½æ•° ***s***ã€‚å®ƒåŸºæœ¬ä¸Šæ˜¯ä¸€ä¸ªå°† Church æ•°å­—å¢åŠ  1 çš„å‡½æ•°ã€‚å› æ­¤ï¼Œåç»§å‡½æ•°æ˜¯ä¸€ä¸ªæ¥å—è¡¨ç¤ºæ•°å­—
    `n` çš„ Church æ•°å­—ï¼Œå¹¶è¿”å›è¡¨ç¤º `n+1` çš„ Church æ•°å­—çš„å‡½æ•°ã€‚
- en: For example, if Î»f.Î»x.f(f x) represents the number 2, if we apply the successor
    function **s** to that, we will get Î»f.Î»x.f(f(f x)) (Church numerical representation
    of number 3).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œå¦‚æœ Î»f.Î»x.f(f x) è¡¨ç¤ºæ•°å­— 2ï¼Œå½“æˆ‘ä»¬å°†åç»§å‡½æ•° **s** åº”ç”¨åˆ°å®ƒæ—¶ï¼Œæˆ‘ä»¬å°†å¾—åˆ° Î»f.Î»x.f(f(f x))ï¼ˆæ•°å­— 3 çš„
    Church è¡¨ç¤ºæ³•ï¼‰ã€‚
- en: 'The successor function is defined as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: åç»§å‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼š
- en: '*s(n) =Î»n.Î»f.Î»x.f((n f) x),* where `n` is the Church numeral `n`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*s(n) =Î»n.Î»f.Î»x.f((n f) x)ï¼Œ* å…¶ä¸­ `n` æ˜¯ Church æ•°å­— `n`ã€‚'
- en: 'Letâ€™s analyze it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åˆ†æä¸€ä¸‹ï¼š
- en: '**Input**: `n` (a Church numeral), `f` (a function), and `x` (an argument)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è¾“å…¥**ï¼š`n`ï¼ˆä¸€ä¸ªæ•™å ‚æ•°å­—ï¼‰ï¼Œ`f`ï¼ˆä¸€ä¸ªå‡½æ•°ï¼‰ï¼Œå’Œ `x`ï¼ˆä¸€ä¸ªå‚æ•°ï¼‰'
- en: '***Application* of n**: The term `(nf)x` represents the application of the
    function `f` to the argument `x` `n` times.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***n çš„åº”ç”¨**ï¼šæœ¯è¯­ `(nf)x` è¡¨ç¤ºå°†å‡½æ•° `f` åº”ç”¨åˆ°å‚æ•° `x` ä¸Š `n` æ¬¡ã€‚'
- en: '**Additional Application**: The term `f((nf)x)` applies `f` one more time to
    the result of `(nf)x`.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**é™„åŠ åº”ç”¨**ï¼šæœ¯è¯­ `f((nf)x)` å°†å‡½æ•° `f` å†åº”ç”¨ä¸€æ¬¡åˆ° `(nf)x` çš„ç»“æœã€‚'
- en: If the Church numeral `n` means to do something `n` times, `s n` means do something
    `n+1` times.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ•™å ‚æ•°å­— `n` è¡¨ç¤ºåšæŸäº‹ `n` æ¬¡ï¼Œ`s n` åˆ™è¡¨ç¤ºåšæŸäº‹ `n+1` æ¬¡ã€‚
- en: 'Letâ€™s for example apply the successor function to the Church numeral for 1:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬å°†åç»§å‡½æ•°åº”ç”¨äºæ•°å­— 1 çš„æ•™å ‚æ•°å­—è¡¨ç¤ºæ³•ï¼š
- en: '**Church numeral for 2**: [*Î»f.Î»x.f(f x)*](http://.)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ•™å ‚æ•°å­— 2**ï¼š[*Î»f.Î»x.f(f x)*](http://.)'
- en: '**Applying successor of this expression:**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**åº”ç”¨æ­¤è¡¨è¾¾å¼çš„åç»§ï¼š**'
- en: We know that *s(n) = Î»n.Î»f.Î»x.f((n f) x)*
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çŸ¥é“ *s(n) = Î»n.Î»f.Î»x.f((n f) x)*
- en: Our n = 2 = [*Î»f.Î»x.f(f x)*](http://.)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ n = 2 = [*Î»f.Î»x.f(f x)*](http://.)
- en: 'Thus, we apply the successor function on that:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å¯¹å…¶åº”ç”¨åç»§å‡½æ•°ï¼š
- en: s([**Î»f.Î»x.f(f x)**](http://.)*) = ( Î»n.Î»f.Î»x.f((n f) x) )(* [**Î»f.Î»x.f(f x)**](http://.)
    *)*
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: s([**Î»f.Î»x.f(f x)**](http://.)*) = ( Î»n.Î»f.Î»x.f((n f) x) )(* [**Î»f.Î»x.f(f x)**](http://.)
    *)*
- en: Using the first *Î²-reduction* on the *application* expression*:*
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹ *åº”ç”¨* è¡¨è¾¾å¼è¿›è¡Œç¬¬ä¸€æ¬¡ *Î²-çº¦ç®€*ï¼š
- en: '*(Î» param . output)input => output [param := input] => result*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î» param . output)input => output [param := input] => result*'
- en: '*( Î»n.Î»f.Î»x.f((n f) x) )(* [**Î»f.Î»x.f(f x)**](http://.) *) => Î»f.Î»x.f((n f)
    x) [n :=* [**Î»f.Î»x.f(f x)**](http://.)**]**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*( Î»n.Î»f.Î»x.f((n f) x) )(* [**Î»f.Î»x.f(f x)**](http://.) *) => Î»f.Î»x.f((n f)
    x) [n :=* [**Î»f.Î»x.f(f x)**](http://.)**]**'
- en: => *Î»f.Î»x.f((*[**Î»f.Î»x.f(f x)**](http://.)*f x)*
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: => *Î»f.Î»x.f((*[**Î»f.Î»x.f(f x)**](http://.)*f x)*
- en: 'Now, letâ€™s analyze the inner *application* expression:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬åˆ†æå†…éƒ¨çš„ *åº”ç”¨* è¡¨è¾¾å¼ï¼š
- en: '*(*[**Î»f.Î»x.f(fx)**](http://.)*f x*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*(*[**Î»f.Î»x.f(fx)**](http://.)*f x*'
- en: 'The underlined term is the Church numeral 2, right? And it can be read as:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸‹åˆ’çº¿éƒ¨åˆ†æ˜¯æ•™å ‚æ•°å­— 2ï¼Œå¯¹å§ï¼Ÿå®ƒå¯ä»¥è§£é‡Šä¸ºï¼š
- en: Given a function *f*, apply *f* 2 times to its argument, which is *x.*
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®šä¸€ä¸ªå‡½æ•° *f*ï¼Œå°† *f* åº”ç”¨ä¸¤æ¬¡äºå…¶å‚æ•° *x*ã€‚
- en: '*(*[**Î»f.Î»x.f(fx)**](http://.)*f x* turns into *f(f x)*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*(*[**Î»f.Î»x.f(fx)**](http://.)*f x* å˜æˆ *f(f x)*'
- en: 'Substituting on our expression *Î»f.Î»x.f((*[**Î»f.Î»x.f(fx)**](http://.)*f x),*
    we get:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: å°†æˆ‘ä»¬çš„è¡¨è¾¾å¼ *Î»f.Î»x.f((*[**Î»f.Î»x.f(fx)**](http://.)*f x),* ä»£å…¥åï¼Œæˆ‘ä»¬å¾—åˆ°ï¼š
- en: '*Î»f.Î»x.f(f(f x)),* which is exactly the Church numerical representation of
    the number 3!'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»f.Î»x.f(f(f x)),* è¿™æ­£æ˜¯æ•°å­— 3 çš„æ•™å ‚æ•°å­—è¡¨ç¤ºæ³•ï¼'
- en: 'So, we just defined the successor lambda operation. By using this idea, if
    we define 0 = Î»f.Î»x.x, we can obtain the other Church numerals using the successor
    function recursively:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰€ä»¥ï¼Œæˆ‘ä»¬åˆšåˆšå®šä¹‰äº†åç»§ lambda æ“ä½œã€‚é€šè¿‡ä½¿ç”¨è¿™ä¸ªæ¦‚å¿µï¼Œå¦‚æœæˆ‘ä»¬å®šä¹‰ 0 = Î»f.Î»x.xï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é€’å½’åœ°åº”ç”¨åç»§å‡½æ•°æ¥è·å¾—å…¶ä»–æ•™å ‚æ•°å­—ï¼š
- en: 1 = **s** **0**
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 1 = **s** **0**
- en: 2 = s(**s** **0**)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 2 = s(**s** **0**)
- en: 3 = **s**(**s**(**s** **0**))
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 3 = **s**(**s**(**s** **0**))
- en: â€¦
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: â€¦
- en: We can take advantage of this functions to implement other operations such as
    addition and multiplication.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥åˆ©ç”¨è¿™äº›å‡½æ•°æ¥å®ç°å…¶ä»–æ“ä½œï¼Œå¦‚åŠ æ³•å’Œä¹˜æ³•ã€‚
- en: 'The addition of two numbers m + n is defined as:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸¤ä¸ªæ•°å­— m + n çš„åŠ æ³•å®šä¹‰ä¸ºï¼š
- en: '*ADD(m, n) = Î»m.Î»n.Î»f.Î»x.(m f)((n f) x)*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*ADD(m, n) = Î»m.Î»n.Î»f.Î»x.(m f)((n f) x)*'
- en: Thus, if we define *m* and *n* as the Church numerical representations of 3
    and 4, respectively, and then apply this ADD function, we will get the Church
    numerical representation of 7.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œå¦‚æœæˆ‘ä»¬å°† *m* å’Œ *n* å®šä¹‰ä¸ºåˆ†åˆ«è¡¨ç¤ºæ•°å­— 3 å’Œ 4 çš„æ•™å ‚æ•°å­—è¡¨ç¤ºæ³•ï¼Œç„¶ååº”ç”¨è¿™ä¸ªåŠ æ³•å‡½æ•°ï¼Œæˆ‘ä»¬å°†å¾—åˆ°æ•°å­— 7 çš„æ•™å ‚æ•°å­—è¡¨ç¤ºæ³•ã€‚
- en: 'The same logic applies to multiplication of two numbers m * n:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ ·çš„é€»è¾‘é€‚ç”¨äºä¸¤ä¸ªæ•°å­— m * n çš„ä¹˜æ³•ï¼š
- en: '*MUL(m, n) = Î»m.Î»n.Î»f.Î»x.m (n f)*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*MUL(m, n) = Î»m.Î»n.Î»f.Î»x.m (n f)*'
- en: Try to apply yourself anytime!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ä»»ä½•æ—¶å€™éƒ½å¯ä»¥å°è¯•åº”ç”¨è‡ªå·±ï¼
- en: Booleans
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å¸ƒå°”å€¼
- en: Before we get into the Church definitions, letâ€™s think of booleans as some operation
    that we can do for *selection.* Among two options A and B, depending on some condition,
    we select A or B.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿›å…¥æ•™å ‚å®šä¹‰ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆå°†å¸ƒå°”å€¼è§†ä¸ºæˆ‘ä»¬å¯ä»¥ç”¨æ¥è¿›è¡Œ *é€‰æ‹©* çš„æŸç§æ“ä½œã€‚åœ¨ä¸¤ä¸ªé€‰é¡¹ A å’Œ B ä¹‹é—´ï¼Œä¾æ®æŸä¸ªæ¡ä»¶ï¼Œé€‰æ‹© A æˆ– Bã€‚
- en: '`IF [CONDITION] THEN [RESULT A] ELSE [RESULT B]`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`IF [CONDITION] THEN [RESULT A] ELSE [RESULT B]`ã€‚'
- en: 'For example, during some app execution, if we want to use booleans to change
    the background color of the screen:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œåœ¨æŸä¸ªåº”ç”¨ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œå¦‚æœæˆ‘ä»¬æƒ³ä½¿ç”¨å¸ƒå°”å€¼æ¥æ›´æ”¹å±å¹•çš„èƒŒæ™¯é¢œè‰²ï¼š
- en: â€œred_theme = Trueâ€
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: â€œred_theme = Trueâ€
- en: This will only be useful when at some other part of the program we do some *selection:*
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™åªæœ‰åœ¨ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†æˆ‘ä»¬è¿›è¡ŒæŸç§ *é€‰æ‹©* æ—¶æ‰æœ‰ç”¨ï¼š
- en: background_color = IF red_theme THEN red ELSE white.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: background_color = å¦‚æœ red_theme ä¸ºçœŸï¼Œåˆ™ä¸º redï¼Œå¦åˆ™ä¸º whiteã€‚
- en: Thus, all we need from booleans is some manner of conditionally selecting two
    options.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬ä»å¸ƒå°”å€¼ä¸­éœ€è¦çš„åªæ˜¯æŸç§æ¡ä»¶é€‰æ‹©ä¸¤ä¸ªé€‰é¡¹çš„æ–¹å¼ã€‚
- en: 'Based on that, in Lambda Calculus, the Church definition of *true* and *false*
    are defined as functions of two parameters:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºæ­¤ï¼Œåœ¨Î»æ¼”ç®—ä¸­ï¼Œ*true*å’Œ*false*çš„Churchå®šä¹‰è¢«å®šä¹‰ä¸ºä¸¤ä¸ªå‚æ•°çš„å‡½æ•°ï¼š
- en: '*true* chooses the first parameter.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*true*é€‰æ‹©ç¬¬ä¸€ä¸ªå‚æ•°ã€‚'
- en: '*false* chooses the second parameter.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*false*é€‰æ‹©ç¬¬äºŒä¸ªå‚æ•°ã€‚'
- en: '*TRUE* = *Î»x.Î»y.x*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*TRUE* = *Î»x.Î»y.x*'
- en: '*FALSE* = *Î»x.Î»y.y*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*FALSE* = *Î»x.Î»y.y*'
- en: 'It seems strange, right? But letâ€™s define some boolean operations and see how
    it goes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹èµ·æ¥æœ‰ç‚¹å¥‡æ€ªï¼Œå¯¹å§ï¼Ÿä½†æ˜¯è®©æˆ‘ä»¬å®šä¹‰ä¸€äº›å¸ƒå°”æ“ä½œï¼Œçœ‹çœ‹ä¼šå‘ç”Ÿä»€ä¹ˆï¼š
- en: '**NOT**: Takes a Boolean and returns the opposite.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**NOT**ï¼šæ¥å—ä¸€ä¸ªå¸ƒå°”å€¼å¹¶è¿”å›å…¶ç›¸åå€¼ã€‚'
- en: '`NOT = Î»p. p FALSE TRUE`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOT = Î»p. p FALSE TRUE`'
- en: 'This means: â€œTake a Boolean function `p`. Apply `p` to the two parameters `FALSE`
    `TRUE`."'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€ï¼šâ€œå–ä¸€ä¸ªå¸ƒå°”å‡½æ•°`p`ã€‚å°†`p`åº”ç”¨åˆ°ä¸¤ä¸ªå‚æ•°`FALSE`å’Œ`TRUE`ã€‚â€
- en: 'Remember the definition of booleans on Church enconding? *TRUE* returns the
    first parameter and *FALSE* returns the second parameter? Thus:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: è¿˜è®°å¾—Churchç¼–ç ä¸­çš„å¸ƒå°”å€¼å®šä¹‰å—ï¼Ÿ*TRUE*è¿”å›ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œ*FALSE*è¿”å›ç¬¬äºŒä¸ªå‚æ•°ï¼Ÿå› æ­¤ï¼š
- en: â†’ If `p` is `TRUE`, it returns `FALSE`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ å¦‚æœ`p`æ˜¯`TRUE`ï¼Œåˆ™è¿”å›`FALSE`ã€‚
- en: â†’ If `p` is `FALSE`, it returns `TRUE`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: â†’ å¦‚æœ`p`æ˜¯`FALSE`ï¼Œåˆ™è¿”å›`TRUE`ã€‚
- en: '**AND**: Takes two Booleans and returns *TRUE* if both are *TRUE*, otherwise
    FALSE.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**AND**ï¼šæ¥å—ä¸¤ä¸ªå¸ƒå°”å€¼ï¼Œå¦‚æœä¸¤ä¸ªéƒ½ä¸º*TRUE*ï¼Œåˆ™è¿”å›*TRUE*ï¼Œå¦åˆ™è¿”å›*FALSE*ã€‚'
- en: '`AND = Î»p.Î»q.p q p`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`AND = Î»p.Î»q.p q p`'
- en: 'This means: â€œTake two Boolean functions `p` and `q`. Apply `p` to `q` and `p`."'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ„å‘³ç€ï¼šâ€œå–ä¸¤ä¸ªå¸ƒå°”å‡½æ•°`p`å’Œ`q`ã€‚å°†`p`åº”ç”¨äº`q`å’Œ`p`ã€‚â€
- en: 'Letâ€™s try on practice:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åœ¨å®è·µä¸­å°è¯•ï¼š
- en: '*AND TRUE FALSE* = (*Î»p.Î»q.p q p) TRUE FALSE:*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*AND TRUE FALSE* = (*Î»p.Î»q.p q p) TRUE FALSE:'
- en: 'Given *TRUE* and *FALSE*, return *TRUE FALSE TRUE*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®š*TRUE*å’Œ*FALSE*ï¼Œè¿”å›*TRUE FALSE TRUE*ï¼š
- en: => *TRUE* *FALSE* *TRUE* = *Î»x.Î»y.x FALSE TRUE*
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: => *TRUE* *FALSE* *TRUE* = *Î»x.Î»y.x FALSE TRUE*
- en: 'Given *FALSE* and *TRUE*, return the first parameter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®š*FALSE*å’Œ*TRUE*ï¼Œè¿”å›ç¬¬ä¸€ä¸ªå‚æ•°ï¼š
- en: '*Î»x.Î»y.x FALSE TRUE = FALSE*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»x.Î»y.x FALSE TRUE = FALSE*'
- en: The definitions of the other boolean operations such as OR, XOR and others follow
    the same idea.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: å…¶ä»–å¸ƒå°”æ“ä½œå¦‚ORã€XORç­‰çš„å®šä¹‰éµå¾ªç›¸åŒçš„æ€è·¯ã€‚
- en: Practice
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: å®è·µ
- en: 'Now, letâ€™s use some Lambda Calculus in practice:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬åœ¨å®è·µä¸­ä½¿ç”¨ä¸€äº›Î»æ¼”ç®—ï¼š
- en: '[PRE2]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we are performing numerical operations using only lambda functions!!
    Also, by extending this with lambda boolean logic, we could implement if/else,
    loops and even an entire programming language solely with lambda functions! Amazing
    right?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€è§ï¼Œæˆ‘ä»¬åªä½¿ç”¨Î»å‡½æ•°æ‰§è¡Œæ•°å€¼æ“ä½œï¼ï¼æ­¤å¤–ï¼Œé€šè¿‡æ‰©å±•è¿™ä¸ªæ–¹æ³•å¹¶ç»“åˆÎ»å¸ƒå°”é€»è¾‘ï¼Œæˆ‘ä»¬ç”šè‡³å¯ä»¥ä»…ä½¿ç”¨Î»å‡½æ•°å®ç°if/elseã€å¾ªç¯ï¼Œç”šè‡³æ•´ä¸ªç¼–ç¨‹è¯­è¨€ï¼æ˜¯ä¸æ˜¯å¾ˆç¥å¥‡ï¼Ÿ
- en: Okay, now after this brief introduction to Lambda Calculus, we can go to the
    next topic of our journey.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½çš„ï¼Œåœ¨ç®€è¦ä»‹ç»å®ŒÎ»æ¼”ç®—ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥è¿›å…¥æˆ‘ä»¬æ—…ç¨‹çš„ä¸‹ä¸€ä¸ªè¯é¢˜ã€‚
- en: Interaction Nets
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: äº¤äº’ç½‘
- en: 'Before going directly to Interaction Combinators, letâ€™s first learn another
    earlier work by Yves Lafont: Interaction Nets. This foundation will make understanding
    Interaction Combinators easier.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç›´æ¥è¿›å…¥äº¤äº’ç»„åˆå­ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå­¦ä¹ ä¸€ä¸‹Yves Lafontçš„å¦ä¸€é¡¹æ—©æœŸå·¥ä½œï¼šäº¤äº’ç½‘ã€‚è¿™ä¸€åŸºç¡€å°†ä½¿ç†è§£äº¤äº’ç»„åˆå­å˜å¾—æ›´åŠ å®¹æ˜“ã€‚
- en: Interaction Nets are a model of computation created by Yves Lafont in 1990\.
    They use graph-like structures and a set of interaction rules to represent algorithms.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: äº¤äº’ç½‘æ˜¯ç”±Yves Lafontåœ¨1990å¹´åˆ›å»ºçš„ä¸€ç§è®¡ç®—æ¨¡å‹ã€‚å®ƒä»¬ä½¿ç”¨ç±»ä¼¼å›¾å½¢çš„ç»“æ„å’Œä¸€ç»„äº¤äº’è§„åˆ™æ¥è¡¨ç¤ºç®—æ³•ã€‚
- en: 'The first thing we need to define is a *cell.* A consists of a some symbol
    *e.g. Î±,* a principal port and n auxiliary ports*,* represented by the image below:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬éœ€è¦å®šä¹‰çš„ç¬¬ä¸€ä»¶äº‹æ˜¯ä¸€ä¸ª*å•å…ƒ*ã€‚å®ƒç”±æŸä¸ªç¬¦å·*ä¾‹å¦‚Î±*ï¼Œä¸€ä¸ªä¸»ç«¯å£å’Œnä¸ªè¾…åŠ©ç«¯å£ç»„æˆï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
- en: '![](../Images/ba40de956a0e60e58c173fb65fa5a68b.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ba40de956a0e60e58c173fb65fa5a68b.png)'
- en: Cell â€” Image by author
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: å•å…ƒ â€” å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: 'When a *cell* has n = 0 auxiliary ports, it is represented as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: å½“ä¸€ä¸ª*å•å…ƒ*çš„è¾…åŠ©ç«¯å£æ•°n = 0æ—¶ï¼Œå®ƒçš„è¡¨ç¤ºå¦‚ä¸‹ï¼š
- en: '![](../Images/8e7e876645ce29028268c7ee95d7299e.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8e7e876645ce29028268c7ee95d7299e.png)'
- en: Cell of arity n=0 â€” Image by author
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: arity n=0çš„å•å…ƒ â€” å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: By connecting a set of *cells* through *wires* on their *ports* we construct
    a *net*. For example, a net with *cells Î±, Î²* and *Î³,* with [arities](https://en.wikipedia.org/wiki/Arity)
    n = 2, 1 and 0, respectively.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: é€šè¿‡å°†ä¸€ç»„*å•å…ƒ*é€šè¿‡å®ƒä»¬çš„*ç«¯å£*ç”¨*ç”µçº¿*è¿æ¥ï¼Œæˆ‘ä»¬æ„é€ ä¸€ä¸ª*ç½‘ç»œ*ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªåŒ…å«*å•å…ƒÎ±, Î²*å’Œ*Î³*çš„ç½‘ç»œï¼Œå…¶ä¸­[arity](https://en.wikipedia.org/wiki/Arity)åˆ†åˆ«ä¸ºn
    = 2, 1å’Œ0ã€‚
- en: '![](../Images/93ad5ba679bdd192864241e7bc4f7d17.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/93ad5ba679bdd192864241e7bc4f7d17.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”±ä½œè€…æä¾›ï¼Œçµæ„Ÿæ¥è‡ª[Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: Note that a *wire* can connect two *ports* of the same *cell* and a *net* may
    not be necessarily connected. Also, in this example there are three free ports
    *x*, *y* and *z.*
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œä¸€ä¸ª*ç”µçº¿*å¯ä»¥è¿æ¥åŒä¸€ä¸ª*å•å…ƒ*çš„ä¸¤ä¸ª*ç«¯å£*ï¼Œå¹¶ä¸”ä¸€ä¸ª*ç½‘ç»œ*ä¸ä¸€å®šéœ€è¦å®Œå…¨è¿æ¥ã€‚æ­¤å¤–ï¼Œåœ¨è¿™ä¸ªç¤ºä¾‹ä¸­æœ‰ä¸‰ä¸ªè‡ªç”±ç«¯å£*x*ã€*y*å’Œ*z*ã€‚
- en: Whenever a pair of cells is connected through their [***principal***](http://.)
    *ports,* there will be an *interaction.* An *interaction* is a rule that will
    modify the *net.* This pairs connected through their *active* ports and ready
    to interact are called an *active pair (*or *redex).*
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: æ¯å½“ä¸€å¯¹å•å…ƒé€šè¿‡å®ƒä»¬çš„[***ä¸»è¦***](http://.) *ç«¯å£*è¿æ¥æ—¶ï¼Œå°±ä¼šå‘ç”Ÿä¸€æ¬¡*äº¤äº’*ã€‚*äº¤äº’*æ˜¯ä¸€æ¡è§„åˆ™ï¼Œå®ƒä¼šä¿®æ”¹*ç½‘ç»œ*ã€‚è¿™äº›é€šè¿‡*æ´»åŠ¨*ç«¯å£è¿æ¥å¹¶å‡†å¤‡äº¤äº’çš„å•å…ƒå¯¹ç§°ä¸º*æ´»åŠ¨å¯¹*ï¼ˆæˆ–*çº¢é›·*ï¼‰ã€‚
- en: On the previous example, there are two possible *interactions* (*active pairs*)
    on the first *iteration.*
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å‰é¢çš„ä¾‹å­ä¸­ï¼Œç¬¬ä¸€è½®æœ‰ä¸¤ä¸ªå¯èƒ½çš„*äº¤äº’*ï¼ˆ*æ´»åŠ¨å¯¹*ï¼‰ã€‚
- en: '![](../Images/5c5f9513d5084292e2586a53b4e278a6.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5c5f9513d5084292e2586a53b4e278a6.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…å›¾åƒï¼Œçµæ„Ÿæ¥è‡ªäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: After applying these rules, the *net* will be modified. We then repeatdly apply
    these rules again to the resulting *nets* until we reach an irreducible form,
    when no more *interaction* rules can be applied. This process of repeatedly applying
    *interaction* rules is also known as reduction.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨åº”ç”¨è¿™äº›è§„åˆ™åï¼Œ*ç½‘ç»œ*å°†è¢«ä¿®æ”¹ã€‚ç„¶åï¼Œæˆ‘ä»¬ä¼šå°†è¿™äº›è§„åˆ™åå¤åº”ç”¨åˆ°ç»“æœç”Ÿæˆçš„*ç½‘ç»œ*ä¸Šï¼Œç›´åˆ°è¾¾åˆ°ä¸€ä¸ªä¸å¯ç®€åŒ–çš„å½¢å¼ï¼Œå³æ— æ³•å†åº”ç”¨ä»»ä½•*äº¤äº’*è§„åˆ™æ—¶ä¸ºæ­¢ã€‚è¿™ä¸ªåå¤åº”ç”¨*äº¤äº’*è§„åˆ™çš„è¿‡ç¨‹ä¹Ÿè¢«ç§°ä¸ºå½’çº¦ã€‚
- en: An *interaction system* is constructed with a set of interaction rules that
    can be applied without ambiguity. That is, if we define an *interaction* rule
    for an *active pair (Î±i, Î±j)*, it will be the same for all *(Î±i, Î±j)* that appear.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*äº¤äº’ç³»ç»Ÿ*æ˜¯ç”±ä¸€ç»„å¯ä»¥æ¯«ä¸å«ç³Šåœ°åº”ç”¨çš„äº¤äº’è§„åˆ™æ„æˆçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬ä¸º*æ´»åŠ¨å¯¹ï¼ˆÎ±i, Î±jï¼‰*å®šä¹‰äº†ä¸€ä¸ª*äº¤äº’*è§„åˆ™ï¼Œé‚£ä¹ˆå¯¹äºæ‰€æœ‰å‡ºç°çš„*(Î±i,
    Î±j)*ï¼Œè¿™ä¸ªè§„åˆ™éƒ½æ˜¯ä¸€æ ·çš„ã€‚'
- en: After this brief explanation, letâ€™s do some practice.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸ªç®€çŸ­çš„è§£é‡Šä¹‹åï¼Œè®©æˆ‘ä»¬åšä¸€äº›ç»ƒä¹ ã€‚
- en: '*Building an interaction system for arithmetics*'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*æ„å»ºä¸€ä¸ªç®—æœ¯äº¤äº’ç³»ç»Ÿ*'
- en: 'Letâ€™s build an interaction system for doing arithmetics. In order to create
    that, letâ€™s first forget our basic intuition about numbers and try to create a
    system that can model natural numbers. In 1889, Giuseppe Peano introduced five
    axioms to formalize natural numbers, similar to how Euclid defined his axioms
    for geometry. The Peanoâ€™s axioms enable an infinite set to be generated by a finite
    set of symbols and rules. Using these axioms, Peano defined some rules for a finite
    set of symbols to model natural numbers and their arithmetic properties:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬æ„å»ºä¸€ä¸ªç”¨äºåšç®—æœ¯çš„äº¤äº’ç³»ç»Ÿã€‚ä¸ºäº†åˆ›å»ºå®ƒï¼Œæˆ‘ä»¬é¦–å…ˆè¦å¿˜è®°å…³äºæ•°å­—çš„åŸºæœ¬ç›´è§‰ï¼Œå°è¯•åˆ›å»ºä¸€ä¸ªèƒ½å¤Ÿå»ºæ¨¡è‡ªç„¶æ•°çš„ç³»ç»Ÿã€‚åœ¨1889å¹´ï¼ŒGiuseppe Peanoæå‡ºäº†äº”æ¡å…¬ç†æ¥å½¢å¼åŒ–è‡ªç„¶æ•°ï¼Œè¿™ç±»ä¼¼äºæ¬§å‡ é‡Œå¾—ä¸ºå‡ ä½•å®šä¹‰çš„å…¬ç†ã€‚Peanoçš„å…¬ç†ä½¿å¾—ä¸€ä¸ªæœ‰é™ç¬¦å·é›†å’Œè§„åˆ™å¯ä»¥ç”Ÿæˆä¸€ä¸ªæ— é™çš„é›†åˆã€‚é€šè¿‡è¿™äº›å…¬ç†ï¼ŒPeanoä¸ºè‡ªç„¶æ•°åŠå…¶ç®—æœ¯æ€§è´¨å®šä¹‰äº†ä¸€äº›è§„åˆ™ï¼š
- en: '***0 â†’ Symbolizes the number zero***'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '***0 â†’ è¡¨ç¤ºæ•°å­—é›¶***'
- en: '***s(n) â†’ Represents the successor function. It returns the next natural number.***'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '***s(n) â†’ è¡¨ç¤ºåç»§å‡½æ•°ã€‚å®ƒè¿”å›ä¸‹ä¸€ä¸ªè‡ªç„¶æ•°ã€‚***'
- en: 'Using **s** and **0** we can define the natural numbers, as we have previously
    seen during lambda calculus studies:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨**s**å’Œ**0**ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰è‡ªç„¶æ•°ï¼Œæ­£å¦‚æˆ‘ä»¬ä¹‹å‰åœ¨Î»æ¼”ç®—å­¦ä¹ ä¸­æ‰€çœ‹åˆ°çš„ï¼š
- en: 1 = **s(0)**
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 1 = **s(0)**
- en: 2 = **s(s(0))**
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 2 = **s(s(0))**
- en: 3 = **s(s(s(0)))**
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 3 = **s(s(s(0)))**
- en: and so onâ€¦
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾æ­¤ç±»æ¨â€¦â€¦
- en: '***+ â†’ Represents addition. It is a function recursively defined as:***'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '***+ â†’ è¡¨ç¤ºåŠ æ³•ã€‚å®ƒæ˜¯ä¸€ä¸ªé€’å½’å®šä¹‰çš„å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š***'
- en: '***Base case:*** 0 + a = a'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '***åŸºç¡€æƒ…å†µï¼š*** 0 + a = a'
- en: '***Recursion:*** a + s(b) = s(a+b)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '***é€’å½’ï¼š*** a + s(b) = s(a+b)'
- en: 'For example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼š
- en: 'a + 3:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: a + 3ï¼š
- en: = a + s(2)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: = a + s(2)
- en: = s(a+2)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: = s(a+2)
- en: = s(a+s(1))
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: = s(a+s(1))
- en: = s(s(a+1))
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: = s(s(a+1))
- en: = s(s(a+s(0)))
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: = s(s(a+s(0)))
- en: = s(s(s(a+0)))
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: = s(s(s(a+0)))
- en: = s(s(s(a)))
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: = s(s(s(a)))
- en: '***Ã—: Represents multiplication. It is a function recursively defined as:***'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '***Ã—ï¼šè¡¨ç¤ºä¹˜æ³•ã€‚å®ƒæ˜¯ä¸€ä¸ªé€’å½’å®šä¹‰çš„å‡½æ•°ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š***'
- en: '***Base case:*** b Ã— **0** = **0**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '***åŸºç¡€æƒ…å†µï¼š*** b Ã— **0** = **0**'
- en: '***Recursion:*** s(a) Ã— b = (a Ã— b) + b'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '***é€’å½’ï¼š*** s(a) Ã— b = (a Ã— b) + b'
- en: 'Inspired by this, Yves Lafont built a interaction system to model natural numbers
    and arithmetics. Letâ€™s understand:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: å—æ­¤å¯å‘ï¼ŒYves Lafont æ„å»ºäº†ä¸€ä¸ªäº¤äº’ç³»ç»Ÿï¼Œç”¨ä»¥å»ºæ¨¡è‡ªç„¶æ•°å’Œç®—æœ¯ã€‚è®©æˆ‘ä»¬æ¥ç†è§£ï¼š
- en: 'First, he defined *cells* for the **s** and **0** symbols:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: é¦–å…ˆï¼Œä»–ä¸º**s**å’Œ**0**ç¬¦å·å®šä¹‰äº†*å•å…ƒ*ï¼š
- en: '![](../Images/4ea3ec73a34ccf2d96466542da9acaa7.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4ea3ec73a34ccf2d96466542da9acaa7.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…å›¾åƒï¼Œçµæ„Ÿæ¥è‡ªäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: 'Then, the *cell* for the addition operation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œå®šä¹‰åŠ æ³•è¿ç®—çš„*å•å…ƒ*ï¼š
- en: '![](../Images/d95bc121072804cd7d37597788eb8880.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d95bc121072804cd7d37597788eb8880.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…å›¾åƒï¼Œçµæ„Ÿæ¥è‡ªäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: It seems strange, I know, but I promise will it will further make sense.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çŸ¥é“è¿™çœ‹èµ·æ¥å¾ˆå¥‡æ€ªï¼Œä½†æˆ‘ä¿è¯å®ƒä¼šå˜å¾—æ›´åŠ æœ‰æ„ä¹‰ã€‚
- en: 'If all natural numbers can be expressed using only the symbols **0** and successor
    **s**, for addition we need to define just two *interaction* rules: how an addition
    interacts with successor and with **0\.** Therefore, Lafont introduced the two
    following *interaction* rules:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæ‰€æœ‰è‡ªç„¶æ•°éƒ½å¯ä»¥ä»…ä½¿ç”¨ç¬¦å· **0** å’Œåç»§ **s** æ¥è¡¨ç¤ºï¼Œé‚£ä¹ˆå¯¹äºåŠ æ³•ï¼Œæˆ‘ä»¬åªéœ€è¦å®šä¹‰ä¸¤ä¸ª *äº¤äº’* è§„åˆ™ï¼šåŠ æ³•å¦‚ä½•ä¸åç»§å’Œ **0**
    è¿›è¡Œäº¤äº’ã€‚å› æ­¤ï¼ŒLafont æå‡ºäº†ä»¥ä¸‹ä¸¤ä¸ª *äº¤äº’* è§„åˆ™ï¼š
- en: '![](../Images/889329bea2557cffd9453a2471b0bbfe.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/889329bea2557cffd9453a2471b0bbfe.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥è‡ªä½œè€…ï¼Œçµæ„Ÿæ¥æºäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: 'Compare these rules with the Peanoâ€™s equations for addition, they are extactly
    the same expressions:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: å°†è¿™äº›è§„åˆ™ä¸çš®äºšè¯ºåŠ æ³•çš„æ–¹ç¨‹è¿›è¡Œæ¯”è¾ƒï¼Œå®ƒä»¬æ­£å¥½æ˜¯ç›¸åŒçš„è¡¨è¾¾å¼ï¼š
- en: s(x) + y = s(x+y)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: s(x) + y = s(x+y)
- en: '**0** + y = y'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**0** + y = y'
- en: 'Now, letâ€™s understand the *interaction* rules for multiplication. The *cell*
    for multiplication is defined as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ç†è§£ä¹˜æ³•çš„ *äº¤äº’* è§„åˆ™ã€‚ä¹˜æ³•çš„ *å•å…ƒæ ¼* å®šä¹‰å¦‚ä¸‹ï¼š
- en: '![](../Images/8fd1125c9726eca7ace99e90589b24b7.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8fd1125c9726eca7ace99e90589b24b7.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥è‡ªä½œè€…ï¼Œçµæ„Ÿæ¥æºäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: 'Now, take a look at Peanoâ€™s equations:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œçœ‹çœ‹çš®äºšè¯ºçš„æ–¹ç¨‹ï¼š
- en: y Ã— **0** = **0**
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: y Ã— **0** = **0**
- en: s(x) Ã— y = (x Ã— y) + y
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: s(x) Ã— y = (x Ã— y) + y
- en: Note that the first equation â€œerasesâ€ the y variable (y appears on the left
    side of the equation and do not appear on the right side). In the second equation,
    the y is â€œduplicatedâ€ with another multiplication and an addition.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: æ³¨æ„ï¼Œç¬¬ä¸€ä¸ªæ–¹ç¨‹â€œæŠ¹é™¤â€äº† y å˜é‡ï¼ˆy å‡ºç°åœ¨æ–¹ç¨‹çš„å·¦ä¾§ï¼Œä½†åœ¨å³ä¾§æ²¡æœ‰å‡ºç°ï¼‰ã€‚åœ¨ç¬¬äºŒä¸ªæ–¹ç¨‹ä¸­ï¼Œy è¢«â€œå¤åˆ¶â€äº†ï¼Œé€šè¿‡å¦ä¸€ä¸ªä¹˜æ³•å’ŒåŠ æ³•ã€‚
- en: 'Thus, two other symbols are needed: *Îµ (eraser)* and *Î´ (duplicator).*'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè¿˜éœ€è¦å¦å¤–ä¸¤ä¸ªç¬¦å·ï¼š*Îµ (æŠ¹é™¤å™¨)* å’Œ *Î´ (å¤åˆ¶å™¨)*ã€‚
- en: '![](../Images/ad52d6c71df9df7fbe0efef5b4b1d0ec.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ad52d6c71df9df7fbe0efef5b4b1d0ec.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥è‡ªä½œè€…ï¼Œçµæ„Ÿæ¥æºäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: 'The idea of this symbols is that a net representing natural numbers will be
    erased when connected to the principal port of *Îµ,* and it will be duplicated
    if it is connected to the principal port of *Î´.* Now, the multiplication rule
    can be represented as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™äº›ç¬¦å·çš„æ€æƒ³æ˜¯ï¼Œè¡¨ç¤ºè‡ªç„¶æ•°çš„ç½‘ç»œåœ¨è¿æ¥åˆ° *Îµ* çš„ä¸»ç«¯å£æ—¶ä¼šè¢«æŠ¹é™¤ï¼Œè€Œè¿æ¥åˆ° *Î´* çš„ä¸»ç«¯å£æ—¶åˆ™ä¼šè¢«å¤åˆ¶ã€‚ç°åœ¨ï¼Œä¹˜æ³•è§„åˆ™å¯ä»¥è¡¨ç¤ºä¸ºï¼š
- en: '![](../Images/5edbb6983572225d6bf4503b71f98e38.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5edbb6983572225d6bf4503b71f98e38.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥è‡ªä½œè€…ï¼Œçµæ„Ÿæ¥æºäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: 'Try to reflect on how they are similar to the Peanoâ€™s expressions:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: å°è¯•åæ€å®ƒä»¬ä¸çš®äºšè¯ºè¡¨è¾¾å¼çš„ç›¸ä¼¼ä¹‹å¤„ï¼š
- en: s(x) Ã— y = (x Ã— y) + y
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: s(x) Ã— y = (x Ã— y) + y
- en: y Ã— **0** = **0**
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: y Ã— **0** = **0**
- en: 'The *interaction* rules for *duplicator* and *eraser* with *successor* and
    0 are defined as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*äº¤äº’* è§„åˆ™å¯¹äº *å¤åˆ¶å™¨* å’Œ *æŠ¹é™¤å™¨* ä¸ *åç»§* å’Œ 0 çš„å®šä¹‰å¦‚ä¸‹ï¼š'
- en: '![](../Images/1fee674e8bd92a26f2008a095ee6487f.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1fee674e8bd92a26f2008a095ee6487f.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾åƒæ¥è‡ªä½œè€…ï¼Œçµæ„Ÿæ¥æºäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: 'Thus, we have a set of six symbols **{0, s, +**, Ã—, *Î´, Îµ*} with the following
    set of eight *interaction* rules: **{(s**, +), **(0, +)**, **(s**, Ã—), **(0**,
    Ã—), **(s***, Î´*)*,* **(*0****, Î´*)*,* **(*s****, Îµ*)*,* **(*0****, Îµ*)}. Letâ€™s
    analyze them in practice for the operation 2 Ã— 2.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬æœ‰ä¸€ç»„å…­ä¸ªç¬¦å· **{0, s, +**, Ã—, *Î´, Îµ*} å’Œä»¥ä¸‹å…«ä¸ª *äº¤äº’* è§„åˆ™ï¼š**{(s**, +), **(0, +)**,
    **(s**, Ã—), **(0**, Ã—), **(s***, Î´*)*,* **(*0****, Î´*)*,* **(*s****, Îµ*)*,* **(*0****,
    Îµ*)}ã€‚è®©æˆ‘ä»¬é€šè¿‡æ“ä½œ 2 Ã— 2 æ¥å®é™…åˆ†æå®ƒä»¬ã€‚
- en: '![](../Images/7761269faea0c99e55e76dd3028a0622.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7761269faea0c99e55e76dd3028a0622.png)'
- en: 2 x 2\. Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 2 x 2ã€‚å›¾åƒæ¥è‡ªä½œè€…ï¼Œçµæ„Ÿæ¥æºäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: 'If you take a look, there is an active pair (**s**, Ã—) that we can apply the
    Rule #3.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'å¦‚æœä½ ä»”ç»†çœ‹ï¼Œä¼šå‘ç°æœ‰ä¸€ä¸ªæ´»è·ƒçš„å¯¹ (**s**, Ã—)ï¼Œæˆ‘ä»¬å¯ä»¥åº”ç”¨è§„åˆ™ #3ã€‚'
- en: '![](../Images/4d416f15180cb9da8b6cf32136505daf.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4d416f15180cb9da8b6cf32136505daf.png)'
- en: 'Applying *interaction rule #3\.* Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: åº”ç”¨*äº¤äº’è§„åˆ™#3*ã€‚å›¾ç‰‡æ¥æºï¼šä½œè€…ï¼Œçµæ„Ÿæ¥è‡ªäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: 'Therefore, the operation is solved by applying the *interaction* rules until
    we reach an irreducible form:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œè¿ç®—é€šè¿‡åº”ç”¨*äº¤äº’*è§„åˆ™æ¥è§£å†³ï¼Œç›´åˆ°æˆ‘ä»¬å¾—åˆ°ä¸€ä¸ªä¸å¯çº¦çš„å½¢å¼ï¼š
- en: '![](../Images/67e138061a4d076406a1a498898e633e.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/67e138061a4d076406a1a498898e633e.png)'
- en: 2x2 = 4\. Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 2x2 = 4ã€‚å›¾ç‰‡æ¥æºï¼šä½œè€…ï¼Œçµæ„Ÿæ¥è‡ªäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: 'Take a look at the final form that we have reached: **s**(**s**(**s**(**s**
    **0**))).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹çœ‹æˆ‘ä»¬å·²ç»å¾—åˆ°çš„æœ€ç»ˆå½¢å¼ï¼š**s**(**s**(**s**(**s** **0**))).
- en: '![](../Images/5ada222ea12c2d41ccfdf3c448047307.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5ada222ea12c2d41ccfdf3c448047307.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…ï¼Œçµæ„Ÿæ¥è‡ªäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: It is exactly the definition of the numeral 4, the result of 2 Ã— 2! Amazing,
    right? After some manipulation of strange symbols, we could solve an arithmetic
    operation! ğŸ˜€
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ­£æ˜¯æ•°å­—4çš„å®šä¹‰ï¼Œ2 Ã— 2çš„ç»“æœï¼ä»¤äººæƒŠè®¶ï¼Œå¯¹å§ï¼Ÿç»è¿‡ä¸€äº›å¥‡æ€ªç¬¦å·çš„æ“ä½œåï¼Œæˆ‘ä»¬ç«Ÿç„¶èƒ½è§£å‡ºä¸€ä¸ªç®—æœ¯è¿ç®—ï¼ğŸ˜€
- en: But why do such a complicated thing? What are the advantages of solving problems
    using these manipulations?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œä¸ºä»€ä¹ˆè¦åšè¿™ä¹ˆå¤æ‚çš„äº‹æƒ…å‘¢ï¼Ÿä½¿ç”¨è¿™äº›æ“ä½œæ¥è§£å†³é—®é¢˜æœ‰ä»€ä¹ˆä¼˜åŠ¿å‘¢ï¼Ÿ
- en: 'Lafontâ€™s nets have an interesting property: if a net *Î¼* can reduce in one
    step to two different possible *nets v* or *vâ€™,* then *v* and *vâ€™* reduce in one
    step to a common net Î¾.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Lafontçš„ç½‘ç»œæœ‰ä¸€ä¸ªæœ‰è¶£çš„æ€§è´¨ï¼šå¦‚æœä¸€ä¸ªç½‘ç»œ*Î¼*èƒ½åœ¨ä¸€æ­¥å†…å‡å°‘åˆ°ä¸¤ä¸ªä¸åŒçš„å¯èƒ½ç½‘ç»œ*v*æˆ–*vâ€™*ï¼Œé‚£ä¹ˆ*v*å’Œ*vâ€™*éƒ½èƒ½åœ¨ä¸€æ­¥å†…å‡å°‘åˆ°ä¸€ä¸ªå…±åŒçš„ç½‘ç»œÎ¾ã€‚
- en: '![](../Images/e93f8e38d3ba54b98c86d32876d794d3.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e93f8e38d3ba54b98c86d32876d794d3.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…ï¼Œçµæ„Ÿæ¥è‡ªäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: The consequence of this confluence property is that if a net *Î¼* reduces to
    *v* in *n* steps, then any sequence of reductions will reach *v* in *n* steps.
    In other words, the order of the application of *interaction* rules does not matter,
    the net will reach the same form with the same amount of steps!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ç§æ±‡èšæ€§è´¨çš„ç»“æœæ˜¯ï¼Œå¦‚æœä¸€ä¸ªç½‘ç»œ*Î¼*åœ¨*n*æ­¥å†…å‡å°‘åˆ°*v*ï¼Œé‚£ä¹ˆä»»ä½•ä¸€ç³»åˆ—çš„å‡å°‘éƒ½ä¼šåœ¨*n*æ­¥å†…è¾¾åˆ°*v*ã€‚æ¢å¥è¯è¯´ï¼Œ*äº¤äº’*è§„åˆ™çš„åº”ç”¨é¡ºåºå¹¶ä¸é‡è¦ï¼Œç½‘ç»œå°†åœ¨ç›¸åŒçš„æ­¥æ•°å†…è¾¾åˆ°ç›¸åŒçš„å½¢å¼ï¼
- en: Did you get the power of this property? Basically, if the order of interactions
    doesnâ€™t matter, we can apply them in parallel! ğŸ¤¯
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ä½ æ„Ÿå—åˆ°è¿™ç§æ€§è´¨çš„åŠ›é‡äº†å—ï¼ŸåŸºæœ¬ä¸Šï¼Œå¦‚æœäº¤äº’çš„é¡ºåºæ— å…³ç´§è¦ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¹¶è¡Œåº”ç”¨å®ƒä»¬ï¼ğŸ¤¯
- en: 'For instance, on our previous 2 Ã— 2 operation, instead of applying the rules
    one by one, we could parallelize them at moments like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ä¾‹å¦‚ï¼Œåœ¨æˆ‘ä»¬ä¹‹å‰çš„2 Ã— 2è¿ç®—ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ç±»ä¼¼çš„æ—¶åˆ»å¹¶è¡Œåº”ç”¨è¿™äº›è§„åˆ™ï¼Œè€Œä¸æ˜¯ä¸€æ¡æ¡é€ä¸ªåº”ç”¨ï¼š
- en: '![](../Images/9025d9f135f76590a34ec27617ad153c.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9025d9f135f76590a34ec27617ad153c.png)'
- en: Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥æºï¼šä½œè€…ï¼Œçµæ„Ÿæ¥è‡ªäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: In actual execution, both rules could be parallelized by running them in two
    separated threads, without concerns about thread collisions and other common issues
    related to parallelism. And thatâ€™s one of the core principles on which HVM/Bend
    is founded! Based on that, all operations that can be parallelized will be inherently
    parallelized!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å®é™…æ‰§è¡Œä¸­ï¼Œè¿™ä¸¤æ¡è§„åˆ™å¯ä»¥é€šè¿‡åœ¨ä¸¤ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ä¸­å¹¶è¡Œè¿è¡Œï¼Œä»è€Œé¿å…çº¿ç¨‹å†²çªå’Œå…¶ä»–ä¸å¹¶è¡Œæ€§ç›¸å…³çš„å¸¸è§é—®é¢˜ã€‚è¿™ä¹Ÿæ˜¯HVM/Bendæ‰€åŸºäºçš„æ ¸å¿ƒåŸåˆ™ä¹‹ä¸€ï¼åŸºäºè¿™ä¸€ç‚¹ï¼Œæ‰€æœ‰å¯ä»¥å¹¶è¡ŒåŒ–çš„æ“ä½œéƒ½å°†è¢«æœ¬è´¨åœ°å¹¶è¡ŒåŒ–ï¼
- en: Now that we understand interaction nets, letâ€™s take one more step. Earlier in
    this article, I mentioned that HVM was based on Interaction Combinators, so letâ€™s
    understand how these concepts relate.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬å·²ç»ç†è§£äº†äº¤äº’ç½‘ç»œï¼Œè®©æˆ‘ä»¬å†è¿ˆè¿›ä¸€æ­¥ã€‚ä¹‹å‰åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘æåˆ°HVMæ˜¯åŸºäºäº¤äº’ç»„åˆå­çš„ï¼Œé‚£ä¹ˆè®©æˆ‘ä»¬æ¥ç†è§£è¿™äº›æ¦‚å¿µä¹‹é—´çš„å…³ç³»ã€‚
- en: Interaction Combinators
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: äº¤äº’ç»„åˆå­
- en: Based on his earlier Interaction Nets work, Yves Lafont created the Interaction
    Combinators. The idea was to create a representation of computation using a minimal
    set of primitives, called combinators. While interaction nets use graph rewriting
    to model computation explicitly, interaction combinators refine this by focusing
    on the fundamental combinatory logic. This shift provides a more abstract but
    more powerful framework for expressing computation processes.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: åŸºäºä»–æ—©æœŸçš„äº¤äº’ç½‘å·¥ä½œï¼ŒYves Lafontåˆ›å»ºäº†äº¤äº’ç»„åˆå­ã€‚è¿™ä¸ªæ€æƒ³æ˜¯ä½¿ç”¨ä¸€ä¸ªæœ€å°çš„åŸºæœ¬ç¬¦å·é›†ï¼ˆç§°ä¸ºç»„åˆå­ï¼‰æ¥åˆ›å»ºè®¡ç®—çš„è¡¨ç¤ºã€‚è™½ç„¶äº¤äº’ç½‘é€šè¿‡å›¾é‡å†™æ˜¾å¼åœ°å»ºæ¨¡è®¡ç®—ï¼Œäº¤äº’ç»„åˆå­åˆ™é€šè¿‡ä¸“æ³¨äºåŸºæœ¬çš„ç»„åˆé€»è¾‘æ¥æ”¹è¿›è¿™ä¸€ç‚¹ã€‚è¿™ä¸€è½¬å˜æä¾›äº†ä¸€ä¸ªæ›´åŠ æŠ½è±¡ä½†æ›´å¼ºå¤§çš„æ¡†æ¶ï¼Œç”¨äºè¡¨è¾¾è®¡ç®—è¿‡ç¨‹ã€‚
- en: 'For interaction combinators, Lafont defined three symbols (also called combinators):
    Î³ (*constructor*), *Î´* (*duplicator*)and *Îµ (eraser).*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºäº¤äº’ç»„åˆå­ï¼ŒLafontå®šä¹‰äº†ä¸‰ä¸ªç¬¦å·ï¼ˆä¹Ÿç§°ä¸ºç»„åˆå­ï¼‰ï¼šÎ³ï¼ˆ*æ„é€ å­*ï¼‰ï¼Œ*Î´*ï¼ˆ*å¤åˆ¶å­*ï¼‰å’Œ*Îµ*ï¼ˆ*æ“¦é™¤å­*ï¼‰ã€‚
- en: 'Using these three combinators, a total of only six rules were created. These
    rules are divided into:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™ä¸‰ä¸ªç»„åˆå­ï¼Œæ€»å…±åˆ›å»ºäº†ä»…å…­æ¡è§„åˆ™ã€‚è¿™äº›è§„åˆ™åˆ†ä¸ºï¼š
- en: '*commutation â€”* when two cells of different symbols interact (Î³*Î´,* Î³*Îµ, Î´Îµ*);'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*äº¤æ¢* â€” å½“ä¸¤ä¸ªä¸åŒç¬¦å·çš„å•å…ƒäº’ç›¸ä½œç”¨æ—¶ï¼ˆÎ³*Î´,* Î³*Îµ, Î´Îµ*ï¼‰ï¼›'
- en: '*annihilation â€”* when two cells of the same symbol interact (Î³Î³, *Î´Î´, ÎµÎµ*).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*æ¹®ç­* â€” å½“ä¸¤ä¸ªç›¸åŒç¬¦å·çš„å•å…ƒäº’ç›¸ä½œç”¨æ—¶ï¼ˆÎ³Î³ï¼Œ*Î´Î´ï¼ŒÎµÎµ*ï¼‰ã€‚'
- en: 'The rules are defined below:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: è§„åˆ™å¦‚ä¸‹æ‰€å®šä¹‰ï¼š
- en: '![](../Images/3aa98d277576638e82070613893d2955.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3aa98d277576638e82070613893d2955.png)'
- en: Commutation rules. Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: äº¤æ¢è§„åˆ™ã€‚å›¾ç‰‡æ¥è‡ªä½œè€…ï¼Œçµæ„Ÿæ¥æºäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: '![](../Images/97e11564dd402b1e26d0184ab2c06034.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/97e11564dd402b1e26d0184ab2c06034.png)'
- en: Annihilation rules. Image by author, inspired from [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: æ¹®ç­è§„åˆ™ã€‚å›¾ç‰‡æ¥è‡ªä½œè€…ï¼Œçµæ„Ÿæ¥æºäº [Lafont, 1997](https://www.sciencedirect.com/science/article/pii/S0890540197926432)
- en: Therefore, using only these six rules you can model any computable algorithm!
    Amazing, right?
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œä»…ä½¿ç”¨è¿™å…­æ¡è§„åˆ™ï¼Œä½ å°±å¯ä»¥å»ºæ¨¡ä»»ä½•å¯è®¡ç®—çš„ç®—æ³•ï¼æƒŠäººå§ï¼Œå¯¹å§ï¼Ÿ
- en: 'However, the HVM runtime uses a variant of Lafontâ€™s interaction combinators,
    called [Symmetric Interaction Combinators (SIC) (Mazza, 2007)](https://lipn.univ-paris13.fr/~mazza/papers/CombSem-MSCS.pdf).
    This variant is a simplified version that uses the same rewrite rule for all of
    its symbols:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶è€Œï¼ŒHVMè¿è¡Œæ—¶ä½¿ç”¨çš„æ˜¯Lafontçš„äº¤äº’ç»„åˆå­çš„ä¸€ä¸ªå˜ä½“ï¼Œç§°ä¸º[å¯¹ç§°äº¤äº’ç»„åˆå­ (SIC) (Mazza, 2007)](https://lipn.univ-paris13.fr/~mazza/papers/CombSem-MSCS.pdf)ã€‚è¿™ä¸ªå˜ä½“æ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆï¼Œå®ƒå¯¹æ‰€æœ‰ç¬¦å·ä½¿ç”¨ç›¸åŒçš„é‡å†™è§„åˆ™ï¼š
- en: '![](../Images/0d41aba45a4959823ee000d41ec2d648.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0d41aba45a4959823ee000d41ec2d648.png)'
- en: Symmetric Interaction Combinators rules. Image by author, inspired from [Mazza,
    2007](https://lipn.univ-paris13.fr/~mazza/papers/CombSem-MSCS.pdf)
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹ç§°äº¤äº’ç»„åˆå­è§„åˆ™ã€‚å›¾ç‰‡æ¥è‡ªä½œè€…ï¼Œçµæ„Ÿæ¥æºäº [Mazza, 2007](https://lipn.univ-paris13.fr/~mazza/papers/CombSem-MSCS.pdf)
- en: As you can see, the single difference is that the rules Î³Î³ and *Î´Î´* are now
    the similar*.* The crucial confluence property is maintained, preserving its parallelization
    capability.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚ä½ æ‰€è§ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯è§„åˆ™Î³Î³å’Œ*Î´Î´*ç°åœ¨æ˜¯ç›¸ä¼¼çš„*ã€‚* å…³é”®çš„æ±‡èšæ€§è´¨å¾—ä»¥ä¿æŒï¼Œä¿ç•™äº†å…¶å¹¶è¡ŒåŒ–èƒ½åŠ›ã€‚
- en: '*For now on, we will be using the SIC rules for our examples, so focus on them.*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*ä»ç°åœ¨å¼€å§‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨SICè§„åˆ™è¿›è¡Œç¤ºä¾‹ï¼Œå› æ­¤è¯·ä¸“æ³¨äºå®ƒä»¬ã€‚*'
- en: Lambda Calculus â†’ Symmetric Interaction Combinators
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda æ¼”ç®— â†’ å¯¹ç§°äº¤äº’ç»„åˆå­
- en: Now you may be asking â€œHow can I write programs using that? How to transform
    my Python function into interaction combinators drawings?â€
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ä½ å¯èƒ½ä¼šé—®ï¼šâ€œæˆ‘è¯¥å¦‚ä½•ä½¿ç”¨è¿™äº›å†™ç¨‹åºï¼Ÿå¦‚ä½•å°†æˆ‘çš„Pythonå‡½æ•°è½¬æ¢ä¸ºäº¤äº’ç»„åˆå­å›¾å½¢ï¼Ÿâ€
- en: I mentioned before that you can represent any computable algorithm using lambda
    calculus right?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä¹‹å‰æåˆ°è¿‡ï¼Œä½ å¯ä»¥ä½¿ç”¨Î»æ¼”ç®—è¡¨ç¤ºä»»ä½•å¯è®¡ç®—çš„ç®—æ³•ï¼Œå¯¹å§ï¼Ÿ
- en: 'Now another information: you can transform lambda calculus into interaction
    combinators!'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æœ‰å¦å¤–ä¸€æ¡ä¿¡æ¯ï¼šä½ å¯ä»¥å°†Î»æ¼”ç®—è½¬æ¢ä¸ºäº¤äº’ç»„åˆå­ï¼
- en: Thus, any program can be transformed into lambda calculus, then transformed
    into interaction combinators, run in parallel and then be transformed back!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œä»»ä½•ç¨‹åºéƒ½å¯ä»¥è½¬æ¢ä¸ºÎ»æ¼”ç®—ï¼Œç„¶åè½¬æ¢ä¸ºäº¤äº’ç»„åˆå­ï¼Œè¿›è¡Œå¹¶è¡Œè¿è¡Œï¼Œå†è½¬æ¢å›æ¥ï¼
- en: '![](../Images/e076537acd1508b1239640bb52df6823.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e076537acd1508b1239640bb52df6823.png)'
- en: Image by author
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡æ¥è‡ªä½œè€…
- en: So, letâ€™s understand how you can translate lambdas to interaction combinators!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: é‚£ä¹ˆï¼Œè®©æˆ‘ä»¬ç†è§£å¦‚ä½•å°†Î»è½¬æ¢ä¸ºäº¤äº’ç»„åˆå­ï¼
- en: 'Lambda *expressions ( Î» )* and *applications* ( @ ) can be expressed using
    a constructor Î³. For instance, a lambda *expression Î»x.y* can be expressed as
    follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda *è¡¨è¾¾å¼ ( Î» )* å’Œ *åº”ç”¨*ï¼ˆ@ï¼‰å¯ä»¥é€šè¿‡æ„é€ å­Î³è¡¨ç¤ºã€‚ä¾‹å¦‚ï¼Œlambda *è¡¨è¾¾å¼ Î»x.y* å¯ä»¥è¡¨ç¤ºä¸ºï¼š
- en: '![](../Images/c58777ecbcf6e4a9491e3330b3b727ff.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c58777ecbcf6e4a9491e3330b3b727ff.png)'
- en: Lambda expression using SIC. Image by author
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ SIC çš„ Lambda è¡¨è¾¾å¼ã€‚ä½œè€…æä¾›çš„å›¾ç‰‡
- en: 'And for a given *application f x,* we can express it as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: å¯¹äºç»™å®šçš„ *åº”ç”¨ f x*ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶è¡¨ç¤ºä¸ºï¼š
- en: '![](../Images/ebe37c5809c0a8c423f30e0b0fd100aa.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ebe37c5809c0a8c423f30e0b0fd100aa.png)'
- en: Lambda application using SIC. Image by author
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ SIC çš„ Lambda åº”ç”¨ã€‚ä½œè€…æä¾›çš„å›¾ç‰‡
- en: Using these representations, we can express the identity *expression Î»x.x (*given
    *x*, return *x* itself*):*
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨è¿™äº›è¡¨ç¤ºæ³•ï¼Œæˆ‘ä»¬å¯ä»¥è¡¨è¾¾æ’ç­‰å¼ *è¡¨è¾¾å¼ Î»x.xï¼ˆ*ç»™å®š *x*ï¼Œè¿”å› *x* æœ¬èº«*ï¼‰ï¼š*
- en: '![](../Images/e373013cf236a706a208fb551c9163fb.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e373013cf236a706a208fb551c9163fb.png)'
- en: '*Î»x.x. Image by author*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*Î»x.xã€‚ä½œè€…æä¾›çš„å›¾ç‰‡*'
- en: Now, imagine we want to do the *application* (*Î»x.x)y:*
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå‡è®¾æˆ‘ä»¬æƒ³è¿›è¡Œ *åº”ç”¨*ï¼ˆ*Î»x.x)y*ï¼š
- en: '![](../Images/a35facf020a380ffda8f89664bb32938.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a35facf020a380ffda8f89664bb32938.png)'
- en: '*(Î»x.x)y* Image by author'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*(Î»x.x)y* ä½œè€…æä¾›çš„å›¾ç‰‡'
- en: If we reduce the expression (*Î»x.x)y,* we will get *y* as result. Letâ€™s analyze
    what can we get using SIC rules?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœæˆ‘ä»¬ç®€åŒ–è¡¨è¾¾å¼ (*Î»x.x)yï¼Œ*æˆ‘ä»¬ä¼šå¾—åˆ° *y* ä½œä¸ºç»“æœã€‚è®©æˆ‘ä»¬åˆ†æä¸€ä¸‹ä½¿ç”¨ SIC è§„åˆ™å¯ä»¥å¾—åˆ°ä»€ä¹ˆï¼Ÿ
- en: Notice that when there is an *application* applied to a lambda *expression,*
    there will be an *active pair* that we can reduce! In this case, we will apply
    the interaction rule Î³Î³. Also, for now on, we will use a circle to identify the
    final calculation result we are interested in.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: è¯·æ³¨æ„ï¼Œå½“ä¸€ä¸ª *åº”ç”¨* åº”ç”¨äºä¸€ä¸ª lambda *è¡¨è¾¾å¼* æ—¶ï¼Œä¼šæœ‰ä¸€ä¸ª *æ´»åŠ¨å¯¹*ï¼Œæˆ‘ä»¬å¯ä»¥ç®€åŒ–å®ƒï¼åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°†åº”ç”¨äº¤äº’è§„åˆ™ Î³Î³ã€‚åŒæ—¶ï¼Œä»ç°åœ¨å¼€å§‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨åœ†åœˆæ¥æ ‡è¯†æˆ‘ä»¬æ„Ÿå…´è¶£çš„æœ€ç»ˆè®¡ç®—ç»“æœã€‚
- en: '![](../Images/cc9a7092abf3788fcfe1de34ad230f0f.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cc9a7092abf3788fcfe1de34ad230f0f.png)'
- en: Image bu author
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡
- en: As you can notice, (*Î»x.x)y* was correctly reduced to *y*! Amazing, right?
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: æ­£å¦‚ä½ æ‰€çœ‹åˆ°çš„ï¼Œ(*Î»x.x)y* è¢«æ­£ç¡®åœ°ç®€åŒ–ä¸º *y*ï¼å¾ˆç¥å¥‡ï¼Œå¯¹å§ï¼Ÿ
- en: 'Now, imagine we want to express *Î»f.ff (*given *f,* apply *f* to itself). As
    you can notice, the parameter *f* is *duplicated* on the body. Thatâ€™s when the
    *duplicator (*Î´) comes into action! We can use *duplicators* to copy (duplicate)
    values:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå‡è®¾æˆ‘ä»¬æƒ³è¡¨è¾¾ *Î»f.ffï¼ˆ*ç»™å®š *f*ï¼Œå°† *f* åº”ç”¨åˆ°å®ƒè‡ªèº«ï¼‰ã€‚æ­£å¦‚ä½ æ‰€æ³¨æ„åˆ°çš„ï¼Œå‚æ•° *f* åœ¨ä¸»ä½“éƒ¨åˆ†æ˜¯ *é‡å¤* çš„ã€‚è¿™æ—¶ï¼Œ*å¤åˆ¶å™¨*ï¼ˆ*Î´ï¼‰å°±æ´¾ä¸Šç”¨åœºäº†ï¼æˆ‘ä»¬å¯ä»¥ä½¿ç”¨
    *å¤åˆ¶å™¨* æ¥å¤åˆ¶ï¼ˆé‡å¤ï¼‰å€¼ï¼š
- en: '![](../Images/278b9ee8e57d4cb0d5631b5852fa73f1.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/278b9ee8e57d4cb0d5631b5852fa73f1.png)'
- en: Image by author
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡
- en: 'Letâ€™s go back to our expression *Î»f.ff.* First, identify that this is an *expression*
    that given the input *f,* it outputs the *application f applied to f itself.*
    Therefore, it can be expressed as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å›åˆ°æˆ‘ä»¬çš„è¡¨è¾¾å¼ *Î»f.ff*ã€‚é¦–å…ˆï¼Œç¡®è®¤è¿™æ˜¯ä¸€ä¸ª *è¡¨è¾¾å¼*ï¼Œå®ƒæ¥å—è¾“å…¥ *f*ï¼Œå¹¶è¾“å‡º *f åº”ç”¨åˆ°å®ƒè‡ªèº«*ã€‚å› æ­¤ï¼Œå®ƒå¯ä»¥è¡¨ç¤ºä¸ºï¼š
- en: '![](../Images/0ce8478c7bffeffd294cca11cf909fd5.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0ce8478c7bffeffd294cca11cf909fd5.png)'
- en: â€œGiven *f,* output *f* applied to *fâ€. Image by author*
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: â€œç»™å®š *f*ï¼Œè¾“å‡º *f* åº”ç”¨åˆ° *f*â€ã€‚ä½œè€…æä¾›çš„å›¾ç‰‡*
- en: 'Beyond duplication, variables can also be vanished. For instance, letâ€™s take
    the Church number **0 :=** *Î»f.Î»x.x.* This expression can be read as â€œgiven two
    variables *f* and *x,* return *xâ€.* As you can notice, the variable *f* is not
    used at the output. If we tried to represent using SIC with our current knowledge,
    we would obtain:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†å¤åˆ¶ï¼Œå˜é‡ä¹Ÿå¯ä»¥æ¶ˆå¤±ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹æ•™å ‚æ•°å­— **0 :=** *Î»f.Î»x.x*ã€‚è¿™ä¸ªè¡¨è¾¾å¼å¯ä»¥è§£è¯»ä¸ºâ€œç»™å®šä¸¤ä¸ªå˜é‡ *f* å’Œ *x*ï¼Œè¿”å›
    *x*â€ã€‚æ­£å¦‚ä½ æ‰€æ³¨æ„åˆ°çš„ï¼Œå˜é‡ *f* åœ¨è¾“å‡ºä¸­æ²¡æœ‰è¢«ä½¿ç”¨ã€‚å¦‚æœæˆ‘ä»¬è¯•å›¾ç”¨å½“å‰çš„ SIC çŸ¥è¯†è¡¨ç¤ºå®ƒï¼Œæˆ‘ä»¬å°†å¾—åˆ°ï¼š
- en: '![](../Images/9ae939db655d63c9f4ebd1d9413bd566.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9ae939db655d63c9f4ebd1d9413bd566.png)'
- en: Image by author
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡
- en: 'The *f* wire is floating. Something seems wrong, right? Thatâ€™s why we have
    the *eraser Îµ!* In order to represent this variable disappearance we do:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '*f* çº¿æ¼‚æµ®ç€ã€‚ä¼¼ä¹æœ‰ç‚¹é—®é¢˜ï¼Œå¯¹å§ï¼Ÿè¿™å°±æ˜¯æˆ‘ä»¬éœ€è¦ *æ©¡çš®æ“¦ Îµ* çš„åŸå› ï¼ä¸ºäº†è¡¨ç¤ºè¿™ä¸ªå˜é‡çš„æ¶ˆå¤±ï¼Œæˆ‘ä»¬è¿™æ ·åšï¼š'
- en: '![](../Images/6040c5d8fa64b89e2b89de2eb863ec5c.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6040c5d8fa64b89e2b89de2eb863ec5c.png)'
- en: Image by author.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡ã€‚
- en: 'In summary, we can handle Lambda Calculus with Symmetric Interaction Combinators
    using:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: æ€»ç»“ä¸€ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼ä½¿ç”¨å¯¹ç§°äº¤äº’ç»„åˆå­å¤„ç† Lambda æ¼”ç®—ï¼š
- en: '![](../Images/069a7921a0fe243a1b2ec902d8e22bc4.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/069a7921a0fe243a1b2ec902d8e22bc4.png)'
- en: Image by author. Inspired by [https://zicklag.katharos.group/blog/interaction-nets-combinators-calculus/](https://zicklag.katharos.group/blog/interaction-nets-combinators-calculus/)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡ã€‚çµæ„Ÿæ¥æºäº [https://zicklag.katharos.group/blog/interaction-nets-combinators-calculus/](https://zicklag.katharos.group/blog/interaction-nets-combinators-calculus/)
- en: Examples
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹
- en: Now that we covered these transformations, we are able to perform more complex
    operations.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬å·²ç»è¦†ç›–äº†è¿™äº›è½¬æ¢ï¼Œèƒ½å¤Ÿæ‰§è¡Œæ›´å¤æ‚çš„æ“ä½œäº†ã€‚
- en: Church numbers
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä¹”æ²»Â·æ•™å ‚æ•°å­—
- en: Letâ€™s draw some Church numbers!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç”»ä¸€äº›ä¹”æ²»Â·æ•™å ‚æ•°å­—ï¼
- en: '![](../Images/71ff48be81fb16b7f945787eb7255ece.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/71ff48be81fb16b7f945787eb7255ece.png)'
- en: Image by author
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…æä¾›çš„å›¾ç‰‡
- en: 'Before we go further, try to replicate this yourself! Get a paper and start
    drawing! For instance, letâ€™s try to draw together the Church number four: *Î»f.Î»x.f(f(f(f
    x))).*'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬ç»§ç»­ä¹‹å‰ï¼Œè¯•ç€è‡ªå·±åšä¸€ä¸‹ï¼æ‹¿å¼ çº¸å¼€å§‹ç”»å§ï¼ä¾‹å¦‚ï¼Œè®©æˆ‘ä»¬ä¸€èµ·å°è¯•ç”»å‡ºæ•™ä¼šæ•° 4ï¼š *Î»f.Î»x.f(f(f(f x)))ã€‚*
- en: The thing that I draw is the outer lambda expression *Î»f.____*
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ç”»çš„ä¸œè¥¿æ˜¯å¤–éƒ¨çš„ lambda è¡¨è¾¾å¼ *Î»f.____*
- en: '![](../Images/4baf00423b2cde5b9974dbf4bd517d25.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4baf00423b2cde5b9974dbf4bd517d25.png)'
- en: Given f, output *Î»*x.f(f(f(f x))). Image by author
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®š fï¼Œè¾“å‡º *Î»*x.f(f(f(f x)))ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: 'Then, the second lambda expression __.*Î»x.*____:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œç¬¬äºŒä¸ª lambda è¡¨è¾¾å¼ __.*Î»x.*____ï¼š
- en: '![](../Images/888164d02fd47ceb1a2abb3a2ff90029.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/888164d02fd47ceb1a2abb3a2ff90029.png)'
- en: Given x, output f(f(f(f x))). Image by author
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ç»™å®š xï¼Œè¾“å‡º f(f(f(f x)))ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: 'Now, we need to draw the *applications* (@). But first, notice that we have
    *f* repeated four times. Therefore, we need to copy (duplicate) *f* three more
    times (so we need three duplicators in sequence):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œæˆ‘ä»¬éœ€è¦ç»˜åˆ¶ *åº”ç”¨*ï¼ˆ@ï¼‰ã€‚ä½†é¦–å…ˆï¼Œè¯·æ³¨æ„æˆ‘ä»¬æœ‰ *f* é‡å¤äº†å››æ¬¡ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å¤åˆ¶ï¼ˆé‡å¤ï¼‰ *f* ä¸‰æ¬¡ï¼ˆæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸‰ä¸ªè¿ç»­çš„å¤åˆ¶å™¨ï¼‰ï¼š
- en: '![](../Images/35deea54aa6b8d04016bec1d7ed8b016.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/35deea54aa6b8d04016bec1d7ed8b016.png)'
- en: Duplications of f. Image by author
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: f çš„å¤åˆ¶ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: Now that we have four copiesof *f,* we can draw the *applications*of *f* to
    *f* in sequence!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨æˆ‘ä»¬æœ‰äº†å››ä¸ª *f* çš„å‰¯æœ¬ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰é¡ºåºç»˜åˆ¶ *f* åˆ° *f* çš„ *åº”ç”¨*ï¼
- en: '![](../Images/5669ee7a20e95e2d0fd88ff9ed37c799.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5669ee7a20e95e2d0fd88ff9ed37c799.png)'
- en: Church number 4 with SIC. Image by author
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ SIC è¡¨ç¤ºæ³•çš„æ•™ä¼šæ•° 4ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: Using the same strategy, we can easily construct other expressions.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ä½¿ç”¨ç›¸åŒçš„ç­–ç•¥ï¼Œæˆ‘ä»¬å¯ä»¥è½»æ¾æ„é€ å…¶ä»–è¡¨è¾¾å¼ã€‚
- en: Successor
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åç»§å‡½æ•°
- en: Letâ€™s implement the successor function. It is given by *Î»n.Î»f.Î»x.f((n f) x).*
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å®ç°åç»§å‡½æ•°ã€‚å®ƒè¡¨ç¤ºä¸º *Î»n.Î»f.Î»x.f((n f) x)ã€‚*
- en: '![](../Images/91eb0ac0fbac96178e46ccddbf24a7b5.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/91eb0ac0fbac96178e46ccddbf24a7b5.png)'
- en: Successor. Image by author
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: åç»§å‡½æ•°ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: Letâ€™s apply SUCC to the number *0* and analyze what we get.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å°†åç»§å‡½æ•°åº”ç”¨äºæ•°å­— *0* å¹¶åˆ†æå¾—åˆ°çš„ç»“æœã€‚
- en: '![](../Images/73bd398bd363b80c9d6693a543157c27.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/73bd398bd363b80c9d6693a543157c27.png)'
- en: SUCC 0\. Image by author
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: SUCC 0ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: 'Letâ€™s apply the interaction rules. In order to facilitate readability, I will
    draw *duplicators* Î´ as black cells and *constructors* Î³ as white cells:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬åº”ç”¨äº¤äº’è§„åˆ™ã€‚ä¸ºäº†ä¾¿äºé˜…è¯»ï¼Œæˆ‘å°† *å¤åˆ¶å™¨* Î´ ç”»ä¸ºé»‘è‰²å•å…ƒï¼Œè€Œ *æ„é€ å™¨* Î³ ç”»ä¸ºç™½è‰²å•å…ƒï¼š
- en: '![](../Images/7483476d2c7eba05287c470db99a8219.png)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/7483476d2c7eba05287c470db99a8219.png)'
- en: SUCC 0 reductions. Image by author
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: SUCC 0 çš„ç®€åŒ–ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: 'Well, we should have reached the Church numeral 1, right? What went wrong?
    Take a look at the *eraser Îµ* connected to the auxiliary port of the duplicator
    Î´ (in black):'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: å¥½å§ï¼Œæˆ‘ä»¬åº”è¯¥å·²ç»å¾—åˆ°äº†æ•™ä¼šæ•° 1ï¼Œå¯¹å§ï¼Ÿå‡ºäº†ä»€ä¹ˆé—®é¢˜ï¼Ÿçœ‹çœ‹ä¸å¤åˆ¶å™¨ Î´ï¼ˆé»‘è‰²ï¼‰è¾…åŠ©ç«¯å£è¿æ¥çš„ *æ©¡çš®æ“¦ Îµ*ï¼š
- en: '![](../Images/8cc2c94526e90cb7650bcd2f8a8b940b.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8cc2c94526e90cb7650bcd2f8a8b940b.png)'
- en: Image by author
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: This *eraser* is making this left auxiliary port to be redundant! All of the
    information passed through this duplicator will be erased. For any *cell* that
    interacts with this *duplicator,* the *left* part will be *erased.*
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™ä¸ª *æ©¡çš®æ“¦* è®©è¿™ä¸ªå·¦ä¾§è¾…åŠ©ç«¯å£å˜å¾—å¤šä½™ï¼é€šè¿‡è¿™ä¸ªå¤åˆ¶å™¨ä¼ é€’çš„æ‰€æœ‰ä¿¡æ¯éƒ½ä¼šè¢«æ“¦é™¤ã€‚å¯¹äºä»»ä½•ä¸è¿™ä¸ª *å¤åˆ¶å™¨* äº¤äº’çš„ *å•å…ƒ*ï¼Œå…¶ *å·¦ä¾§* éƒ¨åˆ†å°†è¢«
    *æ“¦é™¤*ã€‚
- en: 'So we can remove this redundant *duplicator* and connect the *wire* directly:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å»é™¤è¿™ä¸ªå¤šä½™çš„ *å¤åˆ¶å™¨*ï¼Œå¹¶ç›´æ¥è¿æ¥ *ç”µçº¿*ï¼š
- en: '![](../Images/e662d51b21d3f99a9bf46d1bdad4415a.png)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e662d51b21d3f99a9bf46d1bdad4415a.png)'
- en: Image by author.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”±ä½œè€…æä¾›ã€‚
- en: And *voila!* After reducing SUCC(0) we got exactly the Church number 1, as expected!
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: ç„¶åï¼Œ*ç§ï¼* åœ¨ç®€åŒ– SUCC(0) åï¼Œæˆ‘ä»¬å¾—åˆ°äº†æ­£å¥½æ˜¯æ•™ä¼šæ•° 1ï¼Œæ­£å¦‚é¢„æœŸçš„é‚£æ ·ï¼
- en: 'Letâ€™s apply SUCC againt to the number 1 and see if we get the number 2:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬å†æ¬¡å°† SUCC åº”ç”¨åˆ°æ•°å­— 1 ä¸Šï¼Œçœ‹çœ‹æˆ‘ä»¬èƒ½å¦å¾—åˆ°æ•°å­— 2ï¼š
- en: '![](../Images/ff417ab383f7dcf4fa7f00fbfc20c8f3.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ff417ab383f7dcf4fa7f00fbfc20c8f3.png)'
- en: SUCC 1\. Image by author
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: SUCC 1ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: '![](../Images/1c554d864f027d5ae5fd12834413a298.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1c554d864f027d5ae5fd12834413a298.png)'
- en: SUCC 1 = 2\. Image by author
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: SUCC 1 = 2ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: We got exactly the Church number 2! Amazing, right?
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬æ­£å¥½å¾—åˆ°äº†æ•™ä¼šæ•° 2ï¼å¾ˆç¥å¥‡ï¼Œå¯¹å§ï¼Ÿ
- en: Addition
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: åŠ æ³•
- en: 'So far, we have just performed sequential reductions. Letâ€™s do a more complex
    one, such as addition, to visualize the full parallelization potential of interaction
    combinators. Below the SIC representation of addition: *ADD(m, n) = Î»m.Î»n.Î»f.Î»x.(m
    f)((n f) x).*'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªè¿›è¡Œäº†é¡ºåºåŒ–ç®€ã€‚è®©æˆ‘ä»¬åšä¸€ä¸ªæ›´å¤æ‚çš„æ“ä½œï¼Œä¾‹å¦‚åŠ æ³•ï¼Œæ¥å¯è§†åŒ–äº¤äº’ç»„åˆå™¨çš„å®Œæ•´å¹¶è¡ŒåŒ–æ½œåŠ›ã€‚ä¸‹é¢æ˜¯åŠ æ³•çš„ SIC è¡¨ç¤ºæ³•ï¼š *ADD(m,
    n) = Î»m.Î»n.Î»f.Î»x.(m f)((n f) x)ã€‚*
- en: '![](../Images/07cb4ec55cf4a0856b417a91a615ad90.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07cb4ec55cf4a0856b417a91a615ad90.png)'
- en: Addition. Image by author
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: åŠ æ³•ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: 'Letâ€™s calculate ADD 1 1:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬è®¡ç®— ADD 1 1ï¼š
- en: '![](../Images/46ca9526345dc51c5260799e471fea3b.png)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/46ca9526345dc51c5260799e471fea3b.png)'
- en: ADD 1 1\. Image by author
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ADD 1 1ã€‚å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: 'Executing the reductions:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰§è¡Œç®€åŒ–æ“ä½œï¼š
- en: '![](../Images/05ad0dece29ad44eb9b72af6669863e0.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/05ad0dece29ad44eb9b72af6669863e0.png)'
- en: Image by author
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: Take a look at this step. There are two active pairs! In cases like this we
    can reduce both in parallel. In a real program, we could run them in two different
    threads.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: çœ‹ä¸€ä¸‹è¿™ä¸€æ­¥ã€‚è¿™é‡Œæœ‰ä¸¤ä¸ªæ´»è·ƒçš„é…å¯¹ï¼åƒè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥å¹¶è¡Œåœ°ç®€åŒ–è¿™ä¸¤ä¸ªã€‚åœ¨å®é™…çš„ç¨‹åºä¸­ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸¤ä¸ªä¸åŒçš„çº¿ç¨‹ä¸­è¿è¡Œå®ƒä»¬ã€‚
- en: 'Letâ€™s continue:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: è®©æˆ‘ä»¬ç»§ç»­ï¼š
- en: '![](../Images/0a3e0763cf67f8158a12daa49fcfac41.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0a3e0763cf67f8158a12daa49fcfac41.png)'
- en: ADD 1 1 = 2\. Image by author
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ADD 1 1 = 2\. å›¾ç‰‡ç”±ä½œè€…æä¾›
- en: After reducing ADD 1 1 we got exactly the representation of the Church number
    2!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ç®€åŒ–ADD 1 1ä¹‹åï¼Œæˆ‘ä»¬å¾—åˆ°äº†æ°å¥½æ˜¯æ•™å ‚æ•°å­—2çš„è¡¨ç¤ºï¼
- en: And thatâ€™s how the operations are parallelized using Interaction Combinators.
    At each step, if there are multiples active pairs, all of them run in different
    threads.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™å°±æ˜¯å¦‚ä½•ä½¿ç”¨äº¤äº’ç»„åˆå­å¹¶è¡ŒåŒ–æ“ä½œçš„è¿‡ç¨‹ã€‚åœ¨æ¯ä¸€æ­¥ï¼Œå¦‚æœæœ‰å¤šä¸ªæ´»è·ƒçš„é…å¯¹ï¼Œå®ƒä»¬éƒ½ä¼šåœ¨ä¸åŒçš„çº¿ç¨‹ä¸­è¿è¡Œã€‚
- en: Conclusion
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç»“è®º
- en: In this post we covered basic concepts of lambda calculus, interaction combinators,
    and how they are combined to parallelize operations. I hope I could give you a
    brief explanation on how Bend/HVM works and for more information, please visit
    their [website](https://higherorderco.com/).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬æ¶µç›–äº†Î»æ¼”ç®—çš„åŸºæœ¬æ¦‚å¿µã€äº¤äº’ç»„åˆå­ä»¥åŠå®ƒä»¬å¦‚ä½•ç»“åˆä»¥å¹¶è¡ŒåŒ–æ“ä½œã€‚æˆ‘å¸Œæœ›æˆ‘èƒ½ç®€è¦åœ°è§£é‡ŠBend/HVMæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Œæ›´å¤šä¿¡æ¯ï¼Œè¯·è®¿é—®ä»–ä»¬çš„[ç½‘ç«™](https://higherorderco.com/)ã€‚
- en: Also, follow me here and on my [LinkedIn profile](https://www.linkedin.com/in/lucas-de-lima-nogueira/)
    to stay updated on my latest articles!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: åŒæ—¶ï¼Œå…³æ³¨æˆ‘åœ¨è¿™é‡Œå’Œæˆ‘çš„[LinkedInä¸ªäººèµ„æ–™](https://www.linkedin.com/in/lucas-de-lima-nogueira/)ï¼Œä»¥ä¾¿åŠæ—¶äº†è§£æˆ‘çš„æœ€æ–°æ–‡ç« ï¼
- en: References
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: å‚è€ƒæ–‡çŒ®
- en: '[HigherOrderCO website](https://higherorderco.com/)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[HigherOrderCOç½‘ç«™](https://higherorderco.com/)'
- en: '[Lafontâ€™s Interaction Combinators paper](https://core.ac.uk/download/pdf/81113716.pdf)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[Lafontçš„äº¤äº’ç»„åˆå­è®ºæ–‡](https://core.ac.uk/download/pdf/81113716.pdf)'
- en: '[How HVM works video](https://www.youtube.com/watch?v=sDPuQ-UjhVQ&t=1591s)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[HVMå·¥ä½œåŸç†è§†é¢‘](https://www.youtube.com/watch?v=sDPuQ-UjhVQ&t=1591s)'
- en: '[Interaction combinators tutorial 1](https://zicklag.katharos.group/blog/interaction-nets-combinators-calculus/)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[äº¤äº’ç»„åˆå­æ•™ç¨‹ 1](https://zicklag.katharos.group/blog/interaction-nets-combinators-calculus/)'
- en: '[Interaction combinators tutorial 2](https://blog.stevenhuyn.com/succ/)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[äº¤äº’ç»„åˆå­æ•™ç¨‹ 2](https://blog.stevenhuyn.com/succ/)'
- en: '[Lambda calculus tutorial](https://learnxinyminutes.com/docs/lambda-calculus/)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[Î»æ¼”ç®—æ•™ç¨‹](https://learnxinyminutes.com/docs/lambda-calculus/)'

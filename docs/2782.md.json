["```py\n# Loading the required libraries for various functions\nlibrary(\"pscl\")         # For pscl specific functions, like regression models\nlibrary(\"MCMCpack\")     # For MCMC sampling functions, including posterior distributions\nlibrary(mvtnorm)        # For multivariate normal distribution functio\n```", "```py\n## Generate the observations\n# Set the length of the time series (number of observations per group)\nN <- 1000\n# Set the number of simulations (iterations of the MCMC process)\nnSim <- 200\n# Set the number of components in the mixture model (G is the number of groups)\nG <- 3\n```", "```py\n# Set the values for the regression coefficients (betas) for each group\nbetas <- 1:sum(dimG) * 2.5  # Generating sequential betas with a multiplier of 2.5\n# Define the variance (sigma) for each component (group) in the mixture\nsigmas <- rep(1, G) / 1  # Set variance to 1 for each component, with a fixed divisor of 1\n```", "```py\n# Initialize the original group assignments (z_original)\nz_original <- matrix(NA, N * G, 1)\n# Repeat each group label N times (assign labels to each observation per group)\nz_original <- rep(1:G, rep(N, G))\n# Resample the data rows by random order\nsampled_order <- sample(nrow(data))\n# Apply the resampled order to the data\ndata <- data[sampled_order,]\n```", "```py\n## Define Priors for Bayesian estimation# Define the prior mean (muBeta) for the regression coefficients\nmuBeta <- matrix(0, G, 1)# Define the prior variance (VBeta) for the regression coefficients\nVBeta <- 100 * diag(G)  # Large variance (100) as a prior for the beta coefficients# Prior for the sigma parameters (variance of each component)\nag <- 3  # Shape parameter\nbg <- 1/2  # Rate parameter for the prior on sigma\nshSigma <- ag\nraSigma <- bg^(-1)\n```", "```py\n## Initialize MCMC sampling# Initialize matrix to store the samples for beta\nmBeta <- matrix(NA, nSim, G)# Assign the first value of beta using a random normal distribution\nfor (g in 1:G) {\n  mBeta[1, g] <- rnorm(1, muBeta[g, 1], VBeta[g, g])\n}# Initialize the sigma^2 values (variance for each component)\nmSigma2 <- matrix(NA, nSim, G)\nmSigma2[1, ] <- rigamma(1, shSigma, raSigma)# Initialize the mixing proportions (pi), using a Dirichlet distribution\nmPi <- matrix(NA, nSim, G)\nalphaPrior <- rep(N/G, G)  # Prior for the mixing proportions, uniform across groups\nmPi[1, ] <- rdirichlet(1, alphaPrior)\n```", "```py\n## Start the MCMC iterations for posterior sampling# Loop over the number of simulations\nfor (i in 2:nSim) {\n  print(i)  # Print the current iteration number\n\n  # For each observation, update the group assignment (z)\n  for (t in 1:(N*G)) {\n    fig <- NULL\n    for (g in 1:G) {\n      # Calculate the likelihood of each group and the corresponding posterior probability\n      fig[g] <- dnorm(y[t, 1], X[t, ] %*% mBeta[i-1, g], sqrt(mSigma2[i-1, g])) * mPi[i-1, g]\n    }\n    # Avoid zero likelihood and adjust it\n    if (all(fig) == 0) {\n      fig <- fig + 1/G\n    }\n\n    # Sample a new group assignment based on the posterior probabilities\n    z[i, t] <- which(rmultinom(1, 1, fig/sum(fig)) == 1)\n  }\n\n  # Update the regression coefficients for each group\n  for (g in 1:G) {\n    # Compute the posterior mean and variance for beta (using the data for group g)\n    DBeta <- solve(t(X[z[i, ] == g, ]) %*% X[z[i, ] == g, ] / mSigma2[i-1, g] + solve(VBeta[g, g]))\n    dBeta <- t(X[z[i, ] == g, ]) %*% y[z[i, ] == g, 1] / mSigma2[i-1, g] + solve(VBeta[g, g]) %*% muBeta[g, 1]\n\n    # Sample a new value for beta from the multivariate normal distribution\n    mBeta[i, g] <- rmvnorm(1, DBeta %*% dBeta, DBeta)\n\n    # Update the number of observations in group g\n    ng[i, g] <- sum(z[i, ] == g)\n\n    # Update the variance (sigma^2) for each group\n    mSigma2[i, g] <- rigamma(1, ng[i, g]/2 + shSigma, raSigma + 1/2 * sum((y[z[i, ] == g, 1] - (X[z[i, ] == g, ] * mBeta[i, g]))^2))\n  }\n\n  # Reorder the group labels to maintain consistency\n  reorderWay <- order(mBeta[i, ])\n  mBeta[i, ] <- mBeta[i, reorderWay]\n  ng[i, ] <- ng[i, reorderWay]\n  mSigma2[i, ] <- mSigma2[i, reorderWay]\n\n  # Update the mixing proportions (pi) based on the number of observations in each group\n  mPi[i, ] <- rdirichlet(1, alphaPrior + ng[i, ])\n}\n```", "```py\n# Plot the posterior distributions for each beta coefficient\npar(mfrow=c(G,1))\nfor (g in 1:G) {\n  plot(density(mBeta[5:nSim, g]), main = 'True parameter (vertical) and the distribution of the samples')  # Plot the density for the beta estimates\n  abline(v = betas[g])  # Add a vertical line at the true value of beta for comparison\n}\n```"]
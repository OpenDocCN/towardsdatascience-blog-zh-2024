<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Algorithmic Thinking for Data Scientists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Algorithmic Thinking for Data Scientists</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/algorithmic-thinking-for-data-scientists-4601ac68496f?source=collection_archive---------1-----------------------#2024-05-28">https://towardsdatascience.com/algorithmic-thinking-for-data-scientists-4601ac68496f?source=collection_archive---------1-----------------------#2024-05-28</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="584b" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">How to Write Code that Saves Time and Space</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://kcpub21.medium.com/?source=post_page---byline--4601ac68496f--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Chinmay Kakatkar" class="l ep by dd de cx" src="../Images/873531f24cd4ee8a927669a211d61ae8.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/2*X_AID2BTDQ_xGVbTWPQ2aw.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--4601ac68496f--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://kcpub21.medium.com/?source=post_page---byline--4601ac68496f--------------------------------" rel="noopener follow">Chinmay Kakatkar</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--4601ac68496f--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">20 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">May 28, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj lc ld ab q ee le lf" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lb"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg><p class="bf b dy z dx"><span class="pw-responses-count la lb">2</span></p></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap id li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap id ls lt lf lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/c33f1f9833993abe0aa49f4f5eb1554a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*W23NS7eLDTvTFZXR"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Photo by <a class="af nc" href="https://unsplash.com/@curiousjorge?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jose Castillo</a> on <a class="af nc" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="68e9" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk"><strong class="nf fr"><em class="nz">Note:</em></strong><em class="nz"> All example code snippets in the following sections have been created by the author of this article.</em></p><p id="8d75" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk oa"><span class="l ob oc od bo oe of og oh oi ed">A</span><em class="nz">lgorithmic thinking</em> is about combining rigorous logic and creativity to frame, solve, and analyze problems, usually with the help of a computer. Problems involving some form of sorting, searching, and optimization are closely associated with algorithmic thinking and often show up during data science projects. Algorithmic thinking helps us solve such problems in ways that make efficient use of time and space (as in the disk space or memory of a computer), leading to fast and frugal algorithms.</p><p id="d617" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Even if the costs of storage and computing continue to drop in the foreseeable future, algorithmic thinking is unlikely to become any less important for data science projects than it is today for at least a few key reasons. First, the requirements of customers tend to outpace the capabilities of available solutions in many commercial use cases, regardless of the underlying complexity of data science pipelines (from data sourcing and transformation to modeling and provisioning). Customers expect tasks that take days or hours to take minutes or seconds, and tasks that take minutes or seconds to happen in the blink of an eye. Second, a growing number of use cases involving on-device analytics (e.g., in the context of embedded systems, IoT and edge computing) require resource-efficient computation; space and memory are at a premium, and it may not be possible to offload computational tasks to a more powerful, centralized infrastructure on the cloud. And third, the operation of industrial data science pipelines can consume significant energy, which can worsen the ongoing climate crisis. A firm grasp of algorithmic thinking can help data scientists build efficient and sustainable solutions that address such challenges.</p><p id="0732" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">While data scientists with computer science degrees will be familiar with the core concepts of algorithmic thinking, many increasingly enter the field with other backgrounds, ranging from the natural and social sciences to the arts; this trend is likely to accelerate in the coming years as a result of advances in generative AI and the growing prevalence of data science in school and university curriculums. As such, the following sections of this article are aimed primarily at readers unfamiliar with algorithmic thinking. We will begin with a high-level overview of the algorithmic problem-solving process, and then start to build some intuition for algorithmic thinking in a hands-on way by looking at a selection of programming challenges posted on <em class="nz">HackerRank</em> (a popular platform used by companies for hiring data scientists). We will also go over some helpful resources for further reading. Finally, we will briefly talk about the relevance of algorithmic thinking in the context of AI-assisted software development (e.g., using GitHub Copilot), and conclude with a wrap up.</p><h1 id="01ea" class="oj ok fq bf ol om on gq oo op oq gt or os ot ou ov ow ox oy oz pa pb pc pd pe bk">How to Solve It</h1><p id="e4a1" class="pw-post-body-paragraph nd ne fq nf b go pf nh ni gr pg nk nl nm ph no np nq pi ns nt nu pj nw nx ny fj bk">The title of this section is also the title of a famous book, first published in 1945, by Hungarian-American mathematician and Stanford professor George Pólya. In <em class="nz">How to Solve It</em> (<a class="af nc" href="https://www.amazon.com/How-Solve-Mathematical-Penguin-Science/dp/0140124993" rel="noopener ugc nofollow" target="_blank">link</a>), Pólya lays out a deceptively simple, yet highly effective, four-step approach that can be applied to algorithmic problem solving:</p><ol class=""><li id="544b" class="nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny pk pl pm bk"><strong class="nf fr">Understand the problem</strong>: Frame the problem carefully, with due consideration to any constraints on the problem and solution space (e.g., permissible input data types and data ranges, output format, maximum execution time). Ask questions such as, “can I restate the problem in my own words?”, and “do I have enough data to implement a useful solution?”, to check your understanding. Use concrete examples (or datasets) to make the problem and its edge cases more tangible. Spending sufficient time on this step often makes the remaining steps easier to carry out.</li><li id="a6d1" class="nd ne fq nf b go pn nh ni gr po nk nl nm pp no np nq pq ns nt nu pr nw nx ny pk pl pm bk"><strong class="nf fr">Devise a plan</strong>: This will often involve breaking down the problem into smaller sub-problems for which efficient solutions may already be known. The ability to identify and apply suitable existing solutions to different types of sub-problems (e.g., in searching, sorting, etc.) will come with practice and experience. But sometimes, additional creativity may be needed to combine multiple existing approaches, invent a new approach, or borrow an approach from another domain using analogies. Pólya gives several tips to aid the thinking process, such as drawing a diagram and working backwards from a desired goal. In general, it is useful at this stage to gauge, at least at a high-level, whether the devised plan is likely solve the specified problem.</li><li id="4a50" class="nd ne fq nf b go pn nh ni gr po nk nl nm pp no np nq pq ns nt nu pr nw nx ny pk pl pm bk"><strong class="nf fr">Carry out the plan</strong>: Implement the solution using relevant tooling. In a data science project, this might involve libraries such as scikit-learn, PyTorch and TensorFlow for machine learning, and platforms such as AWS, GCP or Azure for hosting and running pipelines. Attention to detail is crucial at this stage, since even small bugs in the code can lead to implementations that do not accurately reflect the previously devised plan, and thus do not end up solving the stated problem. Add sufficient unit tests to check whether the different parts of the code work properly, even for edge cases.</li><li id="f7e1" class="nd ne fq nf b go pn nh ni gr po nk nl nm pp no np nq pq ns nt nu pr nw nx ny pk pl pm bk"><strong class="nf fr">Look back</strong>: The practice of “looking back” is an instinctive part of the validation phase of most data science projects; questions such as “did the new machine learning model perform better than the last?” can only be answered by collecting and reviewing relevant metrics for each experiment. But reviewing other aspects of the data science pipeline (e.g., the ETL code, test cases, productization scripts) and AI lifecycle management (e.g., level of automation, attention to data privacy and security, implementation of a feedback loop in production) is also vital for improving the current project and doing better on future projects, even if finding the time for such a holistic “look back” can be challenging in a fast-paced work environment.</li></ol><p id="658d" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Steps 1 and 2 in Pólya’s problem-solving process can be particularly difficult to get right. Framing a problem or solution in a conceptually logical and systematic way is often a non-trivial task. However, gaining familiarity with <em class="nz">conceptual frameworks</em> (analytical structures for representing abstract concepts) can help significantly in this regard. Common examples of conceptual frameworks include tree diagrams, matrices, process diagrams, and relational diagrams. The book <em class="nz">Conceptual Frameworks: A Guide to Structuring Analyses, Decisions and Presentations</em> (<a class="af nc" href="https://www.amazon.com/Conceptual-Frameworks-Structuring-Decisions-Presentations-ebook/dp/B07GC1JDV8" rel="noopener ugc nofollow" target="_blank">link</a>), written by the author of this article, teaches how to understand, create, apply and evaluate such conceptual frameworks in an easy-to-digest manner.</p><h2 id="8e98" class="ps ok fq bf ol pt pu pv oo pw px py or nm pz qa qb nq qc qd qe nu qf qg qh qi bk">Algorithmic Complexity</h2><p id="075a" class="pw-post-body-paragraph nd ne fq nf b go pf nh ni gr pg nk nl nm ph no np nq pi ns nt nu pj nw nx ny fj bk">One topic that deserves special attention in the context of algorithmic problem solving is that of <em class="nz">complexity</em>. When comparing two different algorithms, it is useful to consider the time and space complexity of each algorithm, i.e., how the time and space taken by each algorithm scales relative to the problem size (or data size). There are five basic levels of complexity, from lowest (best) to highest (worst), that you should be aware of. We will only describe them below in terms of time complexity to simplify the discussion:</p><ol class=""><li id="1f2f" class="nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny pk pl pm bk"><strong class="nf fr">Instantaneous</strong>: regardless of the scale of the problem, the algorithm executes instantaneously. E.g., to determine whether an integer is even, we can simply check if dividing its rightmost digit by two leaves no remainder, regardless of the size of the integer. Accessing a list element by index can also typically be done instantaneously, no matter the length of the list.</li><li id="8c9c" class="nd ne fq nf b go pn nh ni gr po nk nl nm pp no np nq pq ns nt nu pr nw nx ny pk pl pm bk"><strong class="nf fr">Logarithmic</strong>: For a dataset of size <em class="nz">n</em>, the algorithm executes in <em class="nz">log(n)</em> time steps. Note that logarithms may have different bases (e.g., <em class="nz">log2(n)</em> for binary search as the size of the problem is halved in each iteration). Like instantaneous algorithms, those with logarithmic complexity are attractive because they scale sub-linearly with respect to the size of the problem.</li><li id="239b" class="nd ne fq nf b go pn nh ni gr po nk nl nm pp no np nq pq ns nt nu pr nw nx ny pk pl pm bk"><strong class="nf fr">Linear</strong>: As the name suggests, for a dataset of size <em class="nz">n</em>, an algorithm with linear complexity executes in roughly <em class="nz">n</em> time steps.</li><li id="3cda" class="nd ne fq nf b go pn nh ni gr po nk nl nm pp no np nq pq ns nt nu pr nw nx ny pk pl pm bk"><strong class="nf fr">Polynomial</strong>: The algorithm executes in <em class="nz">x^2</em> (quadratic), <em class="nz">x^3</em> (cubic), or more generally, <em class="nz">x^m</em> time steps, for some positive integer <em class="nz">m</em>. A common trick to check for polynomial complexity in code is to count the number of nested loops; e.g., a function with 2 nested loops (a loop within a loop) has a complexity of x^2, a function with 3 nested loops has a complexity of x^3, and so on.</li><li id="e51c" class="nd ne fq nf b go pn nh ni gr po nk nl nm pp no np nq pq ns nt nu pr nw nx ny pk pl pm bk"><strong class="nf fr">Exponential</strong>: The algorithm executes in <em class="nz">2^x</em>, <em class="nz">3^x</em>, or more generally, <em class="nz">m^x</em> time steps, for some positive integer <em class="nz">m</em>. See these posts on StackExchange (<a class="af nc" href="https://math.stackexchange.com/questions/55468/how-to-prove-that-exponential-grows-faster-than-polynomial" rel="noopener ugc nofollow" target="_blank">link 1</a>, <a class="af nc" href="https://math.stackexchange.com/questions/4042364/why-does-an-exponential-function-eventually-get-bigger-than-a-quadratic" rel="noopener ugc nofollow" target="_blank">link 2</a>) to see why exponential functions eventually get bigger than polynomial ones and are therefore worse in terms of algorithmic complexity for large problems.</li></ol><p id="120e" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Some algorithms may manifest <em class="nz">additive</em> or <em class="nz">multiplicative</em> combinations of the above complexity levels. E.g., a for loop followed by a binary search entails an additive combination of linear and logarithmic complexities, attributable to sequential execution of the loop and the search routine, respectively. By contrast, a for loop that carries out a binary search in each iteration entails a multiplicative combination of linear and logarithmic complexities. While multiplicative combinations may generally be more expensive than additive ones, sometimes they are unavoidable and can still be optimized. E.g., a sorting algorithm such as merge sort, with a time complexity of <em class="nz">nlog(n)</em>, is less expensive than selection sort, which has a quadratic time complexity (see <a class="af nc" href="https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/" rel="noopener ugc nofollow" target="_blank">this</a> article for a table comparing the complexities of different sorting algorithms).</p><h1 id="a277" class="oj ok fq bf ol om on gq oo op oq gt or os ot ou ov ow ox oy oz pa pb pc pd pe bk">Building Intuition with Example Problems</h1><p id="6d32" class="pw-post-body-paragraph nd ne fq nf b go pf nh ni gr pg nk nl nm ph no np nq pi ns nt nu pj nw nx ny fj bk">In the following, we will study a selection of problems posted on <a class="af nc" href="https://www.hackerrank.com/" rel="noopener ugc nofollow" target="_blank"><em class="nz">HackerRank</em></a>. Similar problems can be found on platforms such as <a class="af nc" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"><em class="nz">LeetCode</em></a> and <a class="af nc" href="https://www.codewars.com/" rel="noopener ugc nofollow" target="_blank"><em class="nz">CodeWars</em></a>. Studying problems posted on such platforms will help train your algorithmic thinking muscles, can help you more easily navigate technical interviews (hiring managers regularly pose algorithmic questions to candidates applying for data science roles), and may yield pieces of code that you can reuse on the job.</p><p id="2956" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">All example code snippets below have been written by the author of this article in C++, a popular choice among practitioners for building fast data pipelines. These snippets can be readily translated to other languages such as Python or R as needed. To simplify the code snippets, we will assume that the following lines are present at the top of the code file:</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="fe51" class="qn ok fq qk b bg qo qp l qq qr">#include &lt;bits/stdc++.h&gt;<br/>using namespace std;</span></pre><p id="cea6" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">This will allow us to omit “std::” everywhere in the code, letting readers focus on the algorithms themselves. Of course, in productive C++ code, only the relevant libraries would be included and “std::” written explicitly as per the coding guidelines.</p><h2 id="8af1" class="ps ok fq bf ol pt pu pv oo pw px py or nm pz qa qb nq qc qd qe nu qf qg qh qi bk">When a Formula Will Do</h2><p id="efe2" class="pw-post-body-paragraph nd ne fq nf b go pf nh ni gr pg nk nl nm ph no np nq pi ns nt nu pj nw nx ny fj bk">A problem that initially seems to call for an iterative solution with polynomial complexity (e.g., using for loops, while loops, or list comprehensions) can sometimes be solved algebraically using a formula that returns the desired answer instantaneously.</p><p id="8d42" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Consider the <em class="nz">Number Line Jumps</em> problem (<a class="af nc" href="https://www.hackerrank.com/challenges/kangaroo/problem" rel="noopener ugc nofollow" target="_blank">link</a>). There are two kangaroos placed somewhere on a number line (at positions <em class="nz">x1</em> and <em class="nz">x2</em>, respectively) and can move by jumping. The first kangaroo can move <em class="nz">v1</em> meters per jump, while the second can move <em class="nz">v2</em> meters per jump. Given input values for <em class="nz">x1</em>, <em class="nz">v1</em>, <em class="nz">x2</em>, and <em class="nz">v2</em>, the task is to determine whether it is possible for both kangaroos to end up at the same position on the number line at some future time step, assuming that each kangaroo can make only one jump per time step; the solution function should return “YES” or “NO” accordingly.</p><p id="c3aa" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Suppose <em class="nz">x1</em> is smaller than <em class="nz">x2</em>. Then one approach is to implement a loop that checks if the kangaroo starting at <em class="nz">x1</em> will ever catch up with the kangaroo starting at <em class="nz">x2</em>. In other words, we would check whether a positive (integer) time step exists where <em class="nz">x1 + v1*t = x2 + v2*t</em>. If <em class="nz">x1</em> is greater than <em class="nz">x2</em>, we could swap the values in the respective variables and follow the same approach described above. But such a solution could take a long time to execute if <em class="nz">t</em> is large and might even loop infinitely (causing a time-out or crash) if the kangaroos never end up meeting.</p><p id="49b6" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">We can do much better. Let us rearrange the above equation to solve for a positive integer <em class="nz">t</em>. We get <em class="nz">t = (x1 — x2)/(v2 — v1)</em>. This equation for <em class="nz">t</em> is undefined when <em class="nz">v2 = v1</em> (due to division by zero), but in such a case we could return “YES” if both kangaroos start at the same position, since both kangaroos will then obviously arrive at the same position on the number line at the very next time step. Moreover, if the jump distances of both kangaroos are the same but the starting positions are different, then we can directly return “NO”, since the kangaroo starting on the left will never catch up with the kangaroo on the right. Finally, if we find a positive solution to <em class="nz">t</em>, we should check that it is also an integer; this can be done by casting <em class="nz">t</em> to an integer data type and checking whether this is equivalent to the original value. The example code snippet below implements this solution.</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="cb13" class="qn ok fq qk b bg qo qp l qq qr">string kangaroo(int x1, int v1, int x2, int v2) {<br/>    if((v2 == v1) &amp;&amp; (x1 != x2)) return "NO";<br/>    float t = 1.*(x1 - x2)/(v2 - v1);<br/>    return ((0 &lt; t) &amp;&amp; (t == (int) t)) ? "YES" : "NO";<br/>}</span></pre><h2 id="8743" class="ps ok fq bf ol pt pu pv oo pw px py or nm pz qa qb nq qc qd qe nu qf qg qh qi bk">Picking from Multiple Options</h2><p id="71ee" class="pw-post-body-paragraph nd ne fq nf b go pf nh ni gr pg nk nl nm ph no np nq pi ns nt nu pj nw nx ny fj bk">There may be several valid ways of solving the same problem. Having found one solution approach, trying to find others can still be illuminating and worthwhile; each approach will have its pros and cons, making it more or less suitable to the problem context. To illustrate this, we will look at three problems below in varying degrees of detail.</p><p id="0c33" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">First, consider the <em class="nz">Beautiful Days at the Movies</em> problem (<a class="af nc" href="https://www.hackerrank.com/challenges/beautiful-days-at-the-movies/problem" rel="noopener ugc nofollow" target="_blank">link</a>). Upon reading the description, it will become apparent that a key part of solving the problem is coming up with a function to reverse a positive integer. E.g., the reverse of 123 is 321 and the reverse of 12000 is 21 (note the omission of leading zeros in the reversed number).</p><p id="bb14" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">One solution approach (call it <em class="nz">reverse_num_v1</em>) uses a combination of division and modulo operations to bring the rightmost digit to the leftmost position in a way that naturally takes care of leading zeros; see an example implementation below. What makes this approach attractive is that, since the number of digits grows logarithmically relative to the size of the number, the time complexity of <em class="nz">reverse_num_v1</em> is sub-linear; the space complexity is also negligible.</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="ef22" class="qn ok fq qk b bg qo qp l qq qr">int reverse_num_v1(int x) {<br/>    long long res = 0;<br/>    while (x) {<br/>        res = res * 10 + x % 10;<br/>        x /= 10;<br/>        // Check for integer overflow<br/>        if (res &gt; INT_MAX || res &lt; INT_MIN) return 0;<br/>    }<br/>    return res;<br/>}</span></pre><p id="5f8c" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Another approach (call it <em class="nz">reverse_num_v2</em>) uses the idea of converting the integer to a string data type, reversing it, trimming any leading zeros, converting the string back to an integer, and returning the result; see an example implementation below.</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="3d44" class="qn ok fq qk b bg qo qp l qq qr">int reverse_num_v2(int x) {<br/>    string str = to_string(x);<br/>    reverse(str.begin(), str.end());<br/>    // Remove leading zeros<br/>    str.erase(0, min(str.find_first_not_of('0'), str.size()-1));<br/>    int res = stoi(str);<br/>    // Check for integer overflow<br/>    return (res &gt; INT_MAX || res &lt; INT_MIN) ? 0 : res;<br/>}</span></pre><p id="c4e8" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Such <em class="nz">type casting</em> is a common practice in many languages (C++, Python, etc.), library functions for string reversion and trimming leading zeros may also be readily available, and chaining functions to form a pipeline of data transformation operations is a typical pattern seen in data science projects; <em class="nz">reverse_num_v2</em> might thus be the first approach that occurs to many data scientists. If memory space is scarce, however, <em class="nz">reverse_num_v1</em> might be the better option, since the string representation of an integer will take up more space than the integer itself (see <a class="af nc" href="https://www.codecademy.com/resources/docs/cpp/data-types" rel="noopener ugc nofollow" target="_blank">this</a> documentation of memory requirements for different data types in C++).</p><p id="b8fa" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Next, let us briefly consider two further problems, <em class="nz">Time Conversion</em> (<a class="af nc" href="https://www.hackerrank.com/challenges/time-conversion/problem" rel="noopener ugc nofollow" target="_blank">link</a>) and <em class="nz">Forming a Magic Square</em> (<a class="af nc" href="https://www.hackerrank.com/challenges/magic-square-forming/problem" rel="noopener ugc nofollow" target="_blank">link</a>). While these problems might appear to be quite different on the surface, the same technique — namely, the use of lookup tables (or maps) — can be used to solve both problems. In the case of <em class="nz">Time Conversion</em>, a lookup table can be used to provide an instantaneous mapping between 12-hour and 24-hour formats for afternoon times (e.g., 8 pm is mapped to 20, 9 pm is mapped to 21, and so on). In <em class="nz">Forming a Magic Square</em>, the problem is restricted to magic squares consisting of 3 rows and 3 columns, and as it happens, there are only 8 such squares. By storing the configurations of these 8 magic squares in a lookup table, we can implement a fairly simple solution to the problem despite its “medium” difficulty rating on <em class="nz">HackerRank</em>. It is left to the reader to go through these problems in more detail via the links provided above, but the relevant example code snippets of each solution are shown below for comparison.</p><p id="d0d7" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk"><em class="nz">Time Conversion</em>:</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="98c4" class="qn ok fq qk b bg qo qp l qq qr">string timeConversion(string s) {<br/>    // substr(pos, len) starts at position pos and spans len characters<br/>    if(s.substr(s.size() - 2) == "AM") {<br/>        if(s.substr(0, 2) == "12") return "00" + s.substr(2, s.size() - 4);<br/>        else return s.substr(0, s.size() - 2);<br/>    }<br/>    else {<br/>        // PM means add 12 to hours between 01 and 11<br/>        // Store all 11 mappings of afternoon hours in a lookup table/map<br/>        map&lt;string, string&gt; m = {<br/>            {"01", "13"}, {"02", "14"}, {"03", "15"}, {"04", "16"},<br/>            {"05", "17"}, {"06", "18"}, {"07", "19"}, {"08", "20"},<br/>            {"09", "21"}, {"10", "22"}, {"11", "23"}<br/>        };<br/>        string hh = s.substr(0, 2);<br/>        if(m.count(hh)) return m[s.substr(0, 2)] + s.substr(2, s.size() - 4);<br/>        else return s.substr(0, s.size() - 2);<br/>    }<br/>}</span></pre><p id="36b5" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk"><em class="nz">Forming a Magic Square</em>:</p><p id="9906" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Notice that, although part of the code below uses 3 nested for loops, only 8*3*3 = 72 loops involving simple operations are ever needed to solve the problem.</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="8938" class="qn ok fq qk b bg qo qp l qq qr">int formingMagicSquare(vector&lt;vector&lt;int&gt;&gt; s) {<br/>    // Store all 8 possible 3x3 magic squares in a lookup table/matrix<br/>    vector&lt;vector&lt;int&gt;&gt; magic_squares = {<br/>        {8, 1, 6, 3, 5, 7, 4, 9, 2},<br/>        {6, 1, 8, 7, 5, 3, 2, 9, 4},<br/>        {4, 9, 2, 3, 5, 7, 8, 1, 6},<br/>        {2, 9, 4, 7, 5, 3, 6, 1, 8}, <br/>        {8, 3, 4, 1, 5, 9, 6, 7, 2}, <br/>        {4, 3, 8, 9, 5, 1, 2, 7, 6}, <br/>        {6, 7, 2, 1, 5, 9, 8, 3, 4}, <br/>        {2, 7, 6, 9, 5, 1, 4, 3, 8},<br/>    };<br/>    int min_cost = 81;  // Initialize with maximum possible cost of 9*9=81<br/>    for (auto&amp; magic_square : magic_squares) {<br/>        int cost = 0;<br/>        for (int i = 0; i &lt; 3; i++) {<br/>            for (int j = 0; j &lt; 3; j++) {<br/>                cost += abs(s[i][j] - magic_square[3*i + j]);<br/>            }<br/>        }<br/>        min_cost = min(min_cost, cost);<br/>    }<br/>    return min_cost;<br/>}</span></pre><h2 id="502a" class="ps ok fq bf ol pt pu pv oo pw px py or nm pz qa qb nq qc qd qe nu qf qg qh qi bk">Divide and Conquer</h2><p id="872f" class="pw-post-body-paragraph nd ne fq nf b go pf nh ni gr pg nk nl nm ph no np nq pi ns nt nu pj nw nx ny fj bk">When a problem seems too big or too complicated to solve in one go, it can often be a good idea to divide the original problem into smaller sub-problems that can each be conquered more easily. The exact nature of these sub-problems (e.g., sorting, searching, transforming), and their “part-to-whole” relationship with the original problem may vary. For instance, in the case of data cleaning, a common type of problem in data science, each sub-problem may represent a specific, sequential step in the data cleaning process (e.g., removing stop-words, lemmatization). In a “go/no-go” decision-making problem, each sub-problem might reflect smaller decisions that must all result in a “go” decision for the original problem to resolve to “go”; in logical terms, one can think of this as a complex Boolean statement of the form <em class="nz">A AND B</em>.</p><p id="3b2b" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">To see how divide-and-conquer works in practice, we will look at two problems that appear to be very different on the surface. First, let us consider the <em class="nz">Electronics Shop</em> problem (<a class="af nc" href="https://www.hackerrank.com/challenges/electronics-shop/problem" rel="noopener ugc nofollow" target="_blank">link</a>), which is fundamentally about constrained optimization. Given a total spending budget <em class="nz">b</em> and unsorted price lists for computer keyboards and USB drives (call these <em class="nz">K</em> and <em class="nz">D</em>, respectively), the goal is to buy the most expensive keyboard and drive without exceeding the budget. The price lists can have up to 1000 items in the problem posted on <em class="nz">HackerRank</em>, but we can imagine much longer lists in practice.</p><p id="6350" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">A naïve approach might be to iterate through the price lists <em class="nz">K</em> and <em class="nz">D</em> with two nested loops to find the <em class="nz">i</em>-th keyboard and the <em class="nz">j</em>-th drive that make maximal use of the budget. This would be easy to implement, but very slow if <em class="nz">K</em> and <em class="nz">D</em> are long, especially since the price lists are unsorted. In fact, the time complexity of the naïve approach is quadratic, which does not bode well for scaling to large datasets. A more efficient approach would work as follows. First, sort both price lists. Second, pick the shorter of the two price lists for looping. Third, for each item <em class="nz">x</em> in the looped list, do a binary search on the other list to find an item <em class="nz">y</em> (if any), such that <em class="nz">x + y</em> does not exceed the given budget <em class="nz">b</em>, and maintain this result in a variable called <em class="nz">max_spent</em> outside the loop. In each successive iteration of the loop, <em class="nz">max_spent</em> is only updated if the total cost of the latest keyboard-drive pair is within budget and exceeds the current value of <em class="nz">max_spent</em>.</p><p id="7ca9" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Although there is no way around searching both price lists in this problem, the efficient approach reduces the overall search time significantly by picking the smaller price list for looping, and crucially, doing a binary search of the longer price list (which takes logarithmic/sub-linear time to execute). Moreover, while it might initially seem that pre-sorting the two price lists adds to the solution complexity, the sorting can actually be done quite efficiently (e.g., using merge sort), and crucially, this enables the binary search of the longer price list. The net result is a much faster algorithm compared to the naïve approach. See an example implementation of the efficient approach below:</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="1c33" class="qn ok fq qk b bg qo qp l qq qr">int findLargestY(int x, int b, const vector&lt;int&gt;&amp; v) {<br/>    // Simple implementation of binary search<br/>    int i = 0, j = v.size(), y = -1, m, y_curr;<br/>    while (i &lt; j) {<br/>        m = (i + j) / 2;<br/>        y_curr = v[m];<br/>        if (x + y_curr &lt;= b) {<br/>            y = y_curr;<br/>            i = m + 1;<br/>        }<br/>        else j = m;<br/>    }<br/>    return y;<br/>}<br/><br/>int getMoneySpent(vector&lt;int&gt; keyboards, vector&lt;int&gt; drives, int b) {<br/>    int max_spent = -1;<br/>    sort(keyboards.begin(), keyboards.end());<br/>    sort(drives.begin(), drives.end());<br/>    // Use smaller vector for looping, larger vector for binary search<br/>    vector&lt;int&gt; *v1, *v2;<br/>    if(keyboards.size() &lt; drives.size()) {<br/>        v1 = &amp;keyboards;<br/>        v2 = &amp;drives;<br/>    }<br/>    else {<br/>        v1 = &amp;drives;<br/>        v2 = &amp;keyboards;       <br/>    }<br/>    <br/>    int i = 0, j = v2-&gt;size(), x, y;<br/>    for(int i = 0; i &lt; v1-&gt;size(); i++) {<br/>        x = (*v1)[i];<br/>        if(x &lt; b) {<br/>            y = findLargestY(x, b, *v2);  // Use binary search<br/>            if(y != -1) max_spent = max(max_spent, x + y);<br/>        }<br/>        else break;<br/>    }<br/>    return max_spent;<br/>}</span></pre><p id="bcb2" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Next, let us consider the <em class="nz">Climbing the Leaderboard</em> problem (<a class="af nc" href="https://www.hackerrank.com/challenges/climbing-the-leaderboard/problem" rel="noopener ugc nofollow" target="_blank">link</a>). Imagine you are playing an arcade game and wish to track your rank on the leaderboard after each attempt. The leaderboard uses <em class="nz">dense ranking</em>, so players with the same scores will get the same rank. E.g., if the scores are 100, 90, 90, and 80, then the player scoring 100 has rank 1, the two players scoring 90 both have rank 2, and the player scoring 80 has rank 3. The leaderboard is represented as an array or list of integers (each player’s high score) in descending order. What makes the problem tricky is that, whenever a new score is added to the leaderboard, determining the resulting rank is non-trivial since this rank might be shared between multiple players. See the problem description page at the above link on <em class="nz">HackerRank</em> for an illustrated example.</p><p id="042f" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Although the <em class="nz">Electronics Shop</em> and <em class="nz">Climbing the Leaderboard</em> problems have difficulty ratings of “easy” and “medium” on <em class="nz">HackerRank</em>, respectively, the latter problem is simpler in a way, since the leaderboard is already sorted. The example implementation below exploits this fact by running a binary search on the sorted leaderboard to get the rank after each new score:</p><pre class="mm mn mo mp mq qj qk ql bp qm bb bk"><span id="41e0" class="qn ok fq qk b bg qo qp l qq qr">int find_rank(int x, vector&lt;int&gt;&amp; v) {<br/>    // Binary search of rank<br/>    int i = 0, j = v.size(), m_pos, m_val;<br/>    while(i &lt; j) {<br/>        m_pos = (i + j)/2;<br/>        m_val = v[m_pos];<br/>        if(x == m_val) return m_pos + 1;  // Return rank<br/>        else if(m_val &gt; x) i = m_pos + 1;  // Rank must be lower<br/>        else j = m_pos;  // Rank must be higher since val &lt; x <br/>    }<br/>    if(j &lt; 0) return 1;  // Top rank<br/>    else if(i &gt;= v.size()) return v.size() + 1;  // Bottom rank<br/>    else return (x &gt;= m_val) ? m_pos + 1 : m_pos + 2;  // Some middle rank<br/>}<br/><br/>vector&lt;int&gt; climbingLeaderboard(vector&lt;int&gt; ranked, vector&lt;int&gt; player) {<br/>    // Derive vector v of unique values in ranked vector<br/>    vector&lt;int&gt; v;<br/>    v.push_back(ranked[0]);<br/>    for(int i = 1; i &lt; ranked.size(); i++)<br/>        if(ranked[i - 1] != ranked[i]) v.push_back(ranked[i]);<br/>    // Binary search of rank in v for each score<br/>    vector&lt;int&gt; res;<br/>    for(auto x : player) res.push_back(find_rank(x, v));<br/>    return res;<br/>}</span></pre><h2 id="81ba" class="ps ok fq bf ol pt pu pv oo pw px py or nm pz qa qb nq qc qd qe nu qf qg qh qi bk">Resources for Further Reading</h2><p id="32a5" class="pw-post-body-paragraph nd ne fq nf b go pf nh ni gr pg nk nl nm ph no np nq pi ns nt nu pj nw nx ny fj bk">The problems discussed above give an initial taste of algorithmic thinking, but there are many other related topics worth studying in more depth. The aptly titled book <em class="nz">Algorithmic Thinking: A Problem-Based Introduction</em> by Daniel Zingaro, is an excellent place to continue to your journey (<a class="af nc" href="https://www.amazon.com/Algorithmic-Thinking-Problem-Based-Daniel-Zingaro/dp/1718500807" rel="noopener ugc nofollow" target="_blank">link</a>). Zingaro has an engaging writing style and walks the reader through basic concepts like <em class="nz">hash tables</em>, <em class="nz">recursion</em>, <em class="nz">dynamic programming</em>, <em class="nz">graph search</em>, and more. The book also contains an appendix section on <em class="nz">Big O notation</em>, which is a handy way of expressing and reasoning about the complexity of algorithms. Another book that covers several essential algorithms in a digestible manner is <em class="nz">Grokking Algorithms</em> by Aditya Bhargava (<a class="af nc" href="https://www.amazon.com/Grokking-Algorithms-Second-Aditya-Bhargava/dp/1633438538" rel="noopener ugc nofollow" target="_blank">link</a>). The book contains several useful illustrations and code snippets in Python, and is a great resource for brushing up on the basics of algorithmic thinking before technical interviews.</p><p id="9908" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">When it comes to dynamic programming, the series of YouTube videos (<a class="af nc" href="https://www.youtube.com/playlist?list=PLVrpF4r7WIhTT1hJqZmjP10nxsmrbRvlf" rel="noopener ugc nofollow" target="_blank">link to playlist</a>) created by Andrey Grehov provides a great introduction. Dynamic programming is a powerful tool to have in your arsenal, and once you learn it, you will start seeing several opportunities to apply it in data science projects, e.g., to solve optimization problems (where some quantity like cost or revenue must be minimized or maximized, respectively) or combinatorics problems (where the focus is on counting something, essentially answering the question, “how many ways are there to do XYZ?”). Dynamic programming can be usefully applied to problems that exhibit the following two properties: (1) An <em class="nz">optimal substructure</em>, i.e., optimally solving a smaller piece of the problem helps solve the larger problem, and (2) <em class="nz">overlapping sub-problems</em>, i.e., a result calculated as part of a solution to one sub-problem can be used without need for recalculation (e.g., using <em class="nz">memoization</em> or <em class="nz">caching</em>) during the process of solving another sub-problem.</p><p id="f2fd" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Finally, the doctoral dissertation <em class="nz">Advanced Applications of Network Analysis in Marketing Science</em> (<a class="af nc" href="https://www.amazon.com/Advanced-Applications-Network-Analysis-Marketing/dp/3746068118/" rel="noopener ugc nofollow" target="_blank">link</a>), published by the author of this article, discusses a range of practical data science use cases for applying graph theory concepts to fundamental problems in marketing and innovation management, such as identifying promising crowdsourced ideas for new product development, dynamic pricing, and predicting customer behavior with anonymized tracking data. The dissertation demonstrates how transforming tabular or unstructured data into a graph/network representation consisting of nodes (entities) and edges (relationships between entities) can unlock valuable insights and lead to the development of powerful predictive models across a wide range of data science problems.</p><h1 id="c391" class="oj ok fq bf ol om on gq oo op oq gt or os ot ou ov ow ox oy oz pa pb pc pd pe bk">Algorithmic Thinking in the Age of AI-Assisted Software Development</h1><p id="a897" class="pw-post-body-paragraph nd ne fq nf b go pf nh ni gr pg nk nl nm ph no np nq pi ns nt nu pj nw nx ny fj bk">In October 2023, Matt Walsh, an erstwhile computer science professor and engineering director at Google, gave an intriguing guest lecture at Harvard (<a class="af nc" href="https://www.youtube.com/watch?v=JhCl-GeT4jw" rel="noopener ugc nofollow" target="_blank">YouTube link</a>). His talk had a provocative title (<em class="nz">Large Language Models and The End of Programming</em>) and suggested that advances in generative AI — and large language models, in particular — could dramatically change the way we develop software. While he noted that humans would likely still be needed in roles such as product management (to define <em class="nz">what</em> the software should do, and <em class="nz">why</em>), and software testing/QA (to ensure that the software works as intended), he argued that the act of translating a problem specification to production-ready code could largely be automated using AI in the not-too-distant future. By late 2023, AI-powered tools like GitHub Copilot were already showing the ability to auto-complete various basic types of code (e.g., test cases, simple loops and conditionals), and suggested the potential to improve the productivity of developers — if not remove the need for developers entirely. And since then, AI has continued to make impressive advances in delivering increasingly accurate, multimodal predictions.</p><p id="9f69" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">In this context, given the subject of this article, it is worth considering to what extent algorithmic thinking will remain a relevant skill for data scientists in the age of AI-assisted software development. The short answer is that algorithmic thinking will likely be more important than ever before. The longer answer would first start by acknowledging that, even today, it is possible in many cases to generate a draft version of an algorithm (such as the code snippets shown in the sections above) using generative AI tools like ChatGPT or GitHub Copilot. After all, such AI tools are trained by scraping the internet, and there is plenty of code on the internet — but this code may not necessarily be high-quality code, potentially leading to “garbage in, garbage out”. AI-generated code should therefore arguably always be thoroughly reviewed before using it in any data science project, which implies the continued need for human reviewers with relevant technical skills.</p><p id="3ca0" class="pw-post-body-paragraph nd ne fq nf b go ng nh ni gr nj nk nl nm nn no np nq nr ns nt nu nv nw nx ny fj bk">Furthermore, AI-generated code may need to be customized and/or optimized to fit a particular use case, and prompt engineering alone will likely not be enough. In fact, crafting a prompt that can reliably generate the required code (capturing the prompt engineer’s tacit know-how and motivation) often seems to be more verbose and time-consuming than writing the code directly in the target language, and neither approach obviates the need to properly frame the problem and devise a sensible plan for implementing the solution. Tasks such as framing, planning, customizing, optimizing and reviewing AI-generated code for individual use cases will arguably continue to require a decent level of algorithmic thinking, coupled with a deep understanding of the <em class="nz">intent</em> behind the code (i.e., the “why”). It seems unlikely in practice that such work will be substantially delegated to an AI “copilot” any time soon — not least due to the ethical and legal concerns involved; e.g., imagine letting the object avoidance software of a self-driving car system be generated by AI without sufficient human oversight.</p><h1 id="4742" class="oj ok fq bf ol om on gq oo op oq gt or os ot ou ov ow ox oy oz pa pb pc pd pe bk">The Wrap</h1><p id="a824" class="pw-post-body-paragraph nd ne fq nf b go pf nh ni gr pg nk nl nm ph no np nq pi ns nt nu pj nw nx ny fj bk">Algorithmic thinking can help data scientists write code that is fast and makes sparing use of computational resources such as memory and storage. As more and more data scientists enter the field with diverse backgrounds and lacking sufficient exposure to algorithmic thinking, this article takes a step towards filling the knowledge gap. By providing a high-level introduction and hands-on examples of the kind that often appear in technical interviews, this article invites readers to take the next step and extend their study of algorithmic thinking with various resources for further education. Ultimately, algorithmic thinking is a vital skill for data scientists to have today, and will continue to be a skill worth having in our AI-assisted future.</p></div></div></div></div>    
</body>
</html>
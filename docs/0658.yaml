- en: A Comprehensive Guide to Modeling Techniques in Mixed-Integer Linear Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/a-comprehensive-guide-to-modeling-techniques-in-mixed-integer-linear-programming-3e96cc1bc03d?source=collection_archive---------0-----------------------#2024-03-11](https://towardsdatascience.com/a-comprehensive-guide-to-modeling-techniques-in-mixed-integer-linear-programming-3e96cc1bc03d?source=collection_archive---------0-----------------------#2024-03-11)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Convert ideas into mathematical expressions to solve operations research problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@bruscalia12?source=post_page---byline--3e96cc1bc03d--------------------------------)[![Bruno
    Scalia C. F. Leite](../Images/1042cd04be047c0811fef79ecd04e69c.png)](https://medium.com/@bruscalia12?source=post_page---byline--3e96cc1bc03d--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--3e96cc1bc03d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--3e96cc1bc03d--------------------------------)
    [Bruno Scalia C. F. Leite](https://medium.com/@bruscalia12?source=post_page---byline--3e96cc1bc03d--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--3e96cc1bc03d--------------------------------)
    ·13 min read·Mar 11, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3d230ce2da990f4028cfa3593b0eb7f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Aaron Lefler](https://unsplash.com/@alefler?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Numerical optimization is at the core of quantitative techniques in decision
    science. It encompasses a set of frameworks to optimize one or more objectives
    under some prescribed set of circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Two major categories of optimization problems are *Linear* and *Nonlinear Programming*.
    These categories are distinguished by how the mathematical relationships between
    the decision variables are established in the objective(s) and constraints. Management
    sciences and operations research make extensive use of linear models, whereas
    nonlinear programming problems tend to arise naturally in the physical sciences
    and engineering (Nocedal & Wright, 2006).
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical models often require the incorporation of discrete decisions and
    integer values. These have been especially explored in the context of linear models
    as efficient algorithms were proposed throughout the years. When a *Linear Program*
    (LP) includes integrality constraints, it is classified as an *Integer* or a *Mixed-Integer
    Linear Program* (MILP). Fortunately, we have several solvers available to solve
    these problems, including open-source alternatives such as [HiGHS](https://highs.dev/#top)
    and [SCIP](https://www.scipopt.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Although mathematical models are imperfect representations of reality, they
    can be useful in guiding decisions. Therefore, this article aims to address how
    to describe common formulations and expressions encountered in MILP in mathematical
    terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sections will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Logical statements](#5120)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Setup costs and batch sizes](#86a6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conditional expressions](#a5a0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Discrete planning horizons](#1226)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linearization techniques](#8559)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Further reading](#b8cc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Conclusions](#f9ce)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[References](#6f3f)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This article will be a more abstract text on mathematical models than a code-applied
    guide. However, you might find several practical examples of how to solve numerical
    optimization models in my [GitHub repository](https://github.com/bruscalia/optimization-demo-files).
  prefs: []
  type: TYPE_NORMAL
- en: Before you start, remember you might have a better understanding of this text
    if you are already familiar with *Linear Programming*. You can find an interesting
    overview of the subject in my previous article.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/linear-programming-theory-and-applications-c67600591612?source=post_page-----3e96cc1bc03d--------------------------------)
    [## Linear programming: Theory and applications'
  prefs: []
  type: TYPE_NORMAL
- en: Linear optimization main concepts and implementation in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/linear-programming-theory-and-applications-c67600591612?source=post_page-----3e96cc1bc03d--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Now let us dive in!
  prefs: []
  type: TYPE_NORMAL
- en: Logical statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In integer programming (IP) models, logical statements can be translated into
    linear constraints to capture specific conditions or relationships among the decision
    variables. Let us consider at first logical statements involving binary decision
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Implications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us start with the statement “if *x* then *y*”. It must ensure that if *x*
    is True (value of 1), *y* must also be True. Otherwise, *y* can be either 0 or
    1\. It can be described by a simple inequality stating that *y* is greater than
    or equal to *x*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/72c1cdc05a9dd0626160348cd7d4b475.png)'
  prefs: []
  type: TYPE_IMG
- en: Implication constraint in integer programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Logical NOT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The expression for “not *y*” must return its opposite. So, in case *y* is 1,
    it must return 0\. Otherwise, it should return 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9574a64e4a75e2d5c02139eb7a972dd4.png)'
  prefs: []
  type: TYPE_IMG
- en: Logical NOT in integer programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: The “not” statement can be combined with an implication constraint, for instance,
    “if *x* then not *y*”.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/eae727558113d7483f7309905691a629.png)'
  prefs: []
  type: TYPE_IMG
- en: Implication constraint combined with logical NOT in integer programming. (Image
    by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Logical AND
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To compute the logical “and”, let us introduce a variable *z*, which is True
    if both *x* and *y* are True. These are the same rules to describe the product
    between two binary variables, as *x* times *y* only equals 1 if both are equal
    to 1\. This occurs in the [Facility Dispersion Problem](/the-facility-dispersion-problem-mixed-integer-programming-models-98ffdb56cd26)
    when computing an active edge connecting two nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/763a823045320cb0d5cea853face4e91.png)'
  prefs: []
  type: TYPE_IMG
- en: Logical AND constraints in integer programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Logical OR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, to compute the logical “or”, *z* must be True if either *x* or *y* is True.
    We must then ensure that it is greater than or equal to each of them and that
    it is smaller than their sum.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fca970d70ed3fc4da15e99a5068922b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Logical OR constraints in integer programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Setup costs and batch sizes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let us introduce *setup costs* and *batch sizes*, which are similar to
    implication constraints but in a context with real-valued and integer/binary variables.
    Consider a nonnegative variable *x* and a condition where setup costs apply if
    *x* is greater than zero. To mathematically represent this, we state that *y*
    multiplied by a large value *M* should be greater than or equal to *x*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/87a937f3659e87657899339f4e2a91c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Setup costs implication constraint in mixed-integer linear programming. (Image
    by the author).
  prefs: []
  type: TYPE_NORMAL
- en: If *x* is greater than zero, the inequality is only satisfied if *y* is 1\.
    This occurs for instance in the [Dynamic Lot-size Problem](https://medium.com/towards-data-science/the-dynamic-lot-size-model-a-mixed-integer-programming-approach-4a9440ba124e),
    in which we balance between setup and holding inventory costs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/ba135ac31c0e6d07e281602bcbd92858.png)'
  prefs: []
  type: TYPE_IMG
- en: Machine setup costs incurred for producing one or multiple items. (Image by
    the author).
  prefs: []
  type: TYPE_NORMAL
- en: The *M* term — usually denoted the “big M” — should be a natural upper bound
    for *x*. It is important to define it using the smallest possible value such that
    the constraint is nonbinding if *y* equals 1\. Avoiding too large values can improve
    linear relaxation, which has a positive effect on solver performance, besides
    avoiding numerical errors.
  prefs: []
  type: TYPE_NORMAL
- en: For scenarios involving multiple integer batches with limited capacity each
    (e.g., supply trips to a customer) we can use a similar expression. Now consider
    *y* is an integer variable denoting the number of batches performed and *Q* the
    capacity of each. The decision variable *x* still represents a nonnegative real
    value. We can write the same equation to capture our decision rules.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/77f2703044f43788a4ea1e054b17ea83.png)'
  prefs: []
  type: TYPE_IMG
- en: Batch size constraint in mixed-integer linear programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Expressions — “if-then” rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now imagine we want an inequality to be binding when a binary variable *y* is
    1, else nonbinding. Once again, we can include a large value *M* to capture this
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2ef6f26882b461f3cc54999e0e793fe2.png)'
  prefs: []
  type: TYPE_IMG
- en: Conditional expression in mixed-integer linear programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: In case *y* equals 1, the term multiplying *M* becomes zero and the original
    constraint is binding. Otherwise, *M* is multiplied by 1, therefore it assumes
    an arbitrarily large value such that the original constraint is nonbinding for
    any feasible value of *x* considering the context of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/519c8abefacdaf0d994e5d5d92b5b5b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Conditional expression (inequality) that must hold when y equals one. (Image
    by the author).
  prefs: []
  type: TYPE_NORMAL
- en: These expressions will arise quite often in mixed-integer programming models,
    and some of the most common applications are detailed here.
  prefs: []
  type: TYPE_NORMAL
- en: Disjunctive rules — “if-then-else”
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Disjunctive constraints are a series of connected “if-then” constraints. Additional
    rules ensure that either one or the other is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/f97b2ca63bdf98604385117f96a51c95.png)'
  prefs: []
  type: TYPE_IMG
- en: Disjunctive expressions in mixed-integer linear programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Precedence and sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider now a decision as to which operation, *i* or *j*, happens first. In
    some sequencing models, we can include a real-valued decision variable for the
    start of each operation *x*, another variable or a fixed parameter for its duration
    *d*, and a binary decision variable (precedence) *y* which is 1 if *i* occurs
    before *j*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5bfe8cebeb5ce4b98416bf3d5c652948.png)'
  prefs: []
  type: TYPE_IMG
- en: Precedence constraint in mixed-integer linear programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: These expressions will be useful in the [Disjunctive Job-shop Scheduling Model](https://medium.com/towards-data-science/the-job-shop-scheduling-problem-mixed-integer-programming-models-4bbee83d16ab)
    and the [Traveling Salesman Problem](https://doi.org/10.1145/321043.321046) using
    the MTZ Formulation (Miller et al., 1960).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/0e19e0dcfd2d1b10209af2245b4ca03c.png)'
  prefs: []
  type: TYPE_IMG
- en: Gaant plot for the optimal solution of Job-shop scheduling problem with 10 jobs
    and 10 machines. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Min-max and Max-min objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These objectives involve the minimization of the maximum value of a set of expressions
    or the maximization of their minimum value. In simple terms, our goal is to keep
    the worst-case scenario as good as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Min-max expressions, we can create a scalar decision variable
    *z* and ensure that it is always greater than or equal to attributes *d* from
    a set of options *I* if the corresponding item *i* is selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/2efba647bf990dee686a57b36b114d73.png)'
  prefs: []
  type: TYPE_IMG
- en: Min-max expression in mixed-integer linear programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: When handling Max-min expressions, consider now *z* a scalar lesser than or
    equal to the attributes of all selected items. In both scenarios, we introduce
    the big *M* to ensure that, in case the item is not selected, the constraint becomes
    nonbinding. A good choice of *M* would be the difference between the maximum value
    of *d* (from the whole set of items) and the property of item *i*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/34dc2552f72a48a295c1c795564c7329.png)'
  prefs: []
  type: TYPE_IMG
- en: Max-min expression in mixed-integer linear programming. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: These expressions arise for instance in the [Facility Dispersion Problem](https://medium.com/towards-data-science/the-facility-dispersion-problem-mixed-integer-programming-models-98ffdb56cd26)
    considering binary variables to indicate that a given arc or edge is active.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/34cc5b0b6d3d09c37bc224f87a870e5f.png)'
  prefs: []
  type: TYPE_IMG
- en: Maximizing the minimum distance between any five points selected in Euclidean
    instance of the *p-dispersion problem. (Image by the author).*
  prefs: []
  type: TYPE_NORMAL
- en: Discrete planning horizons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several operations research problems include planning over a discrete horizon.
    In such situations, actions taken at a given moment from the timeline will affect
    how decisions should be performed in the future. For instance, production and
    inventory planning usually includes balancing between holding inventory costs,
    setup costs, stock coverage, and demand forecast, among other aspects. The amount
    produced of a given product at a given moment is usually a decision to be taken
    and it should affect the product availability not only when produced but also
    in the future when considering the possibility of stocking goods.
  prefs: []
  type: TYPE_NORMAL
- en: Inventory balance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To calculate inventory balance, let us define a discrete planning horizon *T*
    with instants *t*. The inventory at a given moment will be a decision variable
    *I* indexed by the elements of the set *T*. If we define inputs (for instance
    the number of items produced) and outputs (corresponding demand or items transported)
    of a given moment as *x* and *d* respectively, we can compute the final inventory
    at a given moment as the final inventory of the previous moment plus inputs minus
    outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c8edf40221bf031ffda8a2fa2401a64c.png)'
  prefs: []
  type: TYPE_IMG
- en: Graphical representation of inventory balance in a discrete planning horizon.
    (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Remember the inputs and outputs might be fixed parameters of the problem or
    also decision variables.
  prefs: []
  type: TYPE_NORMAL
- en: We can put it in equation form as the following.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/6eee187c5acfb70b3458df5cf1418c8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Simple inventory balance equation. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: A great example to illustrate this is the [Dynamic Lot-Size](https://medium.com/towards-data-science/the-dynamic-lot-size-model-a-mixed-integer-programming-approach-4a9440ba124e)
    model. However, more complex decisions might be involved in the process and new
    elements should be included in the inventory balance equations then. One example
    will be presented right next.
  prefs: []
  type: TYPE_NORMAL
- en: Inventory with backlogs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now suppose we have deterministic demands *d* for each moment *t*, but we might
    decide to postpone some of them to reduce our costs (for instance setup costs
    or fixed charges in transportation systems). These might become *backlogs* in
    an inventory balance equation, usually with some associated cost in the objective
    function(s). Once again consider our inputs are represented by *x*, but now we
    are also going to include a non-negative decision variable for backlogs *b*, also
    indexed by *t*. The new inventory balance equation becomes the following.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9dfb930493fd827feb77eb7d5a5e0de1.png)'
  prefs: []
  type: TYPE_IMG
- en: Inventory balance with backlogs. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Then it is up to the optimization solver to define when a demand should be postponed
    to reduce overall costs.
  prefs: []
  type: TYPE_NORMAL
- en: Starts and Endings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some planning processes include scheduling activities that start at a certain
    moment and might last for more than one instant in the discrete planning horizon.
    When inserting these decisions in an optimization model, usually it is up to the
    model to define when the activity starts, when it ends, and possibly its corresponding
    duration. Therefore, we must include some binary decision variables to represent
    these decisions.
  prefs: []
  type: TYPE_NORMAL
- en: To a better understanding of the modeling expressions, let us visually represent
    an activity that starts at a given moment, is active during some instants of the
    planning horizon, and then ends.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/a5ccc5bc6c989a0d9c8369d21616157a.png)'
  prefs: []
  type: TYPE_IMG
- en: Activity scheduled in a discrete planning horizon. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that an activity starts in a moment in which it is active but it must
    be inactive in the previous instant. Conversely, at its ending, there’s no rule
    regarding the previous instant but it must be inactive in the following one.
  prefs: []
  type: TYPE_NORMAL
- en: To write that into mathematical expressions, let us use three groups of decision
    variables — all of them indexed by the elements of the planning horizon *T*. The
    variable *x* will be used to denote a moment in which the activity is active,
    *y* will denote its start, and *z* denote its ending.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a tight linear relaxation and help the solver during Branch & Bound,
    three groups of constraints will be created to establish the relationship between
    *x* and *y*, and the same between *x* and *z*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/773225db0127830409a0c4398ee9cec7.png)'
  prefs: []
  type: TYPE_IMG
- en: Set of constraints to identify the starts of an activity in a discrete planning
    horizon. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: 'And to identify endings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/60b3b9e8b8fb46b41df7a14f06b3b568.png)'
  prefs: []
  type: TYPE_IMG
- en: Set of constraints to identify the endings of an activity in a discrete planning
    horizon. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Additional implication constraints might be included in the first and last instants
    to ensure the desired relationships between *x*, *y*, and *z* in these moments.
  prefs: []
  type: TYPE_NORMAL
- en: Linearization techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some problems include nonlinear expressions that cannot be incorporated directly
    into a MILP model. Fortunately, there are strategies involving the use of binary
    variables that allow us to linearize some nonlinear expressions. Two usual applications
    will be presented right next.
  prefs: []
  type: TYPE_NORMAL
- en: Product of real-valued and binary variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, suppose we have a continuous decision variable *x* bounded between feasible
    limits *L* and *U*. Also suppose a binary decision variable *y* and a support
    decision variable *z* which should compute the product between *x* and *y*. When
    *y* is 1, *z* should assume the value of *x*, otherwise 0.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/dcdfef51018431a2d7634200ae80bfbe.png)'
  prefs: []
  type: TYPE_IMG
- en: If *y* is 1, *z* must be greater than or equal to *x* (and its natural lower
    limit) and also lesser than or equal to *x* (and its natural upper limit). The
    only way to satisfy these inequalities is, therefore, if *z* is equal to *x*.
  prefs: []
  type: TYPE_NORMAL
- en: Now if *y* is 0, the last two inequalities ensure that *z* equals 0, while the
    first two inequalities ensure that any value of *x* between its natural bounds
    is feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, using these inequalities, one can linearize the product between a
    binary and a real-valued decision variable.
  prefs: []
  type: TYPE_NORMAL
- en: Piecewise linear approximations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now suppose we want to compute the value of a function defined in piecewise
    linear segments. It can be an approximation for a general nonlinear expression
    or simply a strategy to compute segmented linear expressions such as in contracts
    with distinct levels of unitary costs varying according to the volume of transactions.
    The idea is illustrated below by the approximation of the sigmoid function by
    5 linear segments.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/63db3ad761e683b5dcdaabf4aa5ad760.png)'
  prefs: []
  type: TYPE_IMG
- en: Sigmoid function and its corresponding piecewise linear approximation using
    5 intervals. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a generic function *f*(*x*) defined in a given domain of a real-valued
    variable *x* between *l* and *u*. Now consider this function is discretized over
    *N* segments of arbitrary size. Each segment of index *i* lies between interpolation
    points *x* of indexes *i* and *i*+1, such that there are *N*+1 interpolation points.
    We now include parameters to define the linear equation of each segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '*aᵢ*: the slope of the *i*th linear segment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*bᵢ*: the intercept of the *i*th linear segment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our goal is that the decision variable *y* assumes the value of *f*(*x*). To
    do so, we also include auxiliary decision variables index by *i* within {1, 2,
    …, *N*}:'
  prefs: []
  type: TYPE_NORMAL
- en: '*zᵢ*: a binary decision variable that is an indicator that *x* lies within
    the *i*th linear segment (closed interval).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*sᵢ*: a real-valued decision variable that assumes the value of *x* in case
    it lies within the *i*th linear segment (closed interval).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable *x* should lie within one of the segments created, therefore a
    constraint must ensure that exactly one *z* variable is active.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/8733623f6db0c296bbfb686038318ee7.png)'
  prefs: []
  type: TYPE_IMG
- en: Constraint ensures that one segment is active in a piecewise linear function.
    (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Now we must ensure that *sᵢ* equals *x* when *zᵢ* equals 1, and also compute
    *y* based on the values of *sᵢ* and the corresponding parameters of each segment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/442341a65ccd210bc7f28a59c36f6f16.png)'
  prefs: []
  type: TYPE_IMG
- en: Piecewise linear function constraints. (Image by the author).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, using these expressions one can compute the value of a generic piecewise
    linear function *f*(*x*) to a real-valued decision variable *y* in a way that
    a mixed-integer linear programming solver can interpret.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The algorithm at the core of most MILP solvers is called *Branch & Bound*. It
    efficiently explores a rooted search tree of discrete decisions without enumerating
    all possibilities. You might find a comprehensive introduction to this topic in
    my previous article.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/a-gentle-introduction-to-branch-bound-d00a4ee1cad?source=post_page-----3e96cc1bc03d--------------------------------)
    [## A Gentle Introduction to Branch & Bound'
  prefs: []
  type: TYPE_NORMAL
- en: The most fundamental integer and mixed-integer programming algorithm explained
    with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/a-gentle-introduction-to-branch-bound-d00a4ee1cad?source=post_page-----3e96cc1bc03d--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: Some models might resort to other techniques, such as *Delayed Column Generation*,
    which aims to solve models with a number of decision variables too large to be
    explicitly enumerated from the start. An introduction on this topic with a coding
    example can be found in a previous article too.
  prefs: []
  type: TYPE_NORMAL
- en: '[](/column-generation-in-linear-programming-and-the-cutting-stock-problem-3c697caf4e2b?source=post_page-----3e96cc1bc03d--------------------------------)
    [## Column Generation in Linear Programming and the Cutting Stock Problem'
  prefs: []
  type: TYPE_NORMAL
- en: How to solve linear problems with a large number of decision variables illustrated
    with a Python example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: towardsdatascience.com](/column-generation-in-linear-programming-and-the-cutting-stock-problem-3c697caf4e2b?source=post_page-----3e96cc1bc03d--------------------------------)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now referring to traditional books on the subject, the interested reader might
    refer to *Numerical Optimization* (Nocedal & Wright, 2006) and *Linear and Nonlinear
    Programming* (Luenberger & Ye, 2008) for a deeper understanding of optimization
    algorithms over continuous domain — which are often components of submodels solved
    in integer programming. The book *Integer Programming* (Wolsey, 2020) is often
    referred to as “the bible” of its corresponding subject. It is a great reference
    to understand better how exact algorithms on discrete search spaces are designed
    going deeper into *Branch & Bound*, cutting planes, and much more. The book *Operations
    research: applications and algorithms* (Winston & Goldberg, 2004) is a great alternative
    for those eager to see more applied examples besides a great overview of theoretical
    aspects.'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixed-Integer Linear Programming (MILP) is a relevant area in numerical optimization
    with relevant applications, especially in management sciences and operations research.
    This article covered key expressions of MILP including Logical statements, Setup
    costs, Conditional expressions, Discrete planning horizons, and Linearization
    techniques. By combining these elements, the reader should be able to formulate
    real-world problems as optimization models that can be tackled by MILP solvers.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Luenberger, D. G. & Ye, Y., 2008\. *Linear and Nonlinear Programming.* 3rd
    ed. Stanford: Springer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Nocedal, J. & Wright, S. J., 2006\. *Numerical Optimization.* 2nd ed. New York:
    Springer New York.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Winston, W. L. & Goldberg, J. B., 2004\. *Operations research: applications
    and algorithms.* 4th ed. Belmont, CA: Thomson Brooks/Cole Belmont.'
  prefs: []
  type: TYPE_NORMAL
- en: Wolsey, L. A., 2020\. *Integer Programming.* 2nd ed. John Wiley & Sons.
  prefs: []
  type: TYPE_NORMAL

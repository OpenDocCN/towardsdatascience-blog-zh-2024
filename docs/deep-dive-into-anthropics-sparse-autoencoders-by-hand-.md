# 深入探讨Anthropic的稀疏自编码器 ✍️

> 原文：[https://towardsdatascience.com/deep-dive-into-anthropics-sparse-autoencoders-by-hand-%EF%B8%8F-eebe0ef59709?source=collection_archive---------1-----------------------#2024-05-31](https://towardsdatascience.com/deep-dive-into-anthropics-sparse-autoencoders-by-hand-%EF%B8%8F-eebe0ef59709?source=collection_archive---------1-----------------------#2024-05-31)

## 探索大语言模型（LLMs）可解释性追求背后的概念

[](https://medium.com/@srijanie.dey?source=post_page---byline--eebe0ef59709--------------------------------)[![Srijanie Dey, PhD](../Images/2b3292a3b22d712d91d0bfc14df64446.png)](https://medium.com/@srijanie.dey?source=post_page---byline--eebe0ef59709--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--eebe0ef59709--------------------------------)[![Towards Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--eebe0ef59709--------------------------------) [Srijanie Dey, PhD](https://medium.com/@srijanie.dey?source=post_page---byline--eebe0ef59709--------------------------------)

·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--eebe0ef59709--------------------------------) ·阅读时长：11分钟·2024年5月31日

--

![](../Images/81130790966487c80fb82406f9fe2482.png)

图片来源：作者（Zephyra，卢玛利亚的守护者，由我的4岁孩子绘制）

*“在神秘的卢玛利亚大地上，古老的魔法弥漫在空气中，生活着Zephyra，这只以狮身鹰翼为特征的空灵狮鹫。Zephyra是《真理法典》的崇高守护者，这本古老的文献蕴藏着宇宙的秘密。*

*“在一座神圣的洞窟中，法典由Zephyra那双绿色的眼睛守护，她能看破虚伪，揭示纯粹的真理。一天，一位黑暗巫师降临卢玛利亚大地，试图通过隐藏《法典》将世界笼罩在无知之中。村民们呼唤Zephyra，她如希望的灯塔在空中翱翔。随着一阵雄伟的翅膀挥动，Zephyra在树林周围创造了一个保护光障，击退了巫师，揭示了真理。”*

*“经过一场长久的决斗，最终结论是黑暗巫师无法与Zephyra的光芒抗衡。通过她的勇气和警觉，真正的光明继续照耀着卢玛利亚。随着时间流逝，卢玛利亚在Zephyra的守护下走向繁荣，而她所守护的真理也始终照亮着这片土地。这就是Zephyra传奇延续下去的方式！”*

# Anthropic的“提取可解释特征之旅”

追随Zephyra的故事，Anthropic AI深入探讨了从模型中提取有意义特征的探索过程。这项研究的核心思想在于理解神经网络中不同组件如何相互作用，以及每个组件所扮演的角色。

根据论文**“**[**迈向单一语义性：通过字典学习分解语言模型**](https://transformer-circuits.pub/2023/monosemantic-features/index.html)**”**，稀疏自动编码器能够成功地从模型中提取有意义的特征。换句话说，稀疏自动编码器帮助解决‘多义性’问题——神经激活同时对应多个意义/解释，通过专注于稀疏激活那些只包含单一解释的特征——换句话说，它们更具单向性。

为了理解这一切是如何完成的，我们可以参考[自动编码器](https://lnkd.in/g2rM9iV2)和[稀疏自动编码器](https://www.linkedin.com/posts/tom-yeh_claude-autoencoder-aibyhand-activity-7199774212759183362-msKU/?)的精彩作品，这些作品由[Tom Yeh教授](https://www.linkedin.com/in/tom-yeh/)创作，解释了这些神奇机制的幕后工作原理。

（以下所有图片，除非另有说明，均来自Tom Yeh教授上面提到的LinkedIn帖子，已获他的许可进行编辑。）

首先，让我们首先探讨一下什么是自动编码器，它是如何工作的。

# 什么是自动编码器？

想象一个作家，他的桌子上散乱着各种纸张——有的是他写故事的笔记，有的是最终稿的副本，还有的是为他的动作故事绘制的插图。在这种混乱中，很难找到重要的部分——尤其是当作家很匆忙，出版社在电话中催促他两天内交书时。幸运的是，作家有一个非常高效的助手——这个助手确保杂乱的桌面被定期清理，类似的物品被分组整理，并把东西放到合适的位置。而且，当作家需要时，助手会帮助他快速找到正确的物品，帮助他按时完成出版社设定的截止日期。

嗯，这个助手的名字叫做自动编码器。它主要有两个功能——编码和解码。编码是指压缩输入数据并提取出关键特征（组织）。解码则是从编码表示中重建原始数据的过程，目标是尽量减少信息丢失（恢复）。

现在让我们看看这个助手是如何工作的。

# 自动编码器是如何工作的？

给定：四个训练样本 **X1, X2, X3, X4.**

## [1] 编码器

第一步是将训练样本复制到目标 **Y’**。自动编码器的工作是重建这些训练样本。由于目标就是训练样本本身，所以使用了词***‘Auto’***，它是希腊语的***‘自我’***意思。

## [2] 编码器：第一层 +ReLU

正如我们在之前的所有模型中所看到的，简单的权重和偏置矩阵结合ReLU非常强大，能够做出惊人的效果。因此，通过使用第一个编码层，我们将原始特征集的大小从4x4减少到3x4。

![](../Images/c2c2896b0761620ef71f79dd24b7de1a.png)

> 简要回顾：
> 
> **线性变换**：输入嵌入向量与权重矩阵W相乘，然后与偏置向量**b**相加，
> 
> z = **W**x + **b**，其中**W**是权重矩阵，x是我们的词嵌入，**b**是偏置向量。
> 
> **ReLU激活函数**：接下来，我们将ReLU应用于这个中间的z。
> 
> ReLU返回输入和零之间的逐元素最大值。数学上，**h** = max{0, z}。

## [3] 编码器：第二层 + ReLU

上一层的输出由第二个编码器层处理，该层进一步将输入大小减小到2x3。这时，相关特征的提取发生在此层。这个层也叫做“瓶颈”，因为该层的输出特征远小于输入特征。

![](../Images/486e9e67fbbfac831061f662d28f156c.png)

## [4] 解码器：第一层 + ReLU

一旦编码过程完成，下一步是解码相关特征，以构建最终输出。为此，我们将上一步的特征与相应的权重和偏置相乘，并应用ReLU层。结果是一个3x4的矩阵。

![](../Images/9f9ffd4521b3c28b6eba26be3b1c2100.png)

## [5] 解码器：第二层 + ReLU

第二个解码器层（权重、偏置 + ReLU）应用于之前的输出，给出最终结果，即重建的4x4矩阵。我们这样做是为了恢复原始维度，以便将结果与我们的原始目标进行比较。

![](../Images/47b3bd18b0209d34df20b5cb9f242b97.png)

## [6] 损失梯度和反向传播

一旦获得解码器层的输出，我们计算**输出（Y）**和**目标（Y’）**之间的均方误差（MSE）的梯度。为此，我们求解**2*(Y-Y’)**，这给出了最终的梯度，激活反向传播过程，并相应地更新权重和偏置。

![](../Images/286ca27d2139e0c693ec2fdcee1050b0.png)

现在我们了解了自编码器的工作原理，接下来就该探讨它的**稀疏变体**如何实现大语言模型（LLMs）的可解释性。

# 稀疏自编码器——它是如何工作的？

首先，假设我们给定了：

+   在经过前馈层处理后的变换器输出，即假设我们有五个标记（X）的模型激活值。它们很好，但并不能揭示模型如何得出决策或进行预测。

![](../Images/5c01141ce07bd9ff3330b673178216f6.png)

这里的主要问题是：

> 是否有可能将每个激活（3D）映射到一个更高维度空间（6D），以帮助理解？

## [1] 编码器：线性层

编码器层的第一步是将输入**X**与编码器权重相乘，并添加偏置（如在自编码器的第一步中所做）。

![](../Images/312068c487f5a71ba089baf15668d291.png)

## [2] 编码器：ReLU

下一子步骤是应用ReLU激活函数，加入非线性并抑制负激活。这种抑制导致许多特征被设为0，从而实现稀疏性概念——输出稀疏且可解释的特征***f.***

当我们只有一个或两个正特征时，就会发生可解释性。如果我们检查***f6***，我们可以看到**X2**和**X3**是正的，并可以说它们两个有‘山’这一共同点。

![](../Images/7b8b7f37cd47ccde17cf92263a8a113b.png)

## [3] 解码器 : 重建

一旦完成编码器步骤，我们就进入解码器步骤。我们将***f***与解码器的权重相乘并添加偏置。这样输出的**X’**就是从可解释特征重建的**X**。

![](../Images/0ef0969dd32ed6d5a1a46041619c2efe.png)

如同在自编码器中所做的那样，我们希望**X’**尽可能接近**X**。为了确保这一点，进一步的训练是必不可少的。

## [4] 解码器 : 权重

作为一个中间步骤，我们计算每个权重的L2范数，并将它们保留下来以便稍后使用。

![](../Images/9208c5b6e536090638fa96455a2dc40b.png)

> **L2-范数**
> 
> 也称为欧几里得范数，L2范数使用以下公式计算向量的大小：||x||₂ = √(Σᵢ xᵢ²)。
> 
> 换句话说，它对每个分量的平方进行求和，然后对结果取平方根。这个范数提供了一种直接的方式来量化向量在欧几里得空间中的长度或距离。

# 训练

如前所述，稀疏自编码器通过广泛的训练使得重建的**X’**尽可能接近**X**。为此，我们接下来执行以下步骤：

## [5] 稀疏性 : L1损失

这里的目标是尽可能获得接近零/零的值。我们通过调用**L1稀疏性**来惩罚权重的绝对值——核心思想是我们希望使得和尽可能小。

![](../Images/f8aa5583bdaebc8564e7bd8b44ddd399.png)

> **L1-损失**
> 
> L1-损失是权重绝对值之和：L1 = λΣ|w|，其中λ是正则化参数。
> 
> 这促使许多权重变为零，从而简化了模型，并增强了**可解释性**。
> 
> 换句话说，L1有助于将注意力集中在最相关的特征上，同时防止过拟合，改善模型的泛化能力，并减少计算复杂性。

## [6] 稀疏性 : 梯度

下一步是计算**L1**的梯度，对于正值为-1。因此，对于所有值为***f >0***的情况，结果将被设定为-1。

![](../Images/5e85338940e15e3475ce8be719ff40e3.png)

> **L1惩罚如何将权重推向零？**
> 
> L1惩罚的梯度通过一个过程将权重推向零，这个过程施加一个恒定的力，无论权重的当前值如何。下面是它的工作原理（本小节中的所有图片均为作者提供）：
> 
> L1惩罚表示为：

![](../Images/04df48be6e16080c94467c08c9f248ef.png)

> 这个惩罚相对于权重***w***的梯度是：

![](../Images/52a15cda96d611eb04f7e52d79a4a817.png)

> 其中***sign(w)***是：

![](../Images/5d0377f88ae46308b533ea7284c90ab7.png)

> 在梯度下降过程中，权重的更新规则是：

![](../Images/c4cf2e8036e3f8abe10def8af14ab467.png)

> 其中𝞰是学习率。
> 
> **常量减法（或加法）**操作中的**λ**（根据其符号）会减小权重值的绝对值。如果权重足够小，这个过程可以将其完全驱动为零。

## [7] 稀疏性：零

对于所有已经是零的其他值，我们保持它们不变，因为它们已经被归零。

![](../Images/35dcfe7c72319bdffd087a7baa4fe776.png)

## [8] 稀疏性：权重

我们将第6步中获得的梯度矩阵的每一行与第4步中获得的相应解码器权重相乘。这个步骤至关重要，因为它防止模型学习到较大的权重，避免在重建结果时加入错误的信息。

![](../Images/306a1ce823111e9d815e4b7f1fd15802.png)

## [9] 重建：均方误差损失

我们使用均方误差或**L2**损失函数来计算**X’**和**X**之间的差异。如前所述，目标是将误差最小化到最低值。

![](../Images/f4383312900f938f95dc354d99c296fe.png)

## [10] 重建：梯度

**L2**损失的梯度是**2*(X’-X)**。

因此，正如原始自编码器所示，我们运行反向传播来更新权重和偏差。这里的关键是找到稀疏性和重建之间的良好平衡。

![](../Images/8b70731a04ecd7810360275f13324e41.png)

这样，我们就结束了这一非常巧妙且直观的学习方法，帮助我们理解模型是如何理解一个概念，并在生成响应时采取的方向。

## 总结：

1.  一个**自编码器**整体由两个部分组成：**编码器**和**解码器**。**编码器**利用权重和偏差以及ReLU激活函数将初始输入特征压缩到一个较低的维度，力图仅捕捉相关的部分。另一方面，**解码器**则接收编码器的输出，并努力将输入特征重建回其原始状态。由于自编码器的目标就是初始特征本身，因此才称之为“自”。目标和标准神经网络一样，是通过传播误差的梯度并更新权重和偏差来实现目标特征和输入特征之间的最小误差（差异）。

1.  **稀疏自编码器**由与标准自编码器相同的所有组件以及一些额外的组成部分构成。这里的关键是训练步骤中的不同方法。由于目标是提取可解释的特征，我们希望将那些相对意义较小的值置为零。一旦编码器使用ReLU抑制负值，我们进一步使用L1损失对结果进行处理，通过惩罚权重的绝对值来促进稀疏性。这是通过向损失函数中添加一个惩罚项来实现的，该惩罚项是权重绝对值之和：λΣ|w|。那些保持非零的权重是对模型性能至关重要的。

# 利用稀疏性提取可解释特征

作为人类，我们的大脑仅对特定刺激激活一小部分神经元。同样，稀疏自编码器通过利用稀疏性约束，如**L1**正则化，学习输入的稀疏表示。通过这样做，稀疏自编码器能够从复杂数据中提取可解释的特征，从而增强所学习特征的简洁性和可解释性。这种类似生物神经过程的选择性激活有助于聚焦于输入数据中最相关的部分，使模型更加鲁棒和高效。

随着Anthropic致力于理解AI模型中的可解释性，其倡议强调了透明和易理解的AI系统的必要性，尤其是在AI系统越来越多地融入关键决策过程时。通过专注于创建既强大又可解释的模型，Anthropic为开发可信赖且能有效应用于现实世界的AI做出了贡献。

总之，**稀疏自编码器**对于提取可解释的特征、增强模型的鲁棒性并确保效率至关重要。对这些强大模型的理解工作以及它们如何进行推理，突显了AI可解释性日益重要的趋势，为更加透明的AI系统铺平了道路。未来如何发展这些概念，并推动我们迈向一个将AI安全地融入我们生活的未来，值得期待！

*附言：如果你想自己完成这个练习，下面有一个空白模板的链接供你使用。*

[空白模板用于手工练习](https://drive.google.com/file/d/1xiAjdlWCAzhj-I-YOb7wSMeroUOQzdlE/view?usp=sharing)

现在去玩吧，帮助Zephyr保持《真理法典》的安全！

![](../Images/eb16ec0901108e38f05e6bac5825305e.png)

*再次特别感谢* [*Tom Yeh教授*](https://www.linkedin.com/in/tom-yeh/) *对本项工作的支持！*

## 参考文献：

[1] 朝着单义性：通过字典学习分解语言模型，Bricken等人，2023年10月 [https://transformer-circuits.pub/2023/monosemantic-features/index.html](https://transformer-circuits.pub/2023/monosemantic-features/index.html)

[2] 扩展单义性：从Claude 3 Sonnet中提取可解释特征，Templeton等人，2024年5月 [https://transformer-circuits.pub/2024/scaling-monosemanticity/](https://transformer-circuits.pub/2024/scaling-monosemanticity/)

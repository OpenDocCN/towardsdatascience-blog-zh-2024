<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>A Sharp and Solid Outline of 3D Grid Neighborhoods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>A Sharp and Solid Outline of 3D Grid Neighborhoods</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/a-sharp-and-solid-outline-of-3d-grid-neighborhoods-1b0f264e7c11?source=collection_archive---------3-----------------------#2024-03-08">https://towardsdatascience.com/a-sharp-and-solid-outline-of-3d-grid-neighborhoods-1b0f264e7c11?source=collection_archive---------3-----------------------#2024-03-08</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="8e5f" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx">How 2D grid-based algorithms can be brought into the 3D world</h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="hd he hf hg hh ab"><div><div class="ab hi"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@rhys.goldstein?source=post_page---byline--1b0f264e7c11--------------------------------" rel="noopener follow"><div class="l hj hk by hl hm"><div class="l ed"><img alt="Rhys Goldstein" class="l ep by dd de cx" src="../Images/75dafe578e93f357d5cfd6822b274373.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*E3oc1rwiTxEi33SVWK8N8g.jpeg"/><div class="hn by l dd de em n ho eo"/></div></div></a></div></div><div class="hp ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--1b0f264e7c11--------------------------------" rel="noopener follow"><div class="l hq hr by hl hs"><div class="l ed"><img alt="Towards Data Science" class="l ep by br ht cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="hn by l br ht em n ho eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hu ab q"><div class="ab q hv"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hw hx bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hy" data-testid="authorName" href="https://medium.com/@rhys.goldstein?source=post_page---byline--1b0f264e7c11--------------------------------" rel="noopener follow">Rhys Goldstein</a></p></div></div></div><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hw hx dx"><button class="ib ic ah ai aj ak al am an ao ap aq ar id ie if" disabled="">Follow</button></p></div></div></span></div></div><div class="l ig"><span class="bf b bg z dx"><div class="ab cn ih ii ij"><div class="ik il ab"><div class="bf b bg z dx ab im"><span class="in l ig">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hy ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--1b0f264e7c11--------------------------------" rel="noopener follow"><p class="bf b bg z io ip iq ir is it iu iv bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="hz ia" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">20 min read</span><div class="iw ix l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Mar 8, 2024</span></div></span></div></span></div></div></div><div class="ab cp iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn"><div class="h k w ea eb q"><div class="kd l"><div class="ab q ke kf"><div class="pw-multi-vote-icon ed in kg kh ki"><div class=""><div class="kj kk kl km kn ko kp am kq kr ks ki"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l kt ku kv kw kx ky kz"><p class="bf b dy z dx"><span class="kk">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kj la lb ab q ee lc ld" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="le"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg></button></div></div></div><div class="ab q jo jp jq jr js jt ju jv jw jx jy jz ka kb kc"><div class="lf k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lg an ao ap id lh li lj" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep lk cn"><div class="l ae"><div class="ab cb"><div class="ll lm ln lo lp lq ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lg an ao ap id lr ls ld lt lu lv lw lx s ly lz ma mb mc md me u mf mg mh"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj mk"><img src="../Images/f060f791dcb2e8c13912b577f52a19e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p12B5dLsizVI7diIL_4lAg.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Closeup of the triangular 50-neighborhood. (Image by author)</figcaption></figure><p id="f025" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">In my previous two articles, <a class="af nx" rel="noopener" target="_blank" href="/a-short-and-direct-walk-with-pascals-triangle-26a86d76f75f">A Short and Direct Walk with Pascal’s Triangle</a> and <a class="af nx" rel="noopener" target="_blank" href="/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78">A Quick and Clear Look at Grid-Based Visibility</a>, we saw how easy it is to generate decent-looking travel paths and compute visible regions using grid-based algorithms. The techniques I shared in those posts can be used for video games, mobile robotics, and architectural design, though our examples were limited to two dimensions. In this third and final installment of the series, we take what we know about 2D grid-based algorithms and add the third dimension. Read on to discover five 3D grid neighborhoods you can use to solve AI problems like navigation and visibility in 3D.</p><h1 id="bb9c" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">3D Navigation and Visibility Problems</h1><p id="0de6" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">Since the world is 3D, it’s no surprise that video games, mobile robotics challenges, and architectural design tools often require 3D variants of pathfinding and visibility algorithms. For example, the image below shows what a person can see from a certain point in a 3D model of a city. An architect might use this kind of 3D visibility analysis to design a large building while allowing nearby pedestrians to see as much of the sky as possible.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj oz"><img src="../Images/132e399cb44f2355ad549d7592144194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pEV1Svx8PK8yqJKDW078wg.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Example of 3D visibility by <a class="af nx" href="https://through-the-interface.typepad.com/through_the_interface/about-the-author.html" rel="noopener ugc nofollow" target="_blank">Kean Walmsley</a> on <a class="af nx" href="https://www.keanw.com/2023/10/using-vasa-with-forma-part-2.html" rel="noopener ugc nofollow" target="_blank">Through the Interface</a>. (Used with permission)</figcaption></figure><p id="7275" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">This next image gives us an X-ray view of the route a person might walk between two points on different floors of a building.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj pa"><img src="../Images/a5c80ec26afd238023088d63ee30b0b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gik4RN6BJYVMctpQsjxwGw.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Example of 3D pathfinding by <a class="af nx" href="https://through-the-interface.typepad.com/through_the_interface/about-the-author.html" rel="noopener ugc nofollow" target="_blank">Kean Walmsley</a> on <a class="af nx" href="https://www.keanw.com/2021/10/streamlines-in-the-forge-viewer.html" rel="noopener ugc nofollow" target="_blank">Through the Interface</a>. (Used with permission)</figcaption></figure><p id="f695" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The above example is typical of 3D pathfinding in that the path is constrained to walkable surfaces such as staircases and floors. Another type of 3D navigation problem arises when generating a flight path for an aerial robot such as a quadcopter drone. In that case, the path may go straight through the air instead of adhering to surfaces.</p><p id="5858" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">As in the previous articles, we are interested in solving navigation and visibility problems using grid-based algorithms<strong class="nd fr">.</strong> This means that every time a grid point is visited, information may flow only to neighboring grid points. The set of grid points considered to be “neighbors” is given by the <strong class="nd fr">grid neighborhood</strong>. There are many possible grid neighborhoods, but the ones depicted in the image below are the five smallest <strong class="nd fr">standard 2D grid neighborhoods</strong> [1]. Notice that as the neighborhoods increase in size from 4 to 16 neighbors, they alternate between rectangular and triangular grids. Generally speaking, algorithms that use larger neighborhoods take longer to run but produce more accurate results.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj pb"><img src="../Images/2eb92480d8f720af9a57326b84011511.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0tthMeoqxwUS0EJVWQXn4A.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Rectangular and triangular 2D grid neighborhoods. (Image by <a class="af nx" href="https://www.research.autodesk.com/" rel="noopener ugc nofollow" target="_blank">Autodesk Research</a> [1], used with permission)</figcaption></figure><p id="179e" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">What interests us now is the following question:</p><blockquote class="pc"><p id="9a03" class="pd pe fq bf pf pg ph pi pj pk pl nw dx">What do these 2D neighborhoods look like in 3D?</p></blockquote><p id="7840" class="pw-post-body-paragraph nb nc fq nd b go pm nf ng gr pn ni nj nk po nm nn no pp nq nr ns pq nu nv nw fj bk">The 3D equivalent of the 4-neighborhood and the 8-neighborhood are described in the journal paper “<a class="af nx" href="https://www.jair.org/index.php/jair/article/view/13544" rel="noopener ugc nofollow" target="_blank">Path Counting for Grid-Based Navigation</a>” and elsewhere in the literature, but I had difficulty finding the 3D versions of the other three neighborhoods. I eventually decided to work them out myself so that I could present the complete set. Before we go through them one by one, here’s a sneak peek at the five smallest <strong class="nd fr">standard 3D grid neighborhoods</strong>.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj pr"><img src="../Images/ecab56499e51e27b28777ecb25c11b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M-MOxj87JloNiJcNpjgQJg.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The five smallest standard grid neighborhoods in 3D. (Image by author)</figcaption></figure><p id="1aa7" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">To demonstrate these five neighborhoods, we’ll solve the 3D visibility problem with each of them and compare the five solutions for accuracy. The reason we’re focusing on grid-based visibility is because it’s one of the simplest grid-based algorithms — simple enough for us to take a good look at the code. Once you’ve seen how grid-based visibility can be implemented in 3D, you can use your choice of 3D grid neighborhood to solve 3D pathfinding problems and other AI challenges that arise in the 3D world.</p><h1 id="26c9" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Rectangular 6-Neighborhood</h1><p id="9c25" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">We’ll start with the neighborhoods defined on a <strong class="nd fr">3D rectangular grid</strong>, which is simply the set of points [x, y, z] where x, y, and z are integers. These grids are widely used. They can be represented on a computer using a standard 3D array.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ps"><img src="../Images/eb84b12179c6d509b0b5d7c69c77f66e.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*WQPZlLUafp0Z3fgYCPTVMg.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">A 3x3x3 slice of a 3D rectangular grid. (Image by author)</figcaption></figure><p id="0a70" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The first 3D grid neighborhood is nearly ubiquitous, but we’ll present it anyway for the sake of completeness. When the rectangular 4-neighborhood in 2D is extended to 3D, we end up with the <strong class="nd fr">rectangular 6-neighborhood</strong> illustrated below. To interpret the image, imagine that the two vertical arrows point up and down while the remaining arrows point north, east, south, and west.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj pt"><img src="../Images/805464f757c3dc9ce175d72d25dc45e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*Y2mKbAranTmwnIDkInWcsg.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The rectangular 6-neighborhood represented with vectors. (Image by author)</figcaption></figure><p id="e10c" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Now we’ll apply the rectangular 6-neighborhood to solve the 3D visibility problem using Python. In the code below, the function <code class="cx pu pv pw px b">grid_visibility</code> inputs a 3D array named <code class="cx pu pv pw px b">grid0</code> representing the environment. Cells in this initial grid with a value of 1 represent empty space, and cells with a value of 0 represent an obstacle. The function computes the visibility results in a separate 3D array named <code class="cx pu pv pw px b">grid</code>. Cells in this output grid with a value of 1 are considered visible from a viewpoint at [0, 0, 0], and cells with a value of 0 are considered blocked.</p><pre class="ml mm mn mo mp py px pz bp qa bb bk"><span id="c6c9" class="qb nz fq px b bg qc qd l qe qf">import numpy as np<br/><br/># Solve the 3D visibility problem using a simple grid-based method<br/>def grid_visibility(grid0):<br/>    grid = grid0.copy()<br/>    for x in range(grid.shape[0]):<br/>        for y in range(grid.shape[1]):<br/>            for z in range(int(x==0 and y==0), grid.shape[2]):<br/>                vx = grid[x-1,y,z]<br/>                vy = grid[x,y-1,z]<br/>                vz = grid[x,y,z-1]<br/>                grid[x,y,z] *= (x*vx + y*vy + z*vz) / (x + y + z)<br/>    return grid &gt;= 0.5</span></pre><p id="44a5" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The reason the viewpoint is fixed at [0, 0, 0] is just to simplify the code. If you want the viewpoint to be located somewhere else, such as the center of the grid, the <a class="af nx" rel="noopener" target="_blank" href="/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78">previous article</a> solves that problem in 2D with an array indexing trick that will also work in 3D.</p><p id="0161" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">To test our 3D grid-based visibility solver, we’ll use the scenario shown below. The input grid is 40x40x40 and features a spherical obstacle with center at [10, 20, 16] and radius 8.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qg"><img src="../Images/e0a0030f8b428dfb572f4ddc0f583f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*qz6yZxcNvc2UpErfoE_B_w.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The test scenario. (Image by author)</figcaption></figure><p id="7927" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">This problem is simple enough to solve analytically, allowing us to test the accuracy of the grid-based solution. The red dots in the animation below indicate the grid points that have been misclassified using our 6-neighbor grid-based approach. Notice that the vast majority of the 40x40x40 grid points have no red dot, meaning that they are correctly classified. The errors occur near the boundary of the obstacle’s “shadow”, where grid points are either barely visible or barely obstructed. I find that errors such as these are usually tolerable, though it depends on the application. I’ll provide the testing and visualization code near the end of the article.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qh"><img src="../Images/d3a755e13c69176dedca4e79efdd4efc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*60pKgahQYKHmRmtsynqYvg.gif"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Grid-based visibility classification errors using the 6-neighborhood. (Animation by author)</figcaption></figure><p id="8254" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Now we are going to rewrite our grid-based visibility algorithm in a way that accommodates the larger 3D grid neighborhoods. The key is to solve the visibility problem within a cone bracketed by a set of vectors. In the <a class="af nx" rel="noopener" target="_blank" href="/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78">previous article</a>, we defined a 2D <code class="cx pu pv pw px b">visibility_within_cone</code> function that required two vectors to specify a triangular cone. In 3D, the function requires three vectors to define a tetrahedral cone.</p><pre class="ml mm mn mo mp py px pz bp qa bb bk"><span id="b483" class="qb nz fq px b bg qc qd l qe qf"># Solve the 3D visibility problem by modifying a grid within a cone<br/>def visibility_within_cone(grid, u_vector, v_vector, w_vector):<br/>    u = np.asarray(u_vector, dtype=int)<br/>    v = np.asarray(v_vector, dtype=int)<br/>    w = np.asarray(w_vector, dtype=int)<br/>    origin = np.array([0,0,0], dtype=int)<br/>    dims = np.asarray(grid.shape, dtype=int)<br/>    m = 0<br/>    k = 0<br/>    q = 0<br/>    pos = np.array([0,0,0], dtype=int)<br/>    while np.all(pos &lt; dims):<br/>        while np.all(pos &lt; dims):<br/>            while np.all(pos &lt; dims):<br/>                if not np.all(pos == 0):<br/>                    p = tuple(pos)<br/>                    if grid[p] == 1:<br/>                        pu = tuple(np.maximum(origin, pos - u))<br/>                        pv = tuple(np.maximum(origin, pos - v))<br/>                        pw = tuple(np.maximum(origin, pos - w))<br/>                        grid[p] = (m*grid[pu] + <br/>                                   k*grid[pv] +<br/>                                   q*grid[pw]) / (m + k + q)<br/>                q += 1<br/>                pos += w<br/>            k += 1<br/>            q = 0<br/>            pos = m*u + k*v<br/>        m += 1<br/>        k = 0<br/>        q = 0<br/>        pos = m*u</span></pre><p id="1828" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Below is an alternative illustration of the 6-neighborhood showing the triangular faces associated with each cone. Represented in this fashion, the 6-neighborhood appears as an octahedron.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj pt"><img src="../Images/4601851dfbbb5639aa34b1241e03d191.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*uoXNxN9qBR-98jEU8Lqo4Q.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The rectangular 6-neighborhood represented with triangular faces. (Image by author)</figcaption></figure><p id="2278" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">If we slice the octahedron in half, we can see the rectangular 6-neighborhood’s 2D counterpart: the 4-neighborhood.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj pt"><img src="../Images/92ac9ce07cb930dd4dca23aaa6e3d1dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*hhoPec-Og2f-yAXKxkRpOA.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The 3D 6-neighborhood cut in half to reveal the 2D 4-neighborhood. (Image by author)</figcaption></figure><p id="3f26" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Let’s look at the full octahedron again, and project one of the triangles away from the origin to help us visualize a tetrahedral cone. The 6-neighborhood has 8 such cones in total, one for each 3D octant of the domain. Note that each cone extends to infinity, taking up its entire octant.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj pt"><img src="../Images/8d576426c956f300bf649e37f1253cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/format:webp/1*3SLMDd0NQNeXS3opjKYQfg.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Visualization of a cone in the rectangular 6-neighborhood. (Image by author)</figcaption></figure><p id="709a" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Here is a plot of just one octant of the 6-neighborhood, with its single cone. The plot makes it easy to read off the coordinates of the bracketing vectors, which we’ll need in order to reimplement the grid-based algorithm. In this case the bracketing vectors are <code class="cx pu pv pw px b">[1,0,0]</code>, <code class="cx pu pv pw px b">[0,1,0]</code>, <code class="cx pu pv pw px b">[0,0,1]</code>, the corners of the triangle.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ps"><img src="../Images/865ba5e86babf689fae45bcdb7a3925e.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*ZEoZiVuNN_mWLFDUZa4ETg.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Plot of a cone in one octant of the rectangular 6-neighborhood. (Image by author)</figcaption></figure><p id="f438" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Below is our new implementation of 6-neighbor 3D grid-based visibility.</p><pre class="ml mm mn mo mp py px pz bp qa bb bk"><span id="91a5" class="qb nz fq px b bg qc qd l qe qf"># Solve the 3D visibility problem using the 6-neighborhood<br/>def grid6_visibility(grid0):<br/>    grid = grid0.copy()<br/>    visibility_within_cone(grid, [1,0,0], [0,1,0], [0,0,1])<br/>    return grid &gt;= 0.5</span></pre><p id="991e" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The new <code class="cx pu pv pw px b">grid6-visibility</code> function produces exactly the same results as the <code class="cx pu pv pw px b">grid-visibility</code> function we saw earlier, but our refactoring efforts will help us tackle the larger 3D neighborhoods which have many more cones.</p><h1 id="5a7b" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Rectangular 26-Neighborhood</h1><p id="6236" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">When the rectangular 8-neighborhood in 2D is extended to 3D, we get the <strong class="nd fr">rectangular 26-neighborhood</strong> shown below. The neighborhood appears as a 2x2x2 cube with each side tessellated into triangles representing cones.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qi"><img src="../Images/d23900bcdc3fca8be0bf65a743a8771b.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*HKTFLTMCJV6ii5qACMW1vA.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The rectangular 26-neighborhood. (Image by author)</figcaption></figure><p id="e267" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">As before, we can cut the neighborhood in half to see its 2D counterpart: the 8-neighborhood.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qi"><img src="../Images/a8d17575956761aebe87c798ee9503c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*d3mn5PWFY-eYt2mnmLWaoA.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The 3D 26-neighborhood cut in half to reveal the 2D 8-neighborhood. (Image by author)</figcaption></figure><p id="90a9" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The rectangular 26-neighborhood is well known, though it is rarely shown in a way that identifies its 48 tetrahedral cones. The illustration below highlights one of these cones.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qi"><img src="../Images/415826e69252c7b41127b750dc1bfc6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*NUeVHBkoZaou_ctnP-tLsA.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Visualization of a cone in the rectangular 26-neighborhood. (Image by author)</figcaption></figure><p id="af13" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The following plot helps us to read off the coordinates of the 6 cones within one octant.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ps"><img src="../Images/e9b8272550bfd7a08d7b9c87baa67539.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*BzfsF8J37TL9JP7Z5z4_0w.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Plot of the 6 cones in one octant of the rectangular 26-neighborhood. (Image by author)</figcaption></figure><p id="d4ec" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Here’s our implementation of 26-neighbor 3D grid-based visibility. Notice that we call <code class="cx pu pv pw px b">visibility_within_cone</code> once for each triangle in the plot above.</p><pre class="ml mm mn mo mp py px pz bp qa bb bk"><span id="fb36" class="qb nz fq px b bg qc qd l qe qf"># Solve the 3D visibility problem using the 26-neighborhood<br/>def grid26_visibility(grid0):<br/>    grid = grid0.copy()<br/>    visibility_within_cone(grid, [1,0,0], [1,1,0], [1,1,1])<br/>    visibility_within_cone(grid, [1,0,0], [1,0,1], [1,1,1])<br/>    visibility_within_cone(grid, [0,1,0], [1,1,0], [1,1,1])<br/>    visibility_within_cone(grid, [0,1,0], [0,1,1], [1,1,1])<br/>    visibility_within_cone(grid, [0,0,1], [1,0,1], [1,1,1])<br/>    visibility_within_cone(grid, [0,0,1], [0,1,1], [1,1,1])<br/>    return grid &gt;= 0.5</span></pre><p id="134f" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The visibility results we obtain with the 26-neighborhood contain fewer errors than with the 6-neighborhood. You can see below that the red dots are sparser.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj qj"><img src="../Images/c98d5a0f0de79e315d2f44e3fd9cebc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yo8Q_mKDXoMC-iX_du38ug.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Classification errors using the 6-neighborhood (left) and 26-neighborhood (right). (Image by author)</figcaption></figure><p id="f33a" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The 26-neighborhood is common, though it is usually presented without identifying the 48 tetrahedral cones. In theory these cones aren’t needed for pathfinding or visibility, but they allow us to adopt faster algorithms. For example, it is widely understood among computer scientists that one can find shortest grid paths in 3D by applying Dijkstra’s algorithm using 26 neighbors on a rectangular grid. Dijkstra’s algorithm does not require us to know how those neighbors are grouped into cones. However, if we have identified the cones, we can adopt a faster pathfinding method called <a class="af nx" href="https://ojs.aaai.org/index.php/SOCS/article/view/21762" rel="noopener ugc nofollow" target="_blank">3D Jump Point Search</a> [2]. If you’re looking for a challenge, try implementing Jump Point Search with your choice of 3D grid neighborhood.</p><h1 id="4168" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Rectangular 74-Neighborhood</h1><p id="8fb3" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">The previous two 3D grid neighborhoods are reasonably well established, but now we must venture into unknown territory. When the rectangular 16-neighborhood in 2D is extended to 3D, we get the <strong class="nd fr">rectangular 74-neighborhood</strong>. I’m not sure how to describe the shape of the 74-neighborhood, but this is what it looks like.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ps"><img src="../Images/45691df1c6421f1a8af489a7989592e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*aBUL1M_uA5AwbvkmwobE9Q.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The rectangular 74-neighborhood. (Image by author)</figcaption></figure><p id="ba98" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">And here it is again, this time sliced in half to reveal the 16-neighborhood.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ps"><img src="../Images/2341320c37a99e203d94a1be913b7f4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*Jz_Lx_oOZFnva_j2drLUxA.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The 3D 74-neighborhood cut in half to reveal the 2D 16-neighborhood. (Image by author)</figcaption></figure><p id="9ea2" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The rectangular 74-neighborhood has 144 cones in total. Below is a plot representing the 18 cones in one octant.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ps"><img src="../Images/b25a575a10d1756dd0883cafb5828091.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*7wHIJJZWC7GIu97t2vGERw.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Plot of the 18 cones in one octant of the rectangular 74-neighborhood. (Image by author)</figcaption></figure><p id="3d66" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Reading off the coordinates of each triangle in the plot, we can now implement 74-neighbor 3D grid-based visibility.</p><pre class="ml mm mn mo mp py px pz bp qa bb bk"><span id="ae2a" class="qb nz fq px b bg qc qd l qe qf"># Solve the 3D visibility problem using the 74-neighborhood<br/>def grid74_visibility(grid0):<br/>    grid = grid0.copy()<br/>    visibility_within_cone(grid, [1,0,0], [2,1,0], [2,1,1])<br/>    visibility_within_cone(grid, [1,1,0], [2,1,0], [2,1,1])<br/>    visibility_within_cone(grid, [1,1,0], [1,1,1], [2,1,1])    <br/>    visibility_within_cone(grid, [1,0,0], [2,0,1], [2,1,1])<br/>    visibility_within_cone(grid, [1,0,1], [2,0,1], [2,1,1])<br/>    visibility_within_cone(grid, [1,0,1], [1,1,1], [2,1,1])<br/>    visibility_within_cone(grid, [0,1,0], [1,2,0], [1,2,1])<br/>    visibility_within_cone(grid, [1,1,0], [1,2,0], [1,2,1])<br/>    visibility_within_cone(grid, [1,1,0], [1,1,1], [1,2,1])<br/>    visibility_within_cone(grid, [0,1,0], [0,2,1], [1,2,1])<br/>    visibility_within_cone(grid, [0,1,1], [0,2,1], [1,2,1])<br/>    visibility_within_cone(grid, [0,1,1], [1,1,1], [1,2,1])<br/>    visibility_within_cone(grid, [0,0,1], [1,0,2], [1,1,2])<br/>    visibility_within_cone(grid, [1,0,1], [1,0,2], [1,1,2])<br/>    visibility_within_cone(grid, [1,0,1], [1,1,1], [1,1,2])<br/>    visibility_within_cone(grid, [0,0,1], [0,1,2], [1,1,2])<br/>    visibility_within_cone(grid, [0,1,1], [0,1,2], [1,1,2])<br/>    visibility_within_cone(grid, [0,1,1], [1,1,1], [1,1,2])<br/>    return grid &gt;= 0.5</span></pre><p id="0092" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Below are the errors for all three of our 3D rectangular grid neighborhoods applied to the test scenario. The 74-neighbor solution contains the fewest misclassified points.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj qk"><img src="../Images/2cdc619389de8f9fe56d6011a46490ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdHixcpgK1mbExDpB8rGyA.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Classification errors using the 6-neighborhood (left), 26-neighborhood (center), and 74-neighborhood (right). (Image by author)</figcaption></figure><h1 id="baaa" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Triangular 18-Neighborhood</h1><p id="43e8" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">With the 3D rectangular neighborhoods taken care of, it’s time to see what the triangular neighborhoods look like in 3D. They’re surprisingly hard to visualize! A good way to start is by asking the following question:</p><blockquote class="pc"><p id="0217" class="pd pe fq bf pf pg ph pi pj pk pl nw dx">What solid objects have faces that are equilateral triangles, and can be used to fill 3D space?</p></blockquote><p id="649c" class="pw-post-body-paragraph nb nc fq nd b go pm nf ng gr pn ni nj nk po nm nn no pp nq nr ns pq nu nv nw fj bk">Aristotle took a stab at answering that question over 2000 years ago. He famously taught that regular tetrahedra fill space [3]. He was wrong. If you have a whole bunch of regular tetrahedra and try putting them together, you will necessarily end up with gaps. The same can be said for regular octahedra: they also do not fill space. But as shown below, you <strong class="nd fr"><em class="ql">can</em></strong> fill space using <strong class="nd fr"><em class="ql">both</em></strong> tetrahedra and octahedra.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qm"><img src="../Images/f9f13e329e4c69b00575c0456a102498.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*B7sWz8JxKMb-PE-gO3B3gw.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx"><a class="af nx" href="https://commons.wikimedia.org/wiki/File:HC_P1-P3.png" rel="noopener ugc nofollow" target="_blank">Octahedrons (blue) and tetrahedrons (red) filling space</a>, by <a class="af nx" href="https://commons.wikimedia.org/wiki/User:TED-43" rel="noopener ugc nofollow" target="_blank">TED-43</a> on <a class="af nx" href="https://en.wikipedia.org/wiki/Tetrahedral-octahedral_honeycomb" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="8d7a" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">In the space-filling arrangement above, notice that the vertices of the tetrahedra and octahedra occur at regularly spaced points. These are the points of a <strong class="nd fr">face-centered cubic lattice</strong>, which we’ll refer to as a <strong class="nd fr">3D triangular grid</strong>. If one of these points is located at [0, 0, 0], we can scale and orient the 3D triangular grid so that its points coincide with every <strong class="nd fr"><em class="ql">alternate</em></strong> point on a 3D rectangular grid. The plot below shows a 3D triangular grid with this configuration.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ps"><img src="../Images/3ff387818d893a0e70a19e3c14ccb3ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*ZVYLCa1swapi7H8bQyGodw.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">A 3x3x3 slice of a 3D triangular grid. (Image by author)</figcaption></figure><p id="fd7e" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">To represent these grids on a computer, we’ll adopt the same kind of arrays that we employed for 3D rectangular grids. However, in the case of a 3D triangular grid, only half of the array elements will ever get used. An array element at [x, y, z] will be used only if (x + y + z) is an even number. If (x + y + z) is odd, the element will be initialized to 0 and will always remain 0.</p><p id="eb7d" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">We now know how points in a 3D triangular grid can be arranged, but what does a <strong class="nd fr">triangular grid cell</strong> look like in 3D? When I use the term “grid cell”, I’m referring to a space filling shape that is centered on a grid point. In 2D, a triangular grid cell is not a triangle, but rather a hexagon. The <a class="af nx" href="https://www.redblobgames.com/" rel="noopener ugc nofollow" target="_blank">Red Blog Games</a> tutorial on <a class="af nx" href="https://www.redblobgames.com/grids/hexagons/" rel="noopener ugc nofollow" target="_blank">Hexagonal Grids</a> makes this easy to see. It turns out that in 3D, a triangular grid cell is called a <strong class="nd fr">rhombic dodecahedron</strong>. Rhombic dodecahedra fill 3D space.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qn"><img src="../Images/f8336f6f13341ff3cb42b31ca9eb4c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*4RejqbqVxmKDjEGqfqX4UQ.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx"><a class="af nx" href="https://commons.wikimedia.org/wiki/File:Rhombicdodecahedron.jpg" rel="noopener ugc nofollow" target="_blank">Rhombic dodecahedron</a> by <a class="af nx" href="https://en.wikipedia.org/wiki/User:Cyp" rel="noopener ugc nofollow" target="_blank">Cyp</a> on <a class="af nx" href="https://en.wikipedia.org/wiki/Rhombic_dodecahedron" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="d6fc" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The dual of a polyhedron is the shape you get when you replace each face with a vertex and each vertex with a face. The dual of a <strong class="nd fr">rhombic dodecahedron</strong> is called a <strong class="nd fr">cuboctahedron</strong>.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qo"><img src="../Images/90a249fbea0e531c2486bcbc414bf176.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/0*FnMyXQnIjCNSNiIf.jpg"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx"><a class="af nx" href="https://commons.wikimedia.org/wiki/File:Cuboctahedron.jpg" rel="noopener ugc nofollow" target="_blank">Cuboctahedron</a> by <a class="af nx" href="https://en.wikipedia.org/wiki/User:Cyp" rel="noopener ugc nofollow" target="_blank">Cyp</a> on <a class="af nx" href="https://en.wikipedia.org/wiki/Cuboctahedron" rel="noopener ugc nofollow" target="_blank">Wikipedia</a></figcaption></figure><p id="9cee" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">If we center a cuboctahedron on a 3D triangular grid point, we can scale and orient it so that its 12 vertices coincide with the nearest neighboring grid points. In other words, the cuboctahedron is a viable 3D grid neighborhood. I would not consider this 12-neighborhood to be a <strong class="nd fr"><em class="ql">standard</em></strong> 3D grid neighborhood, however, for the simple reason that some its faces are squares rather than triangles. There is a grid-based visibility algorithm from the urban design community that could be adapted to work with the square faces of the 12-neighborhood [4], but we will stick with our current algorithm requiring triangular faces.</p><p id="b197" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The smallest 3D triangular neighborhood that meets our criteria is the <strong class="nd fr">triangular 18-neighborhood</strong>. It appears as an octahedron with each side tessellated into triangles.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qp"><img src="../Images/94986125756c1fc93f346a866d21f56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:634/format:webp/1*ja0PTmea_sj03ltl6M33dA.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The triangular 18-neighborhood. (Image by author)</figcaption></figure><p id="723e" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">If we slice the 18-neighborhood at an angle, we can see that it extends the 2D triangular 6-neighborhood.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qq"><img src="../Images/780f03018e6ec7d9e521833c47129193.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*eTQu0cJhS3GC3yWz1Hfbow.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The 3D 18-neighborhood cut in half to reveal the 2D 6-neighborhood. (Image by author)</figcaption></figure><p id="a86c" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The triangular 18-neighborhood has 32 cones, 4 cones per octant.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ps"><img src="../Images/0148e8b82a3b960add5cca3f0ec545be.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*LJM-xOjO4l03B-yVvSidYw.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Plot of the 4 cones in one octant of the triangular 18-neighborhood. (Image by author)</figcaption></figure><p id="4a6b" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Here’s our 18-neighbor implementation of grid-based visibility.</p><pre class="ml mm mn mo mp py px pz bp qa bb bk"><span id="0d9f" class="qb nz fq px b bg qc qd l qe qf"># Solve the 3D visibility problem using the 18-neighborhood<br/>def grid18_visibility(grid0):<br/>    grid = grid0.copy()<br/>    visibility_within_cone(grid, [2,0,0], [1,1,0], [1,0,1])<br/>    visibility_within_cone(grid, [0,2,0], [1,1,0], [0,1,1])<br/>    visibility_within_cone(grid, [0,0,2], [1,0,1], [0,1,1])<br/>    visibility_within_cone(grid, [1,1,0], [1,0,1], [0,1,1])<br/>    return grid &gt;= 0.5</span></pre><p id="c1b8" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">And here are the results.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qg"><img src="../Images/0d3a398590890cf6e6fd53b29a404dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*BlUYlihRBDqj-LvOKVg_BQ.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Classification errors using the 18-neighborhood. (Image by author)</figcaption></figure><p id="d186" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">At first glance it may seem that the 18-neighborhood has yielded greater accuracy than the three rectangular neighborhoods, even the ones with more neighbors and cones. However, the main reason the red dots are sparser here than in previous plots is because, for 3D triangular grids, we only evaluate every alternate point [x, y, z].</p><h1 id="5e02" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Triangular 50-Neighborhood</h1><p id="e6f4" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">The fifth and final neighborhood in our collection is the <strong class="nd fr">triangular 50-neighborhood</strong>. Its overall shape is known as a stellated octahedron, which is basically an octahedron with a tetrahedron glued onto each face. In the case of the 50-neighborhood, each face of the stellated octahedron is tessellated into 4 triangles, as shown below.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qr"><img src="../Images/ac92c81dc500e7b563c6b875a2d2e215.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*SUsw89JX_LdRoc_empbV1w.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The triangular 50-neighborhood. (Image by author)</figcaption></figure><p id="27ac" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The 50-neighborhood extends the 2D triangular 12-neighborhood.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qr"><img src="../Images/e609b885e180fa601046e14f97af99fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:938/format:webp/1*wbJaATMWvQgZSOr6cZJQlQ.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">The 3D 50-neighborhood cut in half to reveal the 2D 12-neighborhood. (Image by author)</figcaption></figure><p id="78d5" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">It has 96 cones, 12 per octant.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj ps"><img src="../Images/086820635761d7c5fc6a2eb62ef60e7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*B4WexHxFGnENfhms_JFRNw.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Plot of the 12 cones in one octant of the triangular 50-neighborhood. (Image by author)</figcaption></figure><p id="0d75" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">Below is 50-neighbor grid-based visibility.</p><pre class="ml mm mn mo mp py px pz bp qa bb bk"><span id="2f3f" class="qb nz fq px b bg qc qd l qe qf"># Solve the 3D visibility problem using the 50-neighborhood<br/>def grid50_visibility(grid0):<br/>    grid = grid0.copy()<br/>    visibility_within_cone(grid, [2,0,0], [1,1,0], [2,1,1])<br/>    visibility_within_cone(grid, [2,0,0], [1,0,1], [2,1,1])<br/>    visibility_within_cone(grid, [1,1,0], [2,1,1], [2,2,2])<br/>    visibility_within_cone(grid, [1,0,1], [2,1,1], [2,2,2])<br/>    visibility_within_cone(grid, [0,2,0], [1,1,0], [1,2,1])<br/>    visibility_within_cone(grid, [0,2,0], [0,1,1], [1,2,1])<br/>    visibility_within_cone(grid, [1,1,0], [1,2,1], [2,2,2])<br/>    visibility_within_cone(grid, [0,1,1], [1,2,1], [2,2,2])<br/>    visibility_within_cone(grid, [0,0,2], [1,0,1], [1,1,2])<br/>    visibility_within_cone(grid, [0,0,2], [0,1,1], [1,1,2])<br/>    visibility_within_cone(grid, [1,0,1], [1,1,2], [2,2,2])<br/>    visibility_within_cone(grid, [0,1,1], [1,1,2], [2,2,2])<br/>    return grid &gt;= 0.5</span></pre><p id="d21c" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">And finally, here are the results for both of our 3D triangular grid neighborhoods. It may be hard to tell at a glance, but the 50-neighbor results contain fewer errors.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj qj"><img src="../Images/5b298d1761c7f05c869e290ce8e75c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qh5tms86iU3OYineTVY7Ng.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Classification errors using the 18-neighborhood (left) and 50-neighborhood (right). (Image by author)</figcaption></figure><h1 id="2d42" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Comparison of Neighborhoods</h1><p id="ec67" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">The table below lists the five presented 3D grid neighborhoods, their properties, and the accuracy obtained when applying each neighborhood to our test problem. The accuracy values are calculated by taking the number of grid points correctly classified as visible or not visible, and dividing by the total number of evaluated grid points. As we’d expect, the accuracy scores increase with the number of neighbors.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div role="button" tabindex="0" class="mr ms ed mt bh mu"><div class="mi mj qs"><img src="../Images/1362e61553064817460ee59bef9139cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8riCRulZKRIROQFLlCExg.png"/></div></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">List of 3D grid neighborhoods, their properties, and accuracy results. (Image by author)</figcaption></figure><p id="98fb" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">This analysis is mostly for illustrative purposes. If our goal were to perform a rigorous comparison of these five 3D grid neighborhoods, we would not be satisfied with our single test scenario. Instead we would want to apply each neighborhood to a large set of test scenarios, and average the results.</p><p id="deb0" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">I should also point out that in this article and the <a class="af nx" rel="noopener" target="_blank" href="/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78">previous one</a>, I have taken a shortcut both literally and figuratively when implementing grid-based visibility for large neighborhoods. The proper formula, which you can find in the journal paper “<a class="af nx" href="https://www.jair.org/index.php/jair/article/view/13544" rel="noopener ugc nofollow" target="_blank">Path Counting for Grid-Based Navigation</a>” [1], requires a line-of-sight test between every pair of neighboring grid points. To illustrate, consider the following 2D scenario.</p><figure class="ml mm mn mo mp mq mi mj paragraph-image"><div class="mi mj qt"><img src="../Images/1a5e7e7569249bf6ed02e5e3faf23acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*yayD51l0gbvQJHzGrwx8qQ.png"/></div><figcaption class="mw mx my mi mj mz na bf b bg z dx">Two labelled cells on a 2D rectangular grid. (Image by author)</figcaption></figure><p id="bd90" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">If we’re using the 4-neighborhood or the 8-neighborhood, then cells <strong class="nd fr">A</strong> and <strong class="nd fr">B</strong> in the above example are not neighbors. But if we’re using the 16-neighborhood, then these two points <strong class="nd fr"><em class="ql">are</em></strong> neighbors and so we should technically perform a line-of-sight test between them. The algorithms in this article series alleviate the need for line-of-sight checks between distant grid points, though it is still best to precompute these checks over the short distances between neighbors. If we draw a line between the centers of cells <strong class="nd fr">A</strong> and <strong class="nd fr">B</strong>, the line will pass through a blocked cell. This suggests that the visibility algorithm should probably <strong class="nd fr"><em class="ql">not</em></strong> propagate information directly from <strong class="nd fr">A</strong> to <strong class="nd fr">B</strong>.</p><p id="6c95" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">The literal and figurative shortcut I’ve been taking is to assume two neighboring cells are mutually visible as long as they’re both empty. This works perfectly well for the 4-neighborhood in 2D and the 6-neighborhood in 3D, but it isn’t quite right for the larger neighborhoods. In the example above, a 16-neighbor version of my Python code would treat cells <strong class="nd fr">A</strong> and <strong class="nd fr">B</strong> as mutually visible. It would happily propagate information from one to the other, essentially taking a “shortcut” through the obstacle.</p><p id="bfdd" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">This shortcut I’m describing isn’t such a big deal if our obstacles are sufficiently wide compared with the grid spacing. In our test results, the larger 3D neighborhoods achieved greater accuracy than the smaller ones despite this flaw. But if you plan to use large 2D or 3D grid neighborhoods in your own work, I encourage you to carefully consider which neighboring grid points should and should not be treated as direct pathways for information.</p><h1 id="d6f7" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Testing and Visualization Code</h1><p id="b677" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">Please skip this section and <a class="af nx" href="#6036" rel="noopener ugc nofollow">proceed to the conclusion</a> if you are <strong class="nd fr"><em class="ql">not</em></strong> interested in running the Python code presented in this article.</p><p id="9b43" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">If you <strong class="nd fr"><em class="ql">are</em></strong> interested in running the code, follow these steps:</p><ol class=""><li id="b259" class="nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw qu qv qw bk">Make sure you have Python installed along with the NumPy and Matplotlib libraries.</li><li id="69af" class="nb nc fq nd b go qx nf ng gr qy ni nj nk qz nm nn no ra nq nr ns rb nu nv nw qu qv qw bk">Create an empty text file named <code class="cx pu pv pw px b">grid_visibility_3D.py</code>. Starting from the top, copy into this text file all of the code blocks that have appeared in this article until this point.</li><li id="20b3" class="nb nc fq nd b go qx nf ng gr qy ni nj nk qz nm nn no ra nq nr ns rb nu nv nw qu qv qw bk">Create another text file named <code class="cx pu pv pw px b">test_grid_visibility_3D.py</code> and copy in the long code block that appears below these instructions.</li><li id="fa40" class="nb nc fq nd b go qx nf ng gr qy ni nj nk qz nm nn no ra nq nr ns rb nu nv nw qu qv qw bk">On the command prompt, run <code class="cx pu pv pw px b">python test_grid_visibility_3D.py</code>. You should see the same accuracy scores that were reported in the <a class="af nx" href="#2d42" rel="noopener ugc nofollow">Comparison of Neighborhoods</a> table. You should also see a 3D visualization of the test scenario.</li><li id="9400" class="nb nc fq nd b go qx nf ng gr qy ni nj nk qz nm nn no ra nq nr ns rb nu nv nw qu qv qw bk">Close the visualization window and run the command <code class="cx pu pv pw px b">python test_grid_visibility_3D.py 6</code>. You should see the same output except with red dots appearing in the 3D visualization. You can drag the cursor on the plot to rotate it and get a better view. These dots are the errors associated with the 6-neighbor visibility algorithm. Run the code again with the command line argument <code class="cx pu pv pw px b">6</code> changed to <code class="cx pu pv pw px b">18</code>, <code class="cx pu pv pw px b">26</code>, <code class="cx pu pv pw px b">50</code>, or <code class="cx pu pv pw px b">74</code> to see the errors associated with the other 3D grid neighborhoods.</li></ol><pre class="ml mm mn mo mp py px pz bp qa bb bk"><span id="7717" class="qb nz fq px b bg qc qd l qe qf">from grid_visibility_3D import *<br/><br/>import matplotlib.pyplot as plt<br/>import sys<br/><br/># Set dimensions for the test scenario<br/>nx = 40<br/>ny = 40<br/>nz = 40<br/><br/># Set spherical obstacle parameters for the test scenario<br/>x_sphere = 10<br/>y_sphere = 20<br/>z_sphere = 16<br/>r_sphere = 8<br/><br/># Initialize the 3D visibility problem for the test scenario <br/>def initial_grid():<br/>    grid = np.ones((nx,ny,nz))<br/>    p_sphere = np.array([x_sphere, y_sphere, z_sphere])<br/>    for x in range(nx):<br/>        for y in range(ny):<br/>            for z in range(nz):<br/>                p = np.array([x,y,z])<br/>                r = np.sqrt(np.sum((p - p_sphere)**2))<br/>                if r &lt; r_sphere:<br/>                    grid[x,y,z] = 0<br/>    return grid<br/><br/># Solve the 3D visibility problem analytically for the test scenario<br/>def analytic_solution():<br/>    grid = initial_grid()<br/>    p_sphere = np.array([x_sphere, y_sphere, z_sphere])<br/>    d_sphere = np.sqrt(np.sum(p_sphere**2))<br/>    u = p_sphere/d_sphere<br/>    for x in range(nx):<br/>        for y in range(ny):<br/>            for z in range(nz):<br/>                if grid[x,y,z]:<br/>                    p = np.array([x,y,z])<br/>                    d = np.sum(p*u)<br/>                    if d &gt; d_sphere:<br/>                        h = np.sqrt(np.sum((p - d*u)**2))<br/>                        grid[x,y,z] = h*d_sphere &gt;= d*r_sphere<br/>    return grid<br/><br/># Compare the 3D grid-based results to the analytic solution<br/>def evaluate_grid(test_name, grid, solution, triangular=False):<br/>    error_grid = np.abs(grid - solution)<br/>    total_count = nx*ny*nz<br/>    if triangular:<br/>        for x in range(nx):<br/>            for y in range(ny):<br/>                for z in range(nz):<br/>                    if (x + y + z)%2 == 1:<br/>                        error_grid[x,y,z] = 0<br/>                        total_count -= 1 <br/>    error_count = int(np.sum(error_grid))<br/>    accuracy = 100*(1 - error_count/total_count)<br/>    print(test_name + " accuracy: %.3f" % accuracy)<br/>    return error_grid<br/><br/># Plot the 3D visibility problem with or without resulting errors<br/>def plot_test_scenario(error_grid=None, obstacle=True, pretty=True):<br/>    elevation = 19<br/>    azimuth = 33<br/>    ax = plt.figure().add_subplot(projection='3d')<br/>    ax.view_init(elev=elevation, azim=azimuth, roll=0)<br/>    ax.set_aspect('equal')<br/>    ax.set_xlabel('X')<br/>    ax.set_ylabel('Y')<br/>    ax.set_zlabel('Z')<br/>    ax.scatter(0, 0, 0, color='#6A22C2', s=64)  # Render viewpoint<br/>    if pretty:<br/>        # Choose limits that avoid padding <br/>        ax.set_xlim(0.9, nx - 0.9)<br/>        ax.set_ylim(0.9, ny - 0.9)<br/>        ax.set_zlim(0.9, nz - 0.9)<br/>        # Ensure axes are prominently displayed <br/>        ax.plot([0,nx], [0,0], [0,0], color='gray', linewidth=2)<br/>        ax.plot([0,nx], [ny,ny], [0,0], color='black', linewidth=1)<br/>        ax.plot([0,nx], [0, 0], [nz,nz], color='black', linewidth=1)<br/>        ax.plot([0,0], [0,ny], [0,0], color='gray', linewidth=2)<br/>        ax.plot([nx,nx], [0,ny], [0,0], color='black', linewidth=1)<br/>        ax.plot([0,0], [0,ny], [nz,nz], color='black', linewidth=1)<br/>        ax.plot([0,0], [0,0], [0,nz], color='gray', linewidth=2)<br/>        ax.plot([0,0], [ny,ny], [0,nz], color='black', linewidth=1)<br/>        ax.plot([nx,nx], [0,0], [0,nz], color='black', linewidth=1)<br/>    else:<br/>        ax.set_xlim(0, nx)<br/>        ax.set_ylim(0, ny)<br/>        ax.set_zlim(0, nz)<br/>    if obstacle:<br/>        n = 100<br/>        us = np.linspace(0, 2*np.pi, n)<br/>        vs = np.linspace(0, np.pi, n)<br/>        xs = r_sphere*np.outer(np.cos(us), np.sin(vs)) + x_sphere<br/>        ys = r_sphere*np.outer(np.sin(us), np.sin(vs)) + y_sphere<br/>        zs = r_sphere*np.outer(np.ones(n), np.cos(vs)) + z_sphere<br/>        ax.plot_surface(xs, ys, zs, color='lightgray')<br/>    if np.all(error_grid) != None:<br/>        error_count = int(np.sum(error_grid))<br/>        xs = np.zeros(error_count)<br/>        ys = np.zeros(error_count)<br/>        zs = np.zeros(error_count)<br/>        i = 0<br/>        for x in range(nx):<br/>            for y in range(ny):<br/>                for z in range(nz):<br/>                    if error_grid[x,y,z]:<br/>                        xs[i] = x<br/>                        ys[i] = y<br/>                        zs[i] = z<br/>                        i += 1<br/>        ax.scatter(xs, ys, zs, color='red')<br/>    plt.show()<br/><br/>if __name__ == "__main__":<br/>    # Compute the grid-based solutions<br/>    grid0 = initial_grid()<br/>    grid = grid_visibility(grid0)<br/>    grid6 = grid6_visibility(grid0)<br/>    grid18 = grid18_visibility(grid0)<br/>    grid26 = grid26_visibility(grid0)<br/>    grid50 = grid50_visibility(grid0)<br/>    grid74 = grid74_visibility(grid0)<br/>    # Ensure that 6-neighbor solutions are identical<br/>    if np.any(grid != grid6):<br/>        print("Warning: Alternative 6-neighbor solutions differ")<br/>    # Compute the analytic solution<br/>    solution = analytic_solution()<br/>    # Compute the errors and report accuracy<br/>    error_grid6 = evaluate_grid(' 6-neighbor', grid6, solution)<br/>    error_grid18 = evaluate_grid('18-neighbor', grid18, solution, True)<br/>    error_grid26 = evaluate_grid('26-neighbor', grid26, solution)<br/>    error_grid50 = evaluate_grid('50-neighbor', grid50, solution, True)<br/>    error_grid74 = evaluate_grid('74-neighbor', grid74, solution)<br/>    # Plot the results<br/>    error_grid = None<br/>    if len(sys.argv) &gt;= 2:<br/>        if sys.argv[1] == "6":<br/>            error_grid = error_grid6<br/>        elif sys.argv[1] == "18":<br/>            error_grid = error_grid18<br/>        elif sys.argv[1] == "26":<br/>            error_grid = error_grid26<br/>        elif sys.argv[1] == "50":<br/>            error_grid = error_grid50<br/>        elif sys.argv[1] == "74":<br/>            error_grid = error_grid74<br/>    plot_test_scenario(error_grid)</span></pre><h1 id="6036" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">Conclusion</h1><p id="d409" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">Thank you for reading my articles on pathfinding and visibility in both 2D and 3D. I hope this series has expanded your view of what can be done using simple grid-based algorithms. By counting paths (see <a class="af nx" rel="noopener" target="_blank" href="/a-short-and-direct-walk-with-pascals-triangle-26a86d76f75f">part 1</a>), employing linear interpolation (see <a class="af nx" rel="noopener" target="_blank" href="/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78">part 2</a>), selecting a larger grid neighborhood (as in this article — part 3), or simply choosing a finer grid resolution, we can overcome the perceived limitations of grids and achieve highly satisfactory results. The next time you encounter an AI problem that is usually tackled with brute force ray casting or cumbersome analytic calculations, remember what you can accomplish with a grid-based method and your neighborhood of choice.</p><h1 id="c012" class="ny nz fq bf oa ob oc gq od oe of gt og oh oi oj ok ol om on oo op oq or os ot bk">References</h1><p id="4b71" class="pw-post-body-paragraph nb nc fq nd b go ou nf ng gr ov ni nj nk ow nm nn no ox nq nr ns oy nu nv nw fj bk">[1] R. Goldstein, K. Walmsley, J. Bibliowicz, A. Tessier, S. Breslav, A. Khan, <a class="af nx" href="https://www.jair.org/index.php/jair/article/view/13544" rel="noopener ugc nofollow" target="_blank">Path Counting for Grid-Based Navigation</a> (2022), Journal of Artificial Intelligence Research, vol. 74, pp. 917–955</p><p id="d856" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">[2] T. K. Nobes, D. D. Harabor, M. Wybrow, S. D. C. Walsh, <a class="af nx" href="https://ojs.aaai.org/index.php/SOCS/article/view/21762" rel="noopener ugc nofollow" target="_blank">The Jump Point Search Pathfinding System in 3D</a> (2022), Proceedings of the International Symposium on Combinatorial Search (SoCS)</p><p id="ae3f" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">[3] C. L. Jeffrey, C. Zong, <a class="af nx" href="https://www.ams.org/journals/notices/201211/rtx121101540p.pdf" rel="noopener ugc nofollow" target="_blank">Mysteries in Packing Regular Tetrahedra</a> (2012), Notices of the American Mathematical Society, vol. 59, no. 11, pp. 1540–1549</p><p id="4700" class="pw-post-body-paragraph nb nc fq nd b go ne nf ng gr nh ni nj nk nl nm nn no np nq nr ns nt nu nv nw fj bk">[4] D. Fisher-Gewirtzman, A. Shashkov, Y. Doytsher, <a class="af nx" href="https://www.tandfonline.com/doi/abs/10.1179/1752270613Y.0000000059" rel="noopener ugc nofollow" target="_blank">Voxel Based Volumetric Visibility Analysis of Urban Environments</a> (2013), Survey Review, vol. 45, no. 333, pp. 451–461</p></div></div></div></div>    
</body>
</html>
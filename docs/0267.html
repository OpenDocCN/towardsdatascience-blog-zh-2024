<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Cypher Generation: The Good, The Bad and The Messy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Cypher Generation: The Good, The Bad and The Messy</h1>
<blockquote>原文：<a href="https://towardsdatascience.com/cypher-generation-the-good-the-bad-and-the-messy-4ec119dd72ea?source=collection_archive---------6-----------------------#2024-01-29">https://towardsdatascience.com/cypher-generation-the-good-the-bad-and-the-messy-4ec119dd72ea?source=collection_archive---------6-----------------------#2024-01-29</a></blockquote><div><div class="em fe ff fg fh fi"/><div class="fj fk fl fm fn"><div class="ab cb"><div class="ci bh ev ew ex ey"><div/><div><h2 id="8614" class="pw-subtitle-paragraph gn fp fq bf b go gp gq gr gs gt gu gv gw gx gy gz ha hb hc cq dx"><em class="hd">Methods for creating fine-tuning datasets for text-to-Cypher generation.</em></h2><div><div class="speechify-ignore ab cp"><div class="speechify-ignore bh l"><div class="he hf hg hh hi ab"><div><div class="ab hj"><div><div class="bm" aria-hidden="false"><a href="https://medium.com/@silviaonofrei?source=post_page---byline--4ec119dd72ea--------------------------------" rel="noopener follow"><div class="l hk hl by hm hn"><div class="l ed"><img alt="Silvia Onofrei" class="l ep by dd de cx" src="../Images/198b04b2063b4269eaff52402dc5f8d5.png" width="44" height="44" loading="lazy" data-testid="authorPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:88:88/1*sMBSQ7O4JfKYt-L7TGmlIQ.jpeg"/><div class="ho by l dd de em n hp eo"/></div></div></a></div></div><div class="hq ab ed"><div><div class="bm" aria-hidden="false"><a href="https://towardsdatascience.com/?source=post_page---byline--4ec119dd72ea--------------------------------" rel="noopener follow"><div class="l hr hs by hm ht"><div class="l ed"><img alt="Towards Data Science" class="l ep by br hu cx" src="../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png" width="24" height="24" loading="lazy" data-testid="publicationPhoto" data-original-src="https://miro.medium.com/v2/resize:fill:48:48/1*CJe3891yB1A1mzMdqemkdg.jpeg"/><div class="ho by l br hu em n hp eo"/></div></div></a></div></div></div></div></div><div class="bn bh l"><div class="ab"><div style="flex:1"><span class="bf b bg z bk"><div class="hv ab q"><div class="ab q hw"><div class="ab q"><div><div class="bm" aria-hidden="false"><p class="bf b hx hy bk"><a class="af ag ah ai aj ak al am an ao ap aq ar hz" data-testid="authorName" href="https://medium.com/@silviaonofrei?source=post_page---byline--4ec119dd72ea--------------------------------" rel="noopener follow">Silvia Onofrei</a></p></div></div></div><span class="ia ib" aria-hidden="true"><span class="bf b bg z dx">·</span></span><p class="bf b hx hy dx"><button class="ic id ah ai aj ak al am an ao ap aq ar ie if ig" disabled="">Follow</button></p></div></div></span></div></div><div class="l ih"><span class="bf b bg z dx"><div class="ab cn ii ij ik"><div class="il im ab"><div class="bf b bg z dx ab in"><span class="io l ih">Published in</span><div><div class="l" aria-hidden="false"><a class="af ag ah ai aj ak al am an ao ap aq ar hz ab q" data-testid="publicationName" href="https://towardsdatascience.com/?source=post_page---byline--4ec119dd72ea--------------------------------" rel="noopener follow"><p class="bf b bg z ip iq ir is it iu iv iw bk">Towards Data Science</p></a></div></div></div><div class="h k"><span class="ia ib" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div></div><span class="bf b bg z dx"><div class="ab ae"><span data-testid="storyReadTime">13 min read</span><div class="ix iy l" aria-hidden="true"><span class="l" aria-hidden="true"><span class="bf b bg z dx">·</span></span></div><span data-testid="storyPublishDate">Jan 29, 2024</span></div></span></div></span></div></div></div><div class="ab cp iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo"><div class="h k w ea eb q"><div class="ke l"><div class="ab q kf kg"><div class="pw-multi-vote-icon ed io kh ki kj"><div class=""><div class="kk kl km kn ko kp kq am kr ks kt kj"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" aria-label="clap"><path fill-rule="evenodd" d="M11.37.828 12 3.282l.63-2.454zM15.421 1.84l-1.185-.388-.338 2.5zM9.757 1.452l-1.184.389 1.523 2.112zM20.253 11.84 17.75 7.438c-.238-.353-.57-.584-.93-.643a.96.96 0 0 0-.753.183 1.13 1.13 0 0 0-.443.695c.014.019.03.033.044.053l2.352 4.138c1.614 2.95 1.1 5.771-1.525 8.395a7 7 0 0 1-.454.415c.997-.13 1.927-.61 2.773-1.457 2.705-2.704 2.517-5.585 1.438-7.377M12.066 9.01c-.129-.687.08-1.299.573-1.773l-2.062-2.063a1.123 1.123 0 0 0-1.555 0 1.1 1.1 0 0 0-.273.521z" clip-rule="evenodd"/><path fill-rule="evenodd" d="M14.741 8.309c-.18-.267-.446-.455-.728-.502a.67.67 0 0 0-.533.127c-.146.113-.59.458-.199 1.296l1.184 2.503a.448.448 0 0 1-.236.755.445.445 0 0 1-.483-.248L7.614 6.106A.816.816 0 1 0 6.459 7.26l3.643 3.644a.446.446 0 1 1-.631.63L5.83 7.896l-1.03-1.03a.82.82 0 0 0-1.395.577.81.81 0 0 0 .24.576l1.027 1.028 3.643 3.643a.444.444 0 0 1-.144.728.44.44 0 0 1-.486-.098l-3.64-3.64a.82.82 0 0 0-1.335.263.81.81 0 0 0 .178.89l1.535 1.534 2.287 2.288a.445.445 0 0 1-.63.63l-2.287-2.288a.813.813 0 0 0-1.393.578c0 .216.086.424.238.577l4.403 4.403c2.79 2.79 5.495 4.119 8.681.931 2.269-2.271 2.708-4.588 1.342-7.086z" clip-rule="evenodd"/></svg></div></div></div><div class="pw-multi-vote-count l ku kv kw kx ky kz la"><p class="bf b dy z dx"><span class="kl">--</span></p></div></div></div><div><div class="bm" aria-hidden="false"><button class="ao kk lb lc ab q ee ld le" aria-label="responses"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" class="lf"><path d="M18.006 16.803c1.533-1.456 2.234-3.325 2.234-5.321C20.24 7.357 16.709 4 12.191 4S4 7.357 4 11.482c0 4.126 3.674 7.482 8.191 7.482.817 0 1.622-.111 2.393-.327.231.2.48.391.744.559 1.06.693 2.203 1.044 3.399 1.044.224-.008.4-.112.486-.287a.49.49 0 0 0-.042-.518c-.495-.67-.845-1.364-1.04-2.057a4 4 0 0 1-.125-.598zm-3.122 1.055-.067-.223-.315.096a8 8 0 0 1-2.311.338c-4.023 0-7.292-2.955-7.292-6.587 0-3.633 3.269-6.588 7.292-6.588 4.014 0 7.112 2.958 7.112 6.593 0 1.794-.608 3.469-2.027 4.72l-.195.168v.255c0 .056 0 .151.016.295.025.231.081.478.154.733.154.558.398 1.117.722 1.659a5.3 5.3 0 0 1-2.165-.845c-.276-.176-.714-.383-.941-.59z"/></svg></button></div></div></div><div class="ab q jp jq jr js jt ju jv jw jx jy jz ka kb kc kd"><div class="lg k j i d"/><div class="h k"><div><div class="bm" aria-hidden="false"><button aria-controls="addToCatalogBookmarkButton" aria-expanded="false" aria-label="Add to list bookmark button" data-testid="headerBookmarkButton" class="af ee ah ai aj ak al lh an ao ap ie li lj lk" disabled=""><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24" class="av"><path fill="#000" d="M17.5 1.25a.5.5 0 0 1 1 0v2.5H21a.5.5 0 0 1 0 1h-2.5v2.5a.5.5 0 0 1-1 0v-2.5H15a.5.5 0 0 1 0-1h2.5zm-11 4.5a1 1 0 0 1 1-1H11a.5.5 0 0 0 0-1H7.5a2 2 0 0 0-2 2v14a.5.5 0 0 0 .8.4l5.7-4.4 5.7 4.4a.5.5 0 0 0 .8-.4v-8.5a.5.5 0 0 0-1 0v7.48l-5.2-4a.5.5 0 0 0-.6 0l-5.2 4z"/></svg></button></div></div></div><div class="ep ll cn"><div class="l ae"><div class="ab cb"><div class="lm ln lo lp lq lr ci bh"><div class="ab"><div class="bm bh" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="Listen" data-testid="audioPlayButton" class="af ee ah ai aj ak al lh an ao ap ie ls lt le lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M3 12a9 9 0 1 1 18 0 9 9 0 0 1-18 0m9-10C6.477 2 2 6.477 2 12s4.477 10 10 10 10-4.477 10-10S17.523 2 12 2m3.376 10.416-4.599 3.066a.5.5 0 0 1-.777-.416V8.934a.5.5 0 0 1 .777-.416l4.599 3.066a.5.5 0 0 1 0 .832" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Listen</p></div></button></div></div></div></div></div></div></div></div><div class="bm" aria-hidden="false" aria-describedby="postFooterSocialMenu" aria-labelledby="postFooterSocialMenu"><div><div class="bm" aria-hidden="false"><button aria-controls="postFooterSocialMenu" aria-expanded="false" aria-label="Share Post" data-testid="headerSocialShareButton" class="af ee ah ai aj ak al lh an ao ap ie ls lt le lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M15.218 4.931a.4.4 0 0 1-.118.132l.012.006a.45.45 0 0 1-.292.074.5.5 0 0 1-.3-.13l-2.02-2.02v7.07c0 .28-.23.5-.5.5s-.5-.22-.5-.5v-7.04l-2 2a.45.45 0 0 1-.57.04h-.02a.4.4 0 0 1-.16-.3.4.4 0 0 1 .1-.32l2.8-2.8a.5.5 0 0 1 .7 0l2.8 2.79a.42.42 0 0 1 .068.498m-.106.138.008.004v-.01zM16 7.063h1.5a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-11c-1.1 0-2-.9-2-2v-10a2 2 0 0 1 2-2H8a.5.5 0 0 1 .35.15.5.5 0 0 1 .15.35.5.5 0 0 1-.15.35.5.5 0 0 1-.35.15H6.4c-.5 0-.9.4-.9.9v10.2a.9.9 0 0 0 .9.9h11.2c.5 0 .9-.4.9-.9v-10.2c0-.5-.4-.9-.9-.9H16a.5.5 0 0 1 0-1" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">Share</p></div></button></div></div></div><div class="bm" aria-hidden="false"><div><div class="bm" aria-hidden="false"><button aria-label="More options" data-testid="headerStoryOptionsButton" class="af ee ah ai aj ak al lh an ao ap ie ls lt le lu lv lw lx ly s lz ma mb mc md me mf u mg mh mi"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewbox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M4.385 12c0 .55.2 1.02.59 1.41.39.4.86.59 1.41.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.02.2-1.41.59-.4.39-.59.86-.59 1.41m5.62 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.42.59s1.02-.2 1.41-.59c.4-.39.59-.86.59-1.41s-.2-1.02-.59-1.41a1.93 1.93 0 0 0-1.41-.59c-.55 0-1.03.2-1.42.59s-.58.86-.58 1.41m5.6 0c0 .55.2 1.02.58 1.41.4.4.87.59 1.43.59s1.03-.2 1.42-.59.58-.86.58-1.41-.2-1.02-.58-1.41a1.93 1.93 0 0 0-1.42-.59c-.56 0-1.04.2-1.43.59s-.58.86-.58 1.41" clip-rule="evenodd"/></svg><div class="j i d"><p class="bf b bg z dx">More</p></div></button></div></div></div></div></div></div></div></div></div><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk ml"><img src="../Images/ad8b418ba27894f9c93e3debc77b318b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X86KURPzmdjS4DpspAo-eQ.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Created with ChatGPT-DALLE</figcaption></figure><h1 id="de1d" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Introduction</h1><p id="3b6c" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Cypher is Neo4j’s graph query language. It was inspired and bears similarities with SQL, enabling data retrieval from knowledge graphs. Given the rise of generative AI and the widespread availability of large language models (LLMs), it is natural to ask which LLMs are capable of generating Cypher queries or how we can finetune our own model to generate Cypher from the text.</p><p id="f0f9" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The issue presents considerable challenges, primarily due to the scarcity of fine-tuning datasets and, in my opinion, because such a dataset would significantly rely on the specific graph schema.</p><p id="3288" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In this blog post, I will discuss several approaches for creating a fine-tuning dataset aimed at generating Cypher queries from text. The initial approach is grounded in Large Language Models (LLMs) and utilizes a predefined graph schema. The second strategy, rooted entirely in Python, offers a versatile means to produce a vast array of questions and Cypher queries, adaptable to any graph schema. For experimentation I created a knowledge graph that is based on a subset of the ArXiv dataset.</p><p id="d2c2" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">As I was finalizing this blogpost, Tomaz Bratanic launched an <a class="af oz" href="https://medium.com/@bratanic-tomaz/crowdsourcing-text2cypher-dataset-e65ba51916d4" rel="noopener">initiative project</a> aimed at developing a comprehensive fine-tuning dataset that encompasses various graph schemas and integrates a human-in-the-loop approach to generate and validate Cypher statements. I hope that the insights discussed here will also be advantageous to the project.</p><h1 id="0759" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Knowledge Graph Model</h1><p id="9818" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">I like working with the ArXiv dataset of scientific articles because of its clean, easy-to-integrate format for a knowledge graph. Utilizing techniques from my recent <a class="af oz" href="https://medium.com/towards-data-science/leverage-keybert-hdbscan-and-zephyr-7b-beta-to-build-a-knowledge-graph-33d7534ee01b" rel="noopener">Medium blogpost</a>, I enhanced this dataset with additional keywords and clusters. Since my primary focus is on building a fine-tuning dataset, I’ll omit the specifics of constructing this graph. For those interested, details can be found in this<a class="af oz" href="https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator" rel="noopener ugc nofollow" target="_blank"> Github repository.</a></p><p id="b4de" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The graph is of a reasonable size, featuring over 38K nodes and almost 96K relationships, with 9 node labels and 8 relationship types. Its schema is illustrated in the following image:</p><figure class="mm mn mo mp mq mr mj mk paragraph-image"><div role="button" tabindex="0" class="ms mt ed mu bh mv"><div class="mj mk pa"><img src="../Images/9d2e0017b08013546e0efeae020a78c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YH_HtzP619-XpxHqcPLL0g.png"/></div></div><figcaption class="mx my mz mj mk na nb bf b bg z dx">Image by the Author</figcaption></figure><p id="a22d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">While this knowledge graph isn’t fully optimized and could be improved, it serves the purposes of this blogpost quite effectively. If you prefer to just test queries without building the graph, I uploaded the dump file in this <a class="af oz" href="https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator" rel="noopener ugc nofollow" target="_blank">Github repository</a>.</p><h1 id="2a1a" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Generating Training Pairs with LLM</h1><p id="404f" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">The first approach I implemented was inspired by Tomaz Bratanic’s blogposts on <a class="af oz" href="https://medium.com/neo4j/knowledge-graph-based-chatbot-with-gpt-3-and-neo4j-c4ebbd325ed" rel="noopener">building a knowledge graph chatbot</a> and <a class="af oz" rel="noopener" target="_blank" href="/fine-tuning-an-llm-model-with-h2o-llm-studio-to-generate-cypher-statements-3f34822ad5">finetuning a LLM with H2O Studio</a>. Initially, a selection of sample queries was provided in the prompt. However, some of the recent models have enhanced capability to generate Cypher queries directly from the graph schema. Therefore, in addition to GPT-4 or GPT-4-turbo, there are now accessible open source alternatives such as Mixtral-8x7B I anticipate could effectively generate decent quality training data.</p><p id="0de9" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In this project, I experimented with two models. For the sake of convenience, I decided to use GPT-4-turbo in conjunction with ChatGPT, see this<a class="af oz" href="https://github.com/SolanaO/Blogs_Content/blob/master/cypher_generator/4_ArXiv_KG_Synthetic_Data_OpenAI.ipynb" rel="noopener ugc nofollow" target="_blank"> Colab Notebook</a>. However, in this <a class="af oz" href="https://github.com/SolanaO/Blogs_Content/blob/master/cypher_generator/5_ArXiv_KG_Synthetic_Data_Mixtral.ipynb" rel="noopener ugc nofollow" target="_blank">notebook</a> I performed a few tests with Mixtral-7x2B-GPTQ, a quantized model that is small enough to run on Google Colab, and which delivers satisfactory results.</p><p id="e567" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">To maintain data diversity and effectively monitor the generated questions, Cypher statements pairs, I have adopted a two steps approach:</p><ul class=""><li id="0007" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">Step 1: provide the full schema to the LLM and request it to generate 10–15 different categories of potential questions related to the graph, along with their descriptions,</li><li id="b192" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">Step 2: provide schema information and instruct the LLM to create a specific number N of training pairs for each identified category.</li></ul><h2 id="633e" class="pj nd fq bf ne pk pl pm nh pn po pp nk oh pq pr ps ol pt pu pv op pw px py pz bk">Extract the categories of samples:</h2><p id="f6e2" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">For this step I used ChatGPT Pro version, although I did iterate through the prompt several times, combined and enhanced the outputs.</p><ul class=""><li id="99e0" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">Extract a schema of the graph as a string (more about this in the next section).</li><li id="2b3e" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">Build a prompt to generate the categories:</li></ul><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="dd58" class="qe nd fq qb b bg qf qg l qh qi">chatgpt_categories_prompt = f"""<br/>You are an experienced and useful Python and Neo4j/Cypher developer.<br/><br/>I have a knowledge graph for which I would like to generate <br/>interesting questions which span 12 categories (or types) about the graph. <br/>They should cover single nodes questions,<br/>two or three more nodes, relationships and paths. Please suggest 12<br/>categories together with their short descriptions. <br/>Here is the graph schema:<br/>{schema}<br/> """</span></pre><ul class=""><li id="1eba" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">Ask the LLM to generate the categories.</li><li id="1b26" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">Review, make corrections and enhance the categories as needed. Here is a sample:</li></ul><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="f9e2" class="qe nd fq qb b bg qf qg l qh qi">'''Authorship and Collaboration: Questions about co-authorship and collaboration patterns.<br/>For example, "Which authors have co-authored articles the most?"''',<br/>'''Article-Author Connections: Questions about the relationships between articles and authors,<br/>such as finding articles written by a specific author or authors of a particular article.<br/>For example, "Find all the authors of the article with tile 'Explorations of manifolds'"''',<br/>'''Pathfinding and Connectivity: Questions that involve paths between multiple nodes,<br/>such as tracing the relationship path from an article to a topic through keywords, <br/>or from an author to a journal through their articles.<br/>For example, "How is the author 'John Doe' connected to the journal 'Nature'?"'''</span></pre><p id="7b77" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">💡<strong class="oa fr">Tips</strong>💡</p><ul class=""><li id="fb81" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk"><em class="qj">If the graph schema is very large, split it into overlapping subgraphs (this depends on the graph topology also) and repeat the abov</em>e process for each subgraph.</li><li id="e456" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk"><em class="qj">When working with open source models, choose the best model you can fit on your computational resources. </em><a class="af oz" href="https://huggingface.co/TheBloke" rel="noopener ugc nofollow" target="_blank"><em class="qj">TheBloke</em></a><em class="qj"> has posted an extensive list of quantized models, </em><a class="af oz" href="https://neo4j.com/emil/introducing-genai-stack-developers/" rel="noopener ugc nofollow" target="_blank"><em class="qj">Neo4j GenAI</em></a><em class="qj"> provides tools to work on your own hardware and </em><a class="af oz" href="https://lightning.ai/onboarding" rel="noopener ugc nofollow" target="_blank"><em class="qj">LightningAI Studio</em></a><em class="qj"> is a recently released platform which gives you access to a multitude of LLMs.</em></li></ul><h2 id="f2f3" class="pj nd fq bf ne pk pl pm nh pn po pp nk oh pq pr ps ol pt pu pv op pw px py pz bk">Generate the training pairs:</h2><p id="5bb5" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">This step was performed with OpenAI API, working with GPT-4-turbo which also has the option to output JSON format. Again the schema of the graph is provided with the prompt:</p><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="25e2" class="qe nd fq qb b bg qf qg l qh qi">def create_prompt(schema, category):<br/>    """Build and format the prompt."""<br/>    formatted_prompt = [<br/>        {"role": "system",<br/>        "content": "You are an experienced Cypher developer and a <br/>helpful assistant designed to output JSON!"},<br/>        {"role": "user",<br/>         "content": f"""Generate 40 questions and their corresponding <br/>Cypher statements about the Neo4j graph database with <br/>the following schema:<br/>        {schema}<br/>        The questions should cover {category} and should be phrased <br/>in a natural conversational manner. Make the questions diverse <br/>and interesting.<br/>        Make sure to use the latest Cypher version and that all<br/> the queries are working Cypher queries for the provided graph. <br/>You may add values for the node attributes as needed. <br/>Do not add any comments, do not label or number the questions.<br/>        """}]<br/>    return formatted_prompt</span></pre><p id="2747" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Build the function which will prompt the model and will retrieve the output:</p><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="87c6" class="qe nd fq qb b bg qf qg l qh qi">def prompt_model(messages):<br/>    """Function to produce and extract model's generation."""<br/>    response = client.chat.completions.create(<br/>        model="gpt-4-1106-preview", # work with gpt-4-turbo<br/>        response_format={"type": "json_object"},<br/>        messages=messages)<br/>    return response.choices[0].message.content</span></pre><p id="0390" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Loop through the categories and collect the outputs in a list:</p><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="d2e9" class="qe nd fq qb b bg qf qg l qh qi">def build_synthetic_data(schema, categories):<br/>    """Function to loop through the categories and generate data."""<br/><br/>    # List to collect all outputs<br/>    full_output=[]<br/>    for category in categories:<br/>        # Prompt the model and retrieve the generated answer<br/>        output = [prompt_model(create_prompt(schema, category))]<br/>        # Store all the outputs in a list<br/>        full_output += output<br/>    return full_output<br/><br/># Generate 40 pairs for each of the categories<br/>full_output = build_synthetic_data(schema, categories)<br/><br/># Save the outputs to a file<br/>write_json(full_output, data_path + synthetic_data_file)</span></pre><p id="4122" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">At this point in the project I collected almost 500 pairs of questions, Cypher statements. Here is a sample:</p><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="816a" class="qe nd fq qb b bg qf qg l qh qi">{"Question": "What articles have been written by 'John Doe'?",<br/>"Cypher": "MATCH (a:Author {first_name:'John', last_name:'Doe'})-<br/>[:WRITTEN_BY]-(article:Article) RETURN article.title, article.article_id;"}</span></pre><p id="7064" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The data requires significant cleaning and wrangling. While not overly complex, the process is both time-consuming and tedious. Here are several of the challenges I encountered:</p><ul class=""><li id="6a27" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">non-JSON entries due to incomplete Cypher statements;</li><li id="2b39" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">the expected format is {’question’: ‘some question’, ‘cypher’:’some cypher’}, but deviations are frequent and need to be standardized;</li><li id="bf0e" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">instances where the questions and the Cypher statements are clustered together, necessiting their separation and organization.</li></ul><p id="897d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">💡<strong class="oa fr">Tip</strong>💡</p><p id="8619" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="qj">It is better to iterate through variations of the prompt than trying to find the best prompt format from the beginning. In my experience, even with diligent adjustments, generating a large volume of data like this inevitably leads to some deviations.</em></p><p id="97ce" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Now regarding the content. GPT-4-turbo is quite capable to generate good questions about the graph, however not all the Cypher statements are valid (working Cypher) and correct (extract the intended information). When fine-tuning in a production environment, I would either rectify or eliminate these erroneous statements.</p><p id="78d9" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">I created a function <code class="cx qk ql qm qb b">execute_cypher_queries()</code> that sends the queries to the Neo4j graph database . It either records a message in case of an error or retrieves the output from the database. This function is available in this <a class="af oz" href="https://github.com/SolanaO/Blogs_Content/blob/master/cypher_generator/4_ArXiv_KG_Synthetic_Data_OpenAI.ipynb" rel="noopener ugc nofollow" target="_blank">Google Colab notebook</a>.</p><p id="1abc" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">From the prompt, you may notice that I instructed the LLM to generate mock data to populate the attributes values. While this approach is simpler, it results in numerous empty outputs from the graph. And it demands extra effort to identify those statements involving hallucinatins, such as made-up attributes:</p><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="b3fb" class="qe nd fq qb b bg qf qg l qh qi">'MATCH (author:Author)-[:WRITTEN_BY]-(article:Article)-[:UPDATED]-<br/>(updateDate:UpdateDate) <br/>WHERE article.creation_date = updateDate.update_date <br/>RETURN DISTINCT author.first_name, author.last_name;"</span></pre><p id="1857" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The <code class="cx qk ql qm qb b">Article</code> node has no <code class="cx qk ql qm qb b">creation_date</code> attribute in the ArXiv graph!</p><p id="a58d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">💡<strong class="oa fr">Tip</strong>💡</p><p id="ff55" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="qj">To minimize the empty outputs, we could instead extract instances directly from the graph. These instances can then be incorporated into the prompt, and instruct the LLM to use this information to enrich the Cypher statements.</em></p><h1 id="f79f" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Building Functional Queries</h1><p id="dbc3" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">This method allows to create anywhere from hundreds to hundreds of thousands of correct Cypher queries, depending on the graph’s size and complexity. However, it is crucial to strike a balance bewteen the quantity and the diversity of these queries. Despite being correct and applicable to any graph, these queries can occasionally appear formulaic or rigid.</p><h2 id="334f" class="pj nd fq bf ne pk pl pm nh pn po pp nk oh pq pr ps ol pt pu pv op pw px py pz bk">Extract Information About the Graph Structure</h2><p id="5fc8" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">For this process we need to start with some data extraction and preparation. I use the Cypher queries and the some of the code from the <a class="af oz" href="https://github.com/langchain-ai/langchain/blob/master/libs/community/langchain_community/graphs/neo4j_graph.py" rel="noopener ugc nofollow" target="_blank">neo4j_graph.py</a> module in Langchain.</p><ul class=""><li id="2e6a" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">Connect to an existing Neo4j graph database.</li><li id="4a19" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">Extract the schema in JSON format.</li><li id="498c" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">Extract several node and relationship instances from the graph, i.e. data from the graph to use as samples to populate the queries.</li></ul><p id="9d5d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">I created a Python class that perfoms these steps, it is available at <code class="cx qk ql qm qb b">utils/neo4j_schema.py</code> in the <a class="af oz" href="https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator" rel="noopener ugc nofollow" target="_blank">Github repository</a>. With all these in place, extracting the relevant data about the graph necessitates a few lines of code only:</p><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="3753" class="qe nd fq qb b bg qf qg l qh qi"># Initialize the Neo4j connector<br/>graph = Neo4jGraph(url=URI, username=USER, password=PWD)<br/># Initialize the schema extractor module<br/>gutils = Neo4jSchema(url=URI, username=USER, password=PWD)<br/><br/># Build the schema as a JSON object<br/>jschema = gutils.get_structured_schema<br/># Retrieve the list of nodes in the graph<br/>nodes = get_nodes_list(jschema)<br/># Read the nodes with their properties and their datatypes<br/>node_props_types = jschema['node_props']<br/><br/># Check the output<br/>print(f"The properties of the node Report are:\n{node_props_types['Report']}")<br/><br/>&gt;&gt;&gt;The properties of the node Report are:<br/>   [{'property': 'report_id', 'datatype': 'STRING'}, {'property': 'report_no', 'datatype': 'STRING'}]<br/><br/># Extract a list of relationships<br/>relationships = jschema['relationships']<br/><br/># Check the output<br/>relationships[:1]<br/><br/>&gt;&gt;&gt;[{'start': 'Article', 'type': 'HAS_KEY', 'end': 'Keyword'},<br/> {'start': 'Article', 'type': 'HAS_DOI', 'end': 'DOI'}]</span></pre><h2 id="1ac9" class="pj nd fq bf ne pk pl pm nh pn po pp nk oh pq pr ps ol pt pu pv op pw px py pz bk">Extract Data From the Graph</h2><p id="5752" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">This data will provide authentic values to populate our Cypher queries with.</p><ul class=""><li id="0bd3" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">First, we extract several node instances, this will retrieve all the data for nodes in the graph, including labels, attributes and their values :</li></ul><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="8833" class="qe nd fq qb b bg qf qg l qh qi"># Extract node samples from the graph - 4 sets of node samples<br/>node_instances = gutils.extract_node_instances(<br/>                  nodes, # list of nodes to extract labels<br/>                  4)  # how many instances to extract for each node</span></pre><ul class=""><li id="491b" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">Next, extract relationship instances, this includes all the data on the start node, the relationship with its type and properties, and the end node information:</li></ul><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="032a" class="qe nd fq qb b bg qf qg l qh qi"># Extract relationship instances<br/>rels_instances = gutils.extract_multiple_relationships_instances(<br/>                relationships, # list of relationships to extract instances for<br/>                8)  # how many instances to extract for each relationship</span></pre><p id="dbda" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">💡<strong class="oa fr">Tips</strong>💡</p><ul class=""><li id="b33d" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk"><em class="qj">Both of the above methods work for the full lists of nodes, relationships or sublists of them.</em></li><li id="92dc" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk"><em class="qj">If the graph contains instances that lack records for some attributes, it is advisable to collect more instances to ensure all possible scenarios are covered.</em></li></ul><p id="4d37" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The next step is to serialize the data, by replacing the Neo4j.time values with strings and save it to files.</p><h2 id="f330" class="pj nd fq bf ne pk pl pm nh pn po pp nk oh pq pr ps ol pt pu pv op pw px py pz bk">Parse the Extracted Data</h2><p id="3c8e" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">I refer to this phase as Python gymnastics. Here, we handle the data obtained in the previous step, which consists of the graph schema, node instances, and relationship instances. We reformat this data to make it easily accessible for the functions we are developing.</p><ul class=""><li id="869a" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">We first identify all the datatypes in the graph with:</li></ul><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="5e90" class="qe nd fq qb b bg qf qg l qh qi">dtypes = retrieve_datatypes(jschema)<br/>dtypes<br/><br/>&gt;&gt;&gt;{'DATE', 'INTEGER', 'STRING'}</span></pre><ul class=""><li id="6281" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">For each datatype we extract the attributes (and the corresponding nodes) that have that dataype.</li><li id="308d" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">We parse instances of each datatype.</li><li id="35e7" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">We also process and filter the relationships so that the start and the end nodes have attributes of specifid data types.</li></ul><p id="1bc6" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">All the code is available in the <a class="af oz" href="https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator" rel="noopener ugc nofollow" target="_blank">Github repository</a>. The reasons of doing all these will become transparent in the next section.</p><h2 id="1fa6" class="pj nd fq bf ne pk pl pm nh pn po pp nk oh pq pr ps ol pt pu pv op pw px py pz bk">How to Build One or One Thousand Cypher Statements</h2><p id="fd2f" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">Being a mathematician, I often perceive statements in terms of the underlying functions. Let’s consider the following example:</p><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="f8ae" class="qe nd fq qb b bg qf qg l qh qi">q = "Find the Topic whose description contains 'Jordan normal form'!"<br/>cq = "MATCH (n:Topic) WHERE n.description CONTAINS 'Jordan normal form' RETURN n"</span></pre><p id="888e" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">The above can be regarded as functions of several variables <code class="cx qk ql qm qb b">f(x, y, z)</code> and <code class="cx qk ql qm qb b">g(x. y, z)</code> where</p><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="2e84" class="qe nd fq qb b bg qf qg l qh qi">f(x, y, z) = f"Find the {x} whose {y} contains {z}!"<br/>q = f('Topic', 'description', 'Jordan normal form')<br/><br/>g(x, y, z) = f"MATCH (n:{x}) WHERE n.{y} CONTAINS {z} RETURN n"<br/>qc = g('Topic', 'description', 'Jordan normal form')</span></pre><p id="2fe2" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">How many queries of this type can we build? To simplify the argument let’s assume that there are <code class="cx qk ql qm qb b">N</code> node labels, each having in average <code class="cx qk ql qm qb b">n</code> properties that have <code class="cx qk ql qm qb b">STRING</code> datatype. So at least <code class="cx qk ql qm qb b">Nxn</code> queries are available for us to build, not taking into account the options for the string choices <code class="cx qk ql qm qb b">z</code>.</p><p id="bc12" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">💡<strong class="oa fr">Tip</strong>💡</p><p id="ecdf" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="qj">Just because we are able to construct all these queries using a single line of code doesn’t imply that we should incorporate the entire set of examples into our fine-tuning dataset.</em></p><h2 id="47bc" class="pj nd fq bf ne pk pl pm nh pn po pp nk oh pq pr ps ol pt pu pv op pw px py pz bk">Develop a Process and a Template</h2><p id="3c35" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">The main challenge lies in creating a sufficiently varied list of queries that covers a wide range of aspects related to the graph. With both proprietary and open-source LLMs capable of generating basic Cypher syntax, our focus can shift to generating queries about the nodes and relationships within the graph, while omitting syntax-specific queries. To gather query examples for conversion into functional form, one could refer to any Cypher language book or explore the <a class="af oz" href="https://neo4j.com/docs/cypher-manual/current/introduction/" rel="noopener ugc nofollow" target="_blank">Neo4j Cypher documentation site</a>.</p><p id="0e91" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">In the <a class="af oz" href="https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator" rel="noopener ugc nofollow" target="_blank">GitHub repository</a>, there are about 60 types of these queries that are then applied to the ArXiv knowledge graph. They are versatile and applicable to any graph schema.</p><p id="5851" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Below is the complete Python function for creating one set of similar queries and incorporate it in the fine-tuning dataset:</p><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="b977" class="qe nd fq qb b bg qf qg l qh qi">def find_nodes_connected_to_node_via_relation():<br/>    def prompter(label_1, prop_1, rel_1, label_2):<br/>        subschema = get_subgraph_schema(jschema, [label_1, label_2], 2, True)<br/>        message = {"Prompt": "Convert the following question into a Cypher query using the provided graph schema!",<br/>                   "Question": f"""For each {label_1}, find the number of {label_2} linked via {rel_1} and retrieve the {prop_1} of the {label_1} and the {label_2} counts in ascending order!""",<br/>                   "Schema": f"Graph schema: {subschema}",<br/>                   "Cypher": f"MATCH (n:{label_1}) -[:{rel_1}]-&gt;(m:{label_2}) WITH DISTINCT n, m RETURN n.{prop_1} AS {prop_1}, count(m) AS {label_2.lower()}_count ORDER BY {label_2.lower()}_count"<br/>        }<br/>        return message<br/><br/>    sampler=[]<br/>    for e in all_rels:<br/>        for k, v in e[1].items():<br/>            temp_dict = prompter(e[0], k, e[2], e[3])<br/>            sampler.append(temp_dict)<br/><br/>    return sampler</span></pre><ul class=""><li id="2db4" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">the function find_nodes_connected_to_node_via_relation() takes the generating prompter and evaluates it for all the elements in all_rels which is the collection of extracted and processed relationship instances, whose entries are of the form:</li></ul><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="0927" class="qe nd fq qb b bg qf qg l qh qi">['Keyword',<br/> {'name': 'logarithms', 'key_id': '720452e14ca2e4e07b76fa5a9bc0b5f6'},<br/> 'HAS_TOPIC',<br/> 'Topic',<br/> {'cluster': 0}]</span></pre><ul class=""><li id="f904" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">the prompter inputs are two nodes denoted <code class="cx qk ql qm qb b">label_1</code> and <code class="cx qk ql qm qb b">label_2</code> , the property <code class="cx qk ql qm qb b">prop_1</code> for <code class="cx qk ql qm qb b">label_1</code> and the relationship <code class="cx qk ql qm qb b">rel_1</code> ,</li><li id="9781" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">the <code class="cx qk ql qm qb b">message</code> contains the components of the prompt for the corresponding entry in the fine-tuning dataset,</li><li id="7e58" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">the <code class="cx qk ql qm qb b">subschema</code> extracts first neighbors for the two nodes denoted <code class="cx qk ql qm qb b">label_1</code> and <code class="cx qk ql qm qb b">label_2</code> , this means: the two nodes listed, all the nodes related to them (distance one in the graph), the relationships and all the corresponding attributes.</li></ul><p id="2c89" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">💡<strong class="oa fr">Tip</strong>💡</p><p id="693f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="qj">Including the </em><code class="cx qk ql qm qb b"><em class="qj">subschema</em></code><em class="qj"> in the finetuning dataset is not essential, although the more closely the prompt aligns with the fine-tuning data, the better the generated output tends to be. From my perspective, incorporating the subschema in the fine-tuning data still offers advantages.</em></p><h1 id="9825" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Concluding Remarks</h1><p id="afeb" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk">To summarize, post has explored various methods for building a fine-tuning dataset for generating Cypher queries from text. Here is a breakdown of these techniques, along with their advantages and disadvantages:</p><p id="c96c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr">LLM generated question and Cypher statements pairs</strong>:</p><ul class=""><li id="2f45" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">The method may seem straightforward in terms of data collection, yet it often demands excessive data cleaning.</li><li id="2443" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">While certain proprietary LLMs yield good outcomes, many open source LLMs still lack the proficiency of generating a wide range of accurate Cypher statements.</li><li id="ac1b" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">This technique becomes burdensome when the graph schema is complex.</li></ul><p id="ca39" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr">Functional approach or parametric query generation:</strong></p><ul class=""><li id="059c" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">This method is adaptable across various graphs schemas and allows for easy scaling of the sample size. However, it is important to ensure that the data doesn’t become overly repetitive and maintains diversity.</li><li id="efe4" class="ny nz fq oa b go pe oc od gr pf of og oh pg oj ok ol ph on oo op pi or os ot pb pc pd bk">It requires a significant amount of Python programming. The queries generated can often seem mechanial and may lack a conversational tone.</li></ul><p id="e02c" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">To expand beyond these approaches:</p><ul class=""><li id="1541" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">The graph schema can be seamlessley incorporated into the framework for creating the functional queries. Consider the following question, Cypher statement pair:</li></ul><pre class="mm mn mo mp mq qa qb qc bp qd bb bk"><span id="4304" class="qe nd fq qb b bg qf qg l qh qi">Question: Which articles were written by the author whose last name is Doe?<br/>Cypher: "MATCH (a:Article) -[:WRITTEN_BY]-&gt; (:Author {last_name: 'Doe') RETURN a"</span></pre><p id="511f" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">Instead of using a direct parametrization, we could incorporate basic parsing (such as replacing WRITTEN_BY with written by), enhancing the naturalness of the generated question.</p><p id="627b" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">This highligts the significance of the graph schema’s design and the labelling of graph’s entities in the construction of the fine-tuning pars. Adhering to general norms like using nouns for node labels and suggestive verbs for the relationships proves beneficial and can create a more organically conversational link between the elements.</p><ul class=""><li id="330b" class="ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot pb pc pd bk">Finally, it is crucial not to overlook the value of collecting actual user generated queries from graph interactions. When available, parametrizing these queries or enhancing them through other methods can be very useful. Ultimately, the effectiveness of this method depends on the specific objectives for which the graph has been designed.</li></ul><p id="c043" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">To this end, it is important to mention that my focus was on simpler Cypher queries. I did not address creating or modifying data within the graph, or the graph schema, nor I did include APOC queries.</p><p id="d56d" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><em class="qj">Are there any other methods or ideas you might suggest for generating such fine-tuning question and Cypher statement pairs?</em></p><h1 id="0881" class="nc nd fq bf ne nf ng gq nh ni nj gt nk nl nm nn no np nq nr ns nt nu nv nw nx bk">Resources</h1><p id="b381" class="pw-post-body-paragraph ny nz fq oa b go ob oc od gr oe of og oh oi oj ok ol om on oo op oq or os ot fj bk"><strong class="oa fr">Code</strong></p><p id="7f7a" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><a class="af oz" href="https://www.notion.so/GraphRAG-Unleashing-the-Power-of-KG-with-LLM-51cf4430ea3349ff9320b3375fe47fe5?pvs=21" rel="noopener ugc nofollow" target="_blank">Github Repository: Knowledge_Graphs_Assortment</a> — for building the ArXiv knowledge graph</p><p id="13ae" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><a class="af oz" href="https://github.com/SolanaO/Blogs_Content/tree/master/cypher_generator" rel="noopener ugc nofollow" target="_blank">Github Repository: Cypher_Generator</a> — for all the code related to this blogpost</p><p id="d0ad" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk"><strong class="oa fr">Data</strong></p><p id="57a2" class="pw-post-body-paragraph ny nz fq oa b go ou oc od gr ov of og oh ow oj ok ol ox on oo op oy or os ot fj bk">• Repository of scholary articles: <a class="af oz" href="https://www.kaggle.com/datasets/Cornell-University/arxiv" rel="noopener ugc nofollow" target="_blank">arXiv Dataset</a> that has <a class="af oz" href="https://creativecommons.org/publicdomain/zero/1.0/" rel="noopener ugc nofollow" target="_blank">CC0: Public Domain</a> license.</p></div></div></div></div>    
</body>
</html>
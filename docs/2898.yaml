- en: 'Dunder Methods: The Hidden Gems of Python'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/dunder-methods-the-hidden-gems-of-python-a234e29b192d?source=collection_archive---------0-----------------------#2024-11-30](https://towardsdatascience.com/dunder-methods-the-hidden-gems-of-python-a234e29b192d?source=collection_archive---------0-----------------------#2024-11-30)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Real-world examples on how actively using special methods can simplify coding
    and improve readability.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://medium.com/@federico.zabeo29?source=post_page---byline--a234e29b192d--------------------------------)[![Federico
    Zabeo](../Images/387bdad1380d507c9ace1cbea24a694c.png)](https://medium.com/@federico.zabeo29?source=post_page---byline--a234e29b192d--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--a234e29b192d--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--a234e29b192d--------------------------------)
    [Federico Zabeo](https://medium.com/@federico.zabeo29?source=post_page---byline--a234e29b192d--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--a234e29b192d--------------------------------)
    ·8 min read·Nov 30, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: Dunder methods, though possibly a basic topic in Python, are something I have
    often noticed being understood only superficially, even by people who have been
    coding for quite some time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer:** This is a forgivable gap, as in most cases, actively using
    dunder methods “simply” speeds up and standardize tasks that can be done differently.
    Even when their use is essential, programmers are often unaware that they are
    writing special methods that belong to the broader category of dunder methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, if you code in Python and are not familiar with this topic, or if you
    happen to be a code geek intrigued by the more native aspects of a programming
    language like I am, this article might just be what you’re looking for.
  prefs: []
  type: TYPE_NORMAL
- en: '**Appearances can deceive… even in Python!**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there is one thing I learned in my life is that not everything is what it
    seems like at a first look, and Python is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/07c8e26ee7f55de29278f00feb2ff468.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Robert Katzki](https://unsplash.com/@ro_ka?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider a seemingly simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the “emptiest” custom class we can define in Python, as we did not define
    attributes or methods. It is so empty you would think you can do nothing with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is not the case. For example, Python will not complain if you
    try to create an instance of this class or even compare two instances for equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this is not magic. Simply, leveraging a standard ***object*** interface,
    any object in Python inherits some default attributes and methods that allow the
    user to always have a minimal set of possible interactions with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'While these methods may seem hidden, they are not invisible. To access the
    available methods, including the ones assigned by Python itself, just use the
    ***dir()*** built-in function. For our empty class, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is these methods that can explain the behaviour we observed earlier. For
    example, since the class actually has an ***__init__*** method we should not be
    surprised that we can instantiate an object of the class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Meet the Dunder Methods**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the methods shown in the last output belongs to the special group of — guess
    what — dunder methods. The term “dunder” is short for double underscore, referring
    to the double underscores at the beginning and end of these method names.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are special for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**They are built into every object**: every Python object is equipped with
    a specific set of dunder methods determined by its type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**They are invoked implicitly**: many dunder methods are triggered automatically
    through interactions with Python’s native operators or built-in functions. For
    example, comparing two objects with ***==*** is equivalent to calling their ***__eq__***
    method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**They are customizable**: you can override existing dunder methods or define
    new ones for your classes to give them custom behavior while preserving their
    implicit invocation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For most Python developers, the first dunder they encounter is ***__init__***,
    the constructor method. This method is automatically called when you create an
    instance of a class, using the familiar syntax ***MyClass(*args, **kwargs)***
    as a shortcut for explicitly calling ***MyClass.__init__(*args, **kwargs).***
  prefs: []
  type: TYPE_NORMAL
- en: Despite being the most commonly used, ***__init__*** is also one of the most
    specialized dunder methods. It does not fully showcase the flexibility and power
    of dunder methods, which can allow you to redefine how your objects interact with
    native Python features.
  prefs: []
  type: TYPE_NORMAL
- en: Make an object pretty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us define a class representing an item for sale in a shop and create an
    instance of it by specifying the name and price.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if we try to display the content of the *item* variable? Right
    now, the best Python can do is tell us what type of object it is and where it
    is allocated in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try to get a more informative and pretty output!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/fd7e5e5454f250598838a4907fdd0424.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Shamblen Studios](https://unsplash.com/@shamblenstudios?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we can override the ***__repr__*** dunder, which output will be
    exactly what gets printed when typing a class instance in the interactive Python
    console but also — as soon as the other dunder method ***__str__*** is not override
    — when attempting a ***print()*** call.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**: it is a common practice to have ***__repr__*** provide the necessary
    syntax to recreate the printed instance. So in that latter case we expect the
    output to be *Item(name=”Milk (1L)”, price=0.99).*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing special, right? And you would be right: we could have implemented the
    same method and named it *my_custom_repr* without getting indo dunder methods.
    However, while anyone immediately understands what we mean with ***print(item)***
    or just ***item***, can we say the same for something like ***item.my_custom_repr()***?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define interaction between an object and Python’s native operators**'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we want to create a new class*, Grocery*, that allows us to build a
    collection of *Item* along with their quantities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can use dunder methods for allowing some standard operations
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a specific quantity of *Item* to the *Grocery* using the ***+*** operator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterating directly over the *Grocery* class using a ***for*** loop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accessing a specific Item from the Grocery class using the bracket ***[]***
    notation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To achieve this, we will **define (**we already see thata generic class do not
    have these methods by default) the dunder methods ***__add__***, ***__iter__***
    and ***__getitem__*** respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let us initialize a *Grocery* instance and print the content of its main attribute,
    *items.*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then, we use the ***+*** operator to add a new Item and verify the changes have
    taken effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Friendly and explicit, right?
  prefs: []
  type: TYPE_NORMAL
- en: The ***__iter__*** method allows us to loop through a *Grocery* object following
    the logic implemented in the method (i.e., implicitly the loop will iterate over
    the elements contained in the iterable attribute *items*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, accessing elements is handled by defining the ***__getitem__***
    dunder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In essence, we assigned some standard dictionary-like behaviours to our Grocery
    class while also allowing some operations that would not be natively available
    for this data type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhance functionality: make classes callable for simplicity and power.**'
  prefs: []
  type: TYPE_NORMAL
- en: Let us wrap up this deep-dive on dunder methods with a final eample showcasing
    how they can be a powerful tool in our arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/98a9fbb88437116ee9565a35777a3ad6.png)'
  prefs: []
  type: TYPE_IMG
- en: Photo by [Marek Studzinski](https://unsplash.com/@jccards?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we have implemented a function that performs deterministic and slow
    calculations based on a certain input. To keep things simple, as an example we
    will use an identity function with a built-in ***time.sleep*** of some seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we run the function twice on the same input? Well, right now
    calculation would be executed twice, meaning that we twice get the same output
    waiting two time for the whole execution time (i.e., a total of 10 seconds).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Does this make sense? Why should we do the same calculation (which leads to
    the same output) for the same input, especially if it’s a slow process?
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution is to “wrap” the execution of this function inside the
    ***__call__*** dunder method of a class.
  prefs: []
  type: TYPE_NORMAL
- en: This makes instances of the class callable just like functions — meaning we
    can use the straightforward syntax ***my_class_instance(*args, **kwargs)*** —
    while also allowing us to use attributes as a cache to cut computation time.
  prefs: []
  type: TYPE_NORMAL
- en: With this approach we also have the flexibility to create multiple process (i.e.,
    class instances), each with its own local cache.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the function is cached after the first run, eliminating the need
    for the second computation and thus cutting the overall time in half.
  prefs: []
  type: TYPE_NORMAL
- en: As above mentioned, we can even create separate instances of the class, each
    with its own cache, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we are! A simple yet powerful optimization trick made possible by dunder
    methods that not only reduces redundant calculations but also offers flexibility
    by allowing local, instance-specific caching.
  prefs: []
  type: TYPE_NORMAL
- en: My final considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dunder methods are a broad and ever-evolving topic, and this writing does not
    aim to be an exhaustive resource on the subject (for this purpose, you can refer
    to the [3\. Data model — Python 3.12.3 documentation](https://docs.python.org/3/reference/datamodel.html)).
  prefs: []
  type: TYPE_NORMAL
- en: My goal here was rather to explain clearly what they are and how they can be
    used effectively to handle some common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: While they may not be mandatory for all programmers all the time, once I got
    a good grasp of how they work they have made a ton of difference for me and hopefully
    they may work for you as well.
  prefs: []
  type: TYPE_NORMAL
- en: Dunder methods indeed are a way to avoid reinventing the wheel. They also align
    closely with Python’s philosophy, leading to a more concise, readable and convention-friendly
    code. And that never hurts, right?
  prefs: []
  type: TYPE_NORMAL

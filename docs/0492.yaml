- en: Graph Theory to Harmonize Model Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://towardsdatascience.com/graph-theory-to-harmonize-model-integration-e11b4827135a?source=collection_archive---------7-----------------------#2024-02-21](https://towardsdatascience.com/graph-theory-to-harmonize-model-integration-e11b4827135a?source=collection_archive---------7-----------------------#2024-02-21)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Optimising multi-model collaboration with graph-based orchestration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[](https://albarqawi.medium.com/?source=post_page---byline--e11b4827135a--------------------------------)[![Ahmad
    Albarqawi](../Images/f039f134cbb10d01a838a9ad864fd3c6.png)](https://albarqawi.medium.com/?source=post_page---byline--e11b4827135a--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e11b4827135a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e11b4827135a--------------------------------)
    [Ahmad Albarqawi](https://albarqawi.medium.com/?source=post_page---byline--e11b4827135a--------------------------------)'
  prefs: []
  type: TYPE_NORMAL
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e11b4827135a--------------------------------)
    ·7 min read·Feb 21, 2024
  prefs: []
  type: TYPE_NORMAL
- en: --
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/50e51cf257ee05cfe54011610f330018.png)'
  prefs: []
  type: TYPE_IMG
- en: Orchestra — photographer Arindam Mahanta by unsplash
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the capabilities of various AI models unlocks a symphony of potential,
    from automating complex tasks that require multiple abilities like vision, speech,
    writing, and synthesis to enhancing decision-making processes. Yet, orchestrating
    these collaborations presents a significant challenge in managing the inner relations
    and dependencies. Traditional linear approaches often fall short, struggling to
    manage the intricacies of diverse models and dynamic dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: By translating your machine learning workflow into a graph, you gain avisualisationof
    how each model interacts and contributes to the overall outcome that combines
    natural language processing, computer vision, and speech models. With the graph
    approach, the nodes represent models or tasks, and edges define dependencies between
    them. This graph-based mapping offers several advantages, identifying which models
    rely on the output of others and leveraging parallel processing for independent
    tasks. Additionally, we can execute the tasks using existing graph navigation
    strategies like breadth-first or depth-first according to the task priorities.
  prefs: []
  type: TYPE_NORMAL
- en: The road to harmonious AI models collaboration is not without hurdles. Imagine
    conducting an orchestra where each individual speaks different languages and instruments
    operate independently. This challenge mirrors the communication gaps when integrating
    diverse AI models, requiring a framework to manage the relations and which models
    can receive each input format.
  prefs: []
  type: TYPE_NORMAL
- en: 'From Theory to Practice: Expected Use Cases'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The graph-based orchestration approach opens doors to exciting possibilities
    across various domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collaborative tasks for drug discovery**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/e82bbc6d32b6602982657fa89fd639f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of three models collaboration as part of data analysis task — image
    by author
  prefs: []
  type: TYPE_NORMAL
- en: Researchers can accelerate the drug discovery process with a sequence of AI-powered
    assistants, each designed for a specific task, for example, using a three-step
    discovery mission. The first step involves a language model that scans vast scientific
    data to highlight potential protein targets strongly linked to specific diseases,
    followed by a vision model to explain complex diagrams or images, providing detailed
    insights into the structures of the identified proteins. This visual is crucial
    for understanding how potential drugs might interact with the protein. Finally,
    a third model integrates input from the language and vision models to predict
    how chemical compounds might affect the targeted proteins, offering the researchers
    valuable insights to lead the process efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several challenges will emerge during the model integration to deliver the
    entire pipeline. Extracting relevant images from the scanned content and feeding
    them to the vision model isn’t as simple as it seems. An intermediate processor
    is needed between the text scan and vision tasks to filter the relevant images.
    Secondly, the analysis task itself should merge multiple inputs: the data scan
    output, the vision model’s explanation, and user-specified instructions. This
    requires a template to combine the information for the language model to process
    them. The following sections will describe how to utilise a python framework to
    handle the complex relations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creative Content Generation**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9002dfceb80310637827fd6c08a9cc86.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of four tasks to generate animation — image by author
  prefs: []
  type: TYPE_NORMAL
- en: The models collaboration can facilitate interactive content creation by integrating
    elements such as music composition, animation, and design models to generate animated
    scenes. For instance, in a graph-based collaboration approach, the first task
    can plan a scene like a director and pass the input for each music and image generation
    task. Finally, an animation model will use the output of the art and music models
    to generate a short video.
  prefs: []
  type: TYPE_NORMAL
- en: To optimise this process, we aim to achieve parallel execution of music and
    graphics generation as they are independent tasks. So there’s no need for music
    to wait for graphics completion. Additionally, we need to address the diverse
    input formats by the animation task. While some models like Stable Video Diffusion
    work with images only, the music can be combined using a post-processor.
  prefs: []
  type: TYPE_NORMAL
- en: These examples provide just a glimpse of the graph theory potential in model
    integration. The graph integration approach allows you to tailor multiple tasks
    to your specific needs and unlock innovative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Intelli Framework Orchestrates AI Models with Graph Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../Images/0024fdb638ecb31b16278d49ed944fd2.png)'
  prefs: []
  type: TYPE_IMG
- en: Tasks represented with a graph — image by author
  prefs: []
  type: TYPE_NORMAL
- en: 'Intelli is an open source python module to orchestrate AI workflows, by leveraging
    graph principles through three key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agents** act as representatives of your AI models, you define each agent
    by specifying its type (text, image, vision, or speech), its provider (openai,
    gemini, stability, mistral, etc.), and the mission.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tasks** are individual units within your AI workflow. Each task leveraging
    an agent to perform a specific action and applies custom pre-processing and post-processing
    provided by the user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Flow** binds everything together, orchestrating the execution of your tasks,
    adhering to the dependencies you’ve established through the graph structure. Flow
    management ensures tasks are executed efficiently and in the correct order, enabling
    both sequential and parallel processing where possible.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the flow component to manage the tasks relation as a graph provide several
    benefits when connecting multiple models, however for the case of one task only
    this might be overkill and direct call of the model will be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scaling**: As your project grows in complexity, adding more models and tasks
    requires repetitive code updates to account for data format mismatches and complex
    dependency. The graph approach simplifies this by defining a new node representing
    the task, and the framework automatically resolves input/output differences to
    orchestrates data flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic Adaptation**: With traditional approaches, changes for complex tasks
    will impact the entire workflow, requiring adjustments. When using the flow, it
    will handle adding, removing, or modifying connections automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explainability**: The graph empowers deeper understanding of your AI workflow
    by visualising how the models interact, and optimise the tasks path navigation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: the author participated in designing and developing the intelli framework.
    it is an open source project with Apache licence.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Getting Started**'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, ensure you have python 3.7+, as intelli leverages the latest python
    asyncio features, and install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Agents: The Task Executors**'
  prefs: []
  type: TYPE_NORMAL
- en: Agents in Intelli are designed to interface with specific AI model. Each agent
    includes a unified input layer to access any model type and provides a dictionary
    allowing to pass custom parameters to the model, such as the maximum size, temperature
    and model version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Tasks: The Building Blocks**'
  prefs: []
  type: TYPE_NORMAL
- en: Tasks represent individual units of work or operations to be performed by agents,
    and include the logic to handle the output of the previous task. Each task can
    be a simple operation like generating text or a more complex process, like analysing
    the sentiment of user feedback.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Processors: Tuned I/O**'
  prefs: []
  type: TYPE_NORMAL
- en: Processors add an extra layer of control by defining a custom pre-process for
    the task input and post-process for the output. The example below demonstrates
    creating a function to shorten the text output of the previous step before calling
    the image model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Flow: Specifying the dependencies**'
  prefs: []
  type: TYPE_NORMAL
- en: Flow translates your AI workflow into a Directed Acyclic Graph (DAG) and leverage
    the graph theory for dependency management. This enables you to easily visualise
    the task relations, and optimise the execution order of your tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The map_paths dictates the task dependencies, guiding Flow to orchestrate the
    execution order and ensuring each task receives the necessary output from its
    predecessors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how Flow navigates the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mapping the Workflow: Flow constructs a DAG using tasks as nodes and dependencies
    as edges. This visual representation clarifies the task execution sequence and
    data flow.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Topological Sorting: The flow analyses the graph to determine the optimal execution
    order. Tasks without incoming dependencies are prioritised, ensuring each task
    receives necessary inputs from predecessors before execution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Task Execution: The framework iterates through the sorted tasks, executing
    each with corresponding input. Based on the dependency map, inputs might come
    from previous task outputs and user-defined values.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Input Preparation: Before execution, the task applies any pre-processing functions
    defined for the task, modifying the input data as needed and calls the assigned
    agent.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Output Management: The agent returns an output, which is stored in a dictionary
    with task name as a key and returned to the user.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To visualise your flow as a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/159e0a980ca352141cf8619c60023480.png)'
  prefs: []
  type: TYPE_IMG
- en: The visual of the tasks and assigned agents — image by intelli graph function
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using graph theory has transformed the traditional linear approaches to orchestrating
    AI models by providing a symphony of collaboration between diverse models.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks like Intelli translate your workflow into a visual representation,
    where tasks become nodes and dependencies are mapped as edges, creating an overview
    of your entire process to automate complex tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This approach extends to diverse fields requiring collaborative AI models, including
    scientific research, business decision automation, and interactive content creation.
    However, effective scale requires further refinement in managing the data exchange
    between the models.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Intelli git repo: [https://github.com/intelligentnode/Intelli](https://github.com/intelligentnode/Intelli)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Graph theory: [https://www.britannica.com/topic/graph-theory](https://www.britannica.com/topic/graph-theory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL

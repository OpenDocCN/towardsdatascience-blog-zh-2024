["```py\nimport numpy as np\n\ndef simulate_parent_2_schedule(num_days=5):\n    parent_2_daily_schedule = []  # Initialize empty schedule for Parent 2\n\n    for day in range(num_days):\n        if np.random.rand() < parent_2_work_prob:  # Randomly determine if Parent 2 works\n            shift = np.random.choice(\n                list(parent_2_shift_probabilities.keys()), \n                p=[parent_2_shift_probabilities[shift]['probability'] for shift in parent_2_shift_probabilities]\n            )\n            start_hour = parent_2_shift_probabilities[shift]['start_hour']  # Get start time\n            end_hour = parent_2_shift_probabilities[shift]['end_hour']  # Get end time\n\n            # Check if it's Wednesday and adjust schedule to account for a meeting\n            if day == 2:  \n                meeting_start = 13\n                meeting_end = 16\n                # Adjust schedule if necessary to accommodate the meeting\n                if end_hour <= meeting_start:  \n                    end_hour = meeting_end  \n                elif start_hour >= meeting_end:\n                    parent_2_daily_schedule.append({'start_hour': meeting_start, 'end_hour': end_hour})\n                    continue  \n                else:\n                    if start_hour > meeting_start:\n                        start_hour = meeting_start  \n                    if end_hour < meeting_end:\n                        end_hour = meeting_end  \n\n            parent_2_daily_schedule.append({'start_hour': start_hour, 'end_hour': end_hour})\n        else:\n            # If Parent 2 isn't working that day, leave the schedule empty or just the meeting\n            if day == 2:  \n                parent_2_daily_schedule.append({'start_hour': 14, 'end_hour': 16})\n            else:\n                parent_2_daily_schedule.append({'start_hour': None, 'end_hour': None})\n\n    return parent_2_daily_schedule\n```", "```py\n# Function to generate nanny characteristics\ndef generate_nanny_characteristics():\n    return {\n        'flexible': np.random.choice([True, False]),  # Nanny's flexibility\n        'days_per_week': np.random.choice([3, 4, 5]),  # Days available per week\n        'hours_per_day': np.random.choice([6, 7, 8, 9, 10, 11, 12])  # Hours available per day\n    }\n```", "```py\n# Function to calculate a weekly schedule based on nanny's characteristics\ndef calculate_nanny_schedule(characteristics, num_days=5):\n    shifts = []\n    for _ in range(num_days):\n        start_hour = np.random.randint(6, 12) if characteristics['flexible'] else 9  # Flexible nannies have varying start times\n        end_hour = start_hour + characteristics['hours_per_day']  # Calculate end hour based on hours per day\n        shifts.append((start_hour, end_hour))\n    return shifts  # Return the generated weekly schedule\n```", "```py\n# Function for selection in genetic algorithm\ndef selection(population, fitness_scores, num_parents):\n    # Normalize fitness scores and select parents based on probability\n    min_fitness = np.min(fitness_scores)\n    if min_fitness < 0:\n        fitness_scores = fitness_scores - min_fitness\n\n    fitness_scores_sum = np.sum(fitness_scores)\n    probabilities = fitness_scores / fitness_scores_sum if fitness_scores_sum != 0 else np.ones(len(fitness_scores)) / len(fitness_scores)\n\n    # Select parents based on their fitness scores\n    selected_parents = np.random.choice(population, size=num_parents, p=probabilities)\n    return selected_parents\n```", "```py\n# Function to mutate nanny characteristics\ndef mutate_characteristics(characteristics, mutation_rate=0.1):\n    if np.random.rand() < mutation_rate:\n        characteristics['flexible'] = not characteristics['flexible']\n    if np.random.rand() < mutation_rate:\n        characteristics['days_per_week'] = np.random.choice([3, 4, 5])\n    if np.random.rand() < mutation_rate:\n        characteristics['hours_per_day'] = np.random.choice([6, 7, 8, 9, 10, 11, 12])\n    return characteristics\n```", "```py\n# Function to evolve nanny characteristics over multiple generations\ndef evolve_nanny_characteristics(all_childcare_weeks, population_size=1000, num_generations=10):\n    population = [generate_nanny_characteristics() for _ in range(population_size)]  # Initialize the population\n\n    for generation in range(num_generations):\n        print(f\"\\n--- Generation {generation + 1} ---\")\n\n        fitness_scores = []\n        hours_worked_collection = []\n\n        for characteristics in population:\n            fitness_score, yearly_hours_worked = fitness_function_yearly(characteristics, all_childcare_weeks)\n            fitness_scores.append(fitness_score)\n            hours_worked_collection.append(yearly_hours_worked)\n\n        fitness_scores = np.array(fitness_scores)\n\n        # Find and store the best individual of this generation\n        max_fitness_idx = np.argmax(fitness_scores)\n        best_nanny = population[max_fitness_idx]\n        best_nanny['actual_hours_worked'] = hours_worked_collection[max_fitness_idx]\n\n        # Select parents and generate a new population\n        parents = selection(population, fitness_scores, num_parents=population_size // 2)\n        new_population = []\n        for i in range(0, len(parents), 2):\n            parent_1, parent_2 = parents[i], parents[i + 1]\n            child = {\n                'flexible': np.random.choice([parent_1['flexible'], parent_2['flexible']]),\n                'days_per_week': np.random.choice([parent_1['days_per_week'], parent_2['days_per_week']]),\n                'hours_per_day': np.random.choice([parent_1['hours_per_day'], parent_2['hours_per_day']])\n            }\n            child = mutate_characteristics(child)\n            new_population.append(child)\n\n        population = new_population  # Replace the population with the new generation\n\n    return best_nanny  # Return the best nanny after all generations\n```"]
- en: 'From Basics to Advanced: Exploring LangGraph'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从基础到进阶：探索LangGraph
- en: 原文：[https://towardsdatascience.com/from-basics-to-advanced-exploring-langgraph-e8c1cf4db787?source=collection_archive---------0-----------------------#2024-08-15](https://towardsdatascience.com/from-basics-to-advanced-exploring-langgraph-e8c1cf4db787?source=collection_archive---------0-----------------------#2024-08-15)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/from-basics-to-advanced-exploring-langgraph-e8c1cf4db787?source=collection_archive---------0-----------------------#2024-08-15](https://towardsdatascience.com/from-basics-to-advanced-exploring-langgraph-e8c1cf4db787?source=collection_archive---------0-----------------------#2024-08-15)
- en: Building single- and multi-agent workflows with human-in-the-loop interactions
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建单智能体和多智能体工作流，包含人机协作交互
- en: '[](https://miptgirl.medium.com/?source=post_page---byline--e8c1cf4db787--------------------------------)[![Mariya
    Mansurova](../Images/b1dd377b0a1887db900cc5108bca8ea8.png)](https://miptgirl.medium.com/?source=post_page---byline--e8c1cf4db787--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e8c1cf4db787--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e8c1cf4db787--------------------------------)
    [Mariya Mansurova](https://miptgirl.medium.com/?source=post_page---byline--e8c1cf4db787--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://miptgirl.medium.com/?source=post_page---byline--e8c1cf4db787--------------------------------)[![Mariya
    Mansurova](../Images/b1dd377b0a1887db900cc5108bca8ea8.png)](https://miptgirl.medium.com/?source=post_page---byline--e8c1cf4db787--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e8c1cf4db787--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e8c1cf4db787--------------------------------)
    [Mariya Mansurova](https://miptgirl.medium.com/?source=post_page---byline--e8c1cf4db787--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e8c1cf4db787--------------------------------)
    ·21 min read·Aug 15, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e8c1cf4db787--------------------------------)
    ·21分钟阅读·2024年8月15日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/9be549ca0d6991e179d95d55d5d5388d.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9be549ca0d6991e179d95d55d5d5388d.png)'
- en: Image by DALL-E 3
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：DALL-E 3
- en: '[LangChain](https://www.langchain.com/) is one of the leading frameworks for
    building applications powered by Lardge Language Models. With the [LangChain Expression
    Language](https://python.langchain.com/v0.1/docs/expression_language/) (LCEL),
    defining and executing step-by-step action sequences — also known as chains —
    becomes much simpler. In more technical terms, LangChain allows us to create DAGs
    (directed acyclic graphs).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[LangChain](https://www.langchain.com/) 是构建大型语言模型驱动应用程序的领先框架之一。借助 [LangChain表达式语言](https://python.langchain.com/v0.1/docs/expression_language/)（LCEL），定义和执行逐步行动序列——也就是所谓的链——变得更加简便。从更技术性的角度来看，LangChain
    允许我们创建DAG（有向无环图）。'
- en: As LLM applications, particularly LLM agents, have evolved, we’ve begun to use
    LLMs not just for execution but also as reasoning engines. This shift has introduced
    interactions that frequently involve repetition (cycles) and complex conditions.
    In such scenarios, LCEL is not sufficient, so LangChain implemented a new module
    — [LangGraph](https://langchain-ai.github.io/langgraph/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 随着LLM应用，特别是LLM智能体的发展，我们开始不仅将LLM用于执行任务，还用作推理引擎。这一转变引入了频繁涉及重复（循环）和复杂条件的交互。在这种情况下，LCEL不足以应对，因此LangChain实现了一个新模块——[LangGraph](https://langchain-ai.github.io/langgraph/)。
- en: LangGraph (as you might guess from the name) models all interactions as cyclical
    graphs. These graphs enable the development of advanced workflows and interactions
    with multiple loops and if-statements, making it a handy tool for creating both
    agent and multi-agent workflows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: LangGraph（正如你从名字中可以猜到的）将所有交互建模为循环图。这些图使得开发具有多个循环和条件判断的高级工作流和交互成为可能，因此它成为了创建智能体和多智能体工作流的便捷工具。
- en: In this article, I will explore LangGraph’s key features and capabilities, including
    multi-agent applications. We’ll build a system that can answer different types
    of questions and dive into how to implement a human-in-the-loop setup.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我将探索LangGraph的关键特性和功能，包括多智能体应用。我们将构建一个可以回答不同类型问题的系统，并深入了解如何实现人机协作的设置。
- en: In [the previous article](https://medium.com/towards-data-science/multi-ai-agent-systems-101-bac58e3bcc47),
    we tried using CrewAI, another popular framework for multi-agent systems. LangGraph,
    however, takes a different approach. While CrewAI is a high-level framework with
    many predefined features and ready-to-use components, LangGraph operates at a
    lower level, offering extensive customization and control.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一篇文章](https://medium.com/towards-data-science/multi-ai-agent-systems-101-bac58e3bcc47)中，我们尝试使用了
    CrewAI，这是另一个流行的多代理系统框架。然而，LangGraph 采取了不同的方法。CrewAI 是一个高层框架，具有许多预定义的功能和现成的组件，而
    LangGraph 在较低层次操作，提供广泛的定制和控制。
- en: With that introduction, let’s dive into the fundamental concepts of LangGraph.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个介绍，让我们深入了解 LangGraph 的基本概念。
- en: LangGraph basics
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LangGraph 基础
- en: LangGraph is part of the LangChain ecosystem, so we will continue using well-known
    concepts like prompt templates, tools, etc. However, LangGraph brings a bunch
    of [additional concepts.](https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph)
    Let’s discuss them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: LangGraph 是 LangChain 生态系统的一部分，因此我们将继续使用一些熟悉的概念，比如提示模板、工具等。然而，LangGraph 引入了一些[额外的概念](https://langchain-ai.github.io/langgraph/concepts/low_level/#compiling-your-graph)。让我们来讨论一下它们。
- en: 'LangGraph is created to define cyclical graphs. Graphs consist of the following
    elements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: LangGraph 被创建用于定义循环图。图由以下元素组成：
- en: Nodes represent actual actions and can be either LLMs, agents or functions.
    Also, a special END node marks the end of execution.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点代表实际的操作，可以是 LLM、代理或函数。同时，一个特殊的 END 节点标志着执行的结束。
- en: Edges connect nodes and determine the execution flow of your graph. There are
    basic edges that simply link one node to another and conditional edges that incorporate
    if-statements and additional logic.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边连接节点并确定图的执行流程。有基本边，它们仅仅连接一个节点到另一个节点，还有条件边，它们包含 if 语句和额外的逻辑。
- en: Another important concept is the state of the graph. The state serves as a foundational
    element for collaboration among the graph’s components. It represents a snapshot
    of the graph that any part — whether nodes or edges — can access and modify during
    execution to retrieve or update information.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要概念是图的状态。状态作为图组件协作的基础元素。它表示图的快照，任何部分——无论是节点还是边——都可以在执行过程中访问和修改，以检索或更新信息。
- en: Additionally, the state plays a crucial role in persistence. It is automatically
    saved after each step, allowing you to pause and resume execution at any point.
    This feature supports the development of more complex applications, such as those
    requiring error correction or incorporating human-in-the-loop interactions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，状态在持久化中也起着至关重要的作用。每一步之后，它会自动保存，允许你在任何时刻暂停并恢复执行。这个功能支持更复杂应用的开发，比如那些需要错误修正或包含人工干预的应用。
- en: Single-agent workflow
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单代理工作流
- en: Building agent from scratch
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从零开始构建代理
- en: Let’s start simple and try using LangGraph for a basic use case — an agent with
    tools.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的案例开始，尝试使用 LangGraph 创建一个基础用例——一个带有工具的代理。
- en: I will try to build similar applications to those we did with CrewAI in [the
    previous article](https://medium.com/towards-data-science/multi-ai-agent-systems-101-bac58e3bcc47).
    Then, we will be able to compare the two frameworks. For this example, let’s create
    an application that can automatically generate documentation based on the table
    in the database. It can save us quite a lot of time when creating documentation
    for our data sources.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我将尝试构建类似我们在[上一篇文章](https://medium.com/towards-data-science/multi-ai-agent-systems-101-bac58e3bcc47)中使用
    CrewAI 时的应用程序。然后，我们可以比较这两个框架。对于这个示例，让我们创建一个应用程序，能够根据数据库中的表自动生成文档。这可以节省我们在创建数据源文档时的很多时间。
- en: As usual, we will start by defining the tools for our agent. Since I will use
    the ClickHouse database in this example, I’ve defined a function to execute any
    query. You can use a different database if you prefer, as we won’t rely on any
    database-specific features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们将首先定义我们代理的工具。由于在这个示例中我将使用 ClickHouse 数据库，因此我定义了一个函数来执行任何查询。如果你愿意，也可以使用其他数据库，因为我们不会依赖任何数据库特定的功能。
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It’s crucial to make LLM tools reliable and error-prone. If a database returns
    an error, I provide this feedback to the LLM rather than throwing an exception
    and halting execution. Then, the LLM agent will have an opportunity to fix an
    error and call the function again.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使 LLM 工具可靠且减少错误至关重要。如果数据库返回错误，我会将反馈传递给 LLM，而不是抛出异常并停止执行。这样，LLM 代理就有机会修复错误并重新调用该函数。
- en: Let’s define one tool named `execute_sql` , which enables the execution of any
    SQL query. We use `pydantic` to specify the tool’s structure, ensuring that the
    LLM agent has all the needed information to use the tool effectively.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`execute_sql`的工具，它使得能够执行任何SQL查询。我们使用`pydantic`来指定工具的结构，确保LLM代理能够有效地使用该工具。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can print the parameters of the created tool to see what information is passed
    to LLM.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印出创建的工具的参数，看看传递给LLM的信息是什么。
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Everything looks good. We’ve set up the necessary tool and can now move on to
    defining an LLM agent. As we discussed above, the cornerstone of the agent in
    LangGraph is its state, which enables the sharing of information between different
    parts of our graph.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很好。我们已经设置好了必要的工具，现在可以继续定义LLM代理。如上所述，LangGraph中代理的基石是其状态，它使得我们图中不同部分之间可以共享信息。
- en: Our current example is relatively straightforward. So, we will only need to
    store the history of messages. Let’s define the agent state.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的例子相对简单。因此，我们只需要存储消息的历史记录。让我们定义代理状态。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ve defined a single parameter in `AgentState` — `messages` — which is a list
    of objects of the class `AnyMessage` . Additionally, we annotated it with `operator.add`
    (reducer). This annotation ensures that each time a node returns a message, it
    is appended to the existing list in the state. Without this operator, each new
    message would replace the previous value rather than being added to the list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`AgentState`中定义了一个单一的参数——`messages`——它是`AnyMessage`类对象的列表。此外，我们用`operator.add`（累加器）对其进行了注解。这个注解确保每当一个节点返回一条消息时，它会被附加到状态中现有的消息列表里。如果没有这个操作符，每条新消息会替代掉之前的值，而不是被添加到列表中。
- en: 'The next step is to define the agent itself. Let’s start with `__init__` function.
    We will specify three arguments for the agent: model, list of tools and system
    prompt.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义代理本身。我们从`__init__`函数开始。我们将为代理指定三个参数：模型、工具列表和系统提示。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the initialisation function, we’ve outlined the structure of our graph,
    which includes two nodes: `llm` and `action`. Nodes are actual actions, so we
    have functions associated with them. We will define functions a bit later.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化函数中，我们概述了图的结构，其中包括两个节点：`llm`和`action`。节点是实际的操作，因此我们有与之关联的函数。稍后我们将定义这些函数。
- en: Additionally, we have one conditional edge that determines whether we need to
    execute the function or generate the final answer. For this edge, we need to specify
    the previous node (in our case, `llm`), a function that decides the next step,
    and mapping of the subsequent steps based on the function’s output (formatted
    as a dictionary). If `exists_function_calling` returns True, we follow to the
    function node. Otherwise, execution will conclude at the special `END` node, which
    marks the end of the process.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有一条条件边，决定是否需要执行函数或生成最终答案。对于这条边，我们需要指定前一个节点（在我们的例子中是`llm`）、一个决定下一步的函数，以及基于该函数输出的后续步骤映射（格式为字典）。如果`exists_function_calling`返回True，我们会进入函数节点。否则，执行将在特殊的`END`节点处结束，标志着过程的结束。
- en: We’ve added an edge between `function` and `llm`. It just links these two steps
    and will be executed without any conditions.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`function`和`llm`之间添加了一条边。这条边仅仅将这两个步骤连接起来，并且会在没有任何条件的情况下执行。
- en: With the main structure defined, it’s time to create all the functions outlined
    above. The first one is `call_llm`. This function will execute LLM and return
    the result.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了主要结构后，接下来是创建上述列出的所有函数。第一个是`call_llm`。这个函数将执行LLM并返回结果。
- en: The agent state will be passed to the function automatically so we can use the
    saved system prompt and model from it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 代理状态将自动传递给函数，因此我们可以使用其中保存的系统提示和模型。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As a result, our function returns a dictionary that will be used to update the
    agent state. Since we used `operator.add` as a reducer for our state, the returned
    message will be appended to the list of messages stored in the state.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们的函数返回一个字典，这个字典将用于更新代理状态。由于我们使用了`operator.add`作为状态的累加器，返回的消息会被附加到存储在状态中的消息列表中。
- en: The next function we need is `execute_function` which will run our tools. If
    the LLM agent decides to call a tool, we will see it in the`message.tool_calls`
    parameter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一个函数是`execute_function`，它将运行我们的工具。如果LLM代理决定调用某个工具，我们将在`message.tool_calls`参数中看到它。
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this function, we iterate over the tool calls returned by LLM and either
    invoke these tools or return the error message. In the end, our function returns
    the dictionary with a single key `messages` that will be used to update the graph
    state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们遍历 LLM 返回的工具调用，并且要么调用这些工具，要么返回错误信息。最终，我们的函数返回一个字典，字典中包含一个键`messages`，该键将用于更新图表状态。
- en: There’s only one function left —the function for the conditional edge that defines
    whether we need to execute the tool or provide the final result. It’s pretty straightforward.
    We just need to check whether the last message contains any tool calls.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一个函数——用于条件边的函数，它定义了我们是否需要执行工具还是提供最终结果。这非常简单。我们只需要检查最后一条消息是否包含任何工具调用。
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It’s time to create an agent and LLM model for it. I will use the new OpenAI
    GPT 4o mini model ([doc](https://openai.com/index/gpt-4o-mini-advancing-cost-efficient-intelligence/))
    since it’s cheaper and better performing than GPT 3.5.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为它创建一个代理和 LLM 模型了。我将使用新的 OpenAI GPT 4o mini 模型（[文档](https://openai.com/index/gpt-4o-mini-advancing-cost-efficient-intelligence/)），因为它比
    GPT 3.5 更便宜且性能更好。
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: LangGraph provides us with quite a handy feature to visualise graphs. To use
    it, you need to install `pygraphviz` .
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: LangGraph 提供了一个非常方便的功能来可视化图表。要使用它，你需要安装`pygraphviz`。
- en: 'It’s a bit tricky for Mac with M1/M2 chips, so here is the lifehack for you
    ([source](https://github.com/pygraphviz/pygraphviz/issues/398)):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于带有 M1/M2 芯片的 Mac 来说，这有点棘手，所以这里有个小窍门供你参考（[来源](https://github.com/pygraphviz/pygraphviz/issues/398)）：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After figuring out the installation, here’s our graph.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在弄清楚安装过程后，这就是我们的图表。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](../Images/accdadbbf3700cb7f49695388ad48fb0.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/accdadbbf3700cb7f49695388ad48fb0.png)'
- en: As you can see, our graph has cycles. Implementing something like this with
    LCEL would be quite challenging.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的图表有环。用 LCEL 实现类似的功能会相当具有挑战性。
- en: Finally, it’s time to execute our agent. We need to pass the initial set of
    messages with our questions as `HumanMessage`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，到了执行我们的代理的时候了。我们需要将包含问题的初始消息集作为`HumanMessage`传递。
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `result` variable, we can observe all the messages generated during
    execution. The process worked as expected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`result`变量中，我们可以观察到执行过程中生成的所有消息。整个过程按预期进行：
- en: The agent decided to call the function with the query `describe ecommerce.db_users`.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理决定调用带有查询`describe ecommerce.db_users`的函数。
- en: LLM then processed the information from the tool and provided a user-friendly
    answer.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，LLM 处理了工具提供的信息并给出了用户友好的回答。
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here’s the final result. It looks pretty decent.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终结果，看起来相当不错。
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using prebuilt agents
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用预构建的代理
- en: We’ve learned how to build an agent from scratch. However, we can leverage LangGraph's
    built-in functionality for simpler tasks like this one.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何从零开始构建代理。然而，对于像这样的简单任务，我们可以利用 LangGraph 的内置功能。
- en: 'We can use a [prebuilt ReAct agent](https://langchain-ai.github.io/langgraph/how-tos/create-react-agent/)
    to get a similar result: an agent that can work with tools.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用[预构建的 ReAct 代理](https://langchain-ai.github.io/langgraph/how-tos/create-react-agent/)来获得类似的结果：一个可以与工具协作的代理。
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It is the same agent as we built previously. We will try it out in a second,
    but first, we need to understand two other important concepts: persistence and
    streaming.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前构建的代理是一样的。我们稍后会试用它，但首先，我们需要理解两个其他重要的概念：持久性和流媒体。
- en: Persistence and streaming
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久性与流媒体
- en: Persistence refers to the ability to maintain context across different interactions.
    It’s essential for agentic use cases when an application can get additional input
    from the user.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性指的是在不同的交互之间保持上下文的能力。这对于代理使用场景至关重要，当应用程序可以从用户那里获取额外的输入时。
- en: LangGraph automatically saves the state after each step, allowing you to pause
    or resume execution. This capability supports the implementation of advanced business
    logic, such as error recovery or human-in-the-loop interactions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: LangGraph 会在每一步之后自动保存状态，允许你暂停或恢复执行。这一功能支持实现更复杂的业务逻辑，如错误恢复或人机交互。
- en: The easiest way to add persistence is to use an in-memory SQLite database.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 添加持久性最简单的方法是使用内存中的 SQLite 数据库。
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For the off-the-shelf agent, we can pass memory as an argument while creating
    an agent.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现成的代理，我们可以在创建代理时将内存作为参数传递。
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you’re working with a custom agent, you need to pass memory as a check pointer
    while compiling a graph.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用自定义代理，你需要在编译图表时将内存作为检查指针传递。
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s execute the agent and explore another feature of LangGraph: streaming.
    With streaming, we can receive results from each step of execution as a separate
    event in a stream. This feature is crucial for production applications when multiple
    conversations (or threads) need to be processed simultaneously.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行代理并探索 LangGraph 的另一个特性：流式处理。通过流式处理，我们可以将每个执行步骤的结果作为流中的独立事件接收。这个功能对于需要同时处理多个对话（或线程）的生产环境应用至关重要。
- en: LangGraph supports not only event streaming but also token-level streaming.
    The only use case I have in mind for token streaming is to display the answers
    in real-time word by word (similar to ChatGPT implementation).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: LangGraph 不仅支持事件流式处理，还支持基于令牌的流式处理。我想到的基于令牌流式处理的唯一用例是逐字显示实时回答（类似于 ChatGPT 实现）。
- en: Let’s try using streaming with our new prebuilt agent. I will also use the `pretty_print`
    function for messages to make the result more readable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用流式处理并结合我们的新预构建代理。我还将使用 `pretty_print` 函数来格式化消息，使结果更易读。
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Interestingly, the agent wasn’t able to provide a good enough result. Since
    the agent didn’t look up the table schema, it struggled to guess all columns’
    meanings. We can improve the result by using follow-up questions in the same thread.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，代理并未提供足够好的结果。由于代理没有查阅表格的 schema，它在猜测所有列的含义时遇到了困难。我们可以通过在同一线程中使用后续问题来改善结果。
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time, we got the full answer from the agent. Since we provided the same
    thread, the agent was able to get the context from the previous discussion. That’s
    how persistence works.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们从代理那里得到了完整的答案。由于我们提供了相同的线程，代理能够从之前的讨论中获取上下文。这就是持久性工作的方式。
- en: Let’s try to change the thread and ask the same follow-up question.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试更改线程并提出相同的后续问题。
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It was not surprising that the agent lacked the context needed to answer our
    question. Threads are designed to isolate different conversations, ensuring that
    each thread maintains its own context.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代理缺乏回答我们问题所需的上下文并不令人惊讶。线程的设计旨在隔离不同的对话，确保每个线程保持其独立的上下文。
- en: In real-life applications, managing memory is essential. Conversations might
    become pretty lengthy, and at some point, it won’t be practical to pass the whole
    history to LLM every time. Therefore, it’s worth trimming or filtering messages.
    We won’t go deep into the specifics here, but you can find guidance on it in [the
    LangGraph documentation](https://langchain-ai.github.io/langgraph/how-tos/memory/manage-conversation-history/).
    Another option to compress the conversational history is using summarization ([example](https://langchain-ai.github.io/langgraph/how-tos/memory/add-summary-conversation-history/#how-to-add-summary-of-the-conversation-history)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，内存管理至关重要。对话可能会变得相当冗长，某些时候将整个历史记录每次都传递给 LLM 是不切实际的。因此，值得对消息进行修剪或过滤。我们不会在这里深入讨论细节，但你可以在[LangGraph
    文档](https://langchain-ai.github.io/langgraph/how-tos/memory/manage-conversation-history/)中找到相关指南。压缩对话历史的另一种方法是使用摘要（[示例](https://langchain-ai.github.io/langgraph/how-tos/memory/add-summary-conversation-history/#how-to-add-summary-of-the-conversation-history)）。
- en: We’ve learned how to build systems with single agents using LangGraph. The next
    step is to combine multiple agents in one application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用 LangGraph 构建单一代理的系统。下一步是将多个代理组合到一个应用中。
- en: Multi-Agent Systems
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多代理系统
- en: 'As an example of a multi-agent workflow, I would like to build an application
    that can handle questions from various domains. We will have a set of expert agents,
    each specializing in different types of questions, and a router agent that will
    find the best-suited expert to address each query. Such an application has numerous
    potential use cases: from automating customer support to answering questions from
    colleagues in internal chats.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 作为多代理工作流的示例，我想构建一个可以处理来自不同领域问题的应用。我们将有一组专家代理，每个专家专注于不同类型的问题，以及一个路由代理，负责找到最合适的专家来处理每个查询。这样的应用有许多潜在的使用场景：从自动化客户支持到在内部聊天中回答同事的问题。
- en: 'First, we need to create the agent state — the information that will help agents
    to solve the question together. I will use the following fields:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建代理的状态——这些信息将帮助代理们共同解决问题。我将使用以下字段：
- en: '`question` — initial customer request;'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`question` — 初始的客户请求；'
- en: '`question_type` — the category that defines which agent will be working on
    the request;'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`question_type` — 定义哪个代理将处理请求的类别；'
- en: '`answer` — the proposed answer to the question;'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`answer` — 对问题的建议回答；'
- en: '`feedback` — a field for future use that will gather some feedback.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`反馈` — 一个供未来使用的字段，用于收集一些反馈。'
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I don’t use any reducers, so our state will store only the latest version of
    each field.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有使用任何 reducer，因此我们的状态只会存储每个字段的最新版本。
- en: Then, let’s create a router node. It will be a simple LLM model that defines
    the category of question (database, LangChain or general questions).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个路由节点。它将是一个简单的 LLM 模型，用于定义问题的类别（数据库、LangChain 或一般问题）。
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we have our first node — the router — let’s build a simple graph to
    test the workflow.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了第一个节点——路由节点——让我们构建一个简单的图表来测试工作流程。
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let’s test our workflow with different types of questions to see how it performs
    in action. This will help us evaluate whether the router agent correctly assigns
    questions to the appropriate expert agents.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过不同类型的问题来测试我们的工作流程，看看它在实际操作中的表现。这将帮助我们评估路由代理是否能将问题正确分配给相应的专家代理。
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It’s working well. I recommend you build complex graphs incrementally and test
    each step independently. With such an approach, you can ensure that each iteration
    works expectedly and can save you a significant amount of debugging time.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行得很好。我建议你逐步构建复杂的图表，并独立测试每个步骤。采用这种方法，你可以确保每个迭代都按预期工作，并能节省大量的调试时间。
- en: Next, let’s create nodes for our expert agents. We will use the ReAct agent
    with the SQL tool we previously built as the database agent.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建专家代理节点。我们将使用带有 SQL 工具的 ReAct 代理，将其作为数据库代理。
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For LangChain-related questions, we will use the ReAct agent. To enable the
    agent to answer questions about the library, we will equip it with a search engine
    tool. I chose [Tavily](https://tavily.com/) for this purpose as it provides the
    search results optimised for LLM applications.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与 LangChain 相关的问题，我们将使用 ReAct 代理。为了使该代理能够回答关于库的问题，我们将为其配备一个搜索引擎工具。我选择了 [Tavily](https://tavily.com/)
    作为此目的，因为它提供了针对 LLM 应用优化的搜索结果。
- en: If you don’t have an account, you can register to use Tavily for free (up to
    1K requests per month). To get started, you will need to specify the Tavily API
    key in an environment variable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有账户，你可以注册并免费使用 Tavily（每月最多 1K 次请求）。要开始使用，你需要在环境变量中指定 Tavily API 密钥。
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For general questions, we will leverage a simple LLM model without specific
    tools.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一般问题，我们将利用一个简单的 LLM 模型，而不使用特定工具。
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The last missing bit is a conditional function for routing. This will be quite
    straightforward—we just need to propagate the question type from the state defined
    by the router node.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺少的部分是一个条件函数，用于路由。这将非常简单——我们只需要从路由节点定义的状态中传递问题类型。
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, it’s time to create our graph.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建我们的图表了。
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](../Images/211fb819f5f309883906e7f790e155b4.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/211fb819f5f309883906e7f790e155b4.png)'
- en: Now, we can test the setup on a couple of questions to see how well it performs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过几个问题来测试该设置，看看它的表现如何。
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Good job! It gives a relevant result for the database-related question. Let’s
    try asking about LangChain.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！它为与数据库相关的问题提供了相关结果。让我们试着问一些关于 LangChain 的问题。
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Fantastic! Everything is working well, and it’s clear that Tavily's search is
    effective for LLM applications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！一切都运行良好，显然 Tavily 的搜索对 LLM 应用非常有效。
- en: Adding human-in-the-loop interactions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加人类参与的交互
- en: We’ve done an excellent job creating a tool to answer questions. However, in
    many cases, it’s beneficial to keep a human in the loop to approve proposed actions
    or provide additional feedback. Let’s add a step where we can collect feedback
    from a human before returning the final result to the user.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了一个能够回答问题的工具。然而，在许多情况下，让人类参与其中以批准提议的操作或提供额外的反馈是非常有益的。让我们添加一个步骤，在返回最终结果给用户之前收集人类的反馈。
- en: 'The simplest approach is to add two additional nodes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是添加两个额外的节点：
- en: A `human` node to gather feedback,
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `人类` 节点，用于收集反馈，
- en: An `editor` node to revisit the answer, taking into account the feedback.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `编辑器` 节点，用于根据反馈重新审视答案。
- en: 'Let’s create these nodes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这些节点：
- en: '**Human node:** This will be a dummy node, and it won’t perform any actions.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人类节点：** 这将是一个虚拟节点，它不会执行任何操作。'
- en: '**Editor node:** This will be an LLM model that receives all the relevant information
    (customer question, draft answer and provided feedback) and revises the final
    answer.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器节点：** 这将是一个 LLM 模型，用于接收所有相关信息（客户问题、草拟答案和提供的反馈）并修订最终答案。'
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Let’s add these nodes to our graph. Additionally, we need to introduce an interruption
    before the human node to ensure that the process pauses for human feedback.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些节点添加到我们的图中。此外，我们需要在“人类”节点之前引入一个中断，以确保流程暂停以获取人类反馈。
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![](../Images/4087a0dfd9d81b876f3270713c20e8ac.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4087a0dfd9d81b876f3270713c20e8ac.png)'
- en: Now, when we run the graph, the execution will be stopped before the human node.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行图时，执行将在“人类”节点之前停止。
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let’s get the customer input and update the state with the feedback.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取客户的反馈并更新状态。
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can check the state to confirm that the feedback has been populated and that
    the next node in the sequence is `editor`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查状态，以确认反馈已经被填充，并且序列中的下一个节点是`editor`。
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can just continue the execution. Passing `None` as input will resume the
    process from the point where it was paused.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续执行。传递`None`作为输入将从暂停的位置恢复流程。
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The editor took our feedback into account and added some polite words to our
    final message. That’s a fantastic result!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器考虑了我们的反馈，并在最终信息中添加了一些礼貌的词语。这是一个非常棒的结果！
- en: We can implement human-in-the-loop interactions in a more agentic way by equipping
    our editor with the [Human](https://python.langchain.com/v0.2/docs/integrations/tools/human_tools/)
    tool.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为编辑器配备[Human](https://python.langchain.com/v0.2/docs/integrations/tools/human_tools/)工具，以更具代理性的方式实现人类在环的互动。
- en: Let’s adjust our editor. I’ve slightly changed the prompt and added the tool
    to the agent.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整我们的编辑器。我稍微修改了提示，并向代理中添加了工具。
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, the editor reached out to the human with the question, “Is the draft answer
    complete and accurate for the customer’s question about the types of fields in
    the ecommerce_db.users table?”. After receiving feedback, the editor refined the
    answer to make it more user-friendly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，编辑向人类提问：“草稿中的回答是否完整且准确地回答了关于ecommerce_db.users表中字段类型的问题？”在收到反馈后，编辑修改了答案，使其更易于理解。
- en: Let’s update our main graph to incorporate the new agent instead of using the
    two separate nodes. With this approach, we don’t need interruptions any more.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的主图，合并新的代理，而不是使用两个独立的节点。采用这种方法后，我们不再需要中断。
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This graph will work similarly to the previous one. I personally prefer this
    approach since it leverages tools, making the solution more agile. For example,
    agents can reach out to humans multiple times and refine questions as needed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图的工作方式与之前的类似。我个人更喜欢这种方法，因为它利用了工具，使得解决方案更加灵活。例如，代理可以多次联系到人类，并根据需要调整问题。
- en: That’s it. We’ve built a multi-agent system that can answer questions from different
    domains and take into account human feedback.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们已经构建了一个多代理系统，可以回答来自不同领域的问题，并考虑到人类反馈。
- en: You can find the complete code on [GitHub](https://github.com/miptgirl/miptgirl_medium/blob/main/langgraph_answering_questions/langgraph.ipynb).
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在[GitHub](https://github.com/miptgirl/miptgirl_medium/blob/main/langgraph_answering_questions/langgraph.ipynb)上找到完整的代码。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this article, we’ve explored the LangGraph library and its application for
    building single and multi-agent workflows. We’ve examined a range of its capabilities,
    and now it's time to summarise its strengths and weaknesses. Also, it will be
    useful to compare LangGraph with CrewAI, which we discussed in [my previous article](https://medium.com/towards-data-science/multi-ai-agent-systems-101-bac58e3bcc47).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们探讨了LangGraph库及其在构建单一和多代理工作流中的应用。我们审视了其一系列功能，现在是总结其优缺点的时候了。同时，比较LangGraph和我在[上一篇文章](https://medium.com/towards-data-science/multi-ai-agent-systems-101-bac58e3bcc47)中讨论的CrewAI也会很有用。
- en: 'Overall, I find LangGraph quite a powerful framework for building complex LLM
    applications:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我认为LangGraph是一个相当强大的框架，用于构建复杂的LLM应用：
- en: LangGraph is a low-level framework that offers extensive customisation options,
    allowing you to build precisely what you need.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangGraph是一个低级框架，提供了广泛的自定义选项，使你能够构建出精确所需的内容。
- en: Since LangGraph is built on top of LangChain, it’s seamlessly integrated into
    its ecosystem, making it easy to leverage existing tools and components.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于LangGraph建立在LangChain之上，它与LangChain的生态系统无缝集成，使得利用现有工具和组件变得更加容易。
- en: 'However, there are areas where LangGrpah could be improved:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，LangGraph还有一些可以改进的地方：
- en: The agility of LangGraph comes with a higher entry barrier. While you can understand
    the concepts of CrewAI within 15–30 minutes, it takes some time to get comfortable
    and up to speed with LangGraph.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangGraph的灵活性带来了较高的入门门槛。虽然你可以在15至30分钟内理解CrewAI的概念，但要真正熟悉并跟上LangGraph的节奏则需要一些时间。
- en: LangGraph provides you with a higher level of control, but it misses some cool
    prebuilt features of CrewAI, such as [collaboration](https://docs.crewai.com/core-concepts/Collaboration/)
    or ready-to-use [RAG](https://docs.crewai.com/core-concepts/Tools/#available-crewai-tools)
    tools.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangGraph 为你提供了更高的控制水平，但它缺少 CrewAI 一些很酷的预构建功能，比如[协作](https://docs.crewai.com/core-concepts/Collaboration/)或现成的[检索增强生成（RAG）](https://docs.crewai.com/core-concepts/Tools/#available-crewai-tools)工具。
- en: LangGraph doesn’t enforce best practices like CrewAI does (for example, role-playing
    or guardrails). So it can lead to poorer results.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LangGraph 并不像 CrewAI 那样强制执行最佳实践（例如，角色扮演或护栏）。因此，它可能导致较差的结果。
- en: I would say that CrewAI is a better framework for newbies and common use cases
    because it helps you get good results quickly and provides guidance to prevent
    mistakes.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为 CrewAI 是一个更适合新手和常见用例的框架，因为它帮助你快速获得良好的结果，并提供指导以防止错误。
- en: If you want to build an advanced application and need more control, LangGraph
    is the way to go. Keep in mind that you’ll need to invest time in learning LangGraph
    and should be fully responsible for the final solution, as the framework won’t
    provide guidance to help you avoid common mistakes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想构建一个高级应用并需要更多的控制，LangGraph 是更好的选择。请记住，你需要投入时间来学习 LangGraph，并且要对最终解决方案负责，因为该框架不会提供指导帮助你避免常见的错误。
- en: Thank you a lot for reading this article. I hope this article was insightful
    for you. If you have any follow-up questions or comments, please leave them in
    the comments section.
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 非常感谢你阅读本文。我希望本文对你有所启发。如果你有任何后续问题或评论，请在评论区留言。
- en: Reference
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: This article is inspired by the [“AI Agents in LangGraph”](https://www.deeplearning.ai/short-courses/ai-agents-in-langgraph/)
    short course from DeepLearning.AI.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本文灵感来源于 DeepLearning.AI 的[“LangGraph中的AI代理”](https://www.deeplearning.ai/short-courses/ai-agents-in-langgraph/)短期课程。

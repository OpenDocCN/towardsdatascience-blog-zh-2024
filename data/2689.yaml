- en: Building Knowledge Graphs with LLM Graph Transformer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LLM 图变换器构建知识图谱
- en: 原文：[https://towardsdatascience.com/building-knowledge-graphs-with-llm-graph-transformer-a91045c49b59?source=collection_archive---------0-----------------------#2024-11-05](https://towardsdatascience.com/building-knowledge-graphs-with-llm-graph-transformer-a91045c49b59?source=collection_archive---------0-----------------------#2024-11-05)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/building-knowledge-graphs-with-llm-graph-transformer-a91045c49b59?source=collection_archive---------0-----------------------#2024-11-05](https://towardsdatascience.com/building-knowledge-graphs-with-llm-graph-transformer-a91045c49b59?source=collection_archive---------0-----------------------#2024-11-05)
- en: A deep dive into LangChain’s implementation of graph construction with LLMs
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入探讨 LangChain 在使用 LLM 构建图谱方面的实现
- en: '[](https://bratanic-tomaz.medium.com/?source=post_page---byline--a91045c49b59--------------------------------)[![Tomaz
    Bratanic](../Images/d5821aa70918fcb3fc1ff0013497b3d5.png)](https://bratanic-tomaz.medium.com/?source=post_page---byline--a91045c49b59--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--a91045c49b59--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--a91045c49b59--------------------------------)
    [Tomaz Bratanic](https://bratanic-tomaz.medium.com/?source=post_page---byline--a91045c49b59--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://bratanic-tomaz.medium.com/?source=post_page---byline--a91045c49b59--------------------------------)[![Tomaz
    Bratanic](../Images/d5821aa70918fcb3fc1ff0013497b3d5.png)](https://bratanic-tomaz.medium.com/?source=post_page---byline--a91045c49b59--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--a91045c49b59--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--a91045c49b59--------------------------------)
    [Tomaz Bratanic](https://bratanic-tomaz.medium.com/?source=post_page---byline--a91045c49b59--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--a91045c49b59--------------------------------)
    ·17 min read·Nov 5, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--a91045c49b59--------------------------------)
    ·阅读时长17分钟·2024年11月5日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/c100d65f7368e26e05871fc243e2c8d2.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c100d65f7368e26e05871fc243e2c8d2.png)'
- en: Building knowledge graph. Image by ChatGPT.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 构建知识图谱。图像来自 ChatGPT。
- en: Creating graphs from text is incredibly exciting, but definitely challenging.
    Essentially, it’s about converting unstructured text into structured data. While
    this approach has been around for some time, it gained significant traction with
    the advent of Large Language Models (LLMs), bringing it more into the mainstream.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本创建图谱令人非常兴奋，但无疑也充满挑战。本质上，这就是将非结构化文本转化为结构化数据。虽然这种方法已经存在一段时间，但随着大型语言模型（LLMs）的出现，它获得了显著的关注，逐渐走向主流。
- en: '![](../Images/391f15d81764d9d695809c24cb771da0.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/391f15d81764d9d695809c24cb771da0.png)'
- en: Extracting entities and relationships from text to construct a knowledge graph.
    Image by author.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本中提取实体和关系来构建知识图谱。图像来自作者。
- en: In the image above, you can see how information extraction transforms raw text
    into a knowledge graph. On the left, multiple documents show unstructured sentences
    about individuals and their relationships with companies. On the right, this same
    information is represented as a graph of entities and their connections, showing
    who worked at or founded various organizations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以看到信息提取如何将原始文本转换为知识图谱。在左侧，多个文档展示了关于个人及其与公司之间关系的非结构化句子。在右侧，这些相同的信息以图形的形式展示，图中展示了谁曾在或创办了不同的组织。
- en: But why would you want to extract structured information from text and represent
    it as a graph? One key reason is to power retrieval-augmented generation (RAG)
    applications. While using text embedding models over unstructured text is an useful
    approach, it can fall short when it comes to answering [complex, multi-hop questions](https://medium.com/neo4j/knowledge-graphs-llms-multi-hop-question-answering-322113f53f51)
    that require understanding connections across multiple entities or question where
    [structured operations like filtering, sorting, and aggregation](https://medium.com/neo4j/limitations-of-text-embeddings-in-rag-applications-b060020b543b)
    is required. By extracting structured information from text and constructing knowledge
    graphs, you not only organize data more effectively but also create a powerful
    framework for understanding complex relationships between entities. This structured
    approach makes it much easier to retrieve and leverage specific information, expanding
    the types of questions you can answer while providing greater accuracy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么你想从文本中提取结构化信息并将其表示为图形呢？一个关键原因是为检索增强生成（RAG）应用程序提供支持。虽然在非结构化文本上使用文本嵌入模型是一种有用的方法，但当涉及到回答[复杂的多跳问题](https://medium.com/neo4j/knowledge-graphs-llms-multi-hop-question-answering-322113f53f51)时，它可能不够有效，因为这些问题需要理解多个实体之间的连接，或者问题要求进行[如过滤、排序和聚合](https://medium.com/neo4j/limitations-of-text-embeddings-in-rag-applications-b060020b543b)等结构化操作。通过从文本中提取结构化信息并构建知识图谱，你不仅能更有效地组织数据，还能为理解实体之间的复杂关系创建一个强大的框架。这种结构化的方法使得检索和利用特定信息变得更加容易，从而扩展了你能够回答的问题类型，同时提供更高的准确性。
- en: Around a year ago, I began [experimenting with building graphs using LLMs](https://medium.com/@bratanic-tomaz/constructing-knowledge-graphs-from-text-using-openai-functions-096a6d010c17),
    and due to the growing interest, we decided to integrate this capability into
    LangChain as the [LLM Graph Transformer](https://python.langchain.com/docs/how_to/graph_constructing/).
    Over the past year, we’ve gained valuable insights and introduced new features,
    which we’ll be showcasing in this blog post.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大约一年前，我开始了[使用 LLM 构建图形的实验](https://medium.com/@bratanic-tomaz/constructing-knowledge-graphs-from-text-using-openai-functions-096a6d010c17)，由于越来越多的兴趣，我们决定将这一功能集成到
    LangChain 中，成为[LLM 图形转换器](https://python.langchain.com/docs/how_to/graph_constructing/)。在过去的一年里，我们获得了宝贵的见解并引入了新功能，我们将在这篇博客文章中展示这些内容。
- en: The code is available on [GitHub](https://github.com/tomasonjo/blogs/blob/master/llm/llm_graph_transformer_in_depth.ipynb).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在[GitHub](https://github.com/tomasonjo/blogs/blob/master/llm/llm_graph_transformer_in_depth.ipynb)上找到。
- en: Setting up Neo4j environment
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Neo4j 环境
- en: We will use Neo4j as the underlying graph store, which comes with out-of-the
    box graph visualizations. The easiest way to get started is to use a free instance
    of [Neo4j Aura](https://neo4j.com/cloud/platform/aura-graph-database/), which
    offers cloud instances of the Neo4j database. Alternatively, you can set up a
    local instance of the Neo4j database by downloading the [Neo4j Desktop](https://neo4j.com/download/)
    application and creating a local database instance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Neo4j 作为底层图形存储，它提供开箱即用的图形可视化。最简单的开始方式是使用免费的[Neo4j Aura](https://neo4j.com/cloud/platform/aura-graph-database/)实例，它提供云实例的
    Neo4j 数据库。或者，你也可以通过下载[Neo4j Desktop](https://neo4j.com/download/)应用程序并创建本地数据库实例来设置
    Neo4j 数据库的本地实例。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: LLM Graph Transformer
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLM 图形转换器
- en: The LLM Graph Transformer was designed to provide a flexible framework for building
    graphs using any LLM. With so many different providers and models available, this
    task is far from simple. Fortunately, LangChain steps in to handle much of the
    standardization process. As for the LLM Graph Transformer itself, it’s like two
    cats stacked in a trench coat —with the ability to operate in two completely independent
    modes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: LLM 图形转换器被设计为提供一个灵活的框架，用于使用任何 LLM 构建图形。由于有如此多不同的提供商和模型可用，这个任务远非简单。幸运的是，LangChain
    介入处理了大部分标准化过程。至于 LLM 图形转换器本身，它就像是两只猫堆叠在一件外套里——具有在两种完全独立的模式下操作的能力。
- en: '![](../Images/6657e49d4e353000a1cc75cda74536e7.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6657e49d4e353000a1cc75cda74536e7.png)'
- en: LLM Graph Transformer consists of two separate modes of extracting graphs from
    text. Image by user.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: LLM 图形转换器由两种不同的模式组成，用于从文本中提取图形。图片由用户提供。
- en: The LLM Graph Transformer operates in two distinct modes, each designed to generate
    graphs from documents using an LLM in different scenarios.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: LLM 图形转换器在两种不同的模式下操作，每种模式都旨在在不同场景下使用 LLM 从文档中生成图形。
- en: '**Tool-Based Mode (Default):** When the LLM supports structured output or function
    calling, this mode leverages the [LLM’s built-in](https://python.langchain.com/docs/how_to/structured_output/)
    `[with_structured_output](https://python.langchain.com/docs/how_to/structured_output/)`[to
    use tools](https://python.langchain.com/docs/how_to/structured_output/). The tool
    specification defines the output format, ensuring that entities and relationships
    are extracted in a structured, predefined manner. This is depicted on the left
    side of the image, where code for the Node and Relationship classes is shown.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于工具的模式（默认）：** 当LLM支持结构化输出或函数调用时，这种模式利用[LLM内建的](https://python.langchain.com/docs/how_to/structured_output/)`[with_structured_output](https://python.langchain.com/docs/how_to/structured_output/)`[来使用工具](https://python.langchain.com/docs/how_to/structured_output/)。工具规范定义了输出格式，确保实体和关系以结构化、预定义的方式被提取。这在图像的左侧显示，其中展示了`Node`和`Relationship`类的代码。'
- en: '**Prompt-Based Mode (Fallback):** In situations where the LLM doesn’t support
    tools or function calls, the LLM Graph Transformer falls back to a purely prompt-driven
    approach. This mode uses few-shot prompting to define the output format, guiding
    the LLM to extract entities and relationships in a text-based manner. The results
    are then parsed through a custom function, which converts the LLM’s output into
    a JSON format. This JSON is used to populate nodes and relationships, just as
    in the tool-based mode, but here the LLM is guided entirely by prompting rather
    than structured tools. This is shown on the right side of the image, where an
    example prompt and resulting JSON output are provided.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基于提示的模式（回退模式）：** 当LLM不支持工具或函数调用时，LLM图形转换器会回退到纯粹由提示驱动的方法。这种模式使用少量提示来定义输出格式，引导LLM以基于文本的方式提取实体和关系。然后，结果会通过一个自定义函数进行解析，该函数将LLM的输出转换为JSON格式。这个JSON会用来填充节点和关系，就像在基于工具的模式中一样，但在这里LLM完全由提示引导，而不是通过结构化工具。这在图像的右侧显示，其中提供了一个示例提示和相应的JSON输出。'
- en: These two modes ensure that the LLM Graph Transformer is adaptable to different
    LLMs, allowing it to build graphs either directly using tools or by parsing output
    from a text-based prompt.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式确保LLM图形转换器可以适应不同的LLM，使其能够通过工具直接构建图形，或者通过解析基于文本的提示输出构建图形。
- en: '*Note that you can use prompt-based extraction even with models that support
    tools/functions by setting the attribute* `*ignore_tools_usage=True*`*.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，即使是支持工具/函数的模型，你也可以通过设置属性`*ignore_tools_usage=True*`来使用基于提示的提取。*'
- en: Tool-based extraction
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于工具的提取
- en: We initially chose a tool-based approach for extraction since it minimized the
    need for extensive prompt engineering and custom parsing functions. In LangChain,
    the `with_structured_output` method allows you to extract information using tools
    or functions, with output defined either through a JSON structure or a Pydantic
    object. Personally, I find Pydantic objects clearer, so we opted for that.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初选择了基于工具的提取方法，因为它减少了大量提示工程和自定义解析函数的需求。在LangChain中，`with_structured_output`方法允许你使用工具或函数提取信息，输出可以通过JSON结构或Pydantic对象来定义。就个人而言，我发现Pydantic对象更清晰，因此我们选择了这种方式。
- en: We start by defining a `Node` class.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个`Node`类。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each node has an `id`, a `label`, and optional `properties`. For brevity, I
    haven’t included full descriptions here. Describing ids as human-readable unique
    identifier is important since some LLMs tend to understand ID properties in more
    traditional way like random strings or incremental integers. Instead we want the
    name of entities to be used as id property. We also limit the available label
    types by simply listing them in the `label`description. Additionally, LLMs like
    OpenAI’s, support an `enum` parameter, which we also use.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都有一个`id`、一个`label`和可选的`properties`。为了简洁起见，我在这里没有包含详细的描述。描述ID作为人类可读的唯一标识符很重要，因为一些大型语言模型（LLMs）往往以更传统的方式理解ID属性，例如随机字符串或递增的整数。而我们希望实体的名称作为ID属性来使用。我们还通过在`label`描述中简单列出可用的标签类型来限制可用的标签类型。此外，像OpenAI这样的LLM支持`enum`参数，我们也在使用这个参数。
- en: Next, we take a look at the `Relationship` class
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下`Relationship`类。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is the second iteration of the `Relationship` class. Initially, we used
    a nested `Node` object for the source and target nodes, but we quickly found that
    nested objects reduced the accuracy and quality of the extraction process. So,
    we decided to flatten the source and target nodes into separate fields—for example,
    `source_node_id` and `source_node_label`, along with `target_node_id` and `target_node_label`.
    Additionally, we define the allowed values in the descriptions for node labels
    and relationship types to ensure the LLMs adhere to the specified graph schema.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Relationship`类的第二次迭代。最初，我们使用嵌套的`Node`对象表示源节点和目标节点，但我们很快发现嵌套对象降低了提取过程的准确性和质量。因此，我们决定将源节点和目标节点平铺为独立的字段——例如，`source_node_id`和`source_node_label`，以及`target_node_id`和`target_node_label`。此外，我们在节点标签和关系类型的描述中定义了允许的值，以确保LLM遵守指定的图形模式。
- en: The tool-based extraction approach enables us to define properties for both
    nodes and relationships. Below is the class we used to define them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 基于工具的提取方法使我们能够为节点和关系定义属性。以下是我们用来定义这些属性的类。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each `Property` is defined as a key-value pair. While this approach is flexible,
    it has its limitations. For instance, we can't provide a unique description for
    each property, nor can we specify certain properties as mandatory while others
    optional, so all properties are defined as optional. Additionally, properties
    aren't defined individually for each node or relationship type but are instead
    shared across all of them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Property`都被定义为一个键值对。虽然这种方法很灵活，但也有其局限性。例如，我们不能为每个属性提供独特的描述，也不能指定某些属性为必填项而其他为可选项，因此所有属性都被定义为可选。此外，属性并不是为每种节点或关系类型单独定义的，而是共享的。
- en: We’ve also implemented a [detailed system prompt](https://github.com/langchain-ai/langchain-experimental/blob/main/libs/experimental/langchain_experimental/graph_transformers/llm.py#L72)
    to help guide the extraction. In my experience, though, the function and argument
    descriptions tend to have a greater impact than the system message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了一个[详细的系统提示](https://github.com/langchain-ai/langchain-experimental/blob/main/libs/experimental/langchain_experimental/graph_transformers/llm.py#L72)，帮助指导提取过程。不过根据我的经验，功能和参数描述往往比系统消息更具影响力。
- en: Unfortunately, at the moment, there is no simple way to customize function or
    argument descriptions in LLM Graph Transformer.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前没有简单的方法来定制LLM图形变换器中的功能或参数描述。
- en: Prompt-based extraction
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于提示的提取
- en: Since only a few commercial LLMs and LLaMA 3 support native tools, we implemented
    a fallback for models without tool support. You can also set `ignore_tool_usage=True`
    to switch to a prompt-based approach even when using a model that supports tools.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有少数商业化的LLM和LLaMA 3支持本地工具，我们为不支持工具的模型实现了回退机制。即使使用支持工具的模型，你也可以设置`ignore_tool_usage=True`来切换到基于提示的方法。
- en: Most of the prompt engineering and examples for the prompt-based approach were
    contributed by [Geraldus Wilsen](https://www.linkedin.com/in/geraldus-wilsen/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分基于提示方法的提示工程和示例由[Geraldus Wilsen](https://www.linkedin.com/in/geraldus-wilsen/)贡献。
- en: With the prompt-based approach, we have to define the output structure directly
    in the prompt. You can find the [whole prompt here](https://github.com/langchain-ai/langchain-experimental/blob/main/libs/experimental/langchain_experimental/graph_transformers/llm.py#L206).
    In this blog post, we’ll just do a high-level overview. We start by defining the
    system prompt.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于提示的方法中，我们必须直接在提示中定义输出结构。你可以在[这里找到完整的提示](https://github.com/langchain-ai/langchain-experimental/blob/main/libs/experimental/langchain_experimental/graph_transformers/llm.py#L206)。在这篇博客文章中，我们将做一个高层次的概述。我们从定义系统提示开始。
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the prompt-based approach, a key difference is that we ask the LLM to extract
    only relationships, not individual nodes. This means we won’t have any *isolated
    nodes*, unlike with the tool-based approach. Additionally, because models lacking
    native tool support typically perform worse, we do not allow extraction any properties
    — whether for nodes or relationships, to keep the extraction output simpler.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于提示的方法中，一个关键区别是我们要求LLM仅提取关系，而不是单独的节点。这意味着我们不会有任何*孤立节点*，与基于工具的方法不同。此外，由于缺乏本地工具支持的模型通常表现较差，我们不允许提取任何属性——无论是节点还是关系，以保持提取结果的简洁性。
- en: Next, we add a couple of few-shot examples to the model.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向模型添加了一些少量示例。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this approach, there’s currently no support for adding custom few-shot examples
    or extra instructions. The only way to customize is by modifying the entire prompt
    through the `prompt`attribute. Expanding customization options is something we’re
    actively considering.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，目前不支持添加自定义的少量示例或额外指令。唯一的定制方式是通过 `prompt` 属性修改整个提示。扩展定制选项是我们正在积极考虑的事项。
- en: Next, we’ll take a look at defining the graph schema.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何定义图谱架构。
- en: Defining the graph schema
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义图谱架构
- en: When using the LLM Graph Transformer for information extraction, defining a
    graph schema is essential for guiding the model to build meaningful and structured
    knowledge representations. A well-defined graph schema specifies the types of
    nodes and relationships to be extracted, along with any attributes associated
    with each. This schema serves as a blueprint, ensuring that the LLM consistently
    extracts relevant information in a way that aligns with the desired knowledge
    graph structure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 LLM 图谱转换器进行信息提取时，定义图谱架构对于指导模型构建有意义且结构化的知识表示至关重要。一个明确定义的图谱架构指定了要提取的节点和关系的类型，以及与每个节点或关系相关的任何属性。这个架构作为蓝图，确保
    LLM 始终以符合预期知识图谱结构的方式提取相关信息。
- en: In this blog post, we’ll use the opening paragraph of [Marie Curie’s Wikipedia
    page](https://en.wikipedia.org/wiki/Marie_Curie) for testing with an added sentence
    at the end about Robin Williams.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇博文中，我们将使用[玛丽·居里维基百科页面](https://en.wikipedia.org/wiki/Marie_Curie)的开头段落进行测试，并在末尾添加一段关于罗宾·威廉姆斯的句子。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We’ll also be using GPT-4o in all examples.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有示例中，我们还将使用 GPT-4o。
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To start, let’s examine how the extraction process works without defining any
    graph schema.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看在没有定义任何图谱架构的情况下，提取过程是如何工作的。
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we can process the documents using the `aconvert_to_graph_documents` function,
    which is asynchronous. Using async with LLM extraction is recommended, as it allows
    for parallel processing of multiple documents. This approach can significantly
    reduce wait times and improve throughput, especially when dealing with multiple
    documents.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用 `aconvert_to_graph_documents` 函数处理文档，该函数是异步的。推荐在 LLM 提取中使用异步方式，因为它允许并行处理多个文档。这种方法可以显著减少等待时间并提高吞吐量，尤其是在处理多个文档时。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The response from the LLM Graph Transformer will be a graph document, which
    has the following structure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: LLM 图谱转换器的响应将是一个图谱文档，其结构如下：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The graph document describes extracted `nodes` and `relationships` . Additionally,
    the source document of the extraction is added under the `source` key.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图谱文档描述了提取的 `节点` 和 `关系`。此外，提取的源文档会添加在 `source` 键下。
- en: We can use the Neo4j Browser to visualize the outputs, providing a clearer and
    more intuitive understanding of the data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Neo4j 浏览器来可视化输出，从而更清晰、更直观地理解数据。
- en: '![](../Images/a13874667bfc937faf32649450a465a7.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a13874667bfc937faf32649450a465a7.png)'
- en: Visualization of two extraction passes over the same dataset without a defined
    graph schema. Image by author.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 没有定义图谱架构的情况下，对同一数据集进行两次提取的可视化。图片来自作者。
- en: The image above shows two extraction passes over the same paragraph about Marie
    Curie. In this case, we used GPT-4 with tool-based extraction, which also allows
    for isolated nodes, as illustrated in the image. Because no graph schema was defined,
    the LLM determines at runtime what information to extract, which can lead to variations
    in the output, even from the same paragraph. As a result, some extractions are
    more detailed than others and may vary in structure, even for the same information.
    For instance, on the left, Marie is represented as the `WINNER`of the Nobel Prize,
    while on the right, she `WON`the Nobel Prize.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图片显示了两次提取同一段关于玛丽·居里的段落。在这种情况下，我们使用了 GPT-4 和基于工具的提取方法，这也允许存在孤立的节点，如图中所示。由于没有定义图谱架构，LLM
    在运行时决定提取哪些信息，这可能导致输出的变化，即使是同一段落。因此，有些提取比其他的更详细，结构也可能有所不同，即使是相同的信息。例如，在左侧，玛丽被表示为诺贝尔奖的`获奖者`，而在右侧，她被表示为`赢得`了诺贝尔奖。
- en: Now, let’s try the same extraction using the prompt-based approach. For models
    that support tools, you can enable prompt-based extraction by setting the `ignore_tool_usage`parameter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用基于提示的方法进行相同的提取。对于支持工具的模型，可以通过设置 `ignore_tool_usage` 参数来启用基于提示的提取。
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Again, we can visualize two separate executions in Neo4j Browser.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在 Neo4j 浏览器中可视化两次独立的执行。
- en: '![](../Images/a68da1cdfec428b4b7f1d626e032f4eb.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a68da1cdfec428b4b7f1d626e032f4eb.png)'
- en: Visualization of two extraction passes over the same dataset without a defined
    graph schema using the prompt-based approach. Image by author.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于提示的方法，在没有定义图模式的情况下对相同数据集进行两次提取的可视化。图像来源：作者。
- en: With the prompt-based approach, we won’t see any isolated nodes. However, as
    with previous extractions, the schema can vary between runs, resulting in different
    outputs on the same input.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 采用基于提示的方法，我们不会看到任何孤立的节点。然而，与之前的提取一样，模式在每次运行之间可能会有所不同，导致相同输入的输出结果不同。
- en: Next, let’s walk through how defining a graph schema can help produce more consistent
    outputs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们逐步了解如何通过定义图模式来帮助产生更一致的输出。
- en: Defining allowed nodes
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义允许的节点
- en: Constraining the extracted graph structure can be highly beneficial, as it guides
    the model to focus on specific, relevant entities and relationships. By defining
    a clear schema, you improve consistency across extractions, making the outputs
    more predictable and aligned with the information you actually need. This reduces
    variability between runs and ensures that the extracted data follows a standardized
    structure, capturing expected information. With a well-defined schema, the model
    is less likely to overlook key details or introduce unexpected elements, resulting
    in cleaner, more usable graphs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 限制提取的图结构可以非常有益，因为它指导模型聚焦于特定的相关实体和关系。通过定义一个明确的模式，你可以提高提取的一致性，使输出结果更加可预测，并与实际需要的信息对齐。这减少了不同运行之间的变异性，确保提取的数据遵循标准化结构，捕捉预期的信息。通过一个明确的模式，模型不太可能忽视关键细节或引入意外元素，从而生成更清晰、更易用的图。
- en: We’ll start by defining the expected types of nodes to extract using the `allowed_nodes`parameter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用`allowed_nodes`参数定义预期的节点类型开始。
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we defined that the LLM should extract five types of nodes like *Person*,
    *Organization*, *Location*, and more. We visualize two separate executions in
    Neo4j Browser for comparison.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了LLM应提取五种类型的节点，如*人*、*组织*、*地点*等。我们在Neo4j浏览器中可视化了两次独立的执行结果以进行比较。
- en: '![](../Images/4eb80ac824a94649476f98d7bd4cf60b.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4eb80ac824a94649476f98d7bd4cf60b.png)'
- en: Visualization of two extraction passes with predefined node types. Image by
    author.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预定义的节点类型进行两次提取的可视化。图像来源：作者。
- en: By specifying the expected node types, we achieve more consistent node extraction.
    However, some variation may still occur. For example, in the first run, “radioactivity”
    was extracted as a research field, while in the second, it was not.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定预期的节点类型，我们实现了更一致的节点提取。然而，仍然可能会出现一些变化。例如，在第一次运行中，“放射性”被提取为研究领域，而在第二次运行中则没有。
- en: Since we haven’t defined relationships, their types can also vary across runs.
    Additionally, some extractions may capture more information than others. For instance,
    the `MARRIED_TO`relationship between Marie and Pierre isn’t present in both extractions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有定义关系，因此它们的类型也可能在不同的运行中有所不同。此外，一些提取可能比其他提取捕获更多的信息。例如，Marie和Pierre之间的`MARRIED_TO`关系在两次提取中都没有出现。
- en: Now, let’s explore how defining relationship types can further improve consistency.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何通过定义关系类型来进一步提高一致性。
- en: Defining allowed relationships
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义允许的关系
- en: As we’ve observed, defining only node types still allows for variation in relationship
    extraction. To address this, let’s explore how to define relationships as well.
    The first approach is to specify allowed relationships using a list of available
    types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所观察到的，仅定义节点类型仍然会导致关系提取的变化。为了解决这个问题，让我们探讨如何定义关系。第一种方法是通过列出可用类型来指定允许的关系。
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s again examine two separate extractions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次检查两次独立的提取。
- en: '![](../Images/b8834e9764cd6bf340a7e99377b2dd47.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b8834e9764cd6bf340a7e99377b2dd47.png)'
- en: Visualization of two extraction passes with predefined node and relationship
    types. Image by author.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预定义的节点和关系类型进行两次提取的可视化。图像来源：作者。
- en: With both nodes and relationships defined, our outputs become significantly
    more consistent. For example, Marie is always shown as winning an award, being
    the spouse of Pierre, and working at the University of Paris. However, since relationships
    are specified as a general list without restrictions on which nodes they can connect,
    some variation still occurs. For instance, the `FIELD_OF_RESEARCH`relationship
    might appear between a `Person`and a `ResearchField`, but sometimes it links an
    `Award`to a `ResearchField`. Additionally, since relationship directions aren’t
    defined, there may be differences in directional consistency.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了节点和关系后，我们的输出变得更加一致。例如，玛丽总是被显示为获奖者、皮埃尔的配偶，以及巴黎大学的工作人员。然而，由于关系被指定为一般列表，并未限制可以连接的节点，因此仍然会出现一些变化。例如，`FIELD_OF_RESEARCH`关系可能出现在`Person`和`ResearchField`之间，但有时它也会将`Award`与`ResearchField`连接。此外，由于关系的方向尚未定义，方向一致性可能会有所不同。
- en: To address the issues of not being able to specify which nodes a relationship
    can connect and enforcing relationship direction, we recently introduced a new
    option for defining relationships, as shown below.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决无法指定关系可以连接哪些节点以及强制关系方向的问题，我们最近引入了一个新的选项来定义关系，如下所示。
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Rather than defining relationships as a simple list of strings, we now use a
    three-element tuple format, where the elements represents the source node, relationship
    type, and target node, respectively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不再将关系定义为简单的字符串列表，而是使用三元素元组格式，其中元素分别代表源节点、关系类型和目标节点。
- en: Let’s visualize the results again.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次可视化结果。
- en: '![](../Images/c26aee8a8356ce6ad2d431cf826e499d.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c26aee8a8356ce6ad2d431cf826e499d.png)'
- en: Visualization of two extraction passes with predefined node and advanced relationship
    types. Image by author.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预定义节点和高级关系类型的两次提取过程的可视化。图像来自作者。
- en: Using the three-tuple approach provides a much more consistent schema for the
    extracted graph across multiple executions. However, given the nature of LLMs,
    there may still be some variation in the level of detail extracted. For instance,
    on the right side, Pierre is shown as winning the Nobel Prize, while on the left,
    this information is missing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元组方法提供了一个更加一致的图谱模式，适用于多次执行的提取。然而，由于LLM的特性，提取的细节层次仍可能存在一些差异。例如，在右侧，皮埃尔被显示为获奖，而左侧则缺少这条信息。
- en: Defining properties
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义属性
- en: The final enhancement we can make to the graph schema is to define properties
    for nodes and relationships. Here, we have two options. The first is setting either
    `node_properties`or `relationship_properties`to `true`allows the LLM to autonomously
    decide which properties to extract.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对图谱模式做的最后一个增强是为节点和关系定义属性。在这里，我们有两个选择。第一个是设置`node_properties`或`relationship_properties`为`true`，允许LLM自主决定提取哪些属性。
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s examine the results.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下结果。
- en: '![](../Images/a49d80b92ca86d853d8a4856a6f67e89.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a49d80b92ca86d853d8a4856a6f67e89.png)'
- en: Extracted node and relationship properties. Image by author.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的节点和关系属性。图像来自作者。
- en: We’ve enabled the LLM to add any node or relationship properties it considers
    relevant. For instance, it chose to include Marie Curie’s birth and death dates,
    her role as a professor at the University of Paris, and the fact that she won
    the Nobel Prize twice. These additional properties significantly enrich the extracted
    information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经允许LLM添加它认为相关的任何节点或关系属性。例如，它选择包括玛丽·居里的出生和死亡日期、她在巴黎大学担任教授的身份，以及她两次获得诺贝尔奖的事实。这些附加属性显著丰富了提取的信息。
- en: The second option we have is to define the node and relationship properties
    we want to extract.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个选择是定义我们想要提取的节点和关系属性。
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The properties are simply defined as two lists. Let’s see what the LLM extracted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 属性仅仅是通过两个列表来定义的。让我们看看LLM提取了什么。
- en: '![](../Images/e10e408dd76aaa10d841f25d6b30922b.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e10e408dd76aaa10d841f25d6b30922b.png)'
- en: Extracted predefined node and relationship properties. Image by author.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的预定义节点和关系属性。图像来自作者。
- en: The birth and death dates remain consistent with the previous extraction. However,
    this time, the LLM also extracted the start date of Marie’s professorship at the
    University of Paris.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 出生和死亡日期与先前的提取结果一致。然而，这一次，LLM还提取了玛丽在巴黎大学担任教授的起始日期。
- en: 'Properties indeed add valuable depth to the extracted information, though there
    are currently some limitations in this implementation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 属性确实为提取的信息增加了有价值的深度，尽管目前这种实现存在一些限制：
- en: Properties can only be extracted using the tool-based approach.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性只能通过基于工具的方法进行提取。
- en: All properties are extracted as strings.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有属性都作为字符串提取。
- en: Properties can only be defined globally, not per node label or relationship
    type.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性只能全局定义，而不能按节点标签或关系类型定义。
- en: There is no option to customize property descriptions to guide the LLM for more
    precise extraction.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有选项可以自定义属性描述，以指导LLM进行更精确的提取。
- en: Strict mode
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严格模式
- en: If you thought we had perfected a way to make the LLM follow the defined schema
    flawlessly, I have to set the record straight. While we invested considerable
    effort into prompt engineering, it’s challenging to get LLM, especially the less
    performant one, to adhere to instructions with complete accuracy. To tackle this,
    we introduced a post-processing step, called `strict_mode`, that removes any information
    not conforming to the defined graph schema, ensuring cleaner and more consistent
    results.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为我们已经完善了一种方法，让LLM完美遵循定义的模式，我必须澄清一下。尽管我们在提示工程上投入了相当多的努力，但要让LLM，尤其是性能较差的LLM，完全准确地遵循指令是具有挑战性的。为了解决这个问题，我们引入了一个后处理步骤，称为`strict_mode`，它会去除任何不符合定义图模式的信息，从而确保更清洁、更一致的结果。
- en: 'By default, `strict_mode`is set to `True`, but you can disable it with the
    following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`strict_mode`设置为`True`，但您可以使用以下代码禁用它：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With strict mode turned off, you may get node or relationship types outside
    the defined graph schema, as LLMs can sometimes take creative liberties with output
    structure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭严格模式的情况下，您可能会遇到图模式之外的节点或关系类型，因为LLM有时会在输出结构上采取创造性自由。
- en: Importing graph documents into graph database
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图文档导入图数据库
- en: The extracted graph documents from the LLM Graph Transformer can be imported
    into graph databases like Neo4j for further analysis and applications using the
    `add_graph_documents` method. We’ll explore different options for importing this
    data to suit different use cases.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从LLM图转换器中提取的图文档可以使用`add_graph_documents`方法导入到像Neo4j这样的图数据库中，以便进行进一步的分析和应用。我们将探讨不同的导入选项，以适应不同的使用场景。
- en: '**Default import**'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**默认导入**'
- en: You can import nodes and relationships into Neo4j using the following code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码将节点和关系导入到Neo4j中。
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method straightforwardly imports all nodes and relationships from the provided
    graph documents. We’ve used this approach throughout the blog post to review the
    results of different LLM and schema configurations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法直接将所有节点和关系从提供的图文档导入。我们在整篇博客中使用了这种方法，以回顾不同LLM和模式配置的结果。
- en: '![](../Images/670cba1162b9e041fba881433e0dc851.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/670cba1162b9e041fba881433e0dc851.png)'
- en: Default import setting. Image by author.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认导入设置。图片由作者提供。
- en: Base entity label
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础实体标签
- en: Most graph databases support indexes to optimize data import and retrieval.
    In Neo4j, indexes can only be set for specific node labels. Since we might not
    know all the node labels in advance, we can handle this by adding a secondary
    base label to each node using the `baseEntityLabel`parameter. This way, we can
    still leverage indexing for efficient importing and retrieval without needing
    an index for every possible node label in the graph.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数图数据库支持索引，以优化数据的导入和检索。在Neo4j中，索引只能为特定的节点标签设置。由于我们可能无法提前知道所有的节点标签，我们可以通过使用`baseEntityLabel`参数为每个节点添加一个次级基础标签来处理这个问题。这样，我们仍然可以利用索引来实现高效的导入和检索，而不需要为图中每个可能的节点标签设置索引。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As mentioned, using the `baseEntityLabel` parameter will result in each node
    having an additional `__Entity__` label.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用`baseEntityLabel`参数会导致每个节点拥有额外的`__Entity__`标签。
- en: '![](../Images/2c5f7c083ec1ad026b69ac274b98c052.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2c5f7c083ec1ad026b69ac274b98c052.png)'
- en: Each node gets a secondary label using the baseEntityLabel parameter. Image
    by author.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都使用`baseEntityLabel`参数获得一个次级标签。图片由作者提供。
- en: Include source documents
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含源文档
- en: The final option is to also import the source documents for the extracted nodes
    and relationships. This approach lets us track which documents each entity appeared
    in. You can import the source documents using the `include_source` parameter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的选项是同时导入提取节点和关系的源文档。这种方法让我们能够追踪每个实体出现在哪些文档中。您可以使用`include_source`参数导入源文档。
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Upon inspecting the imported graph, we should see a result similar to this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查导入的图时，我们应该看到类似以下的结果。
- en: '![](../Images/c2cd17506e7328a3bfc5fe28cd56a00d.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c2cd17506e7328a3bfc5fe28cd56a00d.png)'
- en: Imported source document. Image by author.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的源文档。图片由作者提供。
- en: In this visualization, the source document is highlighted in blue, with all
    entities extracted from it connected by `MENTIONS`relationships. This mode allows
    you to build [retrievers that utilize both structured and unstructured search
    approaches](https://medium.com/neo4j/enhancing-the-accuracy-of-rag-applications-with-knowledge-graphs-ad5e2ffab663).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个可视化中，源文档被蓝色高亮显示，所有从中提取的实体通过 `MENTIONS` 关系连接。这种模式允许你构建[利用结构化和非结构化搜索方法的检索器](https://medium.com/neo4j/enhancing-the-accuracy-of-rag-applications-with-knowledge-graphs-ad5e2ffab663)。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this post, we explored LangChain’s LLM Graph Transformer and its dual modes
    for building knowledge graphs from text. The tool-based mode, our primary approach,
    leverages structured output and function calling, which reduces prompt engineering
    and allows for property extraction. Meanwhile, the prompt-based mode is useful
    when tools aren’t available, relying on few-shot examples to guide the LLM. However,
    prompt-based extraction does not support property extraction and also yields no
    isolated nodes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，我们探讨了 LangChain 的 LLM 图谱转换器及其两种构建知识图谱的模式。基于工具的模式是我们主要的方法，它利用结构化输出和函数调用，减少了提示词工程，并允许提取属性。与此同时，当没有工具可用时，基于提示的模式通过少量示例来引导
    LLM，尽管基于提示的提取不支持属性提取，也不会生成孤立节点。
- en: We observed that defining a clear graph schema, including allowed node and relationship
    types, improves extraction consistency and performance. A constrained schema helps
    ensure that the output adheres to our desired structure, making it more predictable,
    reliable, and applicable. Whether using tools or prompts, the LLM Graph Transformer
    enables more organized, structured representations of unstructured data, enabling
    better RAG applications and multi-hop query handling.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到，定义一个清晰的图谱模式，包括允许的节点和关系类型，有助于提高提取的一致性和性能。受限的模式有助于确保输出符合我们期望的结构，使其更加可预测、可靠和适用。无论是使用工具还是提示，LLM
    图谱转换器都能实现对非结构化数据的更有组织、结构化的表示，从而促进更好的 RAG 应用和多跳查询处理。
- en: The code is available on [GitHub](https://github.com/tomasonjo/blogs/blob/master/llm/llm_graph_transformer_in_depth.ipynb).
    You can also try out the LLM Graph Transformer in a no-code environment using
    Neo4j’s hosted **LLM Graph Builder** application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在 [GitHub](https://github.com/tomasonjo/blogs/blob/master/llm/llm_graph_transformer_in_depth.ipynb)
    上找到。你还可以在一个无代码环境中尝试使用 Neo4j 提供的**LLM 图谱构建器**应用程序。
- en: '[## Neo4j graph builder'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[## Neo4j 图谱构建器'
- en: No-code
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无代码
- en: llm-graph-builder.neo4jlabs.com](https://llm-graph-builder.neo4jlabs.com/?source=post_page-----a91045c49b59--------------------------------)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: llm-graph-builder.neo4jlabs.com](https://llm-graph-builder.neo4jlabs.com/?source=post_page-----a91045c49b59--------------------------------)

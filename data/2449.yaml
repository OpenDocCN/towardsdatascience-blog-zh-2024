- en: Nine Rules for Running Rust in the Browser
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中运行 Rust 的九条规则
- en: 原文：[https://towardsdatascience.com/nine-rules-for-running-rust-in-the-browser-8228353649d1?source=collection_archive---------1-----------------------#2024-10-08](https://towardsdatascience.com/nine-rules-for-running-rust-in-the-browser-8228353649d1?source=collection_archive---------1-----------------------#2024-10-08)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/nine-rules-for-running-rust-in-the-browser-8228353649d1?source=collection_archive---------1-----------------------#2024-10-08](https://towardsdatascience.com/nine-rules-for-running-rust-in-the-browser-8228353649d1?source=collection_archive---------1-----------------------#2024-10-08)
- en: Practical lessons from porting range-set-blaze to WASM
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从将 range-set-blaze 移植到 WASM 中获得的实践经验
- en: '[](https://medium.com/@carlmkadie?source=post_page---byline--8228353649d1--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page---byline--8228353649d1--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--8228353649d1--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--8228353649d1--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page---byline--8228353649d1--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@carlmkadie?source=post_page---byline--8228353649d1--------------------------------)[![Carl
    M. Kadie](../Images/9dbe27c76e9567136e5a7dc587f1fb15.png)](https://medium.com/@carlmkadie?source=post_page---byline--8228353649d1--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--8228353649d1--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--8228353649d1--------------------------------)
    [Carl M. Kadie](https://medium.com/@carlmkadie?source=post_page---byline--8228353649d1--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--8228353649d1--------------------------------)
    ·21 min read·Oct 8, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--8228353649d1--------------------------------)
    ·阅读时长：21分钟·2024年10月8日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/f6718aabbf0325b092e3b4437e3f96c6.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f6718aabbf0325b092e3b4437e3f96c6.png)'
- en: 'Rust Running on the Browser — Source: [https://openai.com/dall-e-2/](https://openai.com/dall-e-2/).
    All other figures from the author.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行 Rust — 来源：[https://openai.com/dall-e-2/](https://openai.com/dall-e-2/)。其他所有图像均来自作者。
- en: Do you want your Rust code to run everywhere — from large servers to web pages,
    robots, and even watches? In this second of three articles [[1](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a),
    [2](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1),
    [3](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)],
    I’ll show you how to use WebAssembly (WASM) to run your Rust code directly in
    the user’s browser.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你想让你的 Rust 代码无处不在——从大型服务器到网页、机器人，甚至手表吗？在这篇三篇文章中的第二篇[[1](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a),
    [2](https://medium.com/towards-data-science/nine-rules-for-running-rust-in-the-browser-8228353649d1),
    [3](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)]中，我将向你展示如何使用
    WebAssembly (WASM) 在用户的浏览器中直接运行 Rust 代码。
- en: With this technique, you can provide CPU-intensive, dynamic web pages from a
    — perhaps free — static web server. As a bonus, a user’s data never leaves their
    machine, avoiding privacy issues. For example, I offer a tool to search race results
    for friends, running club members, and teammates. To see the tool, go to [its
    web page](https://carlkcarlk.github.io/race-results/matcher/), and click “match”.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，你可以通过一个—或许是免费的—静态 web 服务器提供 CPU 密集型、动态网页。作为额外的好处，用户的数据永远不会离开他们的机器，避免了隐私问题。例如，我提供了一个工具，帮助朋友、跑步俱乐部成员和队友查找比赛结果。要查看该工具，请访问[其网页](https://carlkcarlk.github.io/race-results/matcher/)，并点击“match”。
- en: '![](../Images/138b2fdb5c996a8d2a16b26e4e50c943.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/138b2fdb5c996a8d2a16b26e4e50c943.png)'
- en: 'Aside: To learn more about matching names, see [Use Bayes’ Theorem to Find
    Distinctive Names in a List](https://medium.com/towards-data-science/use-bayes-theorem-to-find-distinctive-names-in-a-list-5acd8fe03c2b)
    in *Towards Data Science.*'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁注：要了解更多关于匹配名称的信息，请参阅[使用贝叶斯定理在列表中查找独特名称](https://medium.com/towards-data-science/use-bayes-theorem-to-find-distinctive-names-in-a-list-5acd8fe03c2b)，《*Towards
    Data Science*》中的文章。
- en: Running Rust in the browser presents challenges. Your code doesn’t have access
    to a full operating system like Linux, Windows, or macOS. You have no direct access
    to files or networks. You have only limited access to time and random numbers.
    We’ll explore workarounds and solutions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行 Rust 面临一些挑战。你的代码无法像 Linux、Windows 或 macOS 那样访问完整的操作系统。你无法直接访问文件或网络。你仅能有限地访问时间和随机数。我们将探讨一些解决方法和变通方案。
- en: 'Porting code to WASM in the browser requires several steps and choices, and
    navigating these can be time-consuming. Missing a step can lead to failure. We’ll
    reduce this complication by offering nine rules, which we’ll explore in detail:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码移植到浏览器中的WASM需要多个步骤和选择，且这些过程可能耗时。漏掉一步可能会导致失败。我们将通过提供九条规则来简化这一复杂性，接下来我们将详细探讨这些规则：
- en: Confirm that your existing app works with WASM WASI and create a simple JavaScript
    web page.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认你现有的应用程序可以与WASM WASI一起工作，并创建一个简单的JavaScript网页。
- en: Install the `wasm32-unknown-unknown` target, `wasm-pack`, `wasm-bindgen-cli`,
    and Chrome for Testing & Chromedriver.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`wasm32-unknown-unknown`目标、`wasm-pack`、`wasm-bindgen-cli`以及用于测试的Chrome和Chromedriver。
- en: Make your project `cdylib` (and `rlib`), add `wasm-bindgen` dependencies, and
    test.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使你的项目成为`cdylib`（以及`rlib`），添加`wasm-bindgen`依赖，并进行测试。
- en: Learn what types `wasm-bindgen` supports.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解`wasm-bindgen`支持哪些类型。
- en: Change functions to use supported types. Change files to generic `BufRead`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改函数以使用支持的类型。将文件更改为通用的`BufRead`。
- en: Adapt tests, skipping those that don’t apply.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 适配测试，跳过那些不适用的测试。
- en: Change to JavaScript-friendly dependencies, if necessary. Run tests.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，切换到适合JavaScript的依赖。运行测试。
- en: Connect your web page to your functions.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的网页与函数连接起来。
- en: Add `wasm-pack` to your CI (continuous integration) tests.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`wasm-pack`添加到你的CI（持续集成）测试中。
- en: 'Aside: These articles are based on a three-hour workshop that I presented at
    [RustConf24](https://rustconf.com/programs/#755) in Montreal. Thanks to the participants
    of that workshop. A special thanks, also, to the volunteers from the Seattle Rust
    Meetup who helped test this material. These articles replace [an article I wrote
    last year](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2)
    with updated information.'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁注：这些文章基于我在蒙特利尔的[RustConf24](https://rustconf.com/programs/#755)上进行的三小时工作坊。感谢工作坊的参与者。同时也特别感谢来自西雅图Rust
    Meetup的志愿者，他们帮助测试了这些材料。这些文章替代了我去年写的[一篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-the-web-and-on-embedded-94462ef249a2)，并且包含了更新的信息。
- en: As with [the first article in this series](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a),
    before we look at the rules one by one, let’s define our terms.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[本系列的第一篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a)中所述，在逐条查看规则之前，我们先来定义一下术语。
- en: '**Native:** Your home OS (Linux, Windows, macOS)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Native**：你的本地操作系统（Linux、Windows、macOS）'
- en: '**Standard library (std)**: Provides Rust’s core functionality — `Vec`, `String`,
    file input/output, networking, time.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准库（std）**：提供Rust的核心功能——`Vec`、`String`、文件输入/输出、网络、时间等。'
- en: '**WASM**: WebAssembly (WASM) is a binary instruction format that runs in most
    browsers (and beyond).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WASM**：WebAssembly（WASM）是一种二进制指令格式，可以在大多数浏览器中运行（以及其他平台）。'
- en: '**WASI**: WebAssembly System Interface (WASI) allows outside-the-browser WASM
    to access file I/O, networking (not yet), and time handling.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WASI**：WebAssembly系统接口（WASI）允许非浏览器环境中的WASM访问文件I/O、网络（尚未实现）和时间处理。'
- en: '**no_std**: Instructs a Rust program not to use the full standard library,
    making it suitable for small, embedded devices or highly resource-constrained
    environments.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**no_std**：指示Rust程序不使用完整的标准库，使其适用于小型嵌入式设备或高度资源受限的环境。'
- en: '**alloc**: Provides heap memory allocation capabilities (`Vec`, `String`, etc.)
    in `no_std` environments, essential for dynamically managing memory.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**alloc**：在`no_std`环境中提供堆内存分配功能（`Vec`、`String`等），这是动态管理内存所必需的。'
- en: Based on my experience with `[range-set-blaze](https://github.com/CarlKCarlK/range-set-blaze)`,
    a data structure project, here are the decisions I recommend, described one at
    a time. To avoid wishy-washiness, I’ll express them as rules.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基于我在`[range-set-blaze](https://github.com/CarlKCarlK/range-set-blaze)`数据结构项目中的经验，以下是我推荐的决策，逐一描述。为了避免含糊其辞，我将这些决策表达为规则。
- en: 'Rule 1: Confirm that your existing app works with WASM WASI and create a simple
    JavaScript web page.'
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则1：确认你现有的应用程序可以与WASM WASI一起工作，并创建一个简单的JavaScript网页。
- en: 'Getting your Rust code to run in the browser will be easier if you meet two
    prerequisites:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使你的Rust代码能够在浏览器中运行，如果满足两个前提条件，将会更加容易：
- en: Get your Rust code running in WASM WASI.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的Rust代码在WASM WASI中运行。
- en: Get some JavaScript to run in the browser.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让一些JavaScript在浏览器中运行。
- en: For the first prerequisite, see [Nine Rules for Running Rust on WASM WASI](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a)
    in *Towards Data Science*. That article — the first article in this series — details
    how to move your code from your native operating system to WASM WASI. With that
    move, you will be halfway to running on WASM in the Browser.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个先决条件，请参阅[《在 WASM WASI 上运行 Rust 的九条规则》](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a)（来自
    *Towards Data Science*）。那篇文章——本系列的第一篇——详细说明了如何将你的代码从本地操作系统移植到 WASM WASI。通过这个迁移，你将完成一半的工作，接下来就可以在浏览器中运行
    WASM 了。
- en: '![](../Images/c13b6ccb5fcff21890cb7aa324a1c097.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c13b6ccb5fcff21890cb7aa324a1c097.png)'
- en: Environments in which we wish to run our code as a Venn diagram of progressively
    tighter constraints.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望运行代码的环境就像是一个逐渐收紧约束条件的维恩图。
- en: 'Confirm your code runs on WASM WASI via your tests:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过你的测试确认代码在 WASM WASI 上运行：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the second prerequisite, show that you can create some JavaScript code
    and run it in a browser. I suggest adding this `index.html` file to the top level
    of your project:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个先决条件，展示你能创建一些 JavaScript 代码并在浏览器中运行。我建议将这个 `index.html` 文件添加到你项目的顶层：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, serve this page to your browser. You can serve web pages via an editor
    extension. I use [Live Preview](https://marketplace.visualstudio.com/items?itemName=ms-vscode.live-server)
    for VS Code. Alternatively, you can install and use a standalone web server, such
    as [Simple Html Server](https://github.com/TheWaWaR/simple-http-server):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此页面提供给你的浏览器。你可以通过编辑器扩展来提供网页。我使用 [Live Preview](https://marketplace.visualstudio.com/items?itemName=ms-vscode.live-server)
    作为 VS Code 的扩展。或者，你也可以安装并使用独立的 Web 服务器，比如 [Simple Html Server](https://github.com/TheWaWaR/simple-http-server)：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You should now see a web page on which you can select a file. The JavaScript
    on the page counts the lines in the file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该能看到一个网页，在该网页上你可以选择一个文件。页面上的 JavaScript 会统计文件中的行数。
- en: '![](../Images/2e27c53e09c60f8cc65a412a17741755.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2e27c53e09c60f8cc65a412a17741755.png)'
- en: Let’s go over the key parts of the JavaScript because later we will change it
    to call Rust.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 JavaScript 的关键部分，因为稍后我们会修改它以调用 Rust。
- en: 'Aside: Must you learn JavaScript to use Rust in the browser? Yes and no. Yes,
    you’ll need to create at least some simple JavaScript code. No, you may not need
    to “learn”JavaScript. I’ve found ChatGPT good enough to generate the simple JavaScript
    that I need.'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁注：你必须学习 JavaScript 才能在浏览器中使用 Rust 吗？是，也不是。是的，你需要编写一些简单的 JavaScript 代码。不是，你可能不需要“学习”
    JavaScript。我发现 ChatGPT 足够强大，可以生成我所需的简单 JavaScript 代码。
- en: 'See what file the user chose. If none, just return:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看用户选择了哪个文件。如果没有选择文件，则返回：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a new `FileReader` object, do some setup, and then read the file as
    text:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 `FileReader` 对象，进行一些设置，然后以文本形式读取文件：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is the setup. It says: wait until the file is fully read, read its contents
    as a string, split the string into lines, and display the number of lines.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是设置步骤。它说：等待文件完全读取，将其内容作为字符串读取，按行拆分字符串，然后显示行数。
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the prerequisites fulfilled, we turn next to installing the needed WASM-in-the-Browser
    tools.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 满足先决条件后，我们接下来安装所需的 WASM-in-the-Browser 工具。
- en: 'Rule 2: Install the `wasm32-unknown-unknown` target, wasm-pack, `wasm-bindgen-cli`,
    and Chrome for Testing & Chromedriver.'
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 2：安装 `wasm32-unknown-unknown` 目标、wasm-pack、`wasm-bindgen-cli`，以及用于测试的 Chrome
    和 Chromedriver。
- en: 'We start with something easy, installing these three tools:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的开始，安装这三个工具：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first line installs a new target, `wasm32-unknown-unknown`. This target
    compiles Rust to WebAssembly without any assumptions about the environment the
    code will run in. The lack of assumptions makes it suitable to run in browsers.
    (For more on targets, see the [previous article](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a)’s
    Rule #2.)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '第一行安装了一个新的目标，`wasm32-unknown-unknown`。这个目标将 Rust 编译为 WebAssembly，而不对代码将运行的环境做任何假设。没有假设使得它适合在浏览器中运行。（关于目标的更多信息，请参见[上一篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a)中的规则
    #2。）'
- en: The next two lines install `wasm-pack` and `wasm-bindgen-cli`, command-line
    utilities. The first builds, packages, and publishes into a form suitable for
    use by a web page. The second makes testing easier. We use `--force` to ensure
    the utilities are up-to-date and mutually compatible.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行安装 `wasm-pack` 和 `wasm-bindgen-cli`，这两个命令行工具。第一个用于构建、打包和发布，生成适用于网页使用的格式。第二个则简化了测试过程。我们使用
    `--force` 来确保工具是最新的并且互相兼容。
- en: Now, we get to the annoying part, installing Chrome for Testing & Chromedriver.
    Chrome for Testing is an automatable version of the Chrome browser. Chromedriver
    is a separate program that can take your Rust tests cases and run them inside
    Chrome for Testing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入了麻烦的部分，安装测试用的 Chrome 和 Chromedriver。测试用的 Chrome 是一个可自动化的 Chrome 浏览器版本，而
    Chromedriver 是一个独立的程序，可以将你的 Rust 测试用例运行在测试用的 Chrome 中。
- en: Why is installing them annoying? First, the process is somewhat complex. Second,
    the version of Chrome for Testing must match the version of Chromedriver. Third,
    installing Chrome for Testing will conflict with your current installation of
    regular Chrome.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么安装它们很麻烦？首先，过程有些复杂。其次，测试用的 Chrome 版本必须与 Chromedriver 版本匹配。第三，安装测试用的 Chrome
    会与当前安装的常规 Chrome 冲突。
- en: With that background, here are my suggestions. Start by installing the two programs
    into a dedicated subfolder of your home directory.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解这些背景信息后，以下是我的建议。从将这两个程序安装到你主目录的专用子文件夹开始。
- en: 'Linux and WSL (Windows Subsystem for Linux):'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 和 WSL（Windows 子系统 Linux）：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Windows (PowerShell):'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows（PowerShell）：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Aside: I’m sorry but I haven’t tested any Mac instructions. Please see [the
    Chrome for Testing web page](https://googlechromelabs.github.io/chrome-for-testing/)
    and then try to adapt the Linux method. If you let me know what works, I’ll update
    this section.'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁白：抱歉，我还没有测试任何 Mac 系统的安装说明。请查看 [Chrome for Testing 网页](https://googlechromelabs.github.io/chrome-for-testing/)，然后尝试适配
    Linux 的方法。如果你告诉我什么方法有效，我将更新这一部分内容。
- en: This installs version 129.0.6668.70, the stable version as of 9/30/2024\. If
    you wish, check the [Chrome for Testing Availability](https://googlechromelabs.github.io/chrome-for-testing/)
    page for newer stable versions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 129.0.6668.70 版本，这是截至 2024 年 9 月 30 日的稳定版本。如果你愿意，可以查看 [Chrome for Testing
    可用性](https://googlechromelabs.github.io/chrome-for-testing/) 页面，查看最新的稳定版本。
- en: 'Next, we need to add these programs to our `PATH`. We can add them temporarily,
    meaning only for the current terminal session:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将这些程序添加到 `PATH` 中。我们可以临时添加它们，仅对当前的终端会话有效：
- en: 'Linux and WSL (just for this session):'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 和 WSL（仅限本次会话）：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Windows (just for this session):'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows（仅限本次会话）：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Alternatively, we can add them to our `PATH` permanently for all future terminal
    sessions. Understand that this may interfere with access to your regular version
    of Chrome.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以将它们永久添加到我们的 `PATH` 中，适用于所有未来的终端会话。请理解，这可能会干扰你访问常规版本的 Chrome。
- en: 'Linux and WSL (then restart your terminal):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 WSL（然后重新启动终端）：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Windows (PowerShell, then restart your terminal):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Windows（PowerShell，然后重新启动终端）：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once installed, you can verify the installation with:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以使用以下命令验证安装是否成功：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Aside: Can you skip installing and using Chrome for Testing and Chromedriver?
    Yes and no. If you skip them, you’ll still be able to create WASM from your Rust.
    Moreover, you’ll be able to call that WASM from JavaScript in a web page.'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁白：你可以跳过安装并使用测试用的 Chrome 和 Chromedriver 吗？可以，也不可以。如果跳过它们，你仍然能够从 Rust 创建 WASM。此外，你还可以在网页中通过
    JavaScript 调用这个 WASM。
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, your project — like all good code — should already contain tests. If
    you skip Chrome for Testing, you will not be able to run WASM-in-the-Browser test
    cases. Moreover, WASM in the Browser violates Rust’s “If it compiles, it works”
    principle. Specifically, if you use an unsupported feature, like file access,
    compiling to WASM won’t catch the error. Only test cases can catch such errors.
    This makes running test cases critically important.
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，你的项目——就像所有优秀的代码一样——应该已经包含了测试。如果跳过测试用的 Chrome，你将无法运行浏览器中的 WASM 测试用例。此外，浏览器中的
    WASM 违反了 Rust 的 “如果它能编译，它就能工作” 原则。具体来说，如果你使用了不支持的功能，如文件访问，编译成 WASM 时不会捕获错误。只有测试用例才能捕捉到这种错误。因此，运行测试用例是至关重要的。
- en: Now that we have the tools to run tests in the browser, let’s try (and almost
    certainly fail) to run those tests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了在浏览器中运行测试的工具，让我们尝试（几乎可以肯定会失败）运行这些测试。
- en: 'Rule 3: Make your project `cdylib` (and `rlib`), add `wasm-bindgen` dependencies,
    and test.'
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 3：将项目设置为 `cdylib`（和 `rlib`），添加 `wasm-bindgen` 依赖，并进行测试。
- en: The `wasm-bindgen` package is a set of automatically generated bindings between
    Rust and JavaScript. It lets JavaScript call Rust.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`wasm-bindgen` 包是一组自动生成的 Rust 和 JavaScript 之间的绑定，允许 JavaScript 调用 Rust。'
- en: 'To prepare your code for WASM in the Browser, you’ll make your project a library
    project. Additionally, you’ll add and use `wasm-bindgen` dependencies. Follow
    these steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在浏览器中为 WASM 准备代码，你需要将项目设置为库项目。此外，你还需要添加并使用 `wasm-bindgen` 依赖。按照以下步骤操作：
- en: If your project is executable, change it to a library project by renaming `src/main.rs`
    to `src/lib.rs`. Also, comment out your `main` function.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的项目是可执行文件，将其改为库项目，通过将`src/main.rs`重命名为`src/lib.rs`。同时，注释掉你的`main`函数。
- en: 'Make your project create both a static library (the default) and a dynamic
    library (needed by WASM). Specifically, edit `Cargo.toml` to include:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的项目同时创建静态库（默认）和动态库（WASM所需）。具体来说，编辑`Cargo.toml`以包含：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add `wasm-bindgen` dependencies:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`wasm-bindgen`依赖：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create or update `.cargo/config.toml` (not to be confused with `Cargo.toml`)
    to include:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建或更新`.cargo/config.toml`（不要与`Cargo.toml`混淆），并包括：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, what functions do you wish to be visible to JavaScript? Mark those functions
    with `#[wasm_bindgen]` and make them `pub` (public). At the top of the functions’
    files, add `use wasm_bindgen::prelude::*;`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，哪些函数你希望能在JavaScript中可见？用`#[wasm_bindgen]`标记这些函数，并将它们设为`pub`（公共）。在函数文件的顶部，添加`use
    wasm_bindgen::prelude::*;`。
- en: 'Aside: For now, your functions may fail to compile. We’ll address this issue
    in subsequent rules.'
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 旁白：目前，你的函数可能无法编译。我们将在后续规则中解决这个问题。
- en: 'What about tests? Everywhere you have a `#[test]` add a `#[wasm_bindgen_test]`.
    Where needed for tests, add this `use` statement and a configuration statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 测试怎么办？在每个`#[test]`上添加`#[wasm_bindgen_test]`。在测试需要时，添加以下`use`语句和配置语句：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you like, you can try the preceding steps on a small, sample project. Install
    the sample project from GitHub:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以在一个小型示例项目上尝试上述步骤。从GitHub安装该示例项目：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here we see all these changes on the small, sample project’s `lib.rs`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到这些修改应用到了小型示例项目的`lib.rs`：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With these changes made, we’re ready to test (and likely fail):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 做了这些修改后，我们准备开始测试（并可能失败）：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On this sample, the compiler complains that WASM in the Browser doesn’t like
    to return tuple types, here, `(u32, u32)`. It also complains that it doesn’t like
    to return a `Result` with `io::Error`. To fix these problems, we’ll need to understand
    which types WASM in the Browser supports. That’s the topic of Rule 4.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，编译器抱怨浏览器中的WASM不喜欢返回元组类型，这里是`(u32, u32)`。它还抱怨不喜欢返回包含`io::Error`的`Result`。要解决这些问题，我们需要了解浏览器中的WASM支持哪些类型。这正是规则4的主题。
- en: What will happen after we fix the type problems and can run the test? The test
    will still fail, but now with a runtime error. WASM in the Browser doesn’t support
    reading from files. The sample test, however, tries to read from a file. In Rule
    5, we’ll discuss workarounds for both type limitations and file-access restrictions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 修复类型问题并能够运行测试后会发生什么？测试仍然会失败，但这时是运行时错误。浏览器中的WASM不支持从文件中读取。然而，示例测试尝试从文件中读取。在规则5中，我们将讨论针对类型限制和文件访问限制的解决方法。
- en: 'Rule 4: Learn what types `wasm-bindgen` supports.'
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 4：了解`wasm-bindgen`支持哪些类型。
- en: Rust functions that JavaScript can see must have input and output types that
    `wasm-bindgen` supports. Use of unsupported types causes compiler errors. For
    example, passing in a `u32` is fine. Passing in a tuple of `(u32, 32)` is not.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript可以看到的Rust函数必须具有`wasm-bindgen`支持的输入和输出类型。使用不支持的类型会导致编译器错误。例如，传递一个`u32`是可以的。但传递一个元组`(u32,
    32)`则不行。
- en: 'More generally, we can sort Rust types into three categories: “Yep!”, “Nope!”,
    and “Avoid”.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般来说，我们可以将Rust类型分为三类：“是的！”，“不是！”和“避免”。
- en: Yep!
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 是的！
- en: This is the category for Rust types that JavaScript (via `wasm-bindgen`) understands
    well.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Rust类型的类别，JavaScript（通过`wasm-bindgen`）能够很好理解。
- en: 'We’ll start with **Rust’s simple copy types**:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从**Rust的简单复制类型**开始：
- en: '![](../Images/40a0ca49852a34ff8b965969aac0a284.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/40a0ca49852a34ff8b965969aac0a284.png)'
- en: Two items surprised me here. First, 64-bit integers require extra work on the
    JavaScript side. Specifically, they require the use of JavaScript’s `[BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)`
    class. Second, JavaScript does not support 128-bit integers. The 128-bit integers
    are “Nopes”.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个项目让我感到意外。首先，64位整数在JavaScript端需要额外的工作。具体来说，它们需要使用JavaScript的`[BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)`类。其次，JavaScript不支持128位整数。128位整数属于“不是！”类别。
- en: 'Turning now to **String-related and vector-related types**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转向**与字符串和向量相关的类型**：
- en: '![](../Images/fe4f7bd53d64b057ccfc9b2d471ca821.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/fe4f7bd53d64b057ccfc9b2d471ca821.png)'
- en: These super useful types use heap-allocated memory. Because Rust and JavaScript
    manage memory differently, each language makes its own copy of the data. I thought
    I might avoid this allocation by passing a `&mut [u8]` (mutable slice of bytes)
    from JavaScript to Rust. That didn’t work. [Instead of zero copies or one, it
    copied twice](https://stackoverflow.com/questions/78634475/does-wasm-bindgen-copy-mut-u8-zero-times-or-twice/78634853#78634853').
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些超有用的类型使用堆分配的内存。由于Rust和JavaScript的内存管理方式不同，每种语言都会创建一份数据的副本。我曾以为通过从JavaScript向Rust传递`&mut
    [u8]`（可变字节切片）可以避免这种分配。但这并没有奏效。[它并没有零次拷贝或一次拷贝，而是拷贝了两次](https://stackoverflow.com/questions/78634475/does-wasm-bindgen-copy-mut-u8-zero-times-or-twice/78634853#78634853')。
- en: 'Aside: For `String` and `&str`, `wasm-bindgen` also converts between JavaScript’s
    UTF-16 Unicode encoding and Rust’s UTF-8 Unicode encoding.'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 顺便提一下，对于`String`和`&str`，`wasm-bindgen`还在JavaScript的UTF-16 Unicode编码和Rust的UTF-8
    Unicode编码之间进行转换。
- en: Next, in Rust we love our **Option and Result types**. I’m happy to report that
    they are “Yeps”.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在Rust中我们喜欢我们的**Option和Result类型**。我很高兴地报告它们属于“Yeps”。
- en: '![](../Images/e2d7c5632da35f7e6ed59d259c8d2f13.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e2d7c5632da35f7e6ed59d259c8d2f13.png)'
- en: A Rust `Some(3)` becomes a JavaScript `3`, and a Rust `None` becomes a JavaScript
    `null`. In other words, `wasm-bindgen` converts Rust's type-safe null handling
    to JavaScript's old-fashioned approach. In both cases, `null`/`None` is handled
    idiomatically within each language.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的`Some(3)`变成JavaScript的`3`，而Rust的`None`变成JavaScript的`null`。换句话说，`wasm-bindgen`将Rust的类型安全的空值处理转换为JavaScript的传统方式。在两种情况下，`null`/`None`都按照各自语言的习惯方式处理。
- en: Rust `Result` behaves similarly to `Option`. A Rust `Ok(3)` becomes a JavaScript
    `3`, and a Rust `Err("Some error message")` becomes a JavaScript exception that
    can be caught with `try`/`catch`. Note that the value inside the Rust `Err` is
    restricted to types that implement the `Into<JsValue>` trait. Using `String` generally
    works well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Rust的`Result`与`Option`的行为类似。Rust的`Ok(3)`变成JavaScript的`3`，而Rust的`Err("Some error
    message")`变成JavaScript的异常，可以通过`try`/`catch`捕获。请注意，Rust的`Err`中的值只能是实现了`Into<JsValue>`特征的类型。通常使用`String`会很有效。
- en: 'Finally, let’s look at **struct, enum, and JSValue**, our last set of “Yeps”:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看**struct、enum和JSValue**，我们最后一组“Yeps”：
- en: '![](../Images/c1d7ee973c89183ee633c3f549b171f2.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c1d7ee973c89183ee633c3f549b171f2.png)'
- en: Excitingly, JavaScript can construct and call methods on your Rust structs.
    To enable this, you need to mark the struct and any JavaScript-accessible methods
    with `#[wasm_bindgen]`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 激动人心的是，JavaScript可以构建并调用Rust结构体上的方法。为了实现这一点，你需要使用`#[wasm_bindgen]`标记结构体和任何可以由JavaScript访问的方法。
- en: For example, suppose you want to avoid passing a giant string from JavaScript
    to Rust. You could define a Rust struct that processes a series of strings incrementally.
    JavaScript could construct the struct, feed it chunks from a file, and then ask
    for the result.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想避免将一个巨大的字符串从JavaScript传递到Rust。你可以定义一个Rust结构体，按序处理一系列字符串。JavaScript可以构建该结构体，将文件的块传入其中，然后请求结果。
- en: JavaScript’s handling of Rust enums is less exciting. It can only handle enums
    without associated data (C-like enums) and treats their values as integers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript处理Rust枚举的方式不太令人兴奋。它只能处理没有关联数据（类似C枚举）的枚举，并将其值视为整数。
- en: In the middle of the excitement spectrum, you can pass opaque JavaScript values
    to Rust as `JsValue`. Rust can then dynamically inspect the value to determine
    its subtype or—if applicable—call its methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在兴奋感的中间位置，你可以将不透明的JavaScript值作为`JsValue`传递给Rust。Rust随后可以动态检查该值，确定其子类型，或者——如果适用——调用其方法。
- en: That ends the “Yeps”. Time to look at the “Nopes”.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了“Yeps”部分。现在来看一下“Nopes”部分。
- en: Nope!
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不行！
- en: This is the category for Rust types that JavaScript (via `wasm-bindgen`) doesn’t
    handle.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Rust类型的类别，JavaScript（通过`wasm-bindgen`）无法处理。
- en: '![](../Images/2bdc9fc79862c1d8d09fffe0877940e7.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2bdc9fc79862c1d8d09fffe0877940e7.png)'
- en: Not being able to pass, for example, `&u8` by reference is fine because you
    can just use `u8`, which is likely more efficient anyway.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，不能通过引用传递`&u8`是可以接受的，因为你可以直接使用`u8`，而且它可能更高效。
- en: Not being able to return a string slice (`&str`) or a regular slice (`&[u8]`)
    is somewhat annoying. To avoid lifetime issues, you must instead return an owned
    type like `String` or `Vec<u8>`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不能返回字符串切片（`&str`）或常规切片（`&[u8]`）有些令人烦恼。为了避免生命周期问题，你必须返回一个拥有所有权的类型，如`String`或`Vec<u8>`。
- en: You can’t accept a mutable `String` reference (`&mut String`). However, you
    can accept a `String` by value, mutate it, and then return the modified `String`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能接受可变的`String`引用（`&mut String`）。不过，你可以接受一个`String`的值，通过修改它后再返回修改后的`String`。
- en: How do we workaround the “Nopes”? In place of fixed-length arrays, tuples, and
    128-bit integers, use vectors (`Vec<T>`) or structs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决“不可行”的问题？可以用向量（`Vec<T>`）或结构体来替代固定长度数组、元组和 128 位整数。
- en: Rust has sets and maps. JavaScript has sets and maps. The `wasm-bindgen` library,
    however, will not automatically convert between them. So, how can you pass, for
    example, a `HashSet` from Rust to JavaScript? Wrap it in your own Rust struct
    and define needed methods. Then, mark the struct and those methods with `#[wasm-bindgen]`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Rust 有集合和映射。JavaScript 也有集合和映射。然而，`wasm-bindgen` 库不会自动在它们之间转换。那么，如何将 Rust 中的
    `HashSet` 传递给 JavaScript 呢？将其包装在你自己的 Rust 结构体中并定义所需的方法。然后，使用 `#[wasm-bindgen]`
    标记该结构体和这些方法。
- en: And now our third category.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们的第三类。
- en: Avoid
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免
- en: This is the category for Rust types that JavaScript (via `wasm-bindgen`) allows
    but that you shouldn’t use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Rust 类型的类别，JavaScript（通过 `wasm-bindgen`）允许使用，但你不应该使用它们。
- en: '![](../Images/f588e4f19fc187adcd88b822342e1283.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f588e4f19fc187adcd88b822342e1283.png)'
- en: Avoid using `usize` and `isize` because most people will assume they are 64-bit
    integers, but in WebAssembly (WASM), they are 32-bit integers. Instead, use `u32`,
    `i32`, `u64`, or `i64`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 `usize` 和 `isize`，因为大多数人会认为它们是 64 位整数，但在 WebAssembly（WASM）中，它们是 32 位整数。相反，使用
    `u32`、`i32`、`u64` 或 `i64`。
- en: In Rust, `char` is a special `u32` that can contain only valid Unicode scalar
    values. JavaScript, in contrast, treats a `char` as a string. It checks for Unicode
    validity but does not enforce that the string has a length of one. If you need
    to pass a `char` from JavaScript into Rust, it's better to use the `String` type
    and then check the length on the Rust side.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rust 中，`char` 是一个特殊的 `u32`，只能包含有效的 Unicode 标量值。相比之下，JavaScript 将 `char` 视为字符串。它检查
    Unicode 有效性，但不强制字符串的长度为 1。如果你需要将 `char` 从 JavaScript 传递到 Rust，最好使用 `String` 类型，然后在
    Rust 端检查长度。
- en: 'Rule 5: Change functions to use supported types. Change files to generic `BufRead`.'
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 5：更改函数以使用支持的类型。将文件更改为通用的 `BufRead`。
- en: 'With our knowledge of `wasm-bindgen` supported types, we can fixup the functions
    we wish to make available to JavaScript. We left Rule 3’s example with a function
    like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解 `wasm-bindgen` 支持的类型，我们可以修正我们希望暴露给 JavaScript 的函数。我们将规则 3 的示例函数保留为如下所示：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We, now, change the function by removing `#[wasm_bindgen] pub`. We also change
    the function to read from a generic reader rather than a file name. Using `BufRead`
    allows for more flexibility, enabling the function to accept different types of
    input streams, such as in-memory data or files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在通过移除 `#[wasm_bindgen] pub` 来更改函数。我们还将函数修改为从通用读取器中读取，而不是文件名。使用 `BufRead`
    可以提供更多的灵活性，使得该函数能够接受不同类型的输入流，例如内存数据或文件。
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'JavaScript can’t see this function, so we create a wrapper function that calls
    it. For example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 无法看到这个函数，因此我们创建一个包装函数来调用它。例如：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This wrapper function takes as input a byte slice (`&[u8]`), something JavaScript
    can pass. The function turns the byte slice into a reader and calls the inner
    `good_turing`. The inner function returns a `Result<(u32, u32), io::Error>`. The
    wrapper function translates this result into `Result<Vec<u32>, String>`, a type
    that JavaScript will accept.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包装函数接受一个字节切片（`&[u8]`）作为输入，这是 JavaScript 可以传递的内容。该函数将字节切片转换为一个读取器，并调用内部的 `good_turing`
    函数。内部函数返回一个 `Result<(u32, u32), io::Error>`。包装函数将此结果转换为 `Result<Vec<u32>, String>`，这是
    JavaScript 可以接受的类型。
- en: In general, I’m only willing to make minor changes to functions that will run
    both natively and in WASM in the Browser. For example, here I’m willing to change
    the function to work on a generic reader rather than a file name. When JavaScript
    compatibility requires major, non-idiomatic changes, I create a wrapper function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我只愿意对既能原生运行又能在浏览器中以 WASM 运行的函数做一些小修改。例如，在这里，我愿意将函数改为处理通用读取器，而不是文件名。当 JavaScript
    兼容性需要进行重大且不符合惯例的更改时，我会创建一个包装函数。
- en: In the example, after making these changes, the main code now compiles. The
    original test, however, does not yet compile. Fixing tests is the topic of Rule
    6.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，在做出这些更改后，主代码现在可以编译。然而，原始测试仍然无法编译。修复测试是规则 6 的主题。
- en: 'Rule 6: Adapt tests, skipping those that don’t apply.'
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 6：调整测试，跳过不适用的部分。
- en: Rule 3 advocated marking every regular test (`#[test]`) to also be a WASM-in-the-Browser
    test (`#[wasm_bindgen_test]`). However, not all tests from native Rust can be
    run in a WebAssembly environment, due to WASM’s limitations in accessing system
    resources like files.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 3 提倡将每个常规测试（`#[test]`）同时标记为WASM浏览器测试（`#[wasm_bindgen_test]`）。然而，由于WASM在访问系统资源（如文件）方面的限制，并非所有来自原生Rust的测试都可以在WebAssembly环境中运行。
- en: 'In our example, Rule 3 gives us test code that does not compile:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，规则 3 给出的测试代码无法编译：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This test code fails because our updated `good_turing` function expects a generic
    reader rather than a file name. We can fix the test by creating a reader from
    the sample file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试代码失败的原因是我们更新后的 `good_turing` 函数需要一个通用的读取器，而不是文件名。我们可以通过从示例文件创建一个读取器来修复这个测试：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a fine native test. Unfortunately, we can’t run it as a WASM-in-the-Browser
    test because it uses a file reader — something WASM doesn’t support.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的原生测试。不幸的是，我们无法将其作为WASM浏览器测试运行，因为它使用了文件读取器——这是WASM不支持的功能。
- en: 'The solution is to create an additional test:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个额外的测试：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At compile time, this test uses the macro `include_bytes!` to turn a file into
    a WASM-compatible byte slice. The `good_turing_byte_slice` function turns the
    byte slice into a reader and calls `good_turing`. (The `include_bytes` macro is
    [part of the Rust standard library](https://doc.rust-lang.org/std/macro.include_bytes.html)
    and, therefore, available to tests.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，这个测试使用宏 `include_bytes!` 将一个文件转换为WASM兼容的字节切片。`good_turing_byte_slice` 函数将字节切片转换为读取器，并调用
    `good_turing`。 （`include_bytes` 宏是[Rust标准库的一部分](https://doc.rust-lang.org/std/macro.include_bytes.html)，因此可以用于测试。）
- en: Note that the additional test is both a regular test and a WASM-in-the-Browser
    test. As much as possible, we want our tests to be both.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，额外的测试既是常规测试，又是WASM浏览器测试。我们尽量让我们的测试两者兼顾。
- en: 'In my `range-set-blaze` project, I was able to mark almost all tests as both
    regular and WASM in the Browser. One exception: a test used a Criterion benchmarking
    function. Criterion doesn’t run in WASM in the Browser, so I marked that test
    regular only (`#[test]`).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 `range-set-blaze` 项目中，我几乎能够将所有测试都标记为常规测试和WASM浏览器测试。唯一的例外是：有一个测试使用了Criterion基准测试函数。Criterion无法在WASM浏览器中运行，因此我仅将该测试标记为常规测试（`#[test]`）。
- en: With both our main code (Rule 5) and our test code (Rule 6) fixed, can we actually
    run our tests? Not necessarily, we may need to find JavaScript friendly dependences.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复了我们的主代码（规则 5）和测试代码（规则 6）之后，我们能实际运行我们的测试吗？不一定，我们可能需要找到适合JavaScript的依赖。
- en: 'Aside: If you are on Windows and run WASM-in-the-Browser tests, you may see
    “`ERROR tiny_http] Error accepting new client: A blocking operation was interrupted
    by a call to WSACancelBlockingCall. (os error 10004)`” This is not related to
    your tests. You may ignore it.'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '附注：如果你使用的是Windows并运行WASM浏览器测试，你可能会看到“`ERROR tiny_http] Error accepting new
    client: A blocking operation was interrupted by a call to WSACancelBlockingCall.
    (os error 10004)`”。这与您的测试无关，可以忽略它。'
- en: 'Rule 7: Change to JavaScript-friendly dependencies, if necessary. Run tests.'
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 7：如有必要，改用适合JavaScript的依赖项。运行测试。
- en: Dependencies
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'The sample project will now compile. With my `range-set-blaze` project, however,
    fixing my code and tests was not enough. I also needed to fix several dependencies.
    Specifically, I needed to add this to my `Cargo.toml`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 示例项目现在可以编译。然而，在我的 `range-set-blaze` 项目中，仅修复我的代码和测试还不够。我还需要修复一些依赖项。具体来说，我需要在
    `Cargo.toml` 中添加如下内容：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These two dependences enable random numbers and provide an alternative time
    library. By default, WASM in the Browser has no access to random numbers or time.
    Both the dependences wrap JavaScript functions making them accessible to and idiomatic
    for Rust.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个依赖使得随机数生成和提供了一个替代的时间库。默认情况下，浏览器中的WASM无法访问随机数或时间。这两个依赖封装了JavaScript函数，使得它们对Rust既可访问又符合惯用法。
- en: '*Aside: For more information on using* `*cfg*` *expressions in* `*Cargo.toml*`*,
    see my article:* [*Nine Rust Cargo.toml Wats and Wat Nots*](https://medium.com/towards-data-science/nine-rust-cargo-toml-wats-and-wat-nots-1e5e02e41648)*:
    Master Cargo.toml formatting rules and avoid frustration |* Towards Data Science
    (medium.com)*.*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*附注：有关在* `*Cargo.toml*` *中使用* `*cfg*` *表达式的更多信息，请参见我的文章：* [*九个Rust Cargo.toml的陷阱与误区*](https://medium.com/towards-data-science/nine-rust-cargo-toml-wats-and-wat-nots-1e5e02e41648)*：掌握Cargo.toml格式规则，避免挫折
    |* Towards Data Science (medium.com)*.*'
- en: 'Look for other such JavaScript-wrapping libraries in [WebAssembly — Categories
    — crates.io](https://crates.io/categories/wasm). Popular crates that I haven’t
    tried but look interesting include:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [WebAssembly — 分类 — crates.io](https://crates.io/categories/wasm) 中查找其他类似的
    JavaScript 包装库。我还没有尝试过，但看起来很有趣的流行库包括：
- en: '[reqwest](https://crates.io/crates/reqwest)— `features=["wasm"]`— HTTP network
    access'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[reqwest](https://crates.io/crates/reqwest) — `features=["wasm"]` — HTTP 网络访问'
- en: '[plotters](https://crates.io/crates/plotters) — Plotting — includes a [demo](https://github.com/plotters-rs/plotters-wasm-demo)
    that controls the HTML canvas object from Rust'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[plotters](https://crates.io/crates/plotters) — 绘图 — 包括一个 [demo](https://github.com/plotters-rs/plotters-wasm-demo)，它可以从
    Rust 控制 HTML 画布对象'
- en: '[gloo](https://crates.io/crates/gloo) — Toolkit of JavaScript wrappers'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[gloo](https://crates.io/crates/gloo) — JavaScript 包装器工具包'
- en: Also see Rule 7 in [the previous article](/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a)
    — about WASM WASI — for more about fixing dependency issues. In the [next article](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)
    in this series — about `no_std` and embedded — we’ll go deeper into more strategies
    for fixing dependencies.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见 [上一篇文章](/nine-rules-for-running-rust-on-wasm-wasi-550cd14c252a) 中的规则 7
    — 关于 WASM WASI — 了解更多关于修复依赖问题的内容。在本系列的 [下一篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)
    中 — 关于 `no_std` 和嵌入式 — 我们将深入探讨更多修复依赖的策略。
- en: Run Tests
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行测试
- en: 'With our dependencies fixed, we can finally run our tests, both regular and
    WASM in the Browser:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在修复了依赖问题后，我们终于可以运行我们的测试，包括常规测试和浏览器中的 WASM 测试：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Recall that behind the scenes, our call to `cargo test --target wasm32-unknown-unknown:`
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在幕后，我们对 `cargo test --target wasm32-unknown-unknown` 的调用：
- en: Looks in `.cargo/config.toml` and sees `wasm-bindgen-test-runner` (Rule 3).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 `.cargo/config.toml` 并找到 `wasm-bindgen-test-runner`（规则 3）。
- en: Calls `wasm-bindgen-test-runner`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `wasm-bindgen-test-runner`。
- en: Uses Chromedriver to run our tests in Chrome for Testing. (Rule 2, be sure Chrome
    for Testing and Chromedriver are on your path).
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Chromedriver 在 Chrome 中运行我们的测试以进行测试。（规则 2，确保 Chrome for Testing 和 Chromedriver
    已添加到你的路径中）。
- en: With our tests working, we’re now ready to call our Rust code from a web page.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试成功后，我们现在准备从网页调用我们的 Rust 代码。
- en: 'Rule 8: Connect your web page to your functions.'
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 8：将你的网页与你的函数连接起来。
- en: 'To call your Rust functions from a web page you must first package your Rust
    library for the web. We installed `wasm-pack` in Rule 2\. Now, we run it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要从网页调用你的 Rust 函数，你必须首先为网页打包你的 Rust 库。在规则 2 中，我们安装了 `wasm-pack`。现在，我们运行它：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This compiles your project and creates a `pkg` output directory that JavaScript
    understands.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将编译你的项目，并创建一个 JavaScript 能够理解的 `pkg` 输出目录。
- en: Example
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: In Rule 1, we created an `index.html` file that didn’t call Rust. Let’s change
    it now so that it does call Rust. Here is an example of such an `index.html` followed
    by a description of the changes of interest.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则 1 中，我们创建了一个没有调用 Rust 的 `index.html` 文件。现在让我们将其修改为调用 Rust。以下是一个示例的 `index.html`，并附有相关变化的描述。
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s go through the changes of interest.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下关注的变化。
- en: The line below imports two functions into JavaScript from the module file `pkg/good_turing.js`,
    which we created using `wasm-pack`. The default function, `init`, initializes
    our Rust-generated WebAssembly (WASM) module. The second function, `good_turing_byte_slice`,
    is explicitly imported by including its name in curly brackets.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面这行代码将两个函数从 `pkg/good_turing.js` 模块文件导入到 JavaScript 中，该文件是我们使用 `wasm-pack`
    创建的。默认函数 `init` 初始化我们用 Rust 生成的 WebAssembly (WASM) 模块。第二个函数 `good_turing_byte_slice`
    通过将其名称放在大括号中显式导入。
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Create a new `FileReader` object, do some setup, and then read the file as an
    array of bytes.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 `FileReader` 对象，进行一些设置，然后将文件作为字节数组读取。
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is how we setup code that will run after the file is fully read:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是我们在文件完全读取后执行的代码设置：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This line ensures the WASM module is initialized. The first time it’s called,
    the module is initialized. On subsequent calls, it does nothing because the module
    is already ready.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一行确保 WASM 模块已初始化。第一次调用时，模块会被初始化。之后的调用不会有任何动作，因为模块已经准备好了。
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Extract the byte array from the read file.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从读取的文件中提取字节数组。
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Call the Rust-generated WASM function.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 Rust 生成的 WASM 函数。
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Aside: Here `good_turing_byte_slice` is a regular (synchronous) function. If
    you want, however, you can mark it `async` on the Rust side and then call it with
    `await` on the JavaScript side. If your Rust processing is slow, this can keep
    your web page more lively.'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附带说明：这里的`good_turing_byte_slice`是一个常规（同步）函数。不过，如果你愿意，可以在 Rust 端标记为`async`，然后在
    JavaScript 端用`await`调用它。如果你的 Rust 处理速度较慢，这可以让你的网页更加流畅。
- en: Display the result.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示结果。
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If there is an error, display the error message.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有错误，显示错误信息。
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The [final code](https://github.com/CarlKCarlK/rustconf24-good-turing) of the
    sample project is on GitHub, including a [README.md](https://github.com/CarlKCarlK/rustconf24-good-turing/blob/main/README.md)
    that explains what it is doing. Click [this link](https://carlkcarlk.github.io/rustconf24-good-turing/)
    for a live demo.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该 [最终代码](https://github.com/CarlKCarlK/rustconf24-good-turing) 在 GitHub 上，包含一个
    [README.md](https://github.com/CarlKCarlK/rustconf24-good-turing/blob/main/README.md)，解释了它的功能。点击
    [此链接](https://carlkcarlk.github.io/rustconf24-good-turing/) 查看实时演示。
- en: '`range-set-blaze`'
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`range-set-blaze`'
- en: I ported `range-set-blaze` to WASM at a user’s request so that they could use
    it inside their own project. The `[range-set-blaze](https://github.com/CarlKCarlK/range-set-blaze)`
    project is typically used as a library in other projects. In other words, you
    normally wouldn’t expect `range-set-blaze` to be the centerpiece of a web page.
    Nevertheless, I did make a small demo page. You can [browse it](https://carlkcarlk.github.io/range-set-blaze/wasm-demo)
    or [inspect its index.html](https://github.com/CarlKCarlK/range-set-blaze/blob/gh-pages/docs/wasm-demo/index.html).
    The page shows how `range-set-blaze` can turn a list of integers into a sorted
    list of disjoint ranges.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我根据用户的要求将 `range-set-blaze` 移植到 WASM，以便他们可以在自己的项目中使用它。`[range-set-blaze](https://github.com/CarlKCarlK/range-set-blaze)`
    项目通常作为库在其他项目中使用。换句话说，你通常不会期待 `range-set-blaze` 成为网页的核心部分。然而，我确实做了一个小的演示页面。你可以
    [浏览它](https://carlkcarlk.github.io/range-set-blaze/wasm-demo) 或 [查看它的 index.html](https://github.com/CarlKCarlK/range-set-blaze/blob/gh-pages/docs/wasm-demo/index.html)。该页面展示了
    `range-set-blaze` 如何将一个整数列表转换为排序后的不相交范围列表。
- en: 'Aside: **Host Your WASM-in-the-Browser Project on GitHub for Free**'
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 附带说明：**免费在 GitHub 上托管你的 WASM 在浏览器中的项目**
- en: 1\. In your project, create a `docs` folder.
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1\. 在你的项目中创建一个 `docs` 文件夹。
- en: 2\. Do `wasm-pack build --target web`.
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2\. 执行 `wasm-pack build --target web`。
- en: 3\. Copy (don’t just move) `index.html` and `pkg` into `docs`.
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3\. 将 `index.html` 和 `pkg` 复制（而不是移动）到 `docs` 文件夹中。
- en: 4\. Delete the `.gitignore` file in `docs/pkg`.
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 4\. 删除 `docs/pkg` 中的 `.gitignore` 文件。
- en: 5\. Check the project into GitHub.
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 5\. 将项目提交到 GitHub。
- en: 6\. Go to the project on GitHub. Then go to “Settings”, “Pages”.
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 6\. 前往 GitHub 上的项目。然后进入“设置”，“Pages”。
- en: 7\. Set the branch (in my case `main`) and the folder to `docs`. Save.
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 7\. 设置分支（在我的情况下是 `main`）和文件夹为 `docs`。保存。
- en: 8\. The URL will be based on your account and project names, for example, [https://carlkcarlk.github.io/rustconf24-good-turing/](https://carlkcarlk.github.io/rustconf24-good-turing/)
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 8\. URL 将基于你的账户和项目名称，例如，[https://carlkcarlk.github.io/rustconf24-good-turing/](https://carlkcarlk.github.io/rustconf24-good-turing/)
- en: 9\. To update, repeat steps 2 through 5 (inclusive).
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 9\. 要更新，重复步骤 2 到 5（包括）步骤。
- en: 'Rule 9: Add `wasm-pack` to your CI (continuous integration) tests.'
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规则 9：将`wasm-pack`添加到你的 CI（持续集成）测试中。
- en: 'Your project is now compiling to WASM in the Browser, passing tests, and showcased
    on a web page. Are you done? Not quite. Because, as I said in the first article:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目现在已经可以在浏览器中编译为 WASM，运行测试通过，并展示在网页上。完成了吗？还没完全完成。因为，正如我在第一篇文章中所说：
- en: '*If it’s not in CI, it doesn’t exist.*'
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果不在 CI 中，它就不存在。*'
- en: 'Recall that continuous integration (CI) is a system that can automatically
    run your tests every time you update your code, ensuring that your code continues
    to work as expected. In my case, GitHub hosts my project. Here’s the configuration
    I added to `.github/workflows/ci.yml` to test my project on WASM in the browser:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，持续集成（CI）是一个系统，每次你更新代码时，它都可以自动运行测试，确保你的代码继续按预期工作。在我的例子中，GitHub 托管了我的项目。以下是我添加到
    `.github/workflows/ci.yml` 文件中的配置，以便在浏览器中测试我的 WASM 项目：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: By integrating WASM in the Browser into CI, I can confidently add new code to
    my project. CI will automatically test that all my code continues to support WASM
    in the browser in the future.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将浏览器中的 WASM 集成到 CI 中，我可以放心地为我的项目添加新代码。CI 会自动测试我的所有代码，确保它将来继续支持浏览器中的 WASM。
- en: 'So, there you have it — nine rules for porting your Rust code to WASM in the
    Browser. Here is what surprised me:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是—将你的 Rust 代码移植到浏览器中的 WASM 的九条规则。这里有一件事让我感到惊讶：
- en: '**The Bad:**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**不好的部分：**'
- en: It’s hard to set up testing for WASM in the Browser. Specifically, Chrome for
    Testing and Chromedriver are hard to install and manage.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中为WASM设置测试是很难的。特别是，Chrome测试和Chromedriver的安装与管理非常困难。
- en: WASM in the Browser violates Rust’s saying “If it compiles, it works”. If you
    use an unsupported feature — for example, direct file access — the compiler won’t
    catch the error. Instead, you will fail at runtime.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中使用WASM违反了Rust的格言：“如果它能编译，说明它能工作”。如果使用不支持的功能——例如，直接文件访问——编译器不会捕捉到错误。相反，错误会在运行时发生。
- en: Passing strings and byte vectors creates two copies of your data, one on the
    JavaScript side and one on the Rust side.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递字符串和字节向量会创建数据的两个副本，一个在JavaScript端，一个在Rust端。
- en: '**The Good:**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**优点：**'
- en: WASM in the Browser is useful and fun.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中使用WASM既有用又有趣。
- en: 'You can mark your regular tests to also run in WASM in the Browser. Just mark
    your tests with both attributes:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以标记你的常规测试，让它们也在浏览器中的WASM中运行。只需同时为测试添加这两个属性：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can run on WASM in the Browser without needing to port to `no_std`. Nevertheless,
    WASM in the Browser is useful as a steppingstone toward running on embedded/`no_std`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在浏览器中运行WASM，而不需要移植到`no_std`。不过，在浏览器中使用WASM是朝着在嵌入式/`no_std`环境中运行迈出的一个重要步骤。
- en: Stay tuned! In the [next article](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e),
    we’ll see how to port your Rust code to run in an embedded environment via `no_std`.
    This allows your code to run in small devices which I find very cool.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 敬请期待！在[下一篇文章](https://medium.com/towards-data-science/nine-rules-for-running-rust-on-embedded-systems-b0c247ee877e)中，我们将看看如何将Rust代码移植到嵌入式环境并通过`no_std`运行。这将使你的代码能够在小型设备上运行，我觉得非常酷。
- en: Interested in future articles? Please [follow me on Medium](https://medium.com/@carlmkadie).
    I write about Rust and Python, scientific programming, machine learning, and statistics.
    I tend to write about one article per month.
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对未来的文章感兴趣吗？请[在Medium上关注我](https://medium.com/@carlmkadie)。我写关于Rust和Python、科学编程、机器学习和统计学的文章。我倾向于每个月写一篇文章。

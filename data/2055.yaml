- en: An Introduction to Quantum Computers and Quantum Coding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 量子计算机与量子编码简介
- en: 原文：[https://towardsdatascience.com/an-introduction-to-quantum-computers-and-quantum-coding-e5954f5a0415?source=collection_archive---------1-----------------------#2024-08-23](https://towardsdatascience.com/an-introduction-to-quantum-computers-and-quantum-coding-e5954f5a0415?source=collection_archive---------1-----------------------#2024-08-23)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/an-introduction-to-quantum-computers-and-quantum-coding-e5954f5a0415?source=collection_archive---------1-----------------------#2024-08-23](https://towardsdatascience.com/an-introduction-to-quantum-computers-and-quantum-coding-e5954f5a0415?source=collection_archive---------1-----------------------#2024-08-23)
- en: Demystifying the novel world of quantum computing, quantum programming, and
    quantum algorithms.
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭开量子计算、量子编程和量子算法的新世界的神秘面纱。
- en: '[](https://medium.com/@oliverwjohnson06?source=post_page---byline--e5954f5a0415--------------------------------)[![Oliver
    W. Johnson](../Images/66fe30ee3ccc1556ee2a4753b9c02235.png)](https://medium.com/@oliverwjohnson06?source=post_page---byline--e5954f5a0415--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e5954f5a0415--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e5954f5a0415--------------------------------)
    [Oliver W. Johnson](https://medium.com/@oliverwjohnson06?source=post_page---byline--e5954f5a0415--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@oliverwjohnson06?source=post_page---byline--e5954f5a0415--------------------------------)[![Oliver
    W. Johnson](../Images/66fe30ee3ccc1556ee2a4753b9c02235.png)](https://medium.com/@oliverwjohnson06?source=post_page---byline--e5954f5a0415--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e5954f5a0415--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e5954f5a0415--------------------------------)
    [Oliver W. Johnson](https://medium.com/@oliverwjohnson06?source=post_page---byline--e5954f5a0415--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e5954f5a0415--------------------------------)
    ·15 min read·Aug 23, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e5954f5a0415--------------------------------)
    ·阅读时间 15 分钟·2024年8月23日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/d806c85c3928a9c55865f4d10b8f0717.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d806c85c3928a9c55865f4d10b8f0717.png)'
- en: Photo by [Manuel](https://unsplash.com/@manueljota?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来自 [Manuel](https://unsplash.com/@manueljota?utm_source=medium&utm_medium=referral)
    在 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral) 上
- en: 'Preface:'
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前言：
- en: This is an adaptation of something I wrote for one of my physics courses, so
    it assumes a level of knowledge in mathematics and science. The topics referenced
    in the article include some linear algebra, superposition, basic algorithm concepts,
    and a bit of modular arithmetic when discussing algorithms. However, since you’re
    reading an article on quantum computing you’re likely savvy enough to look up
    and understand all the ideas referenced. Furthermore, all sources are cited, so
    you can explore all of those for deeper learning. Also, all images and figures
    used were generated by me, using tools like Microsoft Word, PyCharm, and [diagrams.net](https://www.drawio.com/)
    unless otherwise noted.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为我的一门物理课程所写内容的改编版，因此假设读者具备一定的数学和科学知识。文章中提到的主题包括一些线性代数、叠加原理、基本算法概念，以及在讨论算法时涉及的一些模运算。然而，由于你正在阅读一篇关于量子计算的文章，可能足够聪明，能够查阅并理解文中提到的所有概念。此外，所有的来源都有引用，你可以深入探索这些资源以进行更深的学习。还有，文中使用的所有图像和图表都是我自己生成的，使用了像
    Microsoft Word、PyCharm 和 [diagrams.net](https://www.drawio.com/) 这样的工具，除非另有说明。
- en: Why Does This Matter?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要？
- en: Before committing to a somewhat lengthy and dense read, you might be wondering
    why this matters to you, even if you’ve never touched a quantum computer. The
    reality is that breakthroughs are happening all the time, and quantum computing
    holds real relevance in different computational fields, especially machine learning.
    For starters, the quantum analogs of classical algorithms have potential to be
    much more efficient.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你决定花时间阅读这篇内容前，你可能会想知道，尽管你从未接触过量子计算机，这对你有什么意义。实际上，突破性进展时时发生，量子计算在不同的计算领域中具有现实意义，尤其是在机器学习方面。首先，经典算法的量子类比有可能更加高效。
- en: One example of this is the Quantum Support Vector Machine. Notably, classical
    SVMs often use the [kernel trick](https://en.wikipedia.org/wiki/Kernel_method)
    to transform data into a higher dimensional space so that they can locate a separating
    hyperplane. However, quantum SVMs would have a significant advantage as they naturally
    represent data in exponentially higher dimensional spaces without the computational
    strain that classical computers face. This allows quantum SVMs to handle more
    complex datasets more efficiently.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是量子支持向量机（Quantum Support Vector Machine）。值得注意的是，经典支持向量机（SVM）通常使用[核技巧](https://en.wikipedia.org/wiki/Kernel_method)将数据转换到更高维的空间，从而找到分隔超平面。然而，量子支持向量机则具有显著的优势，因为它们能够自然地在指数级更高维的空间中表示数据，而不会遭遇经典计算机所面临的计算负担。这使得量子支持向量机能够更高效地处理更复杂的数据集。
- en: Another example is in the realm of neural network training. The basic unit of
    quantum computation, the qubit, can be entangled with other qubits, creating correlations
    that classical systems can’t replicate. While entanglement offers possibilities
    for correlated updates across a quantum neural network, it’s important to note
    that the concept is still under research.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是在神经网络训练领域。量子计算的基本单元——量子比特，可以与其他量子比特纠缠，产生经典系统无法复制的关联。虽然纠缠为量子神经网络中相关的更新提供了可能性，但需要注意的是，这一概念仍在研究之中。
- en: '**Part 1: Introduction to Quantum Computing**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一部分：量子计算简介**'
- en: 'Quantum computers function very differently from classical computers, leveraging
    quantum properties and phenomena to greatly increase computational power. At a
    high level, there are a few tenets of quantum computing that differentiate it
    from classical computation: qubits versus bits, quantum versus classical logic
    gates, the presence of quantum phenomena, and the opportunities offered by quantum
    computing’s enhanced computational capabilities.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算机的运作方式与经典计算机截然不同，利用量子特性和现象大幅提升计算能力。从高层次来看，有几个量子计算的基本原则将其与经典计算区分开：量子比特与经典比特，量子与经典逻辑门，量子现象的存在，以及量子计算所提供的增强计算能力所带来的机遇。
- en: At the core of quantum computing is the qubit, which serves as the fundamental
    unit of computation in a quantum computer– taking the place of a classical computer’s
    bit. While the bit can occupy either the 0 or 1 state exclusively, the qubit can
    be in a superposition of the 0 and 1 states (Microsoft, n.d.). It can be very
    hard to conceptualize the qubit; where the classical bit is simply an electric
    current or absence of electric current, the qubit can take many different physical
    forms.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算的核心是量子比特（qubit），它作为量子计算机中的基本计算单元，取代了经典计算机中的比特。经典比特只能独占地处于0或1的状态，而量子比特则可以处于0和1状态的叠加态（Microsoft，n.d.）。量子比特的概念非常难以理解；经典比特仅仅是电流或没有电流的状态，而量子比特则可以有许多不同的物理形式。
- en: These include “spin” qubits, which is the most straightforward example. This
    type of qubit uses the spin property of a particle (generally an electron) to
    complete computations. To initialize a spin qubit, an electron is trapped using
    a quantum dot, for example, then manipulated using magnetic fields that interact
    with their spin state (Harvey, 2024). The computational difference between a bit
    and qubit is significant, and stems from the qubit’s ability to be affected by
    quantum phenomena like superposition between the 0 and 1 states, and entanglement
    with other qubits (Microsoft, n.d.).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包括“自旋”量子比特，这是最直接的例子。这种类型的量子比特利用粒子（通常是电子）的自旋特性来完成计算。例如，要初始化一个自旋量子比特，可以使用量子点困住电子，然后通过与电子自旋状态相互作用的磁场来操控它（Harvey，2024）。比特和量子比特之间的计算差异是显著的，源于量子比特能够受到量子现象的影响，如0和1状态之间的叠加态，以及与其他量子比特的纠缠（Microsoft，n.d.）。
- en: One tool that is very helpful in visualizing the state of a qubit is the Bloch
    sphere; it is effectively just a sphere with north and south poles representing
    |0⟩ and |1⟩ respectively, and all other points along the sphere representing linear
    combinations of the poles’ values (Microsoft, 2024). Since this representation
    of the qubit uses a complex vector space, the state of the qubit will be described
    in Dirac notation hereafter. This visualization of the superposition state of
    a qubit aids in the understanding of quantum logic gates especially because it
    allows for a geometric understanding of the operation being performed. Generally,
    when a qubit is initialized it is in the z-basis |0⟩ state, which is analogous
    to the classical 0 state (Quantum-Inspire by QuTech, 2024).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有助于可视化量子比特状态的工具是Bloch球；它实际上只是一个球体，北极和南极分别代表|0⟩和|1⟩，球体上的所有其他点表示北极和南极值的线性组合（微软，2024）。由于这种量子比特的表示使用了复数向量空间，因此量子比特的状态将在后续用狄拉克符号表示。量子比特叠加态的这一可视化有助于理解量子逻辑门，特别是因为它允许对正在执行的操作进行几何理解。通常，当量子比特初始化时，它处于z基态|0⟩状态，这与经典的0状态类似（Quantum-Inspire
    by QuTech，2024）。
- en: '![](../Images/45c0199014e8b06cb35b197936138a50.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/45c0199014e8b06cb35b197936138a50.png)'
- en: Bloch Sphere illustration, Wikipedia. (n.d.) [https://en.wikipedia.org/wiki/Bloch_sphere](https://en.wikipedia.org/wiki/Bloch_sphere).
    (GFDL License)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Bloch球示意图，维基百科。（无日期）[https://en.wikipedia.org/wiki/Bloch_sphere](https://en.wikipedia.org/wiki/Bloch_sphere)。（GFDL
    许可证）
- en: 'Another key difference between the classical and quantum computer is the logic
    gates: while classical computers use AND, OR, NOT, etc. to perform basic logic
    operations, quantum computers use quantum logic gates such as X, Hadamard, Toffoli,
    and CNOT (Wikipedia, 2024). These quantum gates are used to perform logical operations
    on a single qubit or a very small number of qubits, and can be combined with others
    to perform more complex operations and manipulations.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 经典计算机和量子计算机之间的另一个关键区别是逻辑门：经典计算机使用与、或、非等逻辑门来执行基本逻辑操作，而量子计算机使用量子逻辑门，如X门、哈达玛门、托福利门和CNOT门（维基百科，2024）。这些量子门用于对单个量子比特或少量量子比特执行逻辑操作，并可以与其他量子门结合，进行更复杂的操作和处理。
- en: 'First, the X gate is very similar to the classical NOT gate: it inverts the
    phase of a qubit– if a qubit is in the |0⟩ state, it inverts to the |1⟩ state,
    and vice versa.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，X门非常类似于经典的非门：它会反转量子比特的相位——如果量子比特处于|0⟩状态，它会反转为|1⟩状态，反之亦然。
- en: Next, the Hadamard gate is used to put a qubit in the |0⟩ state into an equal
    superposition between |1⟩ and |0⟩. Third, the Toffoli gate is an example of a
    multi-qubit gate.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，哈达玛门用于将处于|0⟩状态的量子比特置于|1⟩和|0⟩之间的均等叠加态。第三，托福利门是一个多量子比特门的例子。
- en: The Toffoli gate operates with three qubits, two of them are “control” and one
    is the “target.” In the Toffoli gate it will invert the target qubit only if the
    two control qubits are in the |1⟩ state (Roy & Chakrabarti, 2024).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 托福利门操作三个量子比特，其中两个是“控制”量子比特，一个是“目标”量子比特。在托福利门中，只有当两个控制量子比特处于|1⟩状态时，目标量子比特才会被反转（Roy
    & Chakrabarti，2024）。
- en: Finally, the CNOT gate is a very common gate used in quantum computing, and
    we will examine a use case later on. The CNOT is also a multiple qubit gate, as
    it has one target qubit and one control qubit; when the control qubit is in the
    |1⟩ state, it inverts the phase of the target qubit.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，CNOT门是量子计算中非常常见的一个门，我们稍后将讨论它的一个用例。CNOT门也是一个多量子比特门，它有一个目标量子比特和一个控制量子比特；当控制量子比特处于|1⟩状态时，它会反转目标量子比特的相位。
- en: These are just a few examples of many interesting quantum logic gates, and it
    is important to note that unlike classical logic gates, there is not necessarily
    a physical “gate” that the qubits pass through, but rather these are just operations
    that are performed on the qubit which take different forms depending on many factors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是许多有趣的量子逻辑门中的一部分，值得注意的是，与经典逻辑门不同，量子逻辑门不一定有一个物理“门”供量子比特通过，而是这些操作在量子比特上执行，并且根据许多因素的不同，这些操作可以采取不同的形式。
- en: A third major difference between classical and quantum computing is the presence
    of quantum phenomena such as superposition, superconduction, entanglement and
    interference. These properties are used in different ways depending on the methods
    used to perform quantum computations (Microsoft Azure, 2024). Another property
    that is present is quantum decoherence, which poses a serious problem to the development
    of useful or widespread quantum computing. Quantum decoherence is when a particle
    in superposition interacts with its environment and becomes entangled with the
    environment, ultimately interfering with the computational outcome (Brandt, 1999).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 经典计算和量子计算之间的第三个主要区别是量子现象的存在，如叠加、超导、纠缠和干涉。这些特性根据执行量子计算的方法的不同而以不同的方式被使用（Microsoft
    Azure，2024）。另一个存在的特性是量子退相干，它对有用或广泛量子计算的发展构成了严重问题。量子退相干是指处于叠加态的粒子与环境相互作用并与环境纠缠，最终干扰计算结果（Brandt，1999）。
- en: 'The computational advances of a quantum computer are great: take, for example,
    the algorithm used for finding the prime factors of an integer. In classical computing,
    one of the leading prime factorization algorithms is General Number Field Sieve
    (Wikipedia, 2024). The program runs at a quasi-polynomial time complexity, and
    it shows how hard it can be to factor a **very** large number. Compared to the
    leading quantum algorithm, Shor’s Algorithm, which runs in logarithmic space complexity,
    and a polylogarithmic time complexity, which is once again a complicated expression,
    but boils down to the fact that it is vastly more efficient (Li et al., 2022).
    Obviously this is just one example, but it serves as a testament to the power
    of quantum computing– the power to turn a program which runs in exponential time
    into a program which runs in logarithmic time is truly remarkable.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 量子计算机的计算能力非常强大：以一个用于寻找整数素因子的算法为例。在经典计算中，领先的素因数分解算法是广义数域筛法（Wikipedia，2024）。该程序以准多项式时间复杂度运行，显示了分解**非常**大数的困难。与领先的量子算法——Shor算法相比，后者以对数空间复杂度和多对数时间复杂度运行，虽然这也是一个复杂的表达式，但归结为它显著更高效（Li等，2022）。显然，这只是一个例子，但它证明了量子计算的强大——将一个以指数时间运行的程序转变为一个以对数时间运行的程序，实在是令人惊叹。
- en: '**Part 2: Quantum Programming: Languages, Compilers and Algorithms**'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**第二部分：量子编程：语言、编译器与算法**'
- en: Though their hardware is fundamentally different from classical computers, quantum
    computers are programmed using languages often similar in syntax to classical
    languages. These include QCL, Qiskit, and Q#, who are based around the syntax
    of C, Python, and C#/F# respectively. Furthermore, their compilers are built with
    C++, Python and C++, and C# respectively. (IonQ, 2024). Thus, classical and quantum
    languages can be very similar syntactically– the main difference comes from the
    content of the programs, and how quantum algorithms are structured.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们的硬件与经典计算机根本不同，但量子计算机的编程语言通常与经典语言的语法相似。包括QCL、Qiskit和Q#，它们分别基于C、Python和C#/F#的语法。此外，它们的编译器分别是用C++、Python和C++、C#构建的。（IonQ，2024）。因此，经典语言和量子语言在语法上可能非常相似——主要的区别来自程序的内容，以及量子算法的结构方式。
- en: Before examining different languages, their syntaxes, and how they compare to
    the classical languages that they’re based around, it’s important to understand
    the content of a quantum program and why no matter how similar the syntax is,
    there is an unbridgeable gap between a classical and quantum program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究不同的语言、它们的语法以及它们与所基于的经典语言的比较之前，理解量子程序的内容及其原因非常重要——无论语法多么相似，经典程序与量子程序之间始终存在一条无法逾越的鸿沟。
- en: This stems from the mechanics of a quantum computer– as discussed before, quantum
    computation is based around holding qubits in superposition, and applying different
    “gates” to them– effectively transformations along the Bloch sphere that they
    are represented by. What that boils down to is the fact that unlike a classical
    computer, where you write a program which will utilize a pre-made circuit to perform
    computations, quantum programming is the act of actually encoding the circuit.
    Let’s examine some pseudo code and its associated quantum circuit to better understand
    this. Maybe the simplest possible quantum program/circuit, the following program
    simply initializes a qubit, applies a Hadamard gate to put it into a superposition,
    then measures the state of the qubit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这源于量子计算机的机制——正如之前讨论的那样，量子计算是基于将量子比特保持在叠加态，并对其应用不同的“门”——实质上是沿着其表示的布洛赫球进行变换。简而言之，不同于经典计算机，你编写一个程序，它会利用一个预制的电路来执行计算，量子编程则是实际对电路进行编码的过程。让我们通过一些伪代码和其相关的量子电路来更好地理解这一点。也许最简单的量子程序/电路，以下程序只是初始化一个量子比特，应用一个哈达玛门将其置于叠加态，然后测量该量子比特的状态。
- en: '![](../Images/4077e897ba6ae1db001fe536e2930eda.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4077e897ba6ae1db001fe536e2930eda.png)'
- en: Image by author.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由作者提供。
- en: 'The associated quantum circuit for this program is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本程序的相关量子电路为：
- en: '![](../Images/5c02f68d247339f85caae42b9c29a185.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5c02f68d247339f85caae42b9c29a185.png)'
- en: The “H” represents a Hadamrd gate, and the meter represents a measurement being
    taken. Image by author.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “H”表示哈达玛门，测量符号表示正在进行测量。图片由作者提供。
- en: The double line following the measurement symbol indicates that the qubit is
    no longer in a superposition, but rather one of two discrete states (0 or 1) since
    its wave function was collapsed during the measurement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测量符号后的双线表示量子比特不再处于叠加态，而是处于两种离散状态之一（0 或 1），因为其波函数在测量过程中已坍缩。
- en: 'To get a better feel for the syntax of different quantum languages, let’s look
    at programs in the three aforementioned languages that all serve identical purposes.
    All three programs are made to create a Bell state, which is an entangled state
    of two qubits. The gates (operations) applied to the two qubits are: Hadamard
    on the first qubit, 0, then on the second qubit, 1, with the first qubit as the
    control. The function of the CNOT gate is effectively just to entangle two qubits
    (Rioux, 2023).'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解不同量子语言的语法，我们来看一下三种前面提到的语言中的程序，这些程序都实现相同的功能。这三种程序都是用来创建贝尔态的，即两个量子比特的纠缠态。对这两个量子比特施加的门（操作）是：对第一个量子比特应用哈达玛门（0），然后对第二个量子比特应用哈达玛门（1），第一个量子比特作为控制位。CNOT门的功能实际上就是将两个量子比特纠缠起来（Rioux,
    2023）。
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Unsurprisingly, the quantum programs look very similar in syntax to the languages
    each is based on– for example the Pythonic program uses a couple built-in methods
    and doesn’t have much else going on and the C# based program is full of curly
    brackets. Reviewing the syntax of a few quantum languages is helpful to understand
    what a quantum program looks like, but the reality is that the hardware being
    used is so different that the actual code in a quantum program would be useless
    to a classical computer, and vice versa. Because of that, it would be much more
    interesting to analyze two algorithms made for the same purpose, one classical
    and one quantum, and dissect the different steps taken in each case to achieve
    the result.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，量子程序在语法上与它们所基于的语言非常相似——例如，Python 程序使用了几个内置方法，并没有其他太多的内容，而基于 C# 的程序则充满了花括号。回顾一些量子语言的语法有助于理解量子程序的外观，但实际情况是，所使用的硬件差异如此之大，以至于量子程序中的代码对经典计算机而言是无用的，反之亦然。因此，分析两个目的相同的算法，一个是经典算法，一个是量子算法，并对每个步骤进行剖析，分析它们是如何实现结果的，才会更加有趣。
- en: Recall the example presented in Part 1 (GNFS and Shor’s algorithm), where we
    looked at the time complexities of two prime factorization algorithms. As both
    algorithms are rather abstract and complex, it may be easier to understand their
    respective theories in paragraph format instead of examining their pseudo code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第一部分中呈现的例子（GNFS 和 Shor 算法），我们查看了两种质因数分解算法的时间复杂度。由于这两种算法都相当抽象和复杂，可能比起检查它们的伪代码，以段落格式理解它们各自的理论会更加容易。
- en: The classical algorithm, General Number Field Sieve, can be summarized into
    five main algorithmic steps (Case, n.d.). Throughout the explanation, “N” refers
    to the number being factored.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 经典算法，广义数域筛法（GNFS），可以总结为五个主要算法步骤（Case, n.d.）。在整个解释中，“N”指的是待因式分解的数字。
- en: 'The first step is polynomial selection: this step involves selecting two polynomials
    such that they multiply to smooth numbers when evaluated at certain points modulo
    N.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是多项式选择：这一阶段涉及选择两个多项式，使它们在某些点上模 N 计算时相乘得到平滑数。
- en: 'The next step is the “sieve” step: the goal is to find sets of integers (a,
    b) such that 𝑓(𝑎)⋅𝑔(𝑏) ≡ ℎ2(mod N) where *h* is a smooth number, and store all
    values (a, b, and h).'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是“筛选”步骤：目标是找到一组整数（a，b），使得 𝑓(𝑎)⋅𝑔(𝑏) ≡ ℎ²(mod N)，其中 *h* 是一个平滑数，并存储所有的值（a，b
    和 h）。
- en: 'The third step is the matrix step: a large matrix, A, is constructed from the
    relations found in the sieve step.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步是矩阵步骤：从筛选步骤中找到的关系构建一个大型矩阵 A。
- en: Next use Gaussian elimination to reduce A to a simpler form while preserving
    its properties. This process will identify a set of linearly independent relations.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来使用高斯消元法将 A 化简为更简单的形式，同时保留其属性。这个过程将识别出一组线性无关的关系。
- en: Use linnear algebra methods such as Lanczos algorithm to find the null space
    of the matrix– this will give vectors that correspond to dependencies among the
    relations.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用线性代数方法，如 Lanczos 算法，找到矩阵的零空间——这将提供与关系之间的依赖性相关的向量。
- en: Combining the relations found before will produce squares in modulo N, which
    after further mathematical manipulation give two integers X and Y.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将之前找到的关系结合起来，会在模 N 中产生平方，经过进一步的数学操作后得到两个整数 X 和 Y。
- en: These two integers are used to find the non trivial factors of N by computing
    the GCD of X — Y and X + Y with respect to N (Case, n.d.). That method is described
    by quasi-polynomial complexity, which, while it does run in sub-polynomial time,
    is much slower than the quantum method, Shor’s algorithm.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个整数用于通过计算 X — Y 和 X + Y 与 N 的最大公约数（GCD）来找到 N 的非平凡因子（Case, n.d.）。该方法的复杂度为准多项式，虽然它在子多项式时间内运行，但比量子方法
    Shor 算法要慢得多。
- en: The process of calculating an integer N’s prime factors using Shor’s algorithm
    is entirely different from using GNFS. Shor’s algorithm can be broken down into
    a few main steps.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Shor 算法计算整数 N 的质因数与使用 GNFS 完全不同。Shor 算法可以分解为几个主要步骤。
- en: 'The first step uses classical computing: pick a random integer r such that
    1 < r < N, calculate their GCD’s and if it does not equal 1, it is a non-trivial
    factor of N.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步使用经典计算：选择一个随机整数 r，满足 1 < r < N，计算它们的最大公约数，如果不等于 1，则它是 N 的非平凡因子。
- en: The next step is to prepare the needed qubits– we do this with two quantum registers,
    which function just like classical registers. In the first register there are
    enough qubits to represent integers from 0 to q–1 where q is a power of 2 that
    is at least N². The second register has enough qubits to represent integers from
    0 to N–1.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是准备所需的量子比特——我们使用两个量子寄存器来实现，它们的功能类似于经典寄存器。在第一个寄存器中，有足够的量子比特来表示从 0 到 q–1 的整数，其中
    q 是至少 N² 的 2 的幂。第二个寄存器有足够的量子比特来表示从 0 到 N–1 的整数。
- en: 'The next step deviates from classical computing heavily: to put the entire
    first register into a superposition, apply a Hadamard transform to each qubit.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步与经典计算有很大不同：为了将整个第一个寄存器放入叠加态，应用 Hadamard 变换到每一个量子比特。
- en: Next use a quantum circuit to compute the function *f*(x) = r^x mod(N) and store
    the result in the second register; this will entangle the first and second registers.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来使用量子电路计算函数 *f*(x) = r^x mod(N)，并将结果存储在第二个寄存器中；这将纠缠第一个和第二个寄存器。
- en: Next measure the second register– this will collapse it into a state |k⟩ (where
    k = r^x mod(N)) which leaves the first register in a superposition of values x
    that map to |k⟩.Now the period of the function f(x)=r^x mod(N) can be expressed
    as T.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，测量第二个寄存器——这将使其坍缩成一个状态 |k⟩（其中 k = r^x mod(N)），从而将第一个寄存器保持在一个值 x 的叠加态中，这些值映射到
    |k⟩。现在，函数 f(x)=r^x mod(N) 的周期可以表示为 T。
- en: The penultimate step of the algorithm is to apply a quantum fourier transform
    (QFT) to the first register, which will yield a series of peaks in the frequency
    domain corresponding to values of 1/T.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法的倒数第二步是对第一个寄存器应用量子傅里叶变换（QFT），这将在频率域中产生一系列峰值，对应于 1/T 的值。
- en: The final step in the quantum computation is to measure the first register–
    the result will be an integer, B, such that B is q/T, recall q from when we defined
    the first register. Having completed the quantum computation, you then move onto
    the classical post-processing step to get the final result.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 量子计算的最后一步是测量第一个寄存器——结果将是一个整数B，使得B = q/T，回想一下q是我们定义第一个寄存器时的值。完成量子计算后，接下来进入经典后处理步骤，以获得最终结果。
- en: The post-processing involves manipulating the measured result B to get the period,
    T. If T is even, compute the GCD of N with r^(T/2) + 1 and r^(T/2) - 1, which
    will yield non-trivial factors of N. If T is odd, repeat algorithm with a different
    r value. This program’s polylogarithmic time complexity is very efficient, especially
    compared to the GNFS algorithm (Pavlidis & Gizopoulos, 2022).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 后处理涉及操纵测量结果B以得到周期T。如果T是偶数，计算N与r^(T/2) + 1和r^(T/2) - 1的最大公约数（GCD），这将产生N的非平凡因子。如果T是奇数，使用不同的r值重复算法。该程序的多对数时间复杂度非常高效，尤其是与GNFS算法相比（Pavlidis
    & Gizopoulos，2022）。
- en: 'Here is a visual representation of the flow of both algorithms to aid understanding,
    where red is the beginning step, blue is the GNFS algorithm, and green is Shor’s
    algorithm:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是两种算法流程的视觉表示，以帮助理解，其中红色表示开始步骤，蓝色表示GNFS算法，绿色表示Shor算法：
- en: '![](../Images/93b009f5e65cea540c2ef53d0166bdbd.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/93b009f5e65cea540c2ef53d0166bdbd.png)'
- en: Blue steps correspond to GNFS, and green steps correspond to Shor’s Algorithm.
    Image by author.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色步骤对应GNFS，绿色步骤对应Shor算法。图片来自作者。
- en: 'What enables Shor’s algorithm to run so much faster than the GNFS is the fundamentally
    different computational concepts being used: Shor’s algorithm leverages quantum
    mechanics to achieve polynomial time complexity. This speedup is primarily due
    to quantum parallelism (the ability to perform many quantum operations at the
    same time) and the efficient execution of the quantum Fourier transform, which
    are impossible in classical computing. By utilizing superposition and entanglement,
    Shor’s algorithm reduces factoring to a period-finding problem, solved exponentially
    faster than classical methods (Brandt, 1999).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Shor算法比GNFS运行得更快的原因在于其使用了根本不同的计算概念：Shor算法利用量子力学来实现多项式时间复杂度。这种加速主要得益于量子并行性（同时执行多个量子操作的能力）和量子傅里叶变换的高效执行，这在经典计算中是无法实现的。通过利用叠加态和纠缠，Shor算法将因式分解问题转化为周期寻找问题，解决速度远远超过经典方法（Brandt，1999）。
- en: 'Obviously both algorithms are very complex, but they serve as an excellent
    example since the problem of factoring a large integer is something a quantum
    computer can do much faster than a classical computer. A much simpler example
    that we can analyze the quantum code for is a quantum take on rock-paper-scissors
    (or a coin toss if that’s easier to think about). Two players each initialize
    a qubit (one each) to the |0⟩ state and apply a Hadamard gate which puts it into
    an equal superposition between |0⟩ and |1⟩. Finally, both qubits are measured–
    if both qubits collapse to the |0⟩ or |1⟩ state, it is a draw. Otherwise, whoever’s
    qubit collapsed to the |0⟩ state loses, and the one who’s qubit collapsed to the
    |1⟩ state wins. Let’s write the code to run this program in Qiskit:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，两个算法都非常复杂，但它们作为一个极好的例子，因为大整数因式分解问题是量子计算机比经典计算机要快得多的任务。我们可以分析量子代码的一个更简单的例子，就是量子版的剪刀石头布（或者如果更容易理解，可以是抛硬币）。两个玩家各自初始化一个量子比特（各一个）为|0⟩状态，并施加哈达玛门，这将其置于|0⟩和|1⟩的等概率叠加态。最后，两个量子比特被测量——如果两个量子比特都坍缩到|0⟩或|1⟩状态，则为平局。否则，坍缩到|0⟩状态的玩家输，而坍缩到|1⟩状态的玩家赢。让我们编写代码来运行这个程序，使用Qiskit：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of that code is simply the quantum circuit associated with the program,
    since it never actually runs the circuit on a quantum computer. However, that
    is the general format used when defining a very basic quantum circuit– a number
    of qubits and bits are allocated to it, then stating– in order– the operations
    to be performed on each qubit. The output of this code, which is just a visual
    representation of the circuit is:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出只是与程序相关的量子电路，因为它实际上并没有在量子计算机上运行电路。然而，这就是定义一个非常基本量子电路时使用的一般格式——分配一定数量的量子比特和经典比特，然后按顺序列出要对每个量子比特执行的操作。该代码的输出只是该电路的视觉表示：
- en: '![](../Images/f617c91fb0de065d8b3028307c1f7fa0.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f617c91fb0de065d8b3028307c1f7fa0.png)'
- en: The boxes with “H” represent Hadamard gates, those with an “X” represent CNOT
    gates, and those with an “M” represent measurements being taken. Image by author.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 带有“H”的框表示Hadamard门，带有“X”的框表示CNOT门，带有“M”的框表示正在进行的测量。图片由作者提供。
- en: Before we can run this program on a quantum computer, there are a few steps
    we need to take. The most important is optimizing the circuit; not all quantum
    computers have the same ability to operate on qubits with certain gates, and they
    don’t always have the same connectivity of qubits. We need to add this circuit
    optimization into our code to prepare it to run on a real quantum computer. To
    do this we use the following code which defines our access to the IBM Quantum
    Backend using an IBM API key, then runs an optimization of the circuit, printing
    the optimized circuit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够在量子计算机上运行这个程序之前，有几个步骤需要完成。最重要的步骤是优化电路；并非所有的量子计算机都能以相同的方式在量子比特上操作特定的门，也并非所有量子计算机的量子比特之间都有相同的连接性。我们需要将这个电路优化步骤添加到代码中，以便让它准备好在实际的量子计算机上运行。为此，我们使用以下代码，它定义了我们通过IBM
    API密钥访问IBM量子后台的方式，然后对电路进行优化，并打印优化后的电路。
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output of this program is less important since it is just a more complex
    version of the same circuit, but it results in a circuit that is optimized for
    an IBM Quantum computer and while it looks much different and more complicated,
    it will function the same as the circuit from earlier.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出并不那么重要，因为它只是同一电路的更复杂版本，但它生成了一个为IBM量子计算机优化的电路，尽管看起来差异很大且更复杂，但它的功能与之前的电路相同。
- en: 'In conclusion, while the topic of quantum programming can be daunting due to
    its many languages and contrasting algorithms, as well as the background in math,
    physics, and computing needed to understand it, when broken down right it’s not
    so bad. Through incremental learning it’s very achievable to understand quantum
    computing. Furthermore, quantum computing has fascinating aspects in many STEM
    fields– number theory, linear algebra, calculus, and discrete mathematics all
    apply to the theoretical side of quantum algorithms; engineering, physics, computer
    science, and logic all apply to the actual design of quantum algorithms. Then
    again, the more you learn about the fascinating realm of quantum computing, the
    more you may find yourself feeling like Richard Feynman’s famous quote: “I’m smart
    enough to know that I’m dumb.” (Goodreads, 2024)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，尽管量子编程的主题因其多种语言和对比算法，以及理解所需的数学、物理和计算背景，可能会让人感到困难，但如果分解得当，它其实并不那么难。通过渐进学习，理解量子计算是完全可实现的。此外，量子计算在许多STEM领域中具有令人着迷的方面——数论、线性代数、微积分和离散数学都应用于量子算法的理论方面；工程学、物理学、计算机科学和逻辑则都应用于量子算法的实际设计。不过，越是学习量子计算这一迷人的领域，你可能越会发现自己和理查德·费曼的名言产生共鸣：“我足够聪明，知道自己有多笨。”（Goodreads,
    2024）
- en: '**References**'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**参考文献**'
- en: Adedoyin, A., & et. al. (2022, January 8). *Quantum Algorithm Implementations
    for Beginners*. ACM Digital Library. Retrieved May 27, 2024, from [https://dl.acm.org/doi/10.1145/3517340#d1e3003](https://dl.acm.org/doi/10.1145/3517340#d1e3003)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Adedoyin, A., & 等人 (2022年1月8日). *初学者的量子算法实现*. ACM数字图书馆. 2024年5月27日取自 [https://dl.acm.org/doi/10.1145/3517340#d1e3003](https://dl.acm.org/doi/10.1145/3517340#d1e3003)
- en: Brandt, H. E. (1999, November). *Qubit devices and the issue of quantum decoherence*.
    Science Direct. Retrieved May 20, 2024, from [https://www.sciencedirect.com/science/article/pii/S0079672799000038](https://www.sciencedirect.com/science/article/pii/S0079672799000038)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Brandt, H. E. (1999年11月). *量子比特设备与量子退相干问题*. Science Direct. 2024年5月20日取自 [https://www.sciencedirect.com/science/article/pii/S0079672799000038](https://www.sciencedirect.com/science/article/pii/S0079672799000038)
- en: Brubaker, B. (2023, October 17). *Thirty Years Later, a Speed Boost for Quantum
    Factoring*. Quanta Magazine. Retrieved May 27, 2024, from [https://www.quantamagazine.org/thirty-years-later-a-speed-boost-for-quantum-factoring-20231017/](https://www.quantamagazine.org/thirty-years-later-a-speed-boost-for-quantum-factoring-20231017/)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Brubaker, B. (2023年10月17日). *三十年后，量子因式分解的速度提升*. Quanta杂志. 2024年5月27日取自 [https://www.quantamagazine.org/thirty-years-later-a-speed-boost-for-quantum-factoring-20231017/](https://www.quantamagazine.org/thirty-years-later-a-speed-boost-for-quantum-factoring-20231017/)
- en: Case, M. (n.d.). *A Beginner’s Guide To The General Number Field Sieve*. UMD
    Computer Science. Retrieved May 26, 2024, from [https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf](https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Case, M. (无日期). *初学者的通用数域筛法指南*. 马里兰大学计算机科学系. 2024年5月26日取自 [https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf](https://www.cs.umd.edu/~gasarch/TOPICS/factoring/NFSmadeeasy.pdf)
- en: Goodreads. (2024). *Quotes by Richard P. Feynman (Author of Surely You’re Joking,
    Mr. Feynman!)*. Goodreads. Retrieved May 27, 2024, from [https://www.goodreads.com/author/quotes/1429989.Richard_P_Feynman](https://www.goodreads.com/author/quotes/1429989.Richard_P_Feynman)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Goodreads. (2024年). *理查德·费曼的名言（《你一定是在开玩笑，费曼先生！》的作者）*. Goodreads. 2024年5月27日取自
    [https://www.goodreads.com/author/quotes/1429989.Richard_P_Feynman](https://www.goodreads.com/author/quotes/1429989.Richard_P_Feynman)
- en: Harvey, S. P. (2024, March 5). *Quantum Dots/Spin Qubits*. Oxford University
    Press and The American Institute of Physics. Retrieved May 19, 2024, from [https://oxfordre.com/physics/display/10.1093/acrefore/9780190871994.001.0001/acrefore-9780190871994-e-83](https://oxfordre.com/physics/display/10.1093/acrefore/9780190871994.001.0001/acrefore-9780190871994-e-83)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Harvey, S. P. (2024年3月5日). *量子点/自旋量子比特*. 牛津大学出版社和美国物理学会. 2024年5月19日取自 [https://oxfordre.com/physics/display/10.1093/acrefore/9780190871994.001.0001/acrefore-9780190871994-e-83](https://oxfordre.com/physics/display/10.1093/acrefore/9780190871994.001.0001/acrefore-9780190871994-e-83)
- en: IBM. (2024). *IBM Qiskit Docs*. IBM Quantum Documentation. Retrieved May 26,
    2024, from [https://docs.quantum.ibm.com/](https://docs.quantum.ibm.com/)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: IBM. (2024年). *IBM Qiskit文档*. IBM量子文档. 2024年5月26日取自 [https://docs.quantum.ibm.com/](https://docs.quantum.ibm.com/)
- en: IonQ. (2024, March 14). *Hello Many Worlds in Seven Quantum Languages*. IonQ.
    Retrieved May 26, 2024, from [https://ionq.com/docs/hello-many-worlds-seven-quantum-languages](https://ionq.com/docs/hello-many-worlds-seven-quantum-languages)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: IonQ. (2024年3月14日). *七种量子语言中的“你好，多重世界”*. IonQ. 2024年5月26日取自 [https://ionq.com/docs/hello-many-worlds-seven-quantum-languages](https://ionq.com/docs/hello-many-worlds-seven-quantum-languages)
- en: Li, J., Peng, X., Du, J., & Suter, D. (2022, January 8). *An Efficient Exact
    Quantum Algorithm for the Integer Square-free Decomposition Problem*. Nature.
    Retrieved May 26, 2024, from [https://www.nature.com/articles/srep00260](https://www.nature.com/articles/srep00260)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Li, J., Peng, X., Du, J., & Suter, D. (2022年1月8日). *一种高效的精确量子算法用于整数平方自由分解问题*.
    《自然》. 2024年5月26日取自 [https://www.nature.com/articles/srep00260](https://www.nature.com/articles/srep00260)
- en: Microsoft. (n.d.). *What is a Qubit?* Microsoft Azure. Retrieved May 19, 2024,
    from [https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-a-qubit](https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-a-qubit)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft. (无日期). *什么是量子比特?* Microsoft Azure. 2024年5月19日取自 [https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-a-qubit](https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-a-qubit)
- en: Microsoft. (2024). *Azure Quantum | Single-qubit gates*. Azure Quantum. Retrieved
    May 20, 2024, from [https://quantum.microsoft.com/en-us/explore/concepts/single-qubit-gates](https://quantum.microsoft.com/en-us/explore/concepts/single-qubit-gates)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft. (2024年). *Azure量子 | 单量子比特门*. Azure量子. 2024年5月20日取自 [https://quantum.microsoft.com/en-us/explore/concepts/single-qubit-gates](https://quantum.microsoft.com/en-us/explore/concepts/single-qubit-gates)
- en: Microsoft Azure. (2024, January 12). *Understanding quantum computing — Azure
    Quantum*. Microsoft Learn. Retrieved May 20, 2024, from [https://learn.microsoft.com/en-us/azure/quantum/overview-understanding-quantum-computing](https://learn.microsoft.com/en-us/azure/quantum/overview-understanding-quantum-computing)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft Azure. (2024年1月12日). *理解量子计算——Azure量子*. Microsoft Learn. 2024年5月20日取自
    [https://learn.microsoft.com/en-us/azure/quantum/overview-understanding-quantum-computing](https://learn.microsoft.com/en-us/azure/quantum/overview-understanding-quantum-computing)
- en: Pavlidis, A., & Gizopoulos, D. (2022, July 19). *Quantum Cryptography — Shor’s
    Algorithm Explained*. Classiq. Retrieved May 27, 2024, from [https://www.classiq.io/insights/shors-algorithm-explained](https://www.classiq.io/insights/shors-algorithm-explained)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Pavlidis, A., & Gizopoulos, D. (2022年7月19日). *量子密码学——Shor算法解释*. Classiq. 2024年5月27日取自
    [https://www.classiq.io/insights/shors-algorithm-explained](https://www.classiq.io/insights/shors-algorithm-explained)
- en: Quantum-Inspire by QuTech. (2024). *Qubit basis states*. Quantum Inspire. Retrieved
    May 20, 2024, from [https://www.quantum-inspire.com/kbase/qubit-basis-states/](https://www.quantum-inspire.com/kbase/qubit-basis-states/)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Quantum-Inspire by QuTech. (2024年). *量子比特基态*. Quantum Inspire. 2024年5月20日取自
    [https://www.quantum-inspire.com/kbase/qubit-basis-states/](https://www.quantum-inspire.com/kbase/qubit-basis-states/)
- en: 'Rioux, F. (2023, January 10). *8.53: Bell State Exercises*. Chemistry LibreTexts.
    Retrieved May 26, 2024, from [https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Quantum_Tutorials_(Rioux)/08%3A_Quantum_Teleportation/8.53%3A_Bell_State_Exercises](https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Quantum_Tutorials_(Rioux)/08%3A_Quantum_Teleportation/8.53%3A_Bell_State_Exercises)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rioux, F. (2023年1月10日). *8.53: 贝尔态练习*。Chemistry LibreTexts. 2024年5月26日检索自 [https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Quantum_Tutorials_(Rioux)/08%3A_Quantum_Teleportation/8.53%3A_Bell_State_Exercises](https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Quantum_Tutorials_(Rioux)/08%3A_Quantum_Teleportation/8.53%3A_Bell_State_Exercises)'
- en: Roy, S. G., & Chakrabarti, A. (2024, March 5). *Toffoli Gate*. Science Direct.
    Retrieved May 20, 2024, from [https://www.sciencedirect.com/topics/computer-science/toffoli-gate](https://www.sciencedirect.com/topics/computer-science/toffoli-gate)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Roy, S. G., & Chakrabarti, A. (2024年3月5日). *托福利门*。Science Direct. 2024年5月20日检索自
    [https://www.sciencedirect.com/topics/computer-science/toffoli-gate](https://www.sciencedirect.com/topics/computer-science/toffoli-gate)
- en: Wikipedia. (2024). *General number field sieve*. Wikipedia. Retrieved May 24,
    2024, from [https://en.wikipedia.org/wiki/General_number_field_sieve](https://en.wikipedia.org/wiki/General_number_field_sieve)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Wikipedia. (2024年). *一般数域筛法*。Wikipedia. 2024年5月24日检索自 [https://en.wikipedia.org/wiki/General_number_field_sieve](https://en.wikipedia.org/wiki/General_number_field_sieve)
- en: Wikipedia. (2024, May 15). *Quantum logic gate*. Wikipedia. Retrieved May 19,
    2024, from [https://en.wikipedia.org/wiki/Quantum_logic_gate](https://en.wikipedia.org/wiki/Quantum_logic_gate)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Wikipedia. (2024年5月15日). *量子逻辑门*。Wikipedia. 2024年5月19日检索自 [https://en.wikipedia.org/wiki/Quantum_logic_gate](https://en.wikipedia.org/wiki/Quantum_logic_gate)
- en: Wikipedia. (n.d.). *Bloch sphere*. Wikipedia. Retrieved August 20, 2024, from
    [https://en.wikipedia.org/wiki/Bloch_sphere](https://en.wikipedia.org/wiki/Bloch_sphere)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Wikipedia. (无日期). *布洛赫球*。Wikipedia. 2024年8月20日检索自 [https://en.wikipedia.org/wiki/Bloch_sphere](https://en.wikipedia.org/wiki/Bloch_sphere)

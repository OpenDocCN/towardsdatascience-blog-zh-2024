- en: Dask DataFrame Is Fast Now
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dask DataFrame ç°åœ¨éå¸¸å¿«é€Ÿ
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/dask-dataframe-is-fast-now-ec930181c97a?source=collection_archive---------4-----------------------#2024-05-27](https://towardsdatascience.com/dask-dataframe-is-fast-now-ec930181c97a?source=collection_archive---------4-----------------------#2024-05-27)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/dask-dataframe-is-fast-now-ec930181c97a?source=collection_archive---------4-----------------------#2024-05-27](https://towardsdatascience.com/dask-dataframe-is-fast-now-ec930181c97a?source=collection_archive---------4-----------------------#2024-05-27)
- en: How Dask enables processing data at terabyte scale efficiently
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dask å¦‚ä½•é«˜æ•ˆåœ°åœ¨ TB çº§åˆ«å¤„ç†æ•°æ®
- en: '[](https://medium.com/@patrick_hoefler?source=post_page---byline--ec930181c97a--------------------------------)[![Patrick
    Hoefler](../Images/35ca9ef1100d8c93dbadd374f0569fe1.png)](https://medium.com/@patrick_hoefler?source=post_page---byline--ec930181c97a--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--ec930181c97a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--ec930181c97a--------------------------------)
    [Patrick Hoefler](https://medium.com/@patrick_hoefler?source=post_page---byline--ec930181c97a--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@patrick_hoefler?source=post_page---byline--ec930181c97a--------------------------------)[![Patrick
    Hoefler](../Images/35ca9ef1100d8c93dbadd374f0569fe1.png)](https://medium.com/@patrick_hoefler?source=post_page---byline--ec930181c97a--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--ec930181c97a--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--ec930181c97a--------------------------------)
    [Patrick Hoefler](https://medium.com/@patrick_hoefler?source=post_page---byline--ec930181c97a--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--ec930181c97a--------------------------------)
    Â·9 min readÂ·May 27, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘å¸ƒäº[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--ec930181c97a--------------------------------)
    Â·é˜…è¯»æ—¶é—´ 9 åˆ†é’ŸÂ·2024å¹´5æœˆ27æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/308b0407b24987f46372d5b56e3cf07d.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/308b0407b24987f46372d5b56e3cf07d.png)'
- en: '`Performance Improvements for Dask DataFrames â€” All Images created by the Author`'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`Performance Improvements for Dask DataFrames â€” æ‰€æœ‰å›¾ç‰‡ç”±ä½œè€…åˆ›å»º`'
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ä»‹ç»
- en: Dask DataFrame scales out pandas DataFrames to operate at the 100GB-100TB scale.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Dask DataFrame å°† pandas DataFrame æ‰©å±•åˆ° 100GB-100TB çš„è§„æ¨¡è¿›è¡Œæ“ä½œã€‚
- en: Historically, Dask was pretty slow compared to other tools in this space (like
    Spark). Due to a number of improvements focused on performance, itâ€™s now pretty
    fast (about 20x faster than before). The new implementation moved Dask from getting
    destroyed by Spark on every benchmark to regularly outperforming Spark on TPC-H
    queries by a significant margin.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ä»å†å²ä¸Šçœ‹ï¼ŒDask ç›¸æ¯”äºè¯¥é¢†åŸŸçš„å…¶ä»–å·¥å…·ï¼ˆå¦‚ Sparkï¼‰è¦æ…¢å¾—å¤šã€‚é€šè¿‡ä¸“æ³¨äºæ€§èƒ½çš„å¤šé¡¹æ”¹è¿›ï¼Œå®ƒç°åœ¨éå¸¸å¿«é€Ÿï¼ˆæ¯”ä»¥å‰å¿«å¤§çº¦ 20 å€ï¼‰ã€‚æ–°çš„å®ç°ä½¿
    Dask ä»åœ¨æ¯ä¸ªåŸºå‡†æµ‹è¯•ä¸­éƒ½è¢« Spark å®Œå…¨ç¢¾å‹ï¼Œå˜æˆäº†åœ¨ TPC-H æŸ¥è¯¢ä¸­ç»å¸¸å¤§å¹…è¶…è¶Š Sparkã€‚
- en: Dask DataFrame workloads struggled with many things. Performance and memory
    usage were commonly seen pain points, shuffling was unstable for bigger datasets,
    making scaling out hard. Writing efficient code required understanding too much
    of the internals of Dask.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Dask DataFrame çš„å·¥ä½œè´Ÿè½½é¢ä¸´è®¸å¤šæŒ‘æˆ˜ã€‚æ€§èƒ½å’Œå†…å­˜ä½¿ç”¨å¸¸å¸¸æ˜¯ä¸»è¦çš„ç—›ç‚¹ï¼Œæ•°æ®é›†è¾ƒå¤§æ—¶æ´—ç‰Œæ“ä½œä¸ç¨³å®šï¼Œå¯¼è‡´æ‰©å±•å˜å¾—å›°éš¾ã€‚ç¼–å†™é«˜æ•ˆä»£ç éœ€è¦äº†è§£
    Dask çš„å¾ˆå¤šå†…éƒ¨ç»†èŠ‚ã€‚
- en: The new implementation changed all of this. Things that didnâ€™t work were completely
    rewritten from scratch and existing implementations were improved upon. This puts
    Dask DataFrames on a solid foundation that allows faster iteration cycles in the
    future.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: æ–°çš„å®ç°æ”¹å˜äº†è¿™ä¸€åˆ‡ã€‚é‚£äº›æ— æ³•æ­£å¸¸å·¥ä½œçš„éƒ¨åˆ†è¢«å®Œå…¨ä»å¤´é‡å†™ï¼Œç°æœ‰çš„å®ç°ä¹Ÿå¾—åˆ°äº†æ”¹è¿›ã€‚è¿™ä¸º Dask DataFrame æ‰“ä¸‹äº†åšå®çš„åŸºç¡€ï¼Œæœªæ¥å¯ä»¥è¿›è¡Œæ›´å¿«é€Ÿçš„è¿­ä»£ã€‚
- en: Weâ€™ll go through the three most prominent changes, covering how they impact
    performance and make it easier to use Dask efficiently, even for users that are
    new to distributed computing. Weâ€™ll also discuss plans for future improvements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†è®¨è®ºä¸‰é¡¹æœ€æ˜¾è‘—çš„å˜åŒ–ï¼Œä»‹ç»å®ƒä»¬å¦‚ä½•æå‡æ€§èƒ½å¹¶ä½¿ Dask æ›´æ˜“äºä½¿ç”¨ï¼Œå³ä½¿æ˜¯å¯¹åˆ†å¸ƒå¼è®¡ç®—è¾ƒä¸ºé™Œç”Ÿçš„ç”¨æˆ·ã€‚æˆ‘ä»¬è¿˜å°†è®¨è®ºæœªæ¥æ”¹è¿›çš„è®¡åˆ’ã€‚
- en: I am part of the core team of Dask. I am an open source engineer for [Coiled](https://www.coiled.io)
    and was involved in implementing some of the improvements discussed in this post.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æ˜¯ Dask æ ¸å¿ƒå›¢é˜Ÿçš„ä¸€å‘˜ï¼Œè¿˜æ˜¯[Coiled](https://www.coiled.io)çš„å¼€æºå·¥ç¨‹å¸ˆï¼Œå‚ä¸äº†æœ¬æ–‡ä¸­è®¨è®ºçš„ä¸€äº›æ”¹è¿›çš„å®ç°ã€‚
- en: '1\. Apache Arrow Support: Efficient String Datatype'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1\. Apache Arrow æ”¯æŒï¼šé«˜æ•ˆçš„å­—ç¬¦ä¸²æ•°æ®ç±»å‹
- en: A Dask DataFrame consists of many pandas DataFrames. Historically, pandas used
    NumPy for numeric data, but Python objects for text data, which are inefficient
    and blow up memory usage. Operations on object data also hold the GIL, which doesnâ€™t
    matter much for pandas, but is a catastrophy for performance with a parallel system
    like Dask.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Dask DataFrame ç”±å¤šä¸ª pandas DataFrame ç»„æˆã€‚å†å²ä¸Šï¼Œpandas ä½¿ç”¨ NumPy å¤„ç†æ•°å€¼æ•°æ®ï¼Œä½†å¯¹æ–‡æœ¬æ•°æ®ä½¿ç”¨ Python
    å¯¹è±¡ï¼Œè¿™æ ·åšæ•ˆç‡ä½ä¸‹ï¼Œå¹¶ä¸”ä¼šæå¤§å¢åŠ å†…å­˜ä½¿ç”¨ã€‚å¯¹å¯¹è±¡æ•°æ®çš„æ“ä½œä¹Ÿä¼šå ç”¨ GILï¼ˆå…¨å±€è§£é‡Šå™¨é”ï¼‰ï¼Œè¿™å¯¹äº pandas å½±å“ä¸å¤§ï¼Œä½†å¯¹äºåƒ Dask è¿™æ ·çš„å¹¶è¡Œç³»ç»Ÿæ¥è¯´ï¼Œæ€§èƒ½å°†å—åˆ°ç¾éš¾æ€§çš„å½±å“ã€‚
- en: The pandas 2.0 release introduced support for general-purpose Arrow datatypes,
    so Dask now uses PyArrow-backed strings by default. These are *much* better. PyArrow
    strings reduce memory usage by up to 80% and unlock multi-threading for string
    operations. Workloads that previously struggled with available memory now fit
    comfortably in much less space, and are a lot faster because they no longer constantly
    spill excess data to disk.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 2.0 å‘å¸ƒæ—¶å¼•å…¥äº†å¯¹é€šç”¨ Arrow æ•°æ®ç±»å‹çš„æ”¯æŒï¼Œå› æ­¤ Dask ç°åœ¨é»˜è®¤ä½¿ç”¨ PyArrow æ”¯æŒçš„å­—ç¬¦ä¸²ã€‚è¿™äº›å­—ç¬¦ä¸²*è¦å¥½å¾—å¤š*ã€‚PyArrow
    å­—ç¬¦ä¸²å°†å†…å­˜ä½¿ç”¨é‡å‡å°‘äº†å¤šè¾¾ 80%ï¼Œå¹¶ä¸”è§£é”äº†å­—ç¬¦ä¸²æ“ä½œçš„å¤šçº¿ç¨‹åŠŸèƒ½ã€‚ä»¥å‰å› å†…å­˜ä¸è¶³è€Œé‡åˆ°é—®é¢˜çš„å·¥ä½œè´Ÿè½½ï¼Œç°åœ¨èƒ½å¤Ÿåœ¨æ›´å°‘çš„å†…å­˜ä¸­é¡ºåˆ©è¿è¡Œï¼Œè€Œä¸”é€Ÿåº¦æ›´å¿«ï¼Œå› ä¸ºå®ƒä»¬ä¸å†ä¸æ–­å°†å¤šä½™çš„æ•°æ®æº¢å†™åˆ°ç£ç›˜ã€‚
- en: '![](../Images/d84c32d3800a76ea017400b5c0439f0a.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d84c32d3800a76ea017400b5c0439f0a.png)'
- en: '`Memory Usage of the Legacy DataFrames compared with Arrow Strings`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`ä¸ Arrow å­—ç¬¦ä¸²ç›¸æ¯”ï¼Œä¼ ç»Ÿ DataFrame çš„å†…å­˜ä½¿ç”¨`'
- en: I wrote a post about this that [investigates Arrow integrations](https://docs.coiled.io/blog/pyarrow-in-pandas-and-dask.html)
    in more detail if you want to learn more.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘å†™äº†ä¸€ç¯‡å…³äºæ­¤å†…å®¹çš„æ–‡ç« ï¼Œè¯¦ç»†[æ¢è®¨äº† Arrow é›†æˆ](https://docs.coiled.io/blog/pyarrow-in-pandas-and-dask.html)ï¼Œå¦‚æœä½ æƒ³äº†è§£æ›´å¤šï¼Œå¯ä»¥é˜…è¯»ã€‚
- en: 2\. Faster Joins with a New Shuffle Algorithm
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2\. ä½¿ç”¨æ–°æ´—ç‰Œç®—æ³•åŠ é€Ÿè¿æ¥æ“ä½œ
- en: Shuffling is an essential component of distributed systems to enable sorting,
    joins, and complex group by operations. It is an all-to-all, network-intensive
    operation thatâ€™s often the most expensive component in a workflow. We rewrote
    Daskâ€™s shuffling system, which greatly impacts overall performance, especially
    on complex, data-intensive workloads.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: æ´—ç‰Œæ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­çš„ä¸€ä¸ªå…³é”®ç»„ä»¶ï¼Œç”¨äºå®ç°æ’åºã€è¿æ¥å’Œå¤æ‚çš„åˆ†ç»„æ“ä½œã€‚å®ƒæ˜¯ä¸€ç§å…¨å¯¹å…¨ã€ç½‘ç»œå¯†é›†å‹çš„æ“ä½œï¼Œé€šå¸¸æ˜¯å·¥ä½œæµä¸­æœ€æ˜‚è´µçš„éƒ¨åˆ†ã€‚æˆ‘ä»¬é‡å†™äº† Dask
    çš„æ´—ç‰Œç³»ç»Ÿï¼Œè¿™å¯¹æ•´ä½“æ€§èƒ½äº§ç”Ÿäº†å·¨å¤§å½±å“ï¼Œå°¤å…¶æ˜¯åœ¨å¤æ‚çš„æ•°æ®å¯†é›†å‹å·¥ä½œè´Ÿè½½ä¸‹ã€‚
- en: A shuffle operation is intrinsically an all-to-all communication operation where
    every input partition has to provide a tiny slice of data to every output partition.
    Dask was already using itâ€™s own task-based algorithm that managed to reduce the
    `O(n * n)` task complexity to `O(log(n) * n)` where `n` is the number of partitions.
    This was a drastic reduction in the number of tasks, but the non-linear scaling
    ultimately did not allow Dask to process arbitrarily large datasets.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: æ´—ç‰Œæ“ä½œæœ¬è´¨ä¸Šæ˜¯ä¸€ç§å…¨å¯¹å…¨çš„é€šä¿¡æ“ä½œï¼Œå…¶ä¸­æ¯ä¸ªè¾“å…¥åˆ†åŒºå¿…é¡»å°†ä¸€å°éƒ¨åˆ†æ•°æ®æä¾›ç»™æ¯ä¸ªè¾“å‡ºåˆ†åŒºã€‚Dask æœ€åˆä½¿ç”¨äº†è‡ªå·±çš„åŸºäºä»»åŠ¡çš„ç®—æ³•ï¼ŒæˆåŠŸåœ°å°† `O(n
    * n)` çš„ä»»åŠ¡å¤æ‚åº¦å‡å°‘åˆ°äº† `O(log(n) * n)`ï¼Œå…¶ä¸­ `n` æ˜¯åˆ†åŒºæ•°é‡ã€‚è¿™å¤§å¤§å‡å°‘äº†ä»»åŠ¡æ•°é‡ï¼Œä½†éçº¿æ€§æ‰©å±•æ€§æœ€ç»ˆä½¿å¾— Dask æ— æ³•å¤„ç†ä»»æ„å¤§çš„æ•°æ®é›†ã€‚
- en: Dask introduced a new P2P (peer-to-peer) shuffle method that reduced the task
    complexity to `O(n)` which scales linearly with the size of the dataset and the
    size of the cluster. It also incorporates an efficient disk integration which
    allows easily shuffling datasets which are much larger than memory. The new system
    is extremely stable and "just works" across any scale of data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Dask å¼•å…¥äº†ä¸€ç§æ–°çš„ P2Pï¼ˆç‚¹å¯¹ç‚¹ï¼‰æ´—ç‰Œæ–¹æ³•ï¼Œå°†ä»»åŠ¡å¤æ‚åº¦é™ä½åˆ°äº† `O(n)`ï¼Œå¹¶ä¸”éšç€æ•°æ®é›†å¤§å°å’Œé›†ç¾¤è§„æ¨¡çš„å¢é•¿å‘ˆçº¿æ€§æ‰©å±•ã€‚å®ƒè¿˜é›†æˆäº†é«˜æ•ˆçš„ç£ç›˜åŠŸèƒ½ï¼Œä½¿å¾—å¯ä»¥è½»æ¾åœ°æ´—ç‰Œå¤§äºå†…å­˜çš„æ•°æ®é›†ã€‚æ–°ç³»ç»Ÿæå…¶ç¨³å®šï¼Œå¹¶ä¸”åœ¨ä»»ä½•è§„æ¨¡çš„æ•°æ®ä¸Šéƒ½èƒ½â€œæ­£å¸¸å·¥ä½œâ€ã€‚
- en: '![](../Images/06eeae42ba346f26d229371a3f1d9e2c.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06eeae42ba346f26d229371a3f1d9e2c.png)'
- en: '`Memory Usage of the Legacy Shuffle compared with P2P`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ä¸ P2P ç›¸æ¯”ï¼Œä¼ ç»Ÿæ´—ç‰Œçš„å†…å­˜ä½¿ç”¨`'
- en: One of my colleagues wrote [a post about this](https://docs.coiled.io/blog/shuffling-large-data-at-constant-memory.html)
    that includes a more extensive explanation and a lot of technical details.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘çš„ä¸€ä¸ªåŒäº‹å†™äº†[å…³äºæ­¤å†…å®¹çš„æ–‡ç« ](https://docs.coiled.io/blog/shuffling-large-data-at-constant-memory.html)ï¼Œå…¶ä¸­åŒ…å«äº†æ›´ä¸ºè¯¦ç»†çš„è§£é‡Šå’Œå¤§é‡æŠ€æœ¯ç»†èŠ‚ã€‚
- en: 3\. Optimizer
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3\. ä¼˜åŒ–å™¨
- en: Dask itself is lazy, which means that it registers your whole query before doing
    any actual work. This is a powerful concept that enables a lot of optimizations,
    but historically Dask wasnâ€™t taking advantage of this knowledge in the past. Dask
    also did a bad job of hiding internal complexities and left users on their own
    while navigating the difficulties of distributed computing and running large scale
    queries. It made writing efficient code painful for non-experts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Dask æœ¬èº«æ˜¯æƒ°æ€§è®¡ç®—çš„ï¼Œè¿™æ„å‘³ç€å®ƒä¼šåœ¨æ‰§è¡Œä»»ä½•å®é™…å·¥ä½œä¹‹å‰æ³¨å†Œæ•´ä¸ªæŸ¥è¯¢ã€‚è¿™æ˜¯ä¸€ä¸ªå¼ºå¤§çš„æ¦‚å¿µï¼Œä½¿å¾—è®¸å¤šä¼˜åŒ–æˆä¸ºå¯èƒ½ï¼Œä½†å†å²ä¸Š Dask å¹¶æ²¡æœ‰å……åˆ†åˆ©ç”¨è¿™ä¸€çŸ¥è¯†ã€‚Dask
    åœ¨éšè—å†…éƒ¨å¤æ‚æ€§æ–¹é¢åšå¾—ä¸å¥½ï¼Œç”¨æˆ·åœ¨åº”å¯¹åˆ†å¸ƒå¼è®¡ç®—å’Œæ‰§è¡Œå¤§è§„æ¨¡æŸ¥è¯¢çš„å›°éš¾æ—¶åªèƒ½é è‡ªå·±ã€‚è¿™ä½¿å¾—éä¸“å®¶ç¼–å†™é«˜æ•ˆä»£ç å˜å¾—éå¸¸ç—›è‹¦ã€‚
- en: '[The Dask release in March](https://docs.dask.org/en/stable/changelog.html#query-planning)
    includes a complete re-implementation of the DataFrame API to support query optimization.
    This is a big deal. The new engine centers around a query optimizer that rewrites
    our code to make it more efficient and better tailored to Daskâ€™s strengths. Letâ€™s
    dive into some optimization strategies, how they make our code run faster and
    scale better.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[3 æœˆå‘å¸ƒçš„ Dask ç‰ˆæœ¬](https://docs.dask.org/en/stable/changelog.html#query-planning)åŒ…å«äº†
    DataFrame API çš„å®Œå…¨é‡æ–°å®ç°ï¼Œä»¥æ”¯æŒæŸ¥è¯¢ä¼˜åŒ–ã€‚è¿™æ˜¯ä¸€ä¸ªå¤§äº‹ä»¶ã€‚æ–°çš„å¼•æ“å›´ç»•æŸ¥è¯¢ä¼˜åŒ–å™¨å±•å¼€ï¼Œä¼˜åŒ–å™¨ä¼šé‡å†™æˆ‘ä»¬çš„ä»£ç ï¼Œä½¿å…¶æ›´åŠ é«˜æ•ˆï¼Œæ›´å¥½åœ°å‘æŒ¥ Dask
    çš„ä¼˜åŠ¿ã€‚è®©æˆ‘ä»¬æ·±å…¥äº†è§£ä¸€äº›ä¼˜åŒ–ç­–ç•¥ï¼Œå®ƒä»¬å¦‚ä½•ä½¿æˆ‘ä»¬çš„ä»£ç è¿è¡Œå¾—æ›´å¿«ï¼Œå¹¶æ›´å¥½åœ°æ‰©å±•ã€‚'
- en: We will start with a couple of general purpose optimizations that are useful
    for every DataFrame-like tool before we dive into more specific techniques that
    are tailored to distributed systems generally and Dask more specifically.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æ·±å…¥æ¢è®¨ä¸€äº›é’ˆå¯¹åˆ†å¸ƒå¼ç³»ç»Ÿå’Œ Dask æ›´å…·ä½“çš„æŠ€æœ¯ä¹‹å‰ï¼Œæˆ‘ä»¬å°†ä»ä¸€äº›å¯¹æ¯ä¸ªç±»ä¼¼ DataFrame çš„å·¥å…·éƒ½æœ‰ç”¨çš„é€šç”¨ä¼˜åŒ–å¼€å§‹ã€‚
- en: 3.1 Column Projection
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 åˆ—æŠ•å½±
- en: Most datasets have more columns than what we actually need. Dropping them requires
    foresight (â€œWhat columns will I need for this query? ğŸ¤”â€) so most people donâ€™t
    think about this when loading data. This is bad for performance because we carry
    around lots of data that we donâ€™t need, slowing everything down. Column Projection
    drops columns as soon as they arenâ€™t needed anymore. Itâ€™s a straightforward optimization,
    but highly beneficial.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: å¤§å¤šæ•°æ•°æ®é›†çš„åˆ—æ•°è¶…è¿‡æˆ‘ä»¬å®é™…éœ€è¦çš„åˆ—æ•°ã€‚å»é™¤ä¸å¿…è¦çš„åˆ—éœ€è¦å‰ç»æ€§æ€ç»´ï¼ˆâ€œæˆ‘åœ¨è¿™ä¸ªæŸ¥è¯¢ä¸­éœ€è¦å“ªäº›åˆ—ï¼ŸğŸ¤”â€ï¼‰ï¼Œå› æ­¤å¤§å¤šæ•°äººåœ¨åŠ è½½æ•°æ®æ—¶ä¸ä¼šè€ƒè™‘è¿™ä¸€ç‚¹ã€‚è¿™å¯¹æ€§èƒ½ä¸å¥½ï¼Œå› ä¸ºæˆ‘ä»¬æºå¸¦äº†è®¸å¤šä¸éœ€è¦çš„æ•°æ®ï¼Œå¯¼è‡´ä¸€åˆ‡å˜å¾—æ›´æ…¢ã€‚åˆ—æŠ•å½±åœ¨ä¸å†éœ€è¦åˆ—æ—¶ç«‹å³å»é™¤å®ƒä»¬ã€‚è¿™æ˜¯ä¸€ä¸ªç®€å•çš„ä¼˜åŒ–ï¼Œä½†å´éå¸¸æœ‰ç›Šã€‚
- en: The legacy implementation always reads all columns from storage and only drops
    columns if we actively ask for it. Simply operating on less data is a big win
    for performance and memory usage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼ ç»Ÿå®ç°æ€»æ˜¯ä»å­˜å‚¨ä¸­è¯»å–æ‰€æœ‰åˆ—ï¼Œåªæœ‰åœ¨æˆ‘ä»¬ä¸»åŠ¨è¦æ±‚æ—¶æ‰å»é™¤åˆ—ã€‚ä»…ä»…å‡å°‘æ“ä½œçš„æ•°æ®é‡å°±èƒ½å¤§å¹…æå‡æ€§èƒ½å’Œå†…å­˜ä½¿ç”¨æ•ˆç‡ã€‚
- en: The optimizer looks at the query and figures out which columns are needed for
    each operation. We can imagine this as looking at the final step of our query
    and then working backwards step by step to the data source and injecting drop
    operations to get rid of unnecessary columns.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–å™¨æŸ¥çœ‹æŸ¥è¯¢å¹¶ç¡®å®šæ¯ä¸ªæ“ä½œæ‰€éœ€çš„åˆ—ã€‚æˆ‘ä»¬å¯ä»¥å°†å…¶æƒ³è±¡æˆä»æŸ¥è¯¢çš„æœ€ç»ˆæ­¥éª¤å¼€å§‹ï¼Œç„¶åä¸€æ­¥æ­¥å›æº¯åˆ°æ•°æ®æºï¼Œå¹¶æ³¨å…¥ä¸¢å¼ƒæ“ä½œä»¥å»é™¤ä¸å¿…è¦çš„åˆ—ã€‚
- en: '![](../Images/a84cc99cdcd2f59bd804a4137b77b521.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a84cc99cdcd2f59bd804a4137b77b521.png)'
- en: '`We only require a subset of columns in the end. Replace doesn''t need access
    to all columns, so we can drop unnecessary columns directly in the IO step.`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`æœ€ç»ˆæˆ‘ä»¬åªéœ€è¦ä¸€ä¸ªå­é›†çš„åˆ—ã€‚æ›¿æ¢æ“ä½œä¸éœ€è¦è®¿é—®æ‰€æœ‰åˆ—ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥åœ¨ IO æ­¥éª¤ä¸­ç›´æ¥ä¸¢å¼ƒä¸å¿…è¦çš„åˆ—ã€‚`'
- en: 3.2 Filter Pushdown
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 è¿‡æ»¤ä¸‹æ¨
- en: 'Filter pushdown is another general-purpose optimization with the same goal
    as column projection: operate on less data. The legacy implementation just keeps
    filters where we put them. The new implementation executes filter operations as
    early as possible while maintaining the same results.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: è¿‡æ»¤ä¸‹æ¨æ˜¯å¦ä¸€ç§é€šç”¨ä¼˜åŒ–ï¼Œå…¶ç›®æ ‡ä¸åˆ—æŠ•å½±ç›¸åŒï¼šæ“ä½œè¾ƒå°‘çš„æ•°æ®ã€‚ä¼ ç»Ÿå®ç°åªæ˜¯å°†è¿‡æ»¤å™¨ä¿ç•™åœ¨æˆ‘ä»¬æ”¾ç½®çš„ä½ç½®ã€‚æ–°çš„å®ç°å°½å¯èƒ½æ—©åœ°æ‰§è¡Œè¿‡æ»¤æ“ä½œï¼ŒåŒæ—¶ä¿æŒç›¸åŒçš„ç»“æœã€‚
- en: The optimizer identifies every filter in our query and looks at the previous
    operation to see if we can move the filter closer to the data source. It will
    repeat this until it finds an operation that canâ€™t be switched with a filter.
    This is a bit harder than column projections, because we have to make sure that
    the operations donâ€™t change the values of our DataFrame. For example, switching
    a filter and a merge operation is fine (values donâ€™t change), but switching a
    filter and a replace operation is invalid, because our values might change and
    rows that would previously have been filtered out now wonâ€™t be, or vice versa.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–å™¨è¯†åˆ«æˆ‘ä»¬æŸ¥è¯¢ä¸­çš„æ¯ä¸ªè¿‡æ»¤å™¨ï¼Œå¹¶æŸ¥çœ‹ä¹‹å‰çš„æ“ä½œï¼Œåˆ¤æ–­æ˜¯å¦å¯ä»¥å°†è¿‡æ»¤å™¨ç§»å¾—æ›´é è¿‘æ•°æ®æºã€‚å®ƒä¼šé‡å¤è¿™ä¸€è¿‡ç¨‹ï¼Œç›´åˆ°æ‰¾åˆ°ä¸€ä¸ªä¸èƒ½ä¸è¿‡æ»¤å™¨äº¤æ¢çš„æ“ä½œã€‚è¿™æ¯”åˆ—æŠ•å½±è¦éš¾ä¸€äº›ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦ç¡®ä¿è¿™äº›æ“ä½œä¸ä¼šæ”¹å˜æ•°æ®æ¡†çš„å€¼ã€‚ä¾‹å¦‚ï¼Œäº¤æ¢è¿‡æ»¤å™¨å’Œåˆå¹¶æ“ä½œæ˜¯å¯ä»¥çš„ï¼ˆå€¼ä¸å˜ï¼‰ï¼Œä½†äº¤æ¢è¿‡æ»¤å™¨å’Œæ›¿æ¢æ“ä½œæ˜¯æ— æ•ˆçš„ï¼Œå› ä¸ºæˆ‘ä»¬çš„å€¼å¯èƒ½ä¼šæ”¹å˜ï¼ŒåŸæœ¬ä¼šè¢«è¿‡æ»¤æ‰çš„è¡Œç°åœ¨å¯èƒ½ä¸ä¼šè¢«è¿‡æ»¤æ‰ï¼Œåä¹‹äº¦ç„¶ã€‚
- en: '![](../Images/cf3fab96fed4a7b19ba76286970b9b3c.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cf3fab96fed4a7b19ba76286970b9b3c.png)'
- en: '`Initially, the filter happens after the Dropna, but we can execute the filter
    before Dropna without changing the result. This allows us to push the filter into
    the IO step.`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`æœ€åˆï¼Œè¿‡æ»¤æ“ä½œå‘ç”Ÿåœ¨Dropnaä¹‹åï¼Œä½†æˆ‘ä»¬å¯ä»¥åœ¨ä¸æ”¹å˜ç»“æœçš„æƒ…å†µä¸‹ï¼Œåœ¨Dropnaä¹‹å‰æ‰§è¡Œè¿‡æ»¤æ“ä½œã€‚è¿™å…è®¸æˆ‘ä»¬å°†è¿‡æ»¤å™¨æ¨é€åˆ°IOæ­¥éª¤ä¸­ã€‚`'
- en: Additionally, if our filter is strong enough then we can potentially drop complete
    files in the IO step. This is a best-case scenario, where an earlier filter brings
    a huge performance improvement and even requires reading less data from remote
    storage.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼Œå¦‚æœæˆ‘ä»¬çš„è¿‡æ»¤å™¨è¶³å¤Ÿå¼ºå¤§ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯èƒ½åœ¨IOæ­¥éª¤ä¸­ç›´æ¥ä¸¢å¼ƒå®Œæ•´çš„æ–‡ä»¶ã€‚è¿™æ˜¯æœ€ä½³æƒ…å†µï¼Œå…¶ä¸­æ—©æœŸçš„è¿‡æ»¤æ“ä½œå¸¦æ¥äº†å·¨å¤§çš„æ€§èƒ½æå‡ï¼Œç”šè‡³éœ€è¦ä»è¿œç¨‹å­˜å‚¨è¯»å–æ›´å°‘çš„æ•°æ®ã€‚
- en: 3.3 Automatically Resizing Partitions
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 è‡ªåŠ¨è°ƒæ•´åˆ†åŒºå¤§å°
- en: 'In addition to implementing the common optimization techniques described above,
    weâ€™ve also improved a common pain point specific to distributed systems genereally
    and Dask users specifically: optimal partition sizes.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: é™¤äº†å®ç°ä¸Šè¿°å¸¸è§çš„ä¼˜åŒ–æŠ€æœ¯å¤–ï¼Œæˆ‘ä»¬è¿˜æ”¹è¿›äº†ä¸€ä¸ªæ™®éå­˜åœ¨çš„ç—›ç‚¹ï¼Œç‰¹åˆ«æ˜¯å¯¹äºåˆ†å¸ƒå¼ç³»ç»Ÿå’ŒDaskç”¨æˆ·ï¼šæœ€ä½³åˆ†åŒºå¤§å°ã€‚
- en: Dask DataFrames consist of many small pandas DataFrames called *partitions*.
    Often, the number of partitions is decided for you and Dask users are advised
    to manually â€œrepartitionâ€ after reducing or expanding their data (for example
    by dropping columns, filtering data, or expanding with joins) (see the [Dask docs](https://docs.dask.org/en/stable/dataframe-best-practices.html#repartition-to-reduce-overhead)).
    Without this extra step, the (usually small) overhead from Dask can become a bottleneck
    if the pandas DataFrames become too small, making Dask workflows painfully slow.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Dask DataFrameç”±è®¸å¤šç§°ä¸º*åˆ†åŒº*çš„å°å‹pandas DataFrameç»„æˆã€‚é€šå¸¸ï¼Œåˆ†åŒºçš„æ•°é‡æ˜¯ç”±ç³»ç»Ÿå†³å®šçš„ï¼ŒDaskç”¨æˆ·è¢«å»ºè®®åœ¨å‡å°‘æˆ–æ‰©å±•æ•°æ®åæ‰‹åŠ¨â€œé‡æ–°åˆ†åŒºâ€ï¼ˆä¾‹å¦‚é€šè¿‡åˆ é™¤åˆ—ã€è¿‡æ»¤æ•°æ®æˆ–é€šè¿‡è¿æ¥æ“ä½œè¿›è¡Œæ‰©å±•ï¼‰ï¼ˆå‚è§[Daskæ–‡æ¡£](https://docs.dask.org/en/stable/dataframe-best-practices.html#repartition-to-reduce-overhead)ï¼‰ã€‚å¦‚æœæ²¡æœ‰è¿™ä¸€æ­¥ï¼ŒDaskçš„ï¼ˆé€šå¸¸å¾ˆå°çš„ï¼‰å¼€é”€å¯èƒ½ä¼šæˆä¸ºç“¶é¢ˆï¼Œç‰¹åˆ«æ˜¯å½“pandas
    DataFrameå˜å¾—è¿‡å°æ—¶ï¼Œè¿™ä¼šä½¿Daskçš„å·¥ä½œæµå˜å¾—éå¸¸ç¼“æ…¢ã€‚
- en: 'Manually controlling the partition size is a difficult task that we, as Dask
    users, shouldnâ€™t have to worry about. It is also slow because it requires network
    transfer of some partitions. Dask DataFrame now automatically does two things
    to help when the partitions get too small:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: æ‰‹åŠ¨æ§åˆ¶åˆ†åŒºå¤§å°æ˜¯ä¸€é¡¹å›°éš¾çš„ä»»åŠ¡ï¼Œæˆ‘ä»¬ä½œä¸ºDaskç”¨æˆ·ä¸åº”è¯¥ä¸ºæ­¤æ‹…å¿§ã€‚è¿™ä¹Ÿå¾ˆæ…¢ï¼Œå› ä¸ºå®ƒéœ€è¦é€šè¿‡ç½‘ç»œä¼ è¾“ä¸€äº›åˆ†åŒºã€‚ç°åœ¨ï¼ŒDask DataFrameä¼šè‡ªåŠ¨åšä¸¤ä»¶äº‹æ¥å¸®åŠ©å¤„ç†å½“åˆ†åŒºå˜å¾—è¿‡å°çš„æƒ…å†µï¼š
- en: Keeps the size of each partition constant, based on the ratio of data you want
    to compute vs. the original file size. If, for example, you filter out 80% of
    the original dataset, Dask will automatically combine the resulting smaller partitions
    into fewer, larger partitions.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ä¿æŒæ¯ä¸ªåˆ†åŒºçš„å¤§å°æ’å®šï¼ŒåŸºäºä½ æƒ³è¦è®¡ç®—çš„æ•°æ®ä¸åŸå§‹æ–‡ä»¶å¤§å°çš„æ¯”ä¾‹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ ç­›é€‰æ‰åŸå§‹æ•°æ®é›†çš„80%ï¼ŒDaskä¼šè‡ªåŠ¨å°†ç»“æœä¸­è¾ƒå°çš„åˆ†åŒºåˆå¹¶æˆæ›´å°‘ã€æ›´å¤§çš„åˆ†åŒºã€‚
- en: Combines too-small partitions into larger partitions, based on an absolute minimum
    (default is 75 MB). If, for example, your original dataset is split into many
    tiny files, Dask will automatically combine them.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: åŸºäºç»å¯¹æœ€å°å€¼ï¼ˆé»˜è®¤ä¸º75MBï¼‰ï¼Œå°†è¿‡å°çš„åˆ†åŒºåˆå¹¶ä¸ºæ›´å¤§çš„åˆ†åŒºã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ çš„åŸå§‹æ•°æ®é›†è¢«æ‹†åˆ†æˆè®¸å¤šå¾ˆå°çš„æ–‡ä»¶ï¼ŒDaskä¼šè‡ªåŠ¨å°†å®ƒä»¬åˆå¹¶ã€‚
- en: '![](../Images/29a069b1cef38c8590db87fd8c1d8acc.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/29a069b1cef38c8590db87fd8c1d8acc.png)'
- en: '`We select two columns that take up 40 MB of memory out of the 200 MB from
    the whole file.`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`æˆ‘ä»¬ä»æ•´ä¸ªæ–‡ä»¶çš„200MBä¸­é€‰æ‹©äº†ä¸¤ä¸ªå ç”¨40MBå†…å­˜çš„åˆ—ã€‚`'
- en: The optimizer will look at the number of columns and the size of the data within
    those. It calculates a ratio that is used to combine multiple files into one partition.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–å™¨ä¼šæŸ¥çœ‹åˆ—çš„æ•°é‡ä»¥åŠè¿™äº›åˆ—ä¸­çš„æ•°æ®å¤§å°ã€‚å®ƒä¼šè®¡ç®—ä¸€ä¸ªæ¯”ç‡ï¼Œç”¨äºå°†å¤šä¸ªæ–‡ä»¶åˆå¹¶ä¸ºä¸€ä¸ªåˆ†åŒºã€‚
- en: '![](../Images/34dd0149f27adf9b8b3dc472e87ba4a2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/34dd0149f27adf9b8b3dc472e87ba4a2.png)'
- en: '`The ratio of 40/200 results in combining five files into a single partition.`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`40/200çš„æ¯”ç‡å¯¼è‡´å°†äº”ä¸ªæ–‡ä»¶åˆå¹¶ä¸ºä¸€ä¸ªåˆ†åŒºã€‚`'
- en: This step is currently limited to IO operations (like reading in a Parquet dataset),
    but we plan to extend it to other operations that allow cheaply combining partitions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ç›®å‰ï¼Œè¿™ä¸€æ­¥éª¤ä»…é™äºIOæ“ä½œï¼ˆå¦‚è¯»å–Parquetæ•°æ®é›†ï¼‰ï¼Œä½†æˆ‘ä»¬è®¡åˆ’å°†å…¶æ‰©å±•åˆ°å…¶ä»–å…è®¸å»‰ä»·åˆå¹¶åˆ†åŒºçš„æ“ä½œã€‚
- en: 3.4 Trivial Merge and Join Operations
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 ç®€å•çš„åˆå¹¶å’Œè¿æ¥æ“ä½œ
- en: Merge and join operations are typically cheap on a single machine with pandas
    but expensive in a distributed setting. Merging data in shared memory is cheap,
    while merging data across a network is quite slow, due to the shuffle operations
    explained earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å•æœºä¸Šä½¿ç”¨Pandasæ—¶ï¼Œåˆå¹¶å’Œè¿æ¥æ“ä½œé€šå¸¸æ˜¯ä¾¿å®œçš„ï¼Œä½†åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­åˆ™å¾ˆæ˜‚è´µã€‚åœ¨å…±äº«å†…å­˜ä¸­åˆå¹¶æ•°æ®æ˜¯ä¾¿å®œçš„ï¼Œè€Œé€šè¿‡ç½‘ç»œåˆå¹¶æ•°æ®åˆ™éå¸¸æ…¢ï¼Œå› ä¸ºå‰é¢æåˆ°çš„æ´—ç‰Œæ“ä½œã€‚
- en: This is one of the most expensive operations in a distributed system. The legacy
    implementation triggered a network transfer of both input DataFrames for every
    merge operation. This is sometimes necessary, but very expensive.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯åˆ†å¸ƒå¼ç³»ç»Ÿä¸­æœ€æ˜‚è´µçš„æ“ä½œä¹‹ä¸€ã€‚ä¼ ç»Ÿå®ç°æ¯æ¬¡åˆå¹¶æ“ä½œéƒ½ä¼šè§¦å‘è¾“å…¥DataFrameçš„ç½‘ç»œä¼ è¾“ã€‚è¿™åœ¨æŸäº›æƒ…å†µä¸‹æ˜¯å¿…è¦çš„ï¼Œä½†ä»£ä»·é«˜æ˜‚ã€‚
- en: '![](../Images/a51a432975c2076cfb5712349c8db866.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a51a432975c2076cfb5712349c8db866.png)'
- en: '`Both joins are performed on the same column. The left DataFrame is already
    properly partitioned after the first join, so we can avoid shuffling again with
    the new implementation.`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ä¸¤ä¸ªè¿æ¥æ“ä½œéƒ½æ˜¯åœ¨åŒä¸€åˆ—ä¸Šè¿›è¡Œçš„ã€‚å·¦ä¾§çš„DataFrameåœ¨ç¬¬ä¸€æ¬¡è¿æ¥åå·²ç»æ­£ç¡®åˆ†åŒºï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥é¿å…åœ¨æ–°å®ç°ä¸­å†æ¬¡è¿›è¡Œæ´—ç‰Œæ“ä½œã€‚`'
- en: The optimizer will determine when shuffling is necessary versus when a trivial
    join is sufficient because the data is already aligned properly. This can make
    individual merges an order of magnitude faster. This also applies to other operations
    that normally require a shuffle like `groupby().apply()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–å™¨å°†åˆ¤æ–­ä½•æ—¶éœ€è¦æ´—ç‰Œï¼Œä½•æ—¶ä»…ä»…æ˜¯ç®€å•çš„è¿æ¥è¶³å¤Ÿï¼Œå› ä¸ºæ•°æ®å·²ç»å¯¹é½ã€‚è¿™å¯ä»¥ä½¿ä¸ªåˆ«åˆå¹¶æ“ä½œå˜å¾—æ›´å¿«ã€‚è¿™ä¸ªåŸåˆ™åŒæ ·é€‚ç”¨äºå…¶ä»–é€šå¸¸éœ€è¦æ´—ç‰Œçš„æ“ä½œï¼Œå¦‚`groupby().apply()`ã€‚
- en: Dask merges used to be inefficient, which caused long runtimes. The optimizer
    fixes this for the trivial case where these operations happen after each other,
    but the technique isnâ€™t very advanced yet. There is still a lot of potential for
    improvement.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Daskçš„åˆå¹¶æ“ä½œæ›¾ç»æ•ˆç‡ä½ä¸‹ï¼Œå¯¼è‡´è¿è¡Œæ—¶é—´è¿‡é•¿ã€‚ä¼˜åŒ–å™¨è§£å†³äº†è¿™äº›æ“ä½œåœ¨å½¼æ­¤ä¹‹åå‘ç”Ÿæ—¶çš„ç®€å•æƒ…å†µï¼Œä½†è¯¥æŠ€æœ¯ç›®å‰è¿˜ä¸å¤Ÿå…ˆè¿›ã€‚ä»ç„¶æœ‰å¾ˆå¤§çš„æ”¹è¿›ç©ºé—´ã€‚
- en: '![](../Images/cc5ea176270a4da971f228de933a3f7a.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cc5ea176270a4da971f228de933a3f7a.png)'
- en: '`The current implementation shuffles both branches that originate from the
    same table. Injecting a shuffle node further up avoids one of the expensive operations.`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`å½“å‰çš„å®ç°ä¼šå¯¹æ¥è‡ªåŒä¸€è¡¨çš„ä¸¤ä¸ªåˆ†æ”¯è¿›è¡Œæ´—ç‰Œã€‚é€šè¿‡åœ¨æ›´é«˜å±‚æ¬¡æ’å…¥ä¸€ä¸ªæ´—ç‰ŒèŠ‚ç‚¹ï¼Œå¯ä»¥é¿å…å…¶ä¸­ä¸€ä¸ªæ˜‚è´µçš„æ“ä½œã€‚`'
- en: The optimizer will look at the expression and inject shuffle nodes where necessary
    to avoid unnecessary shuffles.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ä¼˜åŒ–å™¨ä¼šæŸ¥çœ‹è¡¨è¾¾å¼ï¼Œå¹¶åœ¨å¿…è¦æ—¶æ’å…¥æ´—ç‰ŒèŠ‚ç‚¹ï¼Œä»¥é¿å…ä¸å¿…è¦çš„æ´—ç‰Œæ“ä½œã€‚
- en: How do the improvements stack up compared to the legacy implementation?
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ç›¸è¾ƒäºä¼ ç»Ÿå®ç°ï¼Œè¿™äº›æ”¹è¿›çš„æ•ˆæœå¦‚ä½•ï¼Ÿ
- en: Dask is now 20x faster than before. This improvement applies to the entire DataFrame
    API (not just isolated components), with no known performance regressions. Dask
    now runs workloads that were impossible to complete in an acceptable timeframe
    before. This performance boost is due to many improvements all layered on top
    of each other. Itâ€™s not about doing one thing especially well, but about doing
    nothing especially poorly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Daskç°åœ¨æ¯”ä»¥å‰å¿«äº†20å€ã€‚è¿™ä¸ªæ”¹è¿›é€‚ç”¨äºæ•´ä¸ªDataFrame APIï¼ˆä¸ä»…ä»…æ˜¯æŸäº›ç‹¬ç«‹çš„ç»„ä»¶ï¼‰ï¼Œä¸”æ²¡æœ‰å·²çŸ¥çš„æ€§èƒ½å›å½’ã€‚Daskç°åœ¨èƒ½å¤Ÿè¿è¡Œä»¥å‰æ— æ³•åœ¨å¯æ¥å—çš„æ—¶é—´å†…å®Œæˆçš„å·¥ä½œè´Ÿè½½ã€‚è¿™ä¸ªæ€§èƒ½æå‡æ˜¯ç”±äºå¤šä¸ªæ”¹è¿›çš„å åŠ ã€‚å®ƒä¸æ˜¯åšä¸€ä»¶äº‹æƒ…ç‰¹åˆ«å¥½ï¼Œè€Œæ˜¯é¿å…åšä»»ä½•äº‹æƒ…ç‰¹åˆ«å·®ã€‚
- en: '![](../Images/308b0407b24987f46372d5b56e3cf07d.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/308b0407b24987f46372d5b56e3cf07d.png)'
- en: '`Performance improvements on Query 3 of the TPC-H Benchmarks from [https://github.com/coiled/benchmarks/tree/main/tests/tpch](https://github.com/coiled/benchmarks/tree/main/tests/tpch_)`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`TPC-HåŸºå‡†æµ‹è¯•ä¸­çš„æŸ¥è¯¢3æ€§èƒ½æå‡ï¼Œæ¥è‡ª[https://github.com/coiled/benchmarks/tree/main/tests/tpch](https://github.com/coiled/benchmarks/tree/main/tests/tpch_)`'
- en: Performance, while the most enticing improvement, is not the only thing that
    got better. The optimizer hides a lot of complexity from the user and makes the
    transition from pandas to Dask a lot easier because itâ€™s now much more difficult
    to write poorly performing code. The whole system is more robust.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: æ€§èƒ½è™½ç„¶æ˜¯æœ€å¸å¼•äººçš„æ”¹è¿›ï¼Œä½†å¹¶ä¸æ˜¯å”¯ä¸€å¾—åˆ°æ”¹å–„çš„åœ°æ–¹ã€‚ä¼˜åŒ–å™¨éšè—äº†å¾ˆå¤šå¤æ‚æ€§ï¼Œä½¿å¾—ç”¨æˆ·ä»pandasè¿ç§»åˆ°Daskå˜å¾—æ›´åŠ å®¹æ˜“ï¼Œå› ä¸ºç°åœ¨å†™å‡ºæ€§èƒ½å·®çš„ä»£ç å˜å¾—æ›´åŠ å›°éš¾ã€‚æ•´ä¸ªç³»ç»Ÿå˜å¾—æ›´åŠ å¥å£®ã€‚
- en: The new architecture of the API is a lot easier to work with as well. The legacy
    implementation leaked a lot of internal complexities into high-level API implementations,
    making changes cumbersome. Improvements are almost trivial to add now.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: æ–°çš„APIæ¶æ„ä¹Ÿæ›´å®¹æ˜“ä½¿ç”¨ã€‚æ—§ç‰ˆå®ç°å°†è®¸å¤šå†…éƒ¨å¤æ‚æ€§æ³„éœ²åˆ°é«˜å±‚APIä¸­ï¼Œå¯¼è‡´æ›´æ”¹å˜å¾—ç¹çã€‚ç°åœ¨ï¼Œæ”¹è¿›å‡ ä¹æ˜¯è½»æ¾æ˜“è¡Œçš„ã€‚
- en: Whatâ€™s to come?
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: æ¥ä¸‹æ¥ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
- en: Dask DataFrame changed a lot over the last 18 months. The legacy API was often
    difficult to work with and struggled with scaling out. The new implementation
    dropped things that didnâ€™t work and improved existing implementations. The heavy
    lifting is finished now, which allows for faster iteration cycles to improve upon
    the status quo. Incremental improvements are now trivial to add.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿‡å»18ä¸ªæœˆä¸­ï¼ŒDask DataFrameå‘ç”Ÿäº†å¾ˆå¤§å˜åŒ–ã€‚æ—§ç‰ˆAPIé€šå¸¸éš¾ä»¥ä½¿ç”¨ï¼Œä¸”åœ¨æ‰©å±•æ€§æ–¹é¢è¡¨ç°è¾ƒå·®ã€‚æ–°çš„å®ç°å»é™¤äº†ä¸å¥æ•ˆçš„éƒ¨åˆ†ï¼Œå¹¶æ”¹è¿›äº†ç°æœ‰å®ç°ã€‚ç°åœ¨ï¼Œç¹é‡çš„å·¥ä½œå·²ç»å®Œæˆï¼Œè¿™ä½¿å¾—åŠ å¿«è¿­ä»£å‘¨æœŸã€æ”¹è¿›ç°çŠ¶æˆä¸ºå¯èƒ½ã€‚å¢é‡æ”¹è¿›ç°åœ¨å˜å¾—è½»è€Œæ˜“ä¸¾ã€‚
- en: 'A few things that are on the immediate roadmap:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€äº›å³å°†å®æ–½çš„äº‹é¡¹ï¼š
- en: '**Auto repartitioning:** this is partially implemented, but there is more potential
    to choose a more efficient partition size during optimization.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è‡ªåŠ¨é‡æ–°åˆ†åŒºï¼š** è¿™éƒ¨åˆ†å·²ç»å®ç°ï¼Œä½†åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­ä»æœ‰æ›´å¤šæ½œåŠ›é€‰æ‹©æ›´é«˜æ•ˆçš„åˆ†åŒºå¤§å°ã€‚'
- en: '**Faster Joins:** thereâ€™s still lots of fine-tuning to be done here. For example,
    we have a PR in flight with a 30â€“40% improvement.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**æ›´å¿«çš„è¿æ¥ï¼š** è¿™é‡Œä»æœ‰å¾ˆå¤šç²¾ç»†è°ƒæ•´çš„ç©ºé—´ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªPRæ­£åœ¨è¿›è¡Œï¼Œå…¶ä¸­å¸¦æ¥äº†30-40%çš„æ€§èƒ½æå‡ã€‚'
- en: '**Join Reordering:** we donâ€™t do this yet, but itâ€™s on the immediate roadmap'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**è¿æ¥é‡æ’åºï¼š** æˆ‘ä»¬è¿˜æ²¡æœ‰åšåˆ°è¿™ä¸€ç‚¹ï¼Œä½†å®ƒåœ¨å³å°†å®æ–½çš„äº‹é¡¹ä¸­ã€‚'
- en: '**Learn More**'
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**äº†è§£æ›´å¤š**'
- en: 'This article focuses on a number of improvements to Dask DataFrame and how
    much faster and more reliable it is as a result. If youâ€™re choosing between Dask
    and other popular DataFrame tools, you might also consider:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬æ–‡é‡ç‚¹ä»‹ç»äº†å¯¹Dask DataFrameçš„å¤šä¸ªæ”¹è¿›ï¼Œä»¥åŠè¿™äº›æ”¹è¿›å¸¦æ¥äº†æ›´å¿«ã€æ›´å¯é çš„è¡¨ç°ã€‚å¦‚æœä½ åœ¨é€‰æ‹©Daskå’Œå…¶ä»–æµè¡Œçš„DataFrameå·¥å…·æ—¶ï¼Œå¯èƒ½è¿˜éœ€è¦è€ƒè™‘ï¼š
- en: '[**DataFrames at Scale Comparison:** TPC-H](https://docs.coiled.io/blog/tpch.html)
    which compares Dask, Spark, Polars, and DuckDB performance on datasets ranging
    from 10 GB to 10 TB both locally and on the cloud.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**å¤§è§„æ¨¡æ•°æ®æ¡†æ¯”è¾ƒï¼š** TPC-H](https://docs.coiled.io/blog/tpch.html)ï¼Œè¯¥æŠ¥å‘Šæ¯”è¾ƒäº†Daskã€Sparkã€Polarså’ŒDuckDBåœ¨ä»10
    GBåˆ°10 TBçš„æ•°æ®é›†ä¸Šçš„æ€§èƒ½ï¼Œæ¶µç›–æœ¬åœ°å’Œäº‘ç«¯ã€‚'
- en: Thank you for reading. Feel free to reach out to share your thoughts and feedback.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: æ„Ÿè°¢é˜…è¯»ã€‚æ¬¢è¿éšæ—¶è”ç³»æˆ‘ä»¬ï¼Œåˆ†äº«æ‚¨çš„æƒ³æ³•å’Œåé¦ˆã€‚

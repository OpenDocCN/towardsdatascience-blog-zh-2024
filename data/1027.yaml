- en: Building an AI-Powered Business Manager
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个AI驱动的业务管理系统
- en: 原文：[https://towardsdatascience.com/building-an-ai-powered-business-manager-e2a31a2fe984?source=collection_archive---------3-----------------------#2024-04-23](https://towardsdatascience.com/building-an-ai-powered-business-manager-e2a31a2fe984?source=collection_archive---------3-----------------------#2024-04-23)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/building-an-ai-powered-business-manager-e2a31a2fe984?source=collection_archive---------3-----------------------#2024-04-23](https://towardsdatascience.com/building-an-ai-powered-business-manager-e2a31a2fe984?source=collection_archive---------3-----------------------#2024-04-23)
- en: '![](../Images/dc602a5cdef860b9a6b382b91264e95b.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dc602a5cdef860b9a6b382b91264e95b.png)'
- en: Created with [DALL·E](https://labs.openai.com/s/1rNDsRujptitO6sPd57aWyZp)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [DALL·E](https://labs.openai.com/s/1rNDsRujptitO6sPd57aWyZp) 创建
- en: A step-by-step guide to linking your AI agent with a SQL database — Part 2 of
    the series
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将AI代理与SQL数据库连接的逐步指南——系列文章的第二部分
- en: '[](https://medium.com/@lukas.kowejsza?source=post_page---byline--e2a31a2fe984--------------------------------)[![Lukasz
    Kowejsza](../Images/8d920478bee9ad674a6c79462128b0db.png)](https://medium.com/@lukas.kowejsza?source=post_page---byline--e2a31a2fe984--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e2a31a2fe984--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e2a31a2fe984--------------------------------)
    [Lukasz Kowejsza](https://medium.com/@lukas.kowejsza?source=post_page---byline--e2a31a2fe984--------------------------------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@lukas.kowejsza?source=post_page---byline--e2a31a2fe984--------------------------------)[![Lukasz
    Kowejsza](../Images/8d920478bee9ad674a6c79462128b0db.png)](https://medium.com/@lukas.kowejsza?source=post_page---byline--e2a31a2fe984--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--e2a31a2fe984--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--e2a31a2fe984--------------------------------)
    [Lukasz Kowejsza](https://medium.com/@lukas.kowejsza?source=post_page---byline--e2a31a2fe984--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e2a31a2fe984--------------------------------)
    ·29 min read·Apr 23, 2024
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--e2a31a2fe984--------------------------------)
    ·29分钟阅读·2024年4月23日
- en: --
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: Imagine streamlining your entire business management through a single, user-friendly
    interface on your phone. While juggling multiple apps is common practice, the
    future lies in consolidating all your interactions into one chat-based platform,
    powered by the capabilities of Large Language Models (LLMs).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下通过一个简单易用的手机界面来简化整个业务管理。虽然同时使用多个应用程序是常见做法，但未来的趋势是将所有互动整合到一个基于聊天的平台中，这个平台由大型语言模型（LLM）驱动。
- en: For small businesses, this approach offers significant advantages. By centralizing
    data management tasks within a unified chat interface, owners can save time, reduce
    complexity, and minimize reliance on disparate software tools. The result is a
    more efficient allocation of resources, allowing a greater focus on core business
    growth activities.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型企业来说，这种方法具有显著优势。通过将数据管理任务集中在统一的聊天界面中，企业主可以节省时间，减少复杂性，并最小化对不同软件工具的依赖。最终的结果是资源分配更为高效，能够将更多精力集中在核心业务增长活动上。
- en: However, the potential extends beyond just small businesses. The concepts and
    techniques detailed in this tutorial are adaptable to personal use cases as well.
    From managing to-do lists and tracking expenses to organizing collections, a chat-based
    interface provides an intuitive and efficient way to interact with your data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一潜力不仅限于小型企业。本教程中详细介绍的概念和技术同样适用于个人使用案例。从管理待办事项和跟踪开支到整理收藏，基于聊天的界面为与数据交互提供了一种直观且高效的方式。
- en: 'This article is the second installment in a series that guides you through
    the process of developing such a software project, from initial concept to practical
    implementation. Building upon the components introduced in the previous article,
    we will establish the foundational elements of our application, including:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本文是一个系列文章中的第二篇，旨在引导你完成从最初的概念到实际实现的整个软件开发过程。在上一篇文章中介绍的组件基础上，我们将建立我们应用程序的基础元素，包括：
- en: Setting up the database schema
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置数据库架构
- en: Defining core application functionality
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义核心应用功能
- en: Structuring the project repository
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化项目仓库
- en: Creating Tools capable of interacting with multiple SQL database tables using
    natural language commands
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建能够使用自然语言命令与多个SQL数据库表交互的工具
- en: By the end of this tutorial, you will have a clear understanding of how to architect
    a chat-based interface that leverages LLMs to simplify data management tasks.
    Whether you’re a small business owner looking to streamline operations or an individual
    seeking to optimize personal organization, the principles covered here will provide
    a solid starting point for your own projects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到本教程结束时，你将清楚地理解如何设计一个基于聊天界面的架构，利用大语言模型（LLM）简化数据管理任务。无论你是希望优化运营的小企业主，还是寻求个人组织优化的个体，这里讲解的原则将为你的项目提供一个坚实的起点。
- en: Let’s begin by briefly recapping the key takeaways from the previous article
    to set the context for our current objectives.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先简要回顾一下上一篇文章的关键要点，为我们当前的目标设定背景。
- en: Recap
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: '[In the first part of this series](/leverage-openai-tool-calling-building-a-reliable-ai-agent-from-scratch-4e21fcd15b62),
    we built a prototype agent workflow capable of interacting with tool objects.
    Our goal was to reduce hallucination in tool arguments generated by the underlying
    language model, in our case `gpt-3.5-turbo`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[在本系列的第一部分](/leverage-openai-tool-calling-building-a-reliable-ai-agent-from-scratch-4e21fcd15b62)中，我们构建了一个原型代理工作流，能够与工具对象进行交互。我们的目标是减少底层语言模型生成的工具参数中的幻觉现象，在我们的案例中是`gpt-3.5-turbo`。'
- en: 'To achieve this, we implemented two key changes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，我们实施了两个关键变更：
- en: Removed required parameters in the tool schema
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除了工具模式中的必需参数
- en: Added a parameter validation step before executing the desired function
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行所需功能之前增加了参数验证步骤
- en: By setting all tool parameters to optional and manually checking for missing
    parameters, we eliminated the urge for the Agent/LLM to hallucinate missing values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有工具参数设为可选，并手动检查缺失的参数，我们消除了代理/大语言模型生成缺失值的幻觉冲动。
- en: 'The key objects introduced in the previous article were:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中介绍的关键对象是：
- en: '`OpenAiAgent`: The main agent workflow class'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenAiAgent`：主要的代理工作流类'
- en: '`Tool`: A class representing a tool the agent can use'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tool`：一个表示代理可以使用的工具的类'
- en: '`ToolResult` and `StepResult`: Classes for encapsulating tool execution results'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToolResult` 和 `StepResult`：用于封装工具执行结果的类'
- en: These components formed the foundation of our agent system, allowing it to process
    user requests, select appropriate tools, and generate responses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件构成了我们代理系统的基础，使其能够处理用户请求，选择合适的工具，并生成响应。
- en: 'If you’d like a more detailed explanation or want to know the reasoning behind
    specific design choices, feel free to check out the previous article: [Leverage
    OpenAI Tool Calling: Building a Reliable AI Agent from Scratch](https://medium.com/towards-data-science/leverage-openai-tool-calling-building-a-reliable-ai-agent-from-scratch-4e21fcd15b62)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更详细的解释或了解特定设计选择背后的原因，可以查看上一篇文章：[利用OpenAI工具调用：从零开始构建可靠的AI代理](https://medium.com/towards-data-science/leverage-openai-tool-calling-building-a-reliable-ai-agent-from-scratch-4e21fcd15b62)
- en: With this recap in mind, let’s dive into the next phase of our project — integrating
    database functionality to store and manage business data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些回顾内容后，让我们进入项目的下一阶段——集成数据库功能以存储和管理业务数据。
- en: Why Chat Interface for Small Business Data Management
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么为小企业数据管理提供聊天界面
- en: Small businesses often face unique challenges when it comes to data maintenance.
    Like larger corporations, they need to regularly update and maintain various types
    of data, such as accounting records, time tracking, invoices, and more. However,
    the complexity and costs associated with modern ERP (Enterprise Resource Planning)
    systems can be prohibitive for small businesses. As a result, many resort to using
    a series of Excel spreadsheets to capture and maintain essential data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 小企业在数据维护方面经常面临独特的挑战。与大公司一样，它们需要定期更新和维护各种类型的数据，如会计记录、时间跟踪、发票等。然而，现代ERP（企业资源规划）系统的复杂性和成本对小企业而言可能是一个障碍。因此，许多小企业不得不依赖一系列Excel电子表格来捕捉和维护关键数据。
- en: The problem with this approach is that small business owners, who are rarely
    dedicated solely to administrative tasks, cannot afford to invest significant
    time and effort into complex administration and control processes. The key is
    to define lean processes and update data as it arises, minimizing the overhead
    of data management.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，小企业主通常并非完全专注于行政任务，无法投入大量时间和精力进行复杂的行政管理和控制流程。关键在于定义精简的流程，并在数据出现时及时更新，最小化数据管理的开销。
- en: By leveraging the power of Large Language Models and creating a chat interface,
    we aim to simplify and streamline data management for small businesses. The chatbot
    will act as a unified interface, allowing users to input data, retrieve information,
    and perform various tasks using natural language commands. This eliminates the
    need for navigating multiple spreadsheets or developing complex web applications
    with multiple forms and dashboards.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用大型语言模型的强大功能并创建聊天界面，我们旨在简化和优化小型企业的数据管理。该聊天机器人将充当统一接口，允许用户输入数据、检索信息，并通过自然语言命令执行各种任务。这消除了需要在多个电子表格之间切换或开发具有多个表单和仪表盘的复杂
    web 应用程序的需求。
- en: Throughout this series, we will gradually enhance the chatbot’s capabilities,
    adding features such as role-based access control, advanced querying and evaluation,
    multimodal support, and integration with popular communication platforms like
    WhatsApp. By the end of the series, you will have a powerful and flexible tool
    that can adapt to your specific needs, whether you’re running a small business
    or simply looking to organize your personal life more efficiently.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一系列教程中，我们将逐步增强聊天机器人的功能，添加诸如基于角色的访问控制、先进的查询与评估、多模态支持，以及与流行的通讯平台（如 WhatsApp）的集成等功能。到系列结束时，您将拥有一个强大而灵活的工具，能够根据您的具体需求进行调整，无论您是经营一家小型企业，还是仅仅希望更高效地组织个人生活。
- en: Let’s get started!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 1\. Project Structure
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 项目结构
- en: 'To ensure a well-organized and maintainable project, we’ve structured our repository
    to encapsulate different functionalities and components systematically. Here’s
    an overview of the repository structure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保项目井井有条并易于维护，我们已经有系统地构建了我们的代码库，封装了不同的功能和组件。以下是代码库结构的概述：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This structure allows for a clear separation of concerns, making it easier to
    develop, maintain, and scale our application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构使得关注点分离更加清晰，简化了应用程序的开发、维护和扩展。
- en: 2\. Set up Database
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 设置数据库
- en: 'Choosing the right database and ORM (Object-Relational Mapping) library is
    crucial for our application. For this project, we’ve selected the following frameworks:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的数据库和 ORM（对象关系映射）库对我们的应用程序至关重要。对于这个项目，我们选择了以下框架：
- en: 'SQLAlchemy: A powerful SQL toolkit and Object-Relational Mapping (ORM) library
    for Python. It provides a set of tools for interacting with databases using Python
    objects and classes.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy：一个强大的 SQL 工具包和 Python 的对象关系映射（ORM）库。它提供了一套与数据库交互的工具，通过 Python 对象和类进行操作。
- en: 'SQLModel: A library that builds on top of SQLAlchemy and Pydantic, offering
    a simple and intuitive way to define database models and perform database operations.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLModel：一个构建在 SQLAlchemy 和 Pydantic 之上的库，提供了一种简单直观的方式来定义数据库模型并执行数据库操作。
- en: By leveraging SQLModel, we can seamlessly integrate with Pydantic and SQLAlchemy,
    enabling efficient data validation and database operations while eliminating the
    risk of SQL injection attacks. Moreover, SQLModel allows us to easily build upon
    our previously designed `Tool` class, which uses Pydantic models for creating
    a tool schema.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用 SQLModel，我们可以与 Pydantic 和 SQLAlchemy 无缝集成，既能高效地进行数据验证和数据库操作，又能消除 SQL 注入攻击的风险。此外，SQLModel
    使我们能够轻松构建我们之前设计的`Tool`类，该类使用 Pydantic 模型来创建工具模式。
- en: 'To ensure the security and robustness of our application, we implement the
    following measures:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为确保我们应用程序的安全性和稳健性，我们实施了以下措施：
- en: 'Role-based access control: Executable operations are bound to user roles, ensuring
    that users can only perform actions they are authorized to do. This adds an extra
    layer of security and prevents unauthorized access to sensitive data.'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于角色的访问控制：可执行的操作与用户角色绑定，确保用户只能执行他们被授权的操作。这为系统增加了额外的安全层，防止未经授权访问敏感数据。
- en: 'Prevention of SQL injection attacks: By utilizing ChatGPT’s natural language
    understanding capabilities, we can validate and sanitize user inputs, mitigating
    the risk of SQL injection vulnerabilities. SQLModel’s integration with Pydantic
    helps us enforce strict data validation rules.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止 SQL 注入攻击：通过利用 ChatGPT 的自然语言理解能力，我们可以验证和清理用户输入，从而减轻 SQL 注入漏洞的风险。SQLModel 与
    Pydantic 的集成帮助我们强制执行严格的数据验证规则。
- en: With our tech stack decided, let’s dive into setting up the database and defining
    our models.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了我们的技术栈后，让我们开始设置数据库并定义我们的模型。
- en: 2.1 Database Models
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 数据库模型
- en: 'To begin building our prototype application, we’ll define the essential database
    tables and their corresponding SQLModel definitions. For this tutorial, we’ll
    focus on three core tables:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始构建我们的原型应用程序，我们将定义基本的数据库表和相应的SQLModel定义。对于本教程，我们将重点介绍三个核心表：
- en: Expense
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支出
- en: Revenue
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收入
- en: Customer
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户
- en: These tables will serve as the foundation for our application, allowing us to
    demonstrate the key functionalities and interactions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表将作为我们应用程序的基础，允许我们演示关键功能和交互。
- en: 'Create a new file named `models.py` in the `database` directory and define
    the tables using SQLModel:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`database`目录下创建一个名为`models.py`的新文件，并使用SQLModel定义表格：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In addition to the standard SQLModel fields, we’ve defined three custom type
    annotations: `DateFormat`, `TimeFormat`, and `Numeric`. These annotations leverage
    Pydantic’s `BeforeValidator` to ensure that the input data is correctly formatted
    before being stored in the database. The `validate_date` function handles the
    conversion of string input to the appropriate `datetime`. This approach allows
    us to accept a variety of date formats from the Large Language Model, reducing
    the need for strict format enforcement in the prompts.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准的SQLModel字段外，我们还定义了三个自定义类型注解：`DateFormat`、`TimeFormat`和`Numeric`。这些注解利用了Pydantic的`BeforeValidator`，以确保在将输入数据存储到数据库之前，它们被正确格式化。`validate_date`函数处理将字符串输入转换为适当的`datetime`。这种方法允许我们接受来自大型语言模型的各种日期格式，从而减少了在提示中对格式的严格要求。
- en: 2.2 Database Engine
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 数据库引擎
- en: 'With our models defined, we need a script to set up the database engine and
    create the corresponding tables. Let’s create a `db.py` file in the `database`
    directory to handle this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了模型之后，我们需要一个脚本来设置数据库引擎并创建相应的表格。让我们在`database`目录中创建一个`db.py`文件来处理这个任务：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this script, we import our models and the necessary SQLModel components.
    We define the `DATABASE_URL` to point to a local SQLite database file named `app.db`.
    We create an `engine` using `create_engine` from SQLModel, passing in the `DATABASE_URL`.
    The `echo=True` parameter enables verbose output for debugging purposes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们导入了我们的模型和必要的SQLModel组件。我们定义了`DATABASE_URL`，它指向名为`app.db`的本地SQLite数据库文件。我们使用SQLModel的`create_engine`创建了一个`engine`，并传入`DATABASE_URL`。`echo=True`参数启用了详细输出，便于调试。
- en: The `create_db_and_tables` function uses `SQLModel.metadata.create_all` to generate
    the corresponding tables in the database based on our defined models. Finally,
    we call this function to ensure the database and tables are created when the script
    is run.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_db_and_tables`函数使用`SQLModel.metadata.create_all`根据我们定义的模型生成相应的数据库表。最后，我们调用这个函数以确保在运行脚本时创建数据库和表格。'
- en: With our database setup complete, we can now focus on updating our `Tool` class
    to work seamlessly with SQLModel and enhance our tool schema conversion process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设置完成后，我们现在可以专注于更新我们的`Tool`类，使其与SQLModel无缝协作，并增强我们的工具架构转换过程。
- en: 3\. Tool Class
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 工具类
- en: In this section, we’ll discuss the updates made to the `Tool` class to handle
    SQLModel instances and improve the validation process. For a more detailed explanation
    of the `Tool` class, visit my previous article.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论对`Tool`类所做的更新，以处理SQLModel实例并改进验证过程。如需更详细的`Tool`类说明，请访问我之前的文章。
- en: First, we’ve added `Type[SQLModel]` as a possible type for the `model` field
    using the `Union` type hint. This allows the `Tool` class to accept both Pydantic's
    `BaseModel` and SQLModel's `SQLModel` as valid model types.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过`Union`类型提示将`Type[SQLModel]`作为`model`字段的可能类型。这使得`Tool`类能够接受Pydantic的`BaseModel`和SQLModel的`SQLModel`作为有效的模型类型。
- en: Next, we’ve introduced a new attribute called `exclude_keys` of type `list[str]`
    with a default value of `["id"]`. The purpose of this attribute is to specify
    which keys should be excluded from the validation process and the OpenAI tool
    schema generation. In this case the default excluded key is `id` since for data
    entry creation with `SqlModel` the id is automatically generated during ingestion.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们引入了一个新的属性`exclude_keys`，其类型为`list[str]`，默认值为`["id"]`。这个属性的目的是指定哪些键应该从验证过程和OpenAI工具架构生成中排除。在这种情况下，默认排除的键是`id`，因为在使用`SqlModel`进行数据录入时，`id`会在数据导入过程中自动生成。
- en: On top of that we introduced `parse_model` boolean attribute to our Tool class.
    Where we can basically decided if the tool function is called with our pydantic/SQLModel
    or with keyword arguments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在`Tool`类中引入了`parse_model`布尔属性。通过这个属性，我们可以决定工具函数是通过Pydantic/SQLModel调用，还是通过关键字参数调用。
- en: In the `validate_input()` method, we've added a check to ensure that the keys
    specified in `exclude_keys` are not considered as missing keys during the validation
    process. This is particularly useful for fields like `id`, which are automatically
    generated by SQLModel and should not be required in the input.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`validate_input()`方法中，我们添加了一个检查，以确保在验证过程中，`exclude_keys`中指定的键不会被视为缺失键。这对于像`id`这样的字段特别有用，因为这些字段是由SQLModel自动生成的，不应作为输入的必需项。
- en: Similarly, in the `openai_tool_schema` property, we've added a loop to remove
    the excluded keys from the generated schema. This ensures that the excluded keys
    are not included in the schema sent to the OpenAI API. For recap we use the `openai_tool_schema`
    property to remove `required` arguments from our tool schema. This is done to
    elimenate hallucination by our language model.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在`openai_tool_schema`属性中，我们添加了一个循环，以从生成的模式中移除被排除的键。这确保了排除的键不会被包括在发送到OpenAI
    API的模式中。为了总结，我们使用`openai_tool_schema`属性从我们的工具模式中移除`required`参数。这是为了消除语言模型的幻觉。
- en: Moreover, we changed the import from `from pydantic.v1 import BaseModel` to
    `from pydantic import BaseModel`. Since `SQLModel` is based on Pydantic v2, we
    want to be consistent and use Pydantic v2 at this point.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将导入语句从`from pydantic.v1 import BaseModel`更改为`from pydantic import BaseModel`。由于`SQLModel`基于Pydantic
    v2，我们希望在此时保持一致，使用Pydantic v2。
- en: 'Here’s the updated code for the `Tool` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Tool`类的更新代码：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These updates to the `Tool` class provide more flexibility and control over
    the validation process and schema generation when working with SQLModel instances.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对`Tool`类的更新提供了更多的灵活性和控制力，能够在处理SQLModel实例时进行更精细的验证过程和模式生成。
- en: 3.1 Custom Tool Schema Conversion
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 自定义工具模式转换
- en: 'In our `Tool` class, we create a schema from a Pydantic model using the `convert_to_openai_tool`
    function from Langchain. However, this function is based on Pydantic v1, while
    SQLModel uses Pydantic v2\. To make the conversion function compatible, we need
    to adapt it. Let''s create a new script called `convert.py`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Tool`类中，我们使用`convert_to_openai_tool`函数从Langchain创建一个Pydantic模型的模式。然而，这个函数是基于Pydantic
    v1的，而SQLModel使用的是Pydantic v2。为了使转换函数兼容，我们需要对其进行调整。让我们创建一个新的脚本，命名为`convert.py`：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This adapted conversion function handles the differences between Pydantic v1
    and v2, ensuring that our `Tool` class can generate compatible schemas for the
    OpenAI API.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调整后的转换函数处理了Pydantic v1和v2之间的差异，确保我们的`Tool`类能够生成与OpenAI API兼容的模式。
- en: 'Next, update the import statement in `tools/base.py` to use the new `convert_to_openai_tool`
    function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`tools/base.py`中更新导入语句，以使用新的`convert_to_openai_tool`函数：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With these changes in place, our `Tool` class can now handle SQLModel instances
    and generate schemas that are compatible with the OpenAI API.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们的`Tool`类现在可以处理SQLModel实例并生成与OpenAI API兼容的模式。
- en: '*Note: If you encounter dependency issues, you may consider removing the Langchain
    dependency entirely and including the* `*_rm_titles*` *and* `*dereference_refs*`
    *functions directly in the* `*convert.py*` *file.*'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*注意：如果遇到依赖问题，您可以考虑完全移除Langchain依赖，并直接在`convert.py`文件中包含`*_rm_titles*`和`*dereference_refs*`函数。*'
- en: By adapting the tool schema conversion process, we’ve ensured that our application
    can seamlessly work with SQLModel and Pydantic v2, enabling us to leverage the
    benefits of these libraries while maintaining compatibility with the OpenAI API.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整工具模式转换过程，我们确保了我们的应用能够与SQLModel和Pydantic v2无缝协作，使我们能够在保持与OpenAI API兼容的同时，利用这些库的优势。
- en: 4\. Defining SQL Tools
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 定义SQL工具
- en: In this section, we will create functions and tools to interact with our database
    tables using SQL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建函数和工具，以便使用SQL与我们的数据库表进行交互。
- en: 4.1 Add Data Tool
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 添加数据工具
- en: 'First, let’s define a generic function `add_row_to_table` that takes a SQLModel
    instance and adds it to the corresponding table:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个通用函数`add_row_to_table`，它接受一个SQLModel实例并将其添加到相应的表中：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we’ll create a model-specific function `add_expense_to_table` that takes
    input arguments for an Expense entry and adds it to the table:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个特定模型的函数`add_expense_to_table`，它接受支出条目的输入参数并将其添加到表中：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In `add_expense_to_table`, we use the `model_validate()` method to trigger the
    execution of the previously defined BeforeValidator and ensure data validation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`add_expense_to_table`中，我们使用`model_validate()`方法触发之前定义的BeforeValidator的执行，并确保数据验证。
- en: 'To avoid writing separate functions for each table or SQLModel, we can dynamically
    generate the functions:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免为每个表或SQLModel编写单独的函数，我们可以动态生成这些函数：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This approach produces the same result and can be used to dynamically generate
    functions for all other models.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法产生相同的结果，并且可以用来动态生成所有其他模型的函数。
- en: 'With these functions in place, we can create tools using our `Tool` class to
    add entries to our database tables via the OpenAIAgent:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些功能就位后，我们可以使用我们的`Tool`类创建工具，通过OpenAIAgent向数据库表中添加条目：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 4.2 Query Tool
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 查询工具
- en: While we need to create an add_xxx_tool for each table due to varying input
    schemas, we only need one query tool for querying all tables. To eliminate the
    risk of SQL injection, we will use the SQL sanitization provided by SQLAlchemy
    and SQLModel. This means we will query the database through standard Python classes
    and objects instead of parsing SQL statements directly.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们需要为每个表创建一个add_xxx_tool，因为输入模式不同，但我们只需要一个查询工具来查询所有表。为了消除SQL注入的风险，我们将使用SQLAlchemy和SQLModel提供的SQL清理功能。这意味着我们将通过标准的Python类和对象来查询数据库，而不是直接解析SQL语句。
- en: 'For the queries we want to perform on our tables, we will need the following
    logic:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们想在表上执行的查询，我们需要以下逻辑：
- en: '**select statement** -> `SELECT * FROM table_name` Arguments: `columns`, `table_name`'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**select语句** -> `SELECT * FROM table_name` 参数：`columns`、`table_name`'
- en: '**where statement** -> `WHERE column_name = value`'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**where语句** -> `WHERE column_name = value`'
- en: 'Arguments: `column`, `operator`, `value`'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数：`column`、`operator`、`value`
- en: 'In SQLModel, this corresponds to the following sanitized code when we want
    to find all expenses for coffee in the `Expense` table:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLModel中，当我们想在`Expense`表中查找所有咖啡的支出时，这对应于以下清理过的代码：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To abstract this into a pydantic model:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将其抽象为一个pydantic模型：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `QueryConfig` model allows us to set a `table_name`, `columns`, and `where`
    statements. The `where` property accepts a list of `WhereStatement` models or
    an empty list (when we want to return all values with no further filtering). A
    `WhereStatement` is a submodel defining a column, operator, and value. The `Literal`
    type is used to restrict the allowed operators to a predefined set.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`QueryConfig`模型允许我们设置`table_name`、`columns`和`where`语句。`where`属性接受一个`WhereStatement`模型的列表或一个空列表（当我们想返回所有值且不进行进一步筛选时）。`WhereStatement`是一个子模型，定义了列、操作符和值。`Literal`类型用于将允许的操作符限制为预定义的集合。'
- en: 'Next, we define a function that executes a query based on the `QueryConfig`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个根据`QueryConfig`执行查询的函数：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `query_data_function` serves as a high-level abstraction for selecting our
    table model from the `TABLES` dictionary, while `sql_query_from_config` is the
    underlying function for executing the `QueryConfig` on a table (SQLModel).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`query_data_function`作为从`TABLES`字典中选择我们的表模型的高级抽象，而`sql_query_from_config`是执行`QueryConfig`查询表（SQLModel）的底层函数。'
- en: In `QueryConfig` you can choose to also define table_names as Literal type,
    where you hard code the available table names into it. You can even dynamically
    define the Literal using our TABLES dictionary. By doing so you can reduce false
    arguments for table_name. For now I have choosen to not use an enum object, because
    I will provide the agent prompt with context about the currently available tables
    and there underling ORM schema. I plan to add a tool for our future agent to create
    new tables on it’s own.While I can dynamically change the agent’s prompt, it won’t
    be straightforward to change the enum object within `QueryConfig` on our running
    server.
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在`QueryConfig`中，你可以选择将`table_names`定义为Literal类型，其中将可用的表名硬编码进去。你甚至可以通过我们的TABLES字典动态定义Literal。通过这样做，可以减少对`table_name`的错误传参。目前我选择不使用枚举对象，因为我将向代理提供关于当前可用表及其底层ORM架构的上下文信息。我计划为我们未来的代理添加一个工具，使其能够自己创建新表。虽然我可以动态更改代理的提示，但在运行中的服务器中更改`QueryConfig`中的枚举对象将不是一件简单的事。
- en: 'Finally, we can define our query tool:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以定义我们的查询工具：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With these tools in place, our OpenAIAgent is now capable of adding and querying
    data in our database tables using natural language commands.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些工具，我们的OpenAIAgent现在能够使用自然语言命令向数据库表中添加和查询数据。
- en: 5\. Configure Agent
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 配置代理
- en: To enable successful tool usage for our previously defined tools, the Agent
    from the previous article will need more context information, especially for using
    the query tool. The Agent prompt will need to include information about available
    tables and their schemas. Since we only use two tables at this point, we can include
    the ORM schema and table names in the system prompt or user prompt. Both options
    might work well, but I prefer to include variable information like this in the
    user prompt. By doing so, we can create few-shot examples that demonstrate context-aware
    tool usage.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们之前定义的工具能够成功使用，前一篇文章中的 Agent 需要更多的上下文信息，尤其是用于查询工具时。Agent 的提示需要包括可用表格及其架构信息。由于目前我们只使用两个表格，我们可以在系统提示或用户提示中包含
    ORM 架构和表格名称。这两种方式都可以，但我更倾向于在用户提示中包含像这样的变量信息。通过这样做，我们可以创建少量示例，演示基于上下文的工具使用。
- en: 'To make our Agent capable of handling variable context in the system prompt
    and user prompt, we can update our Agent class as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 Agent 能够处理系统提示和用户提示中的变量上下文，我们可以按以下方式更新我们的 Agent 类：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The main changes compared to our previous version:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于我们之前的版本，主要的变化如下：
- en: We placed a “{context}” placeholder in the default system prompt.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在默认的系统提示中放置了一个“{context}”占位符。
- en: We added `context` and `user_context` as input arguments to `__init__()`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`context`和`user_context`作为输入参数添加到`__init__()`中。
- en: We added `context` to the `run()` method.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`context`添加到`run()`方法中。
- en: In `run()`, we add `context` to the user message if defined.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`run()`中，如果定义了`context`，我们将其添加到用户消息中。
- en: We also added an `examples` attribute to `__init__()` that, if set, will be
    passed between the system and user messages in `run()`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还在`__init__()`中添加了一个`examples`属性，如果设置了它，将在`run()`中的系统和用户消息之间传递。
- en: Now we can define a system context and a user context while initializing our
    agent. Additionally, we can pass a user context when calling the run method. If
    `context` is passed to the run method, it will overwrite the `user_context` from
    initialization for that run.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在初始化代理时定义系统上下文和用户上下文。此外，我们还可以在调用 run 方法时传递用户上下文。如果`context`被传递给 run 方法，它将覆盖初始化时的`user_context`，只在本次运行中有效。
- en: 5.1 Providing Context to the Agent
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 向 Agent 提供上下文
- en: 'Before we can run our Agent, let’s define a function that generates context
    information. We want to automatically generate `user_context`, which we can then
    pass to the Agent''s run function as implemented above. To keep it simple, we
    want a single line for each table as context information that should include:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够运行 Agent 之前，让我们定义一个生成上下文信息的函数。我们希望自动生成`user_context`，然后将其传递给如上所述的 Agent
    的 run 函数。为了简单起见，我们希望每个表格的上下文信息仅用一行来表示，内容应该包括：
- en: Table name
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格名称
- en: 'Column_name: `<type>`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列名称：`<type>`
- en: 'After a few attempts with trial and error, the following function will do the
    job:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次尝试和错误，以下函数可以完成这个任务：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we pass `Expense` and `Revenue` to `generate_context()`, we should get the
    following context string:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`Expense`和`Revenue`传递给`generate_context()`，我们应该得到以下上下文字符串：
- en: 'We want the Agent to know the current date and day of the week, so we can reference
    the correct date. So let’s add some date parsing functions to our utils class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 Agent 知道当前的日期和星期几，以便我们可以引用正确的日期。因此，接下来我们将在工具类中添加一些日期解析函数：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now let’s create the context for a query agent
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为查询代理创建上下文
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 5.2 Routing Agent
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 路由 Agent
- en: As we add more tools, the complexity of our setup may start to limit the usability
    of cheaper models like “gpt-3.5-turbo”. In the next article, we might consider
    switching to Anthropic Claude, since their newly released tool-use API feature
    seems promising, even for the more affordable HAIKU model, in handling multiple
    tools simultaneously. However, for now, we will continue using OpenAI’s GPT models.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们添加更多的工具，我们的设置复杂性可能会开始限制像“gpt-3.5-turbo”这样的便宜模型的可用性。在下一篇文章中，我们可能会考虑切换到 Anthropic
    Claude，因为它们新发布的工具使用 API 功能似乎在同时处理多个工具时很有前景，甚至适用于更便宜的 HAIKU 模型。然而，目前我们将继续使用 OpenAI
    的 GPT 模型。
- en: When developing for personal use and before creating production-ready applications,
    I find it useful to optimize the workflow for smaller models, such as `gpt-3.5-turbo`
    in this case. This approach forces us to create a streamlined processing logic
    and prompting system. While we may not achieve 100% reliability without using
    the most powerful model, we will be able to catch flaws and identify unclear instructions.
    If your application works in 9 out of 10 cases with a smaller model, you will
    have a production-ready logic that will perform even better with a stronger model.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行个人使用的开发并创建生产就绪应用程序之前，我发现优化工作流程以适应较小的模型（如本例中的`gpt-3.5-turbo`）是非常有用的。这种方法迫使我们创建一个精简的处理逻辑和提示系统。虽然我们可能无法在不使用最强大模型的情况下实现100%的可靠性，但我们能够发现缺陷并识别不清晰的指令。如果您的应用在10次中有9次能在较小模型下正常工作，您就拥有了一套生产就绪的逻辑，并且使用更强大的模型时，系统的表现会更好。
- en: To make multi-tool handling reliable with `gpt-3.5-turbo` we will implement
    a routing agent whose sole purpose is to route the user query to the appropriate
    task agent. This allows us to separate execution logic and reduce complexity.
    Each agent will have a limited scope, enabling us to separate access roles and
    operations in the future. I have observed that even with gpt-4, there are instances
    where the agent does not know when its task is finished.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使多工具处理在`gpt-3.5-turbo`下更可靠，我们将实现一个路由代理，它的唯一目的是将用户查询路由到适当的任务代理。这使我们能够分离执行逻辑，减少复杂性。每个代理将有一个有限的范围，使我们能够在未来分离访问角色和操作。我观察到即使在使用gpt-4时，也会出现代理不知道何时任务完成的情况。
- en: By introducing a routing agent, we can break down the problem into smaller,
    more manageable parts. The routing agent will be responsible for understanding
    the user’s intent and directing the query to the relevant task agent. This approach
    not only simplifies the individual agents’ responsibilities but also makes the
    system more modular and easier to maintain.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入路由代理，我们可以将问题分解成更小、更易管理的部分。路由代理将负责理解用户的意图，并将查询引导到相关的任务代理。这种方法不仅简化了各个代理的职责，还使系统更加模块化，更易于维护。
- en: Furthermore, separating the execution logic and complexity will pave the way
    for implementing role-based access control in the future. Each task agent can
    be assigned specific permissions and access levels, ensuring that sensitive operations
    are only performed by authorized agents.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，分离执行逻辑和复杂性将为未来实现基于角色的访问控制铺平道路。每个任务代理可以被分配特定的权限和访问级别，确保敏感操作仅由授权代理执行。
- en: While the routing agent adds an extra step in the process, it ultimately leads
    to a more robust and scalable system. By optimizing for smaller models and focusing
    on clear, concise prompts, we can create a solid foundation that will perform
    even better when we switch to more powerful models like Claude Opus or GPT-4.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然路由代理在流程中增加了一个额外的步骤，但它最终会导致一个更强大、更具可扩展性的系统。通过优化较小的模型并专注于清晰、简洁的提示，我们可以创建一个坚实的基础，在切换到更强大的模型如Claude
    Opus或GPT-4时，系统的性能会更好。
- en: Let’s have a look on the implementation of the routing agent
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看路由代理的实现
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The biggest differences to our `OpenAIAgent` are:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`OpenAIAgent`相比，最大的区别在于：
- en: '**No open loop:** we want the routing agent to route user’s queries to the
    appropriate agent. So instead of creating an open loop we select the desired agent
    via tool calling and pass the user query to it. The routing Agent should not do
    any other task or follow-up question.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无开环：**我们希望路由代理将用户的查询路由到适当的代理。因此，我们通过工具调用选择所需的代理，并将用户查询传递给它，而不是创建一个开环。路由代理不应该执行其他任务或后续问题。'
- en: '**Agents as Tools**: Instead of calling a tool the routing agent setup a subagent.
    So our previously defined `OpenAIAgent`is now a tool within our routing agent.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理作为工具**：与其称一个工具为路由代理，不如设置一个子代理。因此，我们之前定义的`OpenAIAgent`现在成为路由代理中的一个工具。'
- en: 5.3 Agent as a Tool — Task Agent
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 代理作为工具——任务代理
- en: To use our `OpenAIAgent`as a tool, we need to introduce some sort of tool class
    dedicated for Agents. We want to define a name and description for each agent
    and automate the initialization process. Therefore, we define our last class for
    this tutorial the`TaskAgent`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的`OpenAIAgent`作为工具使用，我们需要引入某种专门为代理设计的工具类。我们希望为每个代理定义一个名称和描述，并自动化初始化过程。因此，我们为本教程定义了最后一个类——`TaskAgent`。
- en: The `TaskAgent` class serves similar functionality as the `Tool` class. We define
    a name a description and an input model which we call `arg_model`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskAgent`类的功能与`Tool`类类似。我们定义了一个名称、描述和一个输入模型，我们称之为`arg_model`。'
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Additionally, we added all relevant attributes to our `TaskAgent` class, which
    we need for an underlying specialized `OpenAIAgent` :'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将所有相关属性添加到我们的`TaskAgent`类中，这是我们需要为底层专用`OpenAIAgent`所做的：
- en: '`create_context` / `create_user_context`: Here we can pass a function to create
    the context or user context like in section 5.1'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_context` / `create_user_context`：在这里，我们可以传递一个函数来创建上下文或用户上下文，就像在第5.1节中一样。'
- en: '`tool_loader` is another callable function which we may need for setting up
    the underlying agent. As in our dynamic tool building previously explained, we
    may need tools that are dynamically built based on the user input/routing agent
    input.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tool_loader`是另一个可调用函数，我们可能需要它来设置底层代理。正如我们之前解释的动态工具构建，我们可能需要根据用户输入或路由代理输入动态构建的工具。'
- en: '`system_message` is the agent’s system prompt. In our example, it will be the
    default system prompt for every agent, but it can be an optimized version for
    each specialized agent.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system_message`是代理的系统提示。在我们的示例中，它将是每个代理的默认系统提示，但它也可以是每个专门代理的优化版本。'
- en: '`tools`: Predefined tools the agent should use.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tools`：代理应该使用的预定义工具。'
- en: '`examples`: Examples to include in subagent’s message history'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`examples`：包括在子代理消息历史中的示例。'
- en: '`routing_example`: Examples to include in routing agent’s message history'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`routing_example`：包括在路由代理消息历史中的示例。'
- en: Moreover, we have an emty BaseModel called `EmptyArgModel` which is default
    `arg_model` in our TaskAgent
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有一个空的BaseModel，叫做`EmptyArgModel`，它是我们`TaskAgent`中的默认`arg_model`。
- en: '![](../Images/296be241ea21139c029a09fa600081de.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/296be241ea21139c029a09fa600081de.png)'
- en: Created by the author [mermaid](https://mermaid.live/)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 作者创建：[mermaid](https://mermaid.live/)
- en: Let’s see if it all plays together!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是否都能协同工作！
- en: Run Agent
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行代理
- en: Now, it’s time to test if our routing and subagents work well together. As we
    introduced examples as a paremeter we can use several test runs to inspect major
    flaws in the execution and define example usage for each sub agent.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候测试我们的路由和子代理是否能够很好地协作。由于我们引入了作为参数的示例，我们可以通过多次测试运行来检查执行中的主要缺陷，并为每个子代理定义示例用法。
- en: 'Let’s define our subagents first:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们的子代理：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see we added some remarks as string to `create_user_context` for
    revenue and expense agents. We want the sub agent to handle tax rates and calculate
    the net or gross amount automatically to test the reasoning capabilites of our
    sub agent.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们为收入和支出代理添加了一些备注字符串到`create_user_context`。我们希望子代理能够处理税率，并自动计算净额或毛额，以测试我们的子代理的推理能力。
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let’s add a revenue:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一笔收入：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And for the last test let’s try to query the revenue that created from database:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后的测试，让我们尝试查询从数据库中创建的收入：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All tools worked as expected. The Routing Agent worked perfectly. For theTask
    Agent I had to update the prompt several times.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工具都按预期工作。路由代理运行得非常完美。对于任务代理，我不得不多次更新提示。
- en: I would recommend to add some example tool calls to each task agent when not
    working with state-of-the-art models like gpt-4\. In general I would recommend
    to tackle flaws with examples and more intuitive designs instead of prompt engineering.
    Reapting flaws are indicators for not straightforward designs. For example when
    the agent struggles with calculating the gross or net amount just add a ‘calculate_gross_amount_tool’
    or ‘calculate_net_amount_tool’. GPT-4 on the other hand would handle use cases
    like that without hestitating.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在没有使用像gpt-4这样的最新模型时，为每个任务代理添加一些示例工具调用。一般来说，我建议通过示例和更直观的设计来解决缺陷，而不是使用提示工程。重复出现的缺陷是设计不够直观的信号。例如，当代理在计算毛额或净额时遇到困难，只需添加一个‘calculate_gross_amount_tool’或‘calculate_net_amount_tool’。另一方面，GPT-4会毫不犹豫地处理这种用例。
- en: Conclusion
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this article, we’ve taken a significant step forward in our journey to create
    a comprehensive chat-based interface for managing small businesses using Large
    Language Models.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文中，我们在创建一个全面的基于聊天的界面以管理小型企业的过程中迈出了重要的一步，利用大型语言模型（Large Language Models）。
- en: By setting up our database schema, defining core functionalities, and structuring
    our project repository, we’ve laid a solid foundation for the development of our
    application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置我们的数据库模式、定义核心功能和构建项目仓库，我们为应用程序的开发奠定了坚实的基础。
- en: We started by designing our database models using SQLModel, which allowed us
    to seamlessly integrate with Pydantic and SQLAlchemy. This approach ensures efficient
    data validation and database operations while minimizing the risk of SQL injection
    attacks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从使用 SQLModel 设计数据库模型开始，这使我们能够无缝地与 Pydantic 和 SQLAlchemy 集成。该方法确保了高效的数据验证和数据库操作，同时最大限度地减少了
    SQL 注入攻击的风险。
- en: We then proceeded to update our `Tool` class to handle SQLModel instances and
    improve the validation process. Next, we implemented SQL tools for adding data
    to our database tables and querying data using natural language commands. By leveraging
    the power of SQLModel and Pydantic, we were able to create a robust and flexible
    system that can handle a wide range of user inputs and generate accurate SQL queries.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们更新了我们的 `Tool` 类，以处理 SQLModel 实例并改进验证过程。接着，我们实现了 SQL 工具，用于向我们的数据库表中添加数据，并使用自然语言命令查询数据。通过利用
    SQLModel 和 Pydantic 的力量，我们能够创建一个强大而灵活的系统，能够处理各种用户输入并生成准确的 SQL 查询。
- en: We configured our OpenAIAgent to provide context-aware tool usage by updating
    the agent class to handle variable context in the system prompt and user prompt.
    This allows our agent to understand the available tables and their schemas, enabling
    more accurate and efficient tool usage. While we’ve made significant progress,
    there’s still much more to explore and implement.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了 OpenAIAgent，以通过更新代理类来处理系统提示和用户提示中的可变上下文，从而提供上下文感知的工具使用。这使得我们的代理能够理解可用的表及其模式，从而实现更准确和高效的工具使用。虽然我们已经取得了显著进展，但仍有很多内容需要探索和实现。
- en: To further enhance our chatbot, we introduced the TaskAgent class, which serves
    a similar functionality as the Tool class. The TaskAgent allows us to define a
    name, description, and input model for each agent, automating the initialization
    process.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步增强我们的聊天机器人，我们引入了 TaskAgent 类，它具有类似 Tool 类的功能。TaskAgent 允许我们为每个代理定义名称、描述和输入模型，自动化初始化过程。
- en: Finally, we tested our routing and subagents by defining subagents for querying
    data, adding expenses, adding revenue. We demonstrated how the agents handle tax
    rates and calculate net or gross amounts automatically, showcasing the reasoning
    capabilities of our subagents.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过为查询数据、添加支出、增加收入定义子代理来测试我们的路由和子代理。我们展示了代理如何处理税率并自动计算净额或毛额，展示了我们子代理的推理能力。
- en: Next steps
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: In the next part of this series, we’ll focus on enhancing our agent’s capabilities
    by adding support for more tools and potentially testing Claude as a new default
    language model. We’ll also explore integrating our application with popular communication
    platforms (WhatsApp) to make it even more accessible and user-friendly.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本系列的下一部分，我们将重点通过添加对更多工具的支持，并可能将Claude测试作为新的默认语言模型，来增强我们代理的能力。我们还将探索将我们的应用程序与流行的通讯平台（如
    WhatsApp）集成，使其更加易于访问和用户友好。
- en: As we continue to refine and expand our application, the possibilities are endless.
    By leveraging the power of Large Language Models and creating intuitive chat-based
    interfaces, we can revolutionize the way small businesses manage their data and
    streamline their operations. Stay tuned for the next installment in this exciting
    series!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们不断完善和扩展应用程序，可能性是无穷无尽的。通过利用大语言模型的力量并创建直观的基于聊天的界面，我们可以彻底改变小型企业管理数据和简化操作的方式。敬请期待本系列的下一部分！
- en: Source Code
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码
- en: Additionally, the entire source code for the projects covered is available on
    GitHub. You can access it at [https://github.com/elokus/ArticleDemo2](https://github.com/elokus/ArticleDemo2)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有涉及的项目源代码都可以在 GitHub 上找到。您可以通过 [https://github.com/elokus/ArticleDemo2](https://github.com/elokus/ArticleDemo2)
    访问它。

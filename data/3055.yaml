- en: Creating a WhatsApp AI Agent with GPT-4o
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GPT-4o 创建 WhatsApp AI 助理
- en: 原文：[https://towardsdatascience.com/creating-a-whatsapp-ai-agent-with-gpt-4o-f0bc197d2ac0?source=collection_archive---------0-----------------------#2024-12-22](https://towardsdatascience.com/creating-a-whatsapp-ai-agent-with-gpt-4o-f0bc197d2ac0?source=collection_archive---------0-----------------------#2024-12-22)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/creating-a-whatsapp-ai-agent-with-gpt-4o-f0bc197d2ac0?source=collection_archive---------0-----------------------#2024-12-22](https://towardsdatascience.com/creating-a-whatsapp-ai-agent-with-gpt-4o-f0bc197d2ac0?source=collection_archive---------0-----------------------#2024-12-22)
- en: '![](../Images/0d1193bc8f30025fc5f60982397b5141.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0d1193bc8f30025fc5f60982397b5141.png)'
- en: Created with DALL-E
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DALL-E 创建
- en: How to use the Meta API to build your own LLM-powered Whatsapp chatbot
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用 Meta API 构建你自己的 LLM 驱动的 Whatsapp 聊天机器人
- en: '[](https://medium.com/@lukas.kowejsza?source=post_page---byline--f0bc197d2ac0--------------------------------)[![Lukasz
    Kowejsza](../Images/8d920478bee9ad674a6c79462128b0db.png)](https://medium.com/@lukas.kowejsza?source=post_page---byline--f0bc197d2ac0--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--f0bc197d2ac0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--f0bc197d2ac0--------------------------------)
    [Lukasz Kowejsza](https://medium.com/@lukas.kowejsza?source=post_page---byline--f0bc197d2ac0--------------------------------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@lukas.kowejsza?source=post_page---byline--f0bc197d2ac0--------------------------------)[![Lukasz
    Kowejsza](../Images/8d920478bee9ad674a6c79462128b0db.png)](https://medium.com/@lukas.kowejsza?source=post_page---byline--f0bc197d2ac0--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--f0bc197d2ac0--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--f0bc197d2ac0--------------------------------)
    [Lukasz Kowejsza](https://medium.com/@lukas.kowejsza?source=post_page---byline--f0bc197d2ac0--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--f0bc197d2ac0--------------------------------)
    ·18 min read·Dec 22, 2024
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布在 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--f0bc197d2ac0--------------------------------)
    ·18分钟阅读·2024年12月22日
- en: --
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: A game-changer in the field of AI and business management is the integration
    of AI agents with widely used communication tools. Think of having a familiar
    chat interface with real-time data requests, updates, and task automation, all
    made possible by direct WhatsApp interaction with your business’s management or
    personal assistant AI.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在人工智能和商业管理领域的一个颠覆性变化是将 AI 助理与广泛使用的通信工具整合。想象一下，借助 WhatsApp 与你业务管理或个人助手 AI 进行实时数据请求、更新和任务自动化，你将拥有一个熟悉的聊天界面，这一切都成为可能。
- en: In this third part of our series on creating an AI-powered business manager,
    I will walk you through the steps of connecting your AI agent to WhatsApp to increase
    its capabilities and reach. The goal to achieve is an AI Assistant capable of
    interacting with all your relevant database tables and even creating a table and
    all necessary tools on its own. As a primary showcase, I focus on a business use
    case like tracking expenses, invoices, and so on. However you can easily adapt
    the same logic to create, for example a Personal Assistant that keeps track of
    your tasks, projects, and ideas.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们关于创建 AI 驱动的商务经理系列的第三部分中，我将带你一步步了解如何将你的 AI 助理与 WhatsApp 连接，以提升其能力和触及范围。目标是实现一个能够与所有相关数据库表进行交互的
    AI 助手，甚至能够自主创建表格和所需工具。作为主要展示，我聚焦于一个商业用例，比如跟踪开支、发票等。不过，你可以轻松将相同的逻辑应用于创建个人助手，例如记录你的任务、项目和创意。
- en: This is the third part of my series. Before we start, for everyone waiting,
    I apologize for the long delay. I’ve been busy in the last few months starting
    a new AI Software Engineering job and adapting to the new work-life balance. I
    have prepared some future parts of this article so far, and we will explore major
    changes in the agent workflow, along with more sophisticated workflows featuring
    several additional features. Some workarounds used in the first two articles were
    necessary for reliable tool calling at that time but are no longer needed due
    to better-performing models like GPT-4o and GPT-4o-mini. I would still recommend
    starting with the first two parts if you are new to tool calling and agent workflow
    development. I find it useful to understand how to build something from scratch
    before relying on frameworks like LangChain or, more specifically, LangGraph for
    deeply customizable Agent Workflows (which I will introduce in the near future).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的系列文章的第三部分。在我们开始之前，首先向大家等待的读者道歉，因为我耽搁了一段时间。过去几个月我一直忙于开始一份新的 AI 软件工程工作，并适应新的工作与生活平衡。我已经为这篇文章准备了未来的几个部分，我们将探讨代理工作流中的重大变化，并展示一些更复杂的工作流，涉及多个附加功能。在前两篇文章中使用的一些变通方法对于当时可靠的工具调用是必要的，但由于像
    GPT-4o 和 GPT-4o-mini 这样的高性能模型，现在已经不再需要这些方法了。如果你是工具调用和代理工作流开发的新手，我仍然建议从前两部分开始学习。我发现了解如何从零开始构建东西，比依赖像
    LangChain 或更具体的 LangGraph 这样的框架（用于深度定制的代理工作流，我将在不久的将来介绍）更为有用。
- en: For now, we have to step back and focus on the infrastructure first. I think
    in most projects, especially in AI Software Projects, it is good practice to initially
    create a working end-to-end product before getting lost in feature creep. I often
    find myself overthinking initial design choices and developing a too-complex product
    in my mind. To overcome this, focusing on building a working end-to-end product
    within a few days of development time really helps to establish a clear foundation.
    After that, you will know which features to prioritize and will be able to gather
    initial feedback. This kickstarts an incremental development process, which is
    always my goal when I commit to a project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们需要先退一步，集中精力关注基础设施。我认为在大多数项目中，尤其是 AI 软件项目中，最好先创建一个可行的端到端产品，然后再避免陷入功能膨胀。我常常发现自己在初期设计选择上过于思考，从而在脑海中构建出过于复杂的产品。为了克服这一点，在几天的开发时间内专注于构建一个可行的端到端产品，真的有助于奠定清晰的基础。之后，你就能知道哪些功能需要优先考虑，并能够收集初步反馈。这将启动一个增量开发过程，这也是我承接项目时的目标。
- en: Recap of Previous Parts
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前文回顾
- en: 'We established the foundation for our AI-powered business manager in earlier
    installments of this series:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本系列的早期章节中，我们为我们的 AI 驱动的业务经理奠定了基础：
- en: '[**Part 1**](/leverage-openai-tool-calling-building-a-reliable-ai-agent-from-scratch-4e21fcd15b62):
    The goal was to develop a prototype agent workflow that could interact with tool
    objects and reduce hallucinations in tool arguments produced by the underlying
    language model (LLM).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**第一部分**](/leverage-openai-tool-calling-building-a-reliable-ai-agent-from-scratch-4e21fcd15b62)：目标是开发一个原型代理工作流，使其能够与工具对象互动，并减少由底层语言模型（LLM）产生的工具参数中的幻觉。'
- en: '[**Part 2**](/building-an-ai-powered-business-manager-e2a31a2fe984): We concentrated
    on defining basic features, organizing the project repository, and building a
    database schema with SQLModel. We also added SQL tools for data addition and querying
    and updated the Tool class to accommodate SQLModel objects. Furthermore, we presented
    a TaskAgent class for automating agent startup and set up an OpenAIAgent for context-aware
    tool usage.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[**第二部分**](/building-an-ai-powered-business-manager-e2a31a2fe984)：我们集中精力定义基本功能，组织项目存储库，并使用
    SQLModel 构建数据库模式。我们还为数据添加和查询添加了 SQL 工具，并更新了 Tool 类以容纳 SQLModel 对象。此外，我们介绍了 TaskAgent
    类，用于自动化代理启动，并设置了 OpenAIAgent 以实现上下文感知的工具使用。'
- en: Scope for This Article
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本文范围
- en: 'As usual, let us begin by defining the scope of this article:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，让我们首先定义本文的范围：
- en: '**Integrate the AI Agent with WhatsApp Using MetaAPI** Set up and configure
    MetaAPI for WhatsApp Business integration.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通过 MetaAPI 将 AI 代理与 WhatsApp 集成** 设置并配置 MetaAPI，以实现 WhatsApp 商业集成。'
- en: Ensure the AI agent can send and receive messages through WhatsApp.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保 AI 代理可以通过 WhatsApp 发送和接收消息。
- en: '**Set Up Webhooks and Run Locally Using Ngrok** Create a FastAPI application
    to handle webhook events from WhatsApp.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置 Webhooks 并使用 Ngrok 本地运行** 创建一个 FastAPI 应用程序以处理来自 WhatsApp 的 webhook 事件。'
- en: Use ngrok to expose the local FastAPI server to the internet.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 ngrok 将本地 FastAPI 服务器暴露到互联网。
- en: Configure MetaAPI to send webhook events to the ngrok URL
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配置 MetaAPI 以将 webhook 事件发送到 ngrok URL
- en: Since we are moving forward to a deployable server, we also need to adjust our
    project architecture. We are essentially implementing a FastAPI server, and therefore,
    my preferred choice of repository structure is Domain-Driven Design (DDD) or rather
    leaning towards DDD. (You can check the Repo structure [here](https://github.com/elokus/WhatsappAgent))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在前进到可部署的服务器，我们还需要调整我们的项目架构。我们基本上是在实现一个 FastAPI 服务器，因此，我偏好的仓库结构是领域驱动设计（DDD），或者更倾向于
    DDD。（你可以在 [这里](https://github.com/elokus/WhatsappAgent) 查看仓库结构）
- en: 1\. Set up WhatsApp Cloud API
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 设置 WhatsApp 云 API
- en: First of all, you need to get familiar with the Cloud API provided by Meta.
    You can achieve the same results using SaaS products like Twilio, which offer
    a more user-friendly integration. However, due to the recent data breach and for
    cost-efficiency reasons, I prefer using the root API provided by Meta.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要熟悉 Meta 提供的云 API。你也可以使用像 Twilio 这样的 SaaS 产品来实现相同的功能，这些产品提供了更友好的集成方式。然而，由于最近的数据泄露事件以及成本效率的考虑，我更倾向于使用
    Meta 提供的根 API。
- en: 1.1 Prerequisites
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.1 前提条件
- en: 'Before you begin, you will need to register a Meta developer account by following
    these steps: [How to open a Meta developer account](https://developers.facebook.com/docs/development/register).
    During this registration process, you will need to verify yourself using a phone
    number. Note that this will not be the phone number of your final WhatsApp client.
    Instead, you will get a test phone number assigned by the platform, which can
    later be changed to another phone number.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，你需要通过以下步骤注册一个 Meta 开发者账户：[如何开设 Meta 开发者账户](https://developers.facebook.com/docs/development/register)。在注册过程中，你需要使用电话号码进行身份验证。请注意，这个电话号码不会是你最终
    WhatsApp 客户端的号码。相反，你会获得一个由平台分配的测试电话号码，稍后可以更改为另一个电话号码。
- en: After registration, go to your dashboard and create an app.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册后，转到你的仪表板并创建一个应用。
- en: Moreover, you will need a Meta Business Account (MBA) that will be associated
    with your real account, or you can create a new one to link to your MBA. You can
    also skip this, as you will be automatically prompted to link or create an MBA
    in the next step.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，你还需要一个 Meta 商业账户（MBA），该账户将与你的真实账户关联，或者你可以创建一个新的账户来关联到你的 MBA。你也可以跳过这一步，因为你将在下一步中自动被提示关联或创建
    MBA。
- en: 1.2 Add WhatsApp Product to Your App
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.2 将 WhatsApp 产品添加到你的应用程序
- en: After you have created an app inside your Meta developer account, you will be
    asked to add products to it. Here you have to choose WhatsApp and follow the setup
    process. If you haven’t done so, create a Meta Business Account here. Once you
    are done, you will have a test WhatsApp Business Account and a test phone number.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了一个 Meta 开发者账户中的应用后，你将被要求为其添加产品。在这里，你需要选择 WhatsApp 并按照设置流程进行。如果你还没有这样做，可以在这里创建一个
    Meta 商业账户。完成后，你将拥有一个测试的 WhatsApp 商业账户和一个测试的电话号码。
- en: 1.3 Add a Recipient Number
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1.3 添加接收号码
- en: In the left-hand menu of the App Dashboard, navigate to
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用仪表板的左侧菜单中，导航到
- en: '**WhatsApp** > **API Setup**'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**WhatsApp** > **API 设置**'
- en: There under **Send and receive messages**, select the **To** field and choose
    **Manage phone number list**. Here, you can add a phone number that is allowed
    to send and receive messages from your test phone number. This should ideally
    be your own phone number as you want to test your application. Before you link
    this WhatsApp API Account to a real number, you will only be able to add up to
    5 recipient numbers.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 **发送和接收消息** 下，选择 **To** 字段并选择 **管理电话号码列表**。在这里，你可以添加一个允许从你的测试电话号码发送和接收消息的电话号码。理想情况下，这应该是你自己的电话号码，因为你想要测试你的应用。在将这个
    WhatsApp API 账户与一个真实号码绑定之前，你最多只能添加 5 个接收号码。
- en: In `WhatsApp > API Setup`, you can now send a test message by filling in the
    `from` field with your test phone number and the `to` field with your recipient
    number (your own phone number).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `WhatsApp > API 设置` 中，你现在可以通过填写 `from` 字段为你的测试电话号码，`to` 字段为你的接收号码（你自己的电话号码）来发送一条测试消息。
- en: Generate an access token. This is your `WHATSAPP_API_TOKEN`, which we will need
    later in step 6.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个访问令牌。这是你的 `WHATSAPP_API_TOKEN`，我们将在第 6 步中使用它。
- en: '![](../Images/6790dd7e097200fd38c229e5372fc718.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/6790dd7e097200fd38c229e5372fc718.png)'
- en: Screenshot ngrok (Image by Author)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 截图 ngrok（图片来自作者）
- en: We have successfully set up the Cloud API as required. In the next step we will
    create a Webhook that will enable communication with our AI Assistant application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功设置云 API，如要求所示。下一步，我们将创建一个 Webhook，使其能够与我们的 AI 助理应用进行通信。
- en: To achieve this, we need to create and serve an endpoint in our backend application.
    This means our Python backend must be accessible through a URL. This URL will
    act as the Webhook endpoint that the AI Assistant can call to send and receive
    data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要在我们的后端应用程序中创建并提供一个端点。这意味着我们的 Python 后端必须通过 URL 访问。这个 URL 将作为 Webhook
    端点，AI 助手可以调用它来发送和接收数据。
- en: 2\. Creating a FastAPI Endpoint
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 创建一个 FastAPI 端点
- en: 'To be accepted by the Webhook, our root endpoint must verify a specific GET
    request that will be sent by the webhook when adding our URL. The webhook will
    send three query parameters:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了被 Webhook 接受，我们的根端点必须验证 Webhook 在添加我们的 URL 时发送的特定 GET 请求。Webhook 将发送三个查询参数：
- en: '`hub.mode`, `hub.challenge`, `hub.verify.token`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`hub.mode`、`hub.challenge`、`hub.verify.token`。'
- en: The verification token is defined when creating the webhook in Cloud API. Your
    backend should verify that this token matches what you have defined and return
    the `hub.challenge` object as a response. Make sure to install FastAPI and Uvicorn
    using `pip install fastapi uvicorn` first.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 验证令牌在创建 Cloud API 的 Webhook 时定义。你的后端应该验证该令牌与定义的值是否匹配，并返回 `hub.challenge` 对象作为响应。首先确保通过
    `pip install fastapi uvicorn` 安装 FastAPI 和 Uvicorn。
- en: 2.1 Create main.py
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 创建 main.py
- en: 'Create a file named `main.py` with the following content:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.py` 的文件，内容如下：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the third line, you can define a `VERIFICATION_TOKEN` that is used later
    by the webhook to verify that the backend is under your control. In this case,
    we have defined it as `"abcdefg12345"`, but you can define a custom token of your
    own.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，你可以定义一个 `VERIFICATION_TOKEN`，Webhook 后续会使用该令牌验证后端是否由你控制。在此案例中，我们将其定义为 `"abcdefg12345"`，但你可以定义自己的自定义令牌。
- en: I’ll continue correcting the remaining sections and include the next part shortly!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我会继续修改剩余的部分，并很快包括下一部分内容！
- en: 2.2 Run the Application
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 运行应用程序
- en: 'Run the application using Uvicorn:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Uvicorn 运行应用程序：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 2.3 Serve Your API Locally
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 本地提供你的 API
- en: Your backend now runs locally on `http://localhost:8000` and/or `http://127.0.0.1:8000`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的后端已在 `http://localhost:8000` 和/或 `http://127.0.0.1:8000` 本地运行。
- en: 'We are now serving the following endpoints:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在提供以下端点：
- en: 'Verify WhatsApp webhook: `[http://127.0.0.1:8000/?hub.mode=subscribe&hub.challenge=1234&hub.verify_token=abcdefg12345](http://127.0.0.1:8000/?hub.mode=subscribe&hub.challenge=1234&hub.verify_token=abcdefg12345)`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证 WhatsApp Webhook：`[http://127.0.0.1:8000/?hub.mode=subscribe&hub.challenge=1234&hub.verify_token=abcdefg12345](http://127.0.0.1:8000/?hub.mode=subscribe&hub.challenge=1234&hub.verify_token=abcdefg12345)`
- en: 'Health endpoint: `[http://127.0.0.1:8000/health](http://127.0.0.1:8000/health)`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康检查端点：`[http://127.0.0.1:8000/health](http://127.0.0.1:8000/health)`
- en: 'Readiness endpoint: `[http://127.0.0.1:8000/readiness](http://127.0.0.1:8000/readiness)`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备就绪端点：`[http://127.0.0.1:8000/readiness](http://127.0.0.1:8000/readiness)`
- en: 'You can use the health endpoint to check if your application is running. Open
    `http://127.0.0.1:8000/health` in your browser, and you should see: `{"status":
    "healthy"}`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '你可以使用健康检查端点来检查应用程序是否正在运行。在浏览器中打开 `http://127.0.0.1:8000/health`，你应该会看到：`{"status":
    "healthy"}`'
- en: 3\. Run a Proxy Server with Ngrok
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 使用 Ngrok 运行代理服务器
- en: 'Since our server is running locally, the WhatsApp Webhook cannot call the endpoint
    for verification. What we need is a public URL that can be used by the webhook.
    There are two options: deploy the application to a cloud server or create a proxy
    server tunnel. Since we are still in the development process, we will use the
    second option.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的服务器在本地运行，WhatsApp Webhook 无法调用该端点进行验证。我们需要的是一个可以被 Webhook 使用的公共 URL。有两个选择：将应用程序部署到云服务器，或创建一个代理服务器隧道。由于我们仍处于开发过程中，我们将使用第二个选项。
- en: Go to [ngrok Signup](https://dashboard.ngrok.com/signup) and create a free account.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [ngrok 注册](https://dashboard.ngrok.com/signup) 并创建一个免费帐户。
- en: 'Install ngrok locally. Depending on your system, you can use Brew, Chocolatey,
    or simply download and install it. See: [Setup & Installation](https://dashboard.ngrok.com/get-started/setup).'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地安装 ngrok。根据你的系统，你可以使用 Brew、Chocolatey 或直接下载并安装。参见：[设置与安装](https://dashboard.ngrok.com/get-started/setup)。
- en: After installation, add your authentication code using the following command
    in your terminal. Replace `$YOUR-AUTHENTICATION_TOKEN` with your ngrok authentication
    token, which can be found under "Your Authtoken" in the ngrok dashboard.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，在终端使用以下命令添加你的认证代码。将 `$YOUR-AUTHENTICATION_TOKEN` 替换为你的 ngrok 认证令牌，该令牌可以在
    ngrok 仪表板中的“Your Authtoken”下找到。
- en: 'Begin forwarding traffic from your localhost on port 8000 by running the following
    command in your terminal:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端运行以下命令，开始从本地主机的 8000 端口转发流量：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your local server is now accessible via public URLs provided by ngrok. You
    should see something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你的本地服务器现在可以通过 ngrok 提供的公共 URL 访问。你应该能看到类似这样的信息：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Use the HTTPS URL provided by ngrok for the webhook configuration.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ngrok 提供的 HTTPS URL 配置 webhook。
- en: 4\. Implementing the Webhook
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 实现 Webhook
- en: Now let us return to Meta’s Cloud API to implement the desired webhook.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到 Meta 的 Cloud API，实施所需的 webhook。
- en: Navigate to [Meta for Developers](https://developers.facebook.com/apps/) and
    select the app created before.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [Meta for Developers](https://developers.facebook.com/apps/) 并选择之前创建的应用。
- en: In the left-hand menu go to **WhatsApp** > **Configuration**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，点击 **WhatsApp** > **配置**。
- en: In the **Webhook** section paste your ngrok HTTPS forwarding URL into the **Callback
    URL** field and enter the `VERIFICATION_TOKEN` defined in `main.py` into the **Verification
    Token** field.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Webhook** 部分，将你的 ngrok HTTPS 转发 URL 粘贴到 **回调 URL** 字段中，并在 **验证令牌** 字段中输入在
    `main.py` 中定义的 `VERIFICATION_TOKEN`。
- en: Click the confirm and save button and wait for the webhook to verify your backend.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击确认并保存按钮，等待 webhook 验证你的后端。
- en: In the section **Webhook Fields** enable the `messages` toggle under **Subscribed
    Fields**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Webhook 字段** 部分，启用 **已订阅字段** 下的 `messages` 开关。
- en: That’s it! You should now be able to receive WhatsApp messages in your Python
    backend server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在你应该能够在 Python 后端服务器中接收 WhatsApp 消息。
- en: 4.1 Understanding Webhooks and Conversations
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 理解 Webhook 和会话
- en: Webhooks are HTTP callbacks that enable programs to receive real-time updates
    when certain events occur such as a new message or a status change. Webhooks make
    system integrations and automation possible by delivering an HTTP request containing
    event data to a pre-configured URL (in our case the ngrok proxy server url).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 是 HTTP 回调，它使得程序能够在特定事件发生时（例如新消息或状态更改）接收实时更新。Webhook 通过将包含事件数据的 HTTP
    请求发送到预配置的 URL（在我们这个案例中是 ngrok 代理服务器 URL）来实现系统集成和自动化。
- en: To understand the logic and pricing behind webhooks in the Meta cosmos it is
    helpful to understand some basic principles about conversations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Meta 生态系统中 webhook 的逻辑和定价，了解一些关于会话的基本原则是很有帮助的。
- en: 'A ‘conversation’ on WhatsApp API starts when:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WhatsApp API 中，“会话”开始于以下情况：
- en: '**1\. The User sends a message**: This opens a 24-hour window, during which
    you can reply with messages including text, images, or other media **without additional
    costs**.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**1. 用户发送消息：** 这会打开一个 24 小时的窗口，在此期间，你可以通过文本、图片或其他媒体消息进行回复，**无需额外费用**。'
- en: '**2\. The Business Initiates Contact**: If no user message has been received
    recently (no open 24-hour window), your AI assistant must use a **pre-approved
    template message** to start the conversation. You can add custom templates but
    they need to be approved by Meta.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**2. 企业发起联系：** 如果最近没有收到用户消息（即没有打开 24 小时窗口），你的 AI 助手必须使用 **预先批准的模板消息** 来开始会话。你可以添加自定义模板，但它们需要经过
    Meta 批准。'
- en: 'As long as the user keeps replying, the 24-hour window resets with each new
    message. This makes it possible to have continuous interaction without additional
    costs. A Conversation costs about 0.00–0.08 USD. The concrete pricing is based
    on you conversation type Marketing, Utility, Service and your location. FYI: Service
    Conversations seem to be nowadays for free. You can find the concrete pricing
    here: [Whatsapp Pricing](https://developers.facebook.com/docs/whatsapp/pricing)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 只要用户持续回复，每当收到新消息时，24 小时窗口会重新计时。这使得可以在没有额外费用的情况下进行持续互动。一场会话的费用大约为 0.00–0.08 美元。具体定价依据你的会话类型（如营销、公共服务、服务）以及你所在的位置而定。仅供参考：目前服务类会话似乎是免费的。你可以在这里找到具体的定价：[Whatsapp
    定价](https://developers.facebook.com/docs/whatsapp/pricing)
- en: 5\. Build a Receive Message Endpoint
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 构建接收消息端点
- en: Now we are able to receive messages in our backend. Since we have subscribed
    to message objects, each time a message is sent to your test number, the webhook
    will create a POST request to the callback URL that you defined in the previous
    step. What we need to do next is to build an endpoint for POST requests in our
    FastAPI application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经能够在后端接收消息。由于我们已经订阅了消息对象，每当有消息发送到你的测试号码时，webhook 会创建一个 POST 请求，发送到你在上一步中定义的回调
    URL。接下来我们需要做的是在 FastAPI 应用中为 POST 请求构建一个端点。
- en: 'Let us first define the requirements:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义需求：
- en: '**Return a 200 HTTP Status Code:** This is essential to inform CloudAPI that
    the message has been received successfully. Failing to do so will cause CloudAPI
    to retry sending the message for up to 7 days.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回 200 HTTP 状态码：** 这是告知 CloudAPI 消息已成功接收的关键。如果未返回状态码，CloudAPI 会尝试重新发送消息，最长可达
    7 天。'
- en: '**Extract Phone Number and Message:** The payload of the incoming request contains
    data that includes the phone number and the message. Which we need to process
    in the backend.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提取电话号码和消息：** 来自请求的有效载荷包含包括电话号码和消息的数据。我们需要在后端对其进行处理。'
- en: '**Filter Incoming Objects:** Since CloudAPI might send multiple events for
    the same message (such as sent, received, and read), the backend needs to ensures
    that only one instance of the message is processed.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤传入的对象：** 由于CloudAPI可能会为同一消息发送多个事件（例如发送、接收和阅读），后端需要确保只处理一条消息的实例。'
- en: '**Handle Multiple Message Types:** The backend can handle different types of
    messages, such as text, voice messages, and images. In order to not spread the
    scope of the artice we will only lay the foundation for images but not implement
    it to the end.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理多种消息类型：** 后端可以处理不同类型的消息，例如文本、语音消息和图像。为了避免扩展文章的范围，我们只会为图像奠定基础，但不会实现到最后。'
- en: '**Process with LLM-Agent Workflow:** The extracted information is processed
    using the LLM-Agent workflow, which we have developed with previous parts of this
    series. You can also use another agentic implementation, e.g. Langchain or Langgraph'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过LLM-Agent工作流处理：** 提取的信息通过LLM-Agent工作流进行处理，我们在系列的前几个部分中开发了这个工作流。你也可以使用其他代理实现，比如Langchain或Langgraph。'
- en: 5.1 Define Models and Schemas
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 定义模型和模式
- en: 'We will receive a payload from a webhook. You can find example payloads in
    Meta’s documentation: [Example Payload](https://developers.facebook.com/docs/whatsapp/cloud-api/webhooks/payload-examples/)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Webhook接收有效载荷。你可以在Meta的文档中找到示例有效载荷：[示例有效载荷](https://developers.facebook.com/docs/whatsapp/cloud-api/webhooks/payload-examples/)
- en: 'I prefer to write my code with Pydantic to add type safety to my Python code.
    Moreover, type annotations and Pydantic are an optimal match for FastAPI applications.
    So, let’s first define the models used in our endpoint:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用Pydantic来编写代码，以为我的Python代码添加类型安全性。此外，类型注解和Pydantic是FastAPI应用的最佳搭配。因此，让我们首先定义在端点中使用的模型：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 5.2 Parse Incoming Messages
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 解析传入的消息
- en: 'Next, we are going to create some helper functions for using dependency injection
    in FastAPI:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些辅助函数，用于在FastAPI中使用依赖注入：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Parsing the Payload:** The `parse_message` function extracts the first message
    from the incoming payload if it exists. This function returns `None` if no messages
    are found, so that only valid messages are processed.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析有效载荷：** `parse_message`函数从传入的有效载荷中提取第一条消息（如果存在）。如果没有找到消息，该函数返回`None`，这样只有有效消息才会被处理。'
- en: '**User Authentication:** The `get_current_user` function uses the `parse_message`
    dependency injection to extract the message and then authenticates the user based
    on the phone number associated with the message. Here we ensure that only authenticated
    users are allowed to send messages.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户身份验证：** `get_current_user`函数使用`parse_message`依赖注入提取消息，然后根据与消息相关联的电话号码进行身份验证。在这里，我们确保只有经过身份验证的用户才能发送消息。'
- en: '**Audio and Image Parsing:** These functions extract audio or image files from
    the message if the message type is “audio” or “image,” respectively. This allows
    the application to handle different types of media.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频和图像解析：** 如果消息类型分别为“音频”或“图像”，这些功能会从消息中提取音频或图像文件。这使得应用能够处理不同类型的媒体。'
- en: '**Message Extraction:** The `message_extractor` function attempts to extract
    text from the message or transcribe audio into text. This ensures that regardless
    of the message type, the content can be processed.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息提取：** `message_extractor`函数尝试从消息中提取文本或将音频转录为文本。这确保无论消息类型如何，内容都能被处理。'
- en: Here we have one import from our domain layer. The whole script `message_service`
    is where we place all domain-specific code for this implementation, such as `authenticate_user_by_phone_number`
    and `transcribe_audio`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个来自领域层的导入。整个脚本`message_service`是我们放置所有特定于领域的代码的地方，比如`authenticate_user_by_phone_number`和`transcribe_audio`。
- en: 5.3 Implementing the POST Endpoint
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 实现POST端点
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**POST Endpoint Implementation:** This endpoint handles the incoming POST request.
    It checks if the user, message, or image is valid. If none are valid, it simply
    returns a status message to CloudAPI. If the user is not authenticated, it raises
    an `HTTPException` with a 401 status code.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST端点实现：** 该端点处理传入的POST请求。它检查用户、消息或图像是否有效。如果没有有效项，它将仅返回一个状态消息给CloudAPI。如果用户未经过身份验证，它将引发一个`HTTPException`，并返回401状态码。'
- en: '**Processing Images and Messages:** If an image is received, we make a simple
    stdout print as a placeholder for future image handling. If a text message is
    received, it is processed asynchronously using a separate thread to avoid blocking
    the main application thread. The `message_service.respond_and_send_message` function
    is invoked to handle the message according to the LLM-Agent workflow.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理图像和消息：** 如果收到图像，我们会简单地打印到标准输出，作为未来图像处理的占位符。如果收到文本消息，它会异步处理，使用单独的线程以避免阻塞主应用程序线程。`message_service.respond_and_send_message`
    函数会根据 LLM-Agent 工作流程来处理消息。'
- en: '**Explanation for Using Thread Pooling for the Webhook:** WhatsApp will resend
    the webhook until it gets a 200 response, so thread pooling is used to ensure
    that message handling doesn’t block the webhook response.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用线程池处理 Webhook 的解释：** WhatsApp 会一直重发 Webhook，直到收到 200 响应，因此使用线程池来确保消息处理不会阻塞
    Webhook 响应。'
- en: 6 Message Services
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 消息服务
- en: In our presentation layer where we previously defined our endpoint, we use some
    `message_service` functions that need to be defined next. Specifically, we need
    an implementation for processing and transcribing audio payloads, authenticating
    users, and finally invoking our agent and sending a response back. We will place
    all this functionality inside `domain/message_service.py`. In production settings,
    as your application grows, I would recommend splitting them further down into,
    e.g., `transcription_service.py`, `message_service.py`, and `authentication_service.py`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前定义了端点的展示层，我们使用了一些 `message_service` 函数，这些函数需要在接下来定义。具体来说，我们需要实现音频负载的处理和转录、用户身份验证，最后调用我们的代理并发送响应回去。我们将把所有这些功能放入
    `domain/message_service.py` 文件中。在生产环境中，随着应用程序的扩展，我建议进一步将它们拆分成，比如，`transcription_service.py`、`message_service.py`
    和 `authentication_service.py`。
- en: In multiple functions in this section, we will make requests to the Meta API
    `"https://graph.facebook.com/..."`. In all of these requests, we need to include
    authorization headers with `WHATSAPP_API_KEY`, which we created in **step 1.3**,
    as the bearer token. I usually store API keys and tokens in an `.env` file and
    access them with the Python `dotenv` library. We also use the OpenAI client with
    your `OPENAI_API_KEY`, which could also be stored in the `.env` file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中的多个函数中，我们将向 Meta API 发出请求 `"https://graph.facebook.com/..."`。在所有这些请求中，我们需要包含带有
    `WHATSAPP_API_KEY`（我们在 **第 1.3 步** 中创建的）作为 Bearer Token 的授权头。我通常将 API 密钥和令牌存储在
    `.env` 文件中，并使用 Python `dotenv` 库来访问它们。我们还会使用带有 `OPENAI_API_KEY` 的 OpenAI 客户端，该密钥也可以存储在
    `.env` 文件中。
- en: 'But for simplicity, let’s just place and initialize them at the top of `message_service.py`
    scripts as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但为了简便起见，我们可以将它们放置并初始化在 `message_service.py` 脚本的顶部，如下所示：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Replace “YOUR_ACCESS_TOKEN” with your actual access token that you created in
    step 1.3.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将“YOUR_ACCESS_TOKEN”替换为您在第 1.3 步中创建的实际访问令牌。
- en: 6.1 Processing and Transcribing Audio Files
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.1 处理和转录音频文件
- en: Handling voice records from a WhatsApp webhook is not as straightforward as
    it may seem. First of all, it is important to know that the incoming webhook only
    tells us the data type and an object ID. So it does not contain the binary audio
    file. We first have to download the audio file using Meta’s Graph API. To download
    our received audio, we need to make two sequential requests. The first one is
    a GET request with the `object_id` to obtain the download URL. This download URL
    is the target of our second GET request.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 处理来自 WhatsApp Webhook 的语音记录并不像看起来那么简单。首先，重要的是要知道，传入的 Webhook 只告诉我们数据类型和对象 ID，因此它不包含二进制音频文件。我们首先需要使用
    Meta 的 Graph API 下载音频文件。为了下载我们接收到的音频，我们需要发出两个顺序请求。第一个是带有 `object_id` 的 GET 请求，用于获取下载
    URL。这个下载 URL 是我们第二个 GET 请求的目标。
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we basically get the download URL and download the file to the file system
    using the object ID and the file extension as its `file_path`. If something fails,
    we raise a `ValueError` that indicates where the error occurred.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们基本上是通过对象 ID 获取下载 URL，并使用文件扩展名作为 `file_path` 将文件下载到文件系统。如果发生错误，我们会引发一个
    `ValueError`，指示错误发生的位置。
- en: 'Next, we simply define a function that takes the audio binary and transcribes
    it using Whisper:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简单地定义一个函数，该函数接受音频二进制数据并使用 Whisper 进行转录：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, let’s bring the download and transcription functions together:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将下载和转录功能结合起来：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 6.2 Authenticate Users
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.2 用户身份验证
- en: While using the test number provided by Meta, we have to predefine which numbers
    our chatbot can send messages to. I am not quite sure and have not tested if any
    number can send a message to our chatbot. But anyway, as soon as we switch to
    a custom number, we don’t want anyone to be able to execute our agent chatbot.
    So we need a method to authenticate the user. We have several options to do this.
    First of all, we have to think of where to store user information. We could use,
    for example, a database like PostgreSQL or a non-relational database like Firestore.
    We can predefine our users in the file system in a JSON file or in an `.env` file.
    For this tutorial, I will go with the simplest way and hardcode the user within
    a list in our authentication function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Meta提供的测试号码时，我们必须预定义哪些号码可以向我们的聊天机器人发送消息。我不太确定，也没有测试过是否任何号码都可以向我们的聊天机器人发送消息。但无论如何，一旦我们切换到自定义号码，我们不希望任何人能够执行我们的代理聊天机器人。所以我们需要一种方法来验证用户身份。我们有几种方法可以做到这一点。首先，我们必须考虑将用户信息存储在哪里。我们可以使用例如PostgreSQL这样的数据库，或者像Firestore这样的非关系型数据库。我们可以在文件系统中通过JSON文件或`.env`文件来预定义我们的用户。对于本教程，我将选择最简单的方式，将用户硬编码在我们的身份验证函数中的一个列表里。
- en: A list entry has the structure of the `User` model as defined in **step 5.1**.
    So a user consists of an ID, first name, last name, and phone number. We have
    not implemented a role system in our agent workflow yet. But in most use cases
    with different users, such as in the example case of a small business assistant,
    different users will have different rights and access scopes. For now, we just
    pass `"default"` as a placeholder role.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项具有与**步骤 5.1**中定义的`User`模型相同的结构。因此，用户由ID、名、姓和电话号码组成。我们尚未在我们的代理工作流中实现角色系统。但是在大多数不同用户的使用场景中，例如小型商业助理的示例中，不同的用户将拥有不同的权限和访问范围。目前，我们仅将`"default"`作为占位符角色传递。
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So just verify if the phone number is in our list of `allowed_users` and return
    the user if it is. Otherwise, we return `None`. If you look at our endpoint in
    **step 5.3**, you will see we raise an error if the user is `None` to prevent
    further processing of unauthorized user messages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，只需验证电话号码是否在我们的`allowed_users`列表中，如果在，则返回该用户。否则，返回`None`。如果你查看**步骤 5.3**中的端点，你会看到如果用户是`None`，我们会抛出一个错误，以防止进一步处理未授权用户的消息。
- en: 6.3 Send Message
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.3 发送消息
- en: Now, our last helper function before we can actually invoke our agent is `send_whatsapp_message`.
    I have included two modes into this function because of some Meta-specific WhatsApp
    API logic.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们实际调用代理之前，最后一个辅助函数是`send_whatsapp_message`。我在这个函数中加入了两种模式，因为某些Meta特定的WhatsApp
    API逻辑。
- en: Basically, you are not allowed to send a custom message to a user as a conversation
    starter. This means you can respond with an individual text message if the user
    starts the conversation and writes a message to the chatbot first. Otherwise,
    if you want the chatbot to initiate a conversation, you are limited to approved
    templates, like the “Hello World” template.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，你不允许向用户发送自定义消息作为对话的开始。这意味着，如果用户首先启动对话并向聊天机器人发送消息，你可以回复一条单独的文本消息。否则，如果你希望聊天机器人启动对话，你只能使用已批准的模板，如“Hello
    World”模板。
- en: Also important to mention, when we talk about Meta logic, a conversation after
    being started opens a conversation window of 24 hours in which you can send messages
    to that user. This conversation window is also what gets charged, not the individual
    message. It gets a bit more complex based on the type of conversation, such as
    marketing, support, etc.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要提到的是，当我们谈论Meta逻辑时，开始后的对话会打开一个24小时的对话窗口，在此窗口内你可以向该用户发送消息。这个对话窗口是收费的，而不是单独的消息。根据对话的类型（如营销、支持等），这个过程会变得稍微复杂一些。
- en: You can also define a template on your own and let it be approved by Meta. I
    have not done that at this point, so to test if we can send a message from our
    backend to a user, I use the “Hello World” template. If you add some custom approved
    templates, you can also use this function to send them to the user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以自己定义一个模板并让Meta批准。在这一点上我还没有做，所以为了测试我们是否可以从后端向用户发送消息，我使用了“Hello World”模板。如果你添加了一些自定义的已批准模板，你也可以使用此功能将它们发送给用户。
- en: 'So back to the code. To send a message, we make a POST request and define a
    payload that either includes the text body or the template:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码部分。为了发送消息，我们发起一个POST请求并定义一个有效载荷，该载荷可以包括文本内容或模板：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 6.4 Invoke Our Agent
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6.4 调用我们的代理
- en: Finally, we can integrate our agent from our previous examples. At this stage,
    you can also integrate your custom agent, a Langchain `AgentExecutor`, Langgraph
    `AgentWorkflow`, etc.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将我们之前的示例中的代理集成。在此阶段，您还可以集成您的自定义代理、Langchain `AgentExecutor`、Langgraph
    `AgentWorkflow`等。
- en: So our main function that will be called on each incoming message is `respond_and_send_message`,
    which takes the `user_message` string and passes it to our agent workflow as the
    input object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的主要函数 `respond_and_send_message` 将在每个传入消息上被调用，它接受 `user_message` 字符串并将其作为输入对象传递给我们的代理工作流。
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After invoking our agent, we get a response message that we want to send back
    to the user using the send_whatsapp_message function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 调用我们的代理后，我们会得到一个响应消息，我们希望使用 `send_whatsapp_message` 函数将其发送回用户。
- en: 'Now you should be able to send messages to the test number and get answer by
    the agent executor. **Remark**: While using the Whatsapp test number you have
    to register phone numbers that are allowed to send messages to your bot in you
    Meta API app.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够向测试号码发送消息，并通过代理执行器获得答复。**备注**：在使用 WhatsApp 测试号码时，您必须在 Meta API 应用中注册允许向您的机器人发送消息的电话号码。
- en: By following this guide, you’ve taken a big step toward creating a strong LLM-powered
    chatbot that works seamlessly with WhatsApp. This isn’t just about setting up
    automated business communication in real-time; it’s about laying the groundwork
    for more advanced AI-driven workflows down the road.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循本指南，您已迈出了创建与 WhatsApp 无缝配合的强大LLM驱动聊天机器人的重要一步。这不仅仅是关于实时设置自动化业务通信；更是为未来更先进的基于AI的工作流奠定基础。
- en: '**What have we done:**'
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**我们做了什么：**'
- en: '**WhatsApp Cloud API Integration:**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WhatsApp 云 API 集成：**'
- en: We got Meta’s Cloud API for WhatsApp up and running, including building a webhook
    for live message handling.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经让 Meta 的 WhatsApp 云 API 运行起来了，包括构建用于实时消息处理的 Webhook。
- en: '**Backend Development with FastAPI:**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 FastAPI 进行后端开发：**'
- en: Set up endpoints to verify webhooks, process incoming messages, and handle responses
    asynchronously.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设置端点以验证 Webhooks、处理传入消息并异步处理响应。
- en: '**Multimedia & Authentication Support:**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多媒体和认证支持：**'
- en: Enabled stuff like audio transcription, and user authentication for more personalized
    interactions. Image handling is not implemented to the fullest but we have added
    the possibility for it.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启用了诸如音频转录和用户认证等功能，以实现更加个性化的互动。图像处理尚未完全实现，但我们已经为此添加了可能性。
- en: 'Whats Next:'
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来做什么：
- en: In the next part(s), which I promise to publish sooner 🙏 I will move the implementation
    to LangGraph. I will add some more capabilities to the agent like creating database
    tables + tools on its one. Which will make the Agent more flexible. I am also
    open for Feedback and ideas what to Features to add!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我承诺会更快地发布🙏，我将把实现移至LangGraph。我将为代理添加更多功能，如创建数据库表+工具。这将使代理更加灵活。我也乐意接受反馈和想法，以确定要添加的功能！
- en: '**Wrapping It Up:**'
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**总结：**'
- en: Combining the reach and usability of WhatsApp with LLMs is a big win for businesses
    and personal use cases. Whether you’re aiming for a personal assistant or a full-blown
    business tool, this guide gives you the path to get there. Keep tinkering, improving,
    and pushing boundaries — this is just the start of what you can build.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将 WhatsApp 的覆盖范围和易用性与LLMs相结合对于企业和个人使用场景来说是一大胜利。无论您是想要个人助手还是完整的商业工具，本指南都为您提供了实现目标的路径。继续调试、改进和突破界限——这只是您可以构建的开始。
- en: Happy coding! 🚀
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 祝编码愉快！🚀
- en: 'You can find the full code here: [Github Repo](https://github.com/elokus/WhatsappAgent)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到完整的代码：[Github 仓库](https://github.com/elokus/WhatsappAgent)
- en: 'Full Link: [https://github.com/elokus/WhatsappAgent](https://github.com/elokus/WhatsappAgent)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 完整链接：[https://github.com/elokus/WhatsappAgent](https://github.com/elokus/WhatsappAgent)

- en: Core AI For Any Rummy Variant
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä»»ä½• Rummy å˜ç§çš„æ ¸å¿ƒ AI
- en: åŸæ–‡ï¼š[https://towardsdatascience.com/core-ai-for-any-rummy-variant-4ff414da1703?source=collection_archive---------2-----------------------#2024-11-09](https://towardsdatascience.com/core-ai-for-any-rummy-variant-4ff414da1703?source=collection_archive---------2-----------------------#2024-11-09)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: åŸæ–‡ï¼š[https://towardsdatascience.com/core-ai-for-any-rummy-variant-4ff414da1703?source=collection_archive---------2-----------------------#2024-11-09](https://towardsdatascience.com/core-ai-for-any-rummy-variant-4ff414da1703?source=collection_archive---------2-----------------------#2024-11-09)
- en: Step by Step guide to a Rummy AI
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rummy AI çš„é€æ­¥æŒ‡å—
- en: '[](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)[![Iheb
    Rachdi](../Images/39cf41b34ea79226efa58484da1f90bb.png)](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)
    [Iheb Rachdi](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)[![Iheb
    Rachdi](../Images/39cf41b34ea79226efa58484da1f90bb.png)](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)
    [Iheb Rachdi](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)'
- en: Â·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)
    Â·10 min readÂ·Nov 9, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Â·å‘è¡¨äº [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)
    Â·é˜…è¯»æ—¶é—´ 10 åˆ†é’ŸÂ·2024å¹´11æœˆ9æ—¥
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/2122bd1ef90e34703cbb260791d126c8.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2122bd1ef90e34703cbb260791d126c8.png)'
- en: Image generated by the author using DALL-E
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ä½œè€…ä½¿ç”¨ DALL-E ç”Ÿæˆçš„å›¾åƒ
- en: '**Motivation**'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**åŠ¨æœº**'
- en: As I was in the process of developing a reinforcement learning (RL) model for
    a Rummy game, I reached the stage where I needed an AI opponent to carry out the
    environment setup and contribute to the model training. However, after searching
    online, I found that resources for creating an AI for Rummy game were limited,
    and the few solutions available were too slow for my needs. Since the AI would
    be used in training, (training time was already high without it) therefore, the
    AI needed to operate quickly and efficiently in both processing speed and memory
    use. Needless to say Brute-force solution simply wouldnâ€™t cut it, so I had to
    experiment with various algorithms and optimization techniques to achieve the
    complexity and speed appropriate for training.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä¸º Rummy æ¸¸æˆå¼€å‘å¼ºåŒ–å­¦ä¹ ï¼ˆRLï¼‰æ¨¡å‹çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘åˆ°äº†éœ€è¦ä¸€ä¸ª AI å¯¹æ‰‹æ¥æ‰§è¡Œç¯å¢ƒè®¾ç½®å¹¶ä¸ºæ¨¡å‹è®­ç»ƒæä¾›æ”¯æŒçš„é˜¶æ®µã€‚ç„¶è€Œï¼Œåœ¨ç½‘ä¸Šæœç´¢åï¼Œæˆ‘å‘ç°ç”¨äºåˆ›å»º
    Rummy æ¸¸æˆ AI çš„èµ„æºéå¸¸æœ‰é™ï¼Œä¸”ç°æœ‰çš„å°‘æ•°è§£å†³æ–¹æ¡ˆå¯¹æˆ‘æ¥è¯´å¤ªæ…¢äº†ã€‚ç”±äº AI å°†ç”¨äºè®­ç»ƒï¼ˆè€Œä¸”æ²¡æœ‰å®ƒè®­ç»ƒæ—¶é—´å·²ç»å¾ˆé•¿ï¼‰ï¼Œå› æ­¤ï¼ŒAI éœ€è¦åœ¨å¤„ç†é€Ÿåº¦å’Œå†…å­˜ä½¿ç”¨ä¸Šéƒ½èƒ½å¿«é€Ÿé«˜æ•ˆåœ°è¿è¡Œã€‚ä¸ç”¨è¯´ï¼Œæš´åŠ›ç ´è§£æ³•æ ¹æœ¬æ— æ³•æ»¡è¶³éœ€æ±‚ï¼Œæ‰€ä»¥æˆ‘å¿…é¡»å°è¯•å„ç§ç®—æ³•å’Œä¼˜åŒ–æŠ€æœ¯ï¼Œä»¥è¾¾åˆ°é€‚åˆè®­ç»ƒçš„å¤æ‚æ€§å’Œé€Ÿåº¦ã€‚
- en: '**So Why Read These Article ?**'
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**ä¸ºä»€ä¹ˆè¦é˜…è¯»è¿™ç¯‡æ–‡ç« ï¼Ÿ**'
- en: What weâ€™re going to build here is general, adaptable and suitable for almost
    any type of Rummy game you may be developing. Youâ€™ll only need to add your own
    strategy layer on top of it, then allow the AI to make decisions based on the
    output of this system. Additionally, you can directly integrate it into your Rummy
    game to be a tool to help players organize their cards by automatically Dividing
    them into possible meld combinations. Furthermore, the techniques weâ€™ll implement
    here can be applied to other areas, so no matter what, I guarantee it will benefit
    you in one way or another.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬åœ¨è¿™é‡Œæ„å»ºçš„æ˜¯ä¸€ä¸ªé€šç”¨ã€å¯é€‚åº”çš„ç³»ç»Ÿï¼Œé€‚ç”¨äºå‡ ä¹ä»»ä½•ä½ å¯èƒ½å¼€å‘çš„ Rummy æ¸¸æˆç±»å‹ã€‚ä½ åªéœ€è¦åœ¨å…¶åŸºç¡€ä¸Šæ·»åŠ è‡ªå·±çš„ç­–ç•¥å±‚ï¼Œç„¶åè®© AI æ ¹æ®è¯¥ç³»ç»Ÿçš„è¾“å‡ºåšå‡ºå†³ç­–ã€‚æ­¤å¤–ï¼Œä½ è¿˜å¯ä»¥å°†å…¶ç›´æ¥é›†æˆåˆ°ä½ çš„
    Rummy æ¸¸æˆä¸­ï¼Œä½œä¸ºå¸®åŠ©ç©å®¶æ•´ç†å¡ç‰Œçš„å·¥å…·ï¼Œè‡ªåŠ¨å°†å¡ç‰Œåˆ†æˆå¯èƒ½çš„ç»„åˆã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œå®ç°çš„æŠ€æœ¯è¿˜å¯ä»¥åº”ç”¨åˆ°å…¶ä»–é¢†åŸŸï¼Œæ‰€ä»¥æ— è®ºå¦‚ä½•ï¼Œæˆ‘ä¿è¯å®ƒä¼šåœ¨æŸç§ç¨‹åº¦ä¸Šå¯¹ä½ æœ‰æ‰€å¸®åŠ©ã€‚
- en: '**Putting Things in Perspective,**'
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**ä»æ•´ä½“æ¥çœ‹ï¼Œ**'
- en: This article wonâ€™t cover the complete AI; rather, it presents the essential
    building blocks and core component of the AI, which weâ€™ll refer to as â€œhand evaluatorâ€
    system. This hand evaluator analyzes a given Rummy hand and extracts all possible
    â€œCombosâ€ that can be formed. It serves as the initial step and forms the groundwork
    for the AIâ€™s decision-making process, that will be explored in a separate Medium
    article in the future.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: æœ¬æ–‡ä¸ä¼šæ¶µç›–å®Œæ•´çš„AIï¼Œè€Œæ˜¯ä»‹ç»AIçš„åŸºæœ¬æ„å»ºå—å’Œæ ¸å¿ƒç»„ä»¶ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œæ‰‹ç‰Œè¯„ä¼°å™¨â€ç³»ç»Ÿã€‚è¯¥æ‰‹ç‰Œè¯„ä¼°å™¨åˆ†æç»™å®šçš„Rummyæ‰‹ç‰Œï¼Œå¹¶æå–æ‰€æœ‰å¯èƒ½å½¢æˆçš„â€œç»„åˆâ€ã€‚å®ƒä½œä¸ºåˆæ­¥æ­¥éª¤ï¼Œä¸ºAIå†³ç­–è¿‡ç¨‹æ‰“ä¸‹åŸºç¡€ï¼Œåç»­å°†åœ¨å¦ä¸€ç¯‡Mediumæ–‡ç« ä¸­è¿›ä¸€æ­¥æ¢è®¨ã€‚
- en: '**Project Scope and Expectation**'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**é¡¹ç›®èŒƒå›´ä¸é¢„æœŸ**'
- en: 'Before starting, itâ€™s essential to define the scope of the hand evaluator system
    we aim to develop. In short, what we are gone build will take a set of *n* Rummy
    cards (15 in our case) and output a list of valid combinations, or â€œcomboâ€ that
    can be extracted from the hand. To keep the system widely adaptable for Rummy
    variants, weâ€™ll exclude two specific options: first, the use of Joker cards, and
    second, the option to place the Ace card after the King in a run meld. By setting
    these rules, the system becomes easier to understand. However, these design choices
    donâ€™t restrict the systemâ€™s adaptability, as it can easily be expanded to include
    those rules if needed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨å¼€å§‹ä¹‹å‰ï¼Œå®šä¹‰æˆ‘ä»¬ç›®æ ‡ç³»ç»Ÿçš„èŒƒå›´è‡³å…³é‡è¦ã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªå¯ä»¥å¤„ç†ä¸€ç»„*n*å¼ Rummyç‰Œï¼ˆåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ä¸º15å¼ ï¼‰çš„ç³»ç»Ÿï¼Œå¹¶è¾“å‡ºä»è¿™äº›ç‰Œä¸­èƒ½æå–å‡ºçš„æœ‰æ•ˆç»„åˆæˆ–â€œç»„åˆï¼ˆcomboï¼‰â€ã€‚ä¸ºäº†ä½¿è¯¥ç³»ç»Ÿèƒ½å¹¿æ³›é€‚åº”ä¸åŒçš„Rummyå˜ç§ï¼Œæˆ‘ä»¬å°†æ’é™¤ä¸¤ä¸ªç‰¹å®šé€‰é¡¹ï¼šé¦–å…ˆæ˜¯å°ä¸‘ç‰Œçš„ä½¿ç”¨ï¼Œå…¶æ¬¡æ˜¯å°†Aç‰Œæ”¾åœ¨Kç‰Œåé¢ç»„æˆé¡ºå­ã€‚é€šè¿‡è®¾å®šè¿™äº›è§„åˆ™ï¼Œç³»ç»Ÿå˜å¾—æ›´åŠ æ˜“äºç†è§£ã€‚ç„¶è€Œï¼Œè¿™äº›è®¾è®¡é€‰æ‹©å¹¶ä¸é™åˆ¶ç³»ç»Ÿçš„é€‚åº”æ€§ï¼Œå› ä¸ºå¦‚æœéœ€è¦ï¼Œå®ƒå¯ä»¥å¾ˆå®¹æ˜“åœ°æ‰©å±•ä»¥åŒ…æ‹¬è¿™äº›è§„åˆ™ã€‚
- en: Since this hand evaluator will be called repeatedly throughout the gameplay,
    it must remain optimized and memory efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ç”±äºè¿™ä¸ªæ‰‹ç‰Œè¯„ä¼°å™¨å°†åœ¨æ•´ä¸ªæ¸¸æˆè¿‡ç¨‹ä¸­åå¤è°ƒç”¨ï¼Œå› æ­¤å¿…é¡»ä¿æŒä¼˜åŒ–å¹¶é«˜æ•ˆä½¿ç”¨å†…å­˜ã€‚
- en: Moreover, given the nature of Rummy, for the AI to process all potential actions,
    it needs to evaluate different scenarios by adding or removing cards. To address
    this, the hand evaluator system must support dynamic hand modifications. Ideally,
    we want to avoid reprocessing the hand from scratch; instead, we need to use the
    already processed hand from previous runs of the system to minimize the work required
    to re-extract combos whenever the hand is modified.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: æ­¤å¤–ï¼Œé‰´äºRummyæ¸¸æˆçš„æ€§è´¨ï¼Œä¸ºäº†è®©AIå¤„ç†æ‰€æœ‰æ½œåœ¨çš„è¡ŒåŠ¨ï¼Œå®ƒéœ€è¦é€šè¿‡æ·»åŠ æˆ–ç§»é™¤ç‰Œæ¥è¯„ä¼°ä¸åŒçš„åœºæ™¯ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ‰‹ç‰Œè¯„ä¼°å™¨ç³»ç»Ÿå¿…é¡»æ”¯æŒåŠ¨æ€ä¿®æ”¹æ‰‹ç‰Œã€‚ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›é¿å…ä»å¤´å¼€å§‹é‡æ–°å¤„ç†æ‰‹ç‰Œï¼›è€Œæ˜¯å¸Œæœ›åˆ©ç”¨ä¹‹å‰ç³»ç»Ÿè¿è¡Œä¸­å·²ç»å¤„ç†è¿‡çš„æ‰‹ç‰Œï¼Œä»¥æœ€å°åŒ–æ¯æ¬¡æ‰‹ç‰Œä¿®æ”¹åé‡æ–°æå–ç»„åˆçš„å·¥ä½œé‡ã€‚
- en: '**Key Terminology and Setup**'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**å…³é”®æœ¯è¯­å’Œè®¾ç½®**'
- en: '**Deck:** the deck will contain 104 card with 52 Unique card and each card
    is duplicated once with a total of 13 * 4 * 2 = 104.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç‰Œç»„ï¼š** è¯¥ç‰Œç»„åŒ…å«104å¼ å¡ç‰Œï¼Œå…¶ä¸­æœ‰52å¼ ç‹¬ç‰¹çš„å¡ç‰Œï¼Œæ¯å¼ å¡ç‰Œéƒ½é‡å¤ä¸€æ¬¡ï¼Œæ€»å…±æœ‰13 * 4 * 2 = 104å¼ å¡ç‰Œã€‚'
- en: '**Card Ranks:** from 1 to 13 ï‚· with ranks 11, 12, and 13 representing the Jack,
    Queen, and King, respectively.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç‰Œé¢å€¼ï¼ˆCard Ranksï¼‰ï¼š** ä»1åˆ°13ï¼Œå…¶ä¸­11ã€12å’Œ13åˆ†åˆ«ä»£è¡¨Jï¼ˆæ°å…‹ï¼‰ã€Qï¼ˆçš‡åï¼‰å’ŒKï¼ˆå›½ç‹ï¼‰ã€‚'
- en: '**Card Suits:** The four suits are Hearts, Spades, Clubs, and Diamonds, which
    can also be indicated by **H**, **S**, **C**, and **D, or with icon** respectively.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**èŠ±è‰²ï¼ˆCard Suitsï¼‰ï¼š** å››ç§èŠ±è‰²ä¸ºçº¢å¿ƒã€é»‘æ¡ƒã€æ¢…èŠ±å’Œæ–¹å—ï¼Œåˆ†åˆ«å¯ä»¥ç”¨**H**ã€**S**ã€**C**ã€**D**æˆ–ç›¸åº”çš„å›¾æ ‡è¡¨ç¤ºã€‚'
- en: '**Run**: A sequence of three or more consecutive cards of the same suit.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**é¡ºå­ï¼ˆRunï¼‰ï¼š** ä¸‰å¼ æˆ–æ›´å¤šè¿ç»­ç‚¹æ•°çš„åŒèŠ±è‰²ç‰Œã€‚'
- en: '*Example*: 3H | 4H | 5H'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*ç¤ºä¾‹*ï¼š3H | 4H | 5H'
- en: '**Set**: A group of three or four cards with the same rank but different suits.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**åˆ»å­ï¼ˆSetï¼‰ï¼š** ä¸‰å¼ æˆ–å››å¼ åŒç‚¹æ•°ä½†èŠ±è‰²ä¸åŒçš„ç‰Œã€‚'
- en: '*Example*: 6H | 6S | 6D'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*ç¤ºä¾‹*ï¼š6H | 6S | 6D'
- en: '**Dump**: A group of cards that couldnâ€™t be used to create or be added to valid
    melds.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä¸¢ç‰Œï¼ˆDumpï¼‰ï¼š** æ— æ³•ç”¨æ¥ç»„æˆæœ‰æ•ˆç»„åˆçš„ç‰Œã€‚'
- en: '**Combo**: One possible division of a hand into runs, sets, and dump.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**ç»„åˆï¼ˆComboï¼‰ï¼š** ä¸€ç§å¯èƒ½çš„æ‰‹ç‰Œåˆ’åˆ†æ–¹å¼ï¼ŒåŒ…æ‹¬é¡ºå­ã€åˆ»å­å’Œä¸¢ç‰Œã€‚'
- en: 'Example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ç¤ºä¾‹ï¼š
- en: '**Hand:**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**æ‰‹ç‰Œï¼š**'
- en: 3H | 4H | 5H | 6H | 7H | 7C | 7S | 6S | 10S | JD | 6D | KH | 2C | 3D | 4S
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 3H | 4H | 5H | 6H | 7H | 7C | 7S | 6S | 10S | JD | 6D | KH | 2C | 3D | 4S
- en: '**One Possible Combo:**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**ä¸€ä¸ªå¯èƒ½çš„ç»„åˆï¼š**'
- en: Â· **Run:** 3H | 4H | 5H | 6H
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Â· **é¡ºå­ï¼š** 3H | 4H | 5H | 6H
- en: Â· **Set:** 7H | 7C | 7S
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Â· **åˆ»å­ï¼ˆSetï¼‰ï¼š** 7H | 7C | 7S
- en: Â· **Dump:** 6S | 10S | JD | 6D | KH | 2C | 3D | 4S
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Â· **ä¸¢ç‰ŒåŒºï¼š** 6S | 10S | JD | 6D | KH | 2C | 3D | 4S
- en: System Breakdown
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ç³»ç»Ÿåˆ†æ
- en: '**Identifying and Collecting key Data**'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**è¯†åˆ«ä¸æ”¶é›†å…³é”®æ•°æ®**'
- en: I explored several algorithms to optimize and reduce the search space for all
    possible combos. However, the fact that each card can appear twice increased the
    number of potential combos, making it challenging to track and validate each one.
    While competing on Codeforces, I encountered a problem that reminded me of the
    â€˜[island problem](https://codeforces.com/problemset/problem/627/F),â€™ which gave
    me new insight into approaching the hand evaluator system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘æ¢ç´¢äº†å‡ ç§ç®—æ³•ï¼Œä»¥ä¼˜åŒ–å’Œå‡å°‘æ‰€æœ‰å¯èƒ½ç»„åˆçš„æœç´¢ç©ºé—´ã€‚ç„¶è€Œï¼Œæ¯å¼ ç‰Œå¯ä»¥å‡ºç°ä¸¤æ¬¡çš„äº‹å®å¢åŠ äº†æ½œåœ¨ç»„åˆçš„æ•°é‡ï¼Œä½¿å¾—è·Ÿè¸ªå’ŒéªŒè¯æ¯ä¸ªç»„åˆå˜å¾—å…·æœ‰æŒ‘æˆ˜æ€§ã€‚åœ¨å‚ä¸Codeforcesæ¯”èµ›æ—¶ï¼Œæˆ‘é‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼Œæé†’æˆ‘æƒ³åˆ°äº†â€˜[å²›å±¿é—®é¢˜](https://codeforces.com/problemset/problem/627/F)â€™ï¼Œå®ƒè®©æˆ‘å¯¹æ‰‹ç‰Œè¯„ä¼°ç³»ç»Ÿçš„å¤„ç†æ–¹å¼æœ‰äº†æ–°çš„æ´å¯Ÿã€‚
- en: 'We can represent the hand as a 2D grid of size 4x13, where each column represents
    ranks from 1 to 13 and each row corresponds to the 4 suits. Each cell in this
    grid contains the count of cards in the hand in our case either 1, 2, or 0 . This
    allows us to divide the hand into â€˜islands,â€™ which are defined as groups of connected
    land cells with counts of 1 or 2 based on the following connectivity rules:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯ä»¥å°†æ‰‹ç‰Œè¡¨ç¤ºä¸ºä¸€ä¸ª4x13çš„äºŒç»´ç½‘æ ¼ï¼Œå…¶ä¸­æ¯ä¸€åˆ—ä»£è¡¨ä»1åˆ°13çš„ç‚¹æ•°ï¼Œæ¯ä¸€è¡Œå¯¹åº”å››ç§èŠ±è‰²ã€‚ç½‘æ ¼ä¸­çš„æ¯ä¸ªå•å…ƒæ ¼åŒ…å«æ‰‹ç‰Œä¸­å¯¹åº”ç‰Œçš„æ•°é‡ï¼Œåœ¨æˆ‘ä»¬çš„æƒ…å†µä¸‹å¯èƒ½æ˜¯1ã€2æˆ–0ã€‚è¿™å…è®¸æˆ‘ä»¬å°†æ‰‹ç‰Œåˆ’åˆ†ä¸ºâ€œå²›å±¿â€ï¼Œå²›å±¿å®šä¹‰ä¸ºæ ¹æ®ä»¥ä¸‹è¿æ¥è§„åˆ™ï¼Œè®¡æ•°ä¸º1æˆ–2çš„ç›¸é‚»æ ¼å­çš„ç»„ï¼š
- en: '**1.** Two cells are considered connected if they share a side (left, right,
    above, or below) in the grid.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.** å¦‚æœä¸¤ä¸ªå•å…ƒæ ¼åœ¨ç½‘æ ¼ä¸­æœ‰ä¸€è¾¹ç›¸æ¥ï¼ˆå·¦ã€å³ã€ä¸Šæˆ–ä¸‹ï¼‰ï¼Œåˆ™å®ƒä»¬è¢«è®¤ä¸ºæ˜¯è¿æ¥çš„ã€‚'
- en: '**2.** All cells within the same column are also connected if they both contain
    at least 1s, even if they are not adjacent (above or below).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.** åŒä¸€åˆ—ä¸­çš„æ‰€æœ‰å•å…ƒæ ¼ä¹Ÿè¢«è®¤ä¸ºæ˜¯è¿æ¥çš„ï¼Œå¦‚æœå®ƒä»¬éƒ½åŒ…å«è‡³å°‘ä¸€ä¸ª1ï¼Œå³ä½¿å®ƒä»¬ä¸ç›¸é‚»ï¼ˆä¸Šä¸‹ï¼‰ã€‚'
- en: 'EXP of â€˜ hand Aâ€™ : 11C 3H 4H 11D 3D 5H 9D 2H 6H 3C 4H 3D 4D 5H 12D 3C'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: â€˜æ‰‹ç‰ŒAâ€™çš„EXPï¼š11C 3H 4H 11D 3D 5H 9D 2H 6H 3C 4H 3D 4D 5H 12D 3C
- en: '![](../Images/9e30a157f6d14454f9560390869bf1dc.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9e30a157f6d14454f9560390869bf1dc.png)'
- en: Table representation of â€˜hand Aâ€™
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: â€˜æ‰‹ç‰ŒAâ€™çš„è¡¨æ ¼è¡¨ç¤º
- en: Our first task is to identify and label all distinct islands. Since each island
    is independent of the others, we can make our life easier by mapping each island
    to a class type letâ€™s name it _cardGraph. This class will be responsible for that
    island in terms of extracting, modifying, or deleting operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä»»åŠ¡æ˜¯è¯†åˆ«å¹¶æ ‡è®°æ‰€æœ‰ä¸åŒçš„å²›å±¿ã€‚ç”±äºæ¯ä¸ªå²›å±¿å½¼æ­¤ç‹¬ç«‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å°†æ¯ä¸ªå²›å±¿æ˜ å°„åˆ°ä¸€ä¸ªç±»ç±»å‹æ¥ç®€åŒ–å·¥ä½œï¼Œç§°å…¶ä¸º_cardGraph_ã€‚è¯¥ç±»å°†è´Ÿè´£è¯¥å²›å±¿çš„æå–ã€ä¿®æ”¹æˆ–åˆ é™¤æ“ä½œã€‚
- en: 'For clarity, letâ€™s isolate one island and work on it in the upcoming sections,
    so itâ€™s easier for you to follow. If it helps, you can think of each island as
    a connected graph, as Shown in the figure below:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸ºäº†æ›´æ¸…æ¥šåœ°è¯´æ˜ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°†å­¤ç«‹ä¸€ä¸ªå²›å±¿å¹¶åœ¨åç»­ç« èŠ‚ä¸­è¿›è¡Œå¤„ç†ï¼Œè¿™æ ·ä½ å¯ä»¥æ›´å®¹æ˜“åœ°è·Ÿéšã€‚å¦‚æœæœ‰å¸®åŠ©ï¼Œä½ å¯ä»¥å°†æ¯ä¸ªå²›å±¿è§†ä¸ºä¸€ä¸ªè¿æ¥å›¾ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
- en: '![](../Images/c040a20f4eccfb4b632fb89cc55efcf6.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c040a20f4eccfb4b632fb89cc55efcf6.png)'
- en: 'in Left: Island Represented in the Table; in Right: Same Island in a Connected
    Graph Perspective'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: å·¦ä¾§ï¼šè¡¨æ ¼ä¸­è¡¨ç¤ºçš„å²›å±¿ï¼›å³ä¾§ï¼šç›¸åŒå²›å±¿åœ¨è¿æ¥å›¾ä¸­çš„è§†è§’
- en: Now If you take multiple island examples and try to extract the possible combos,
    youâ€™ll notice that some cards have unique roles in branching out to a potential
    combinations. Weâ€™ll call these type of cards a **control points** or **Cpts**
    for short, as they play an essential role by reducing the search space significantly
    as you will see in the following steps.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œå¦‚æœä½ è€ƒè™‘å¤šä¸ªå²›å±¿ç¤ºä¾‹å¹¶å°è¯•æå–å¯èƒ½çš„ç»„åˆï¼Œä½ ä¼šæ³¨æ„åˆ°æœ‰äº›ç‰Œåœ¨åˆ†æ”¯æ½œåœ¨ç»„åˆæ—¶èµ·ç€ç‹¬ç‰¹çš„ä½œç”¨ã€‚æˆ‘ä»¬å°†è¿™ç§ç‰Œç§°ä¸º**æ§åˆ¶ç‚¹**æˆ–ç®€å†™ä¸º**Cpts**ï¼Œå› ä¸ºå®ƒä»¬é€šè¿‡æ˜¾è‘—å‡å°‘æœç´¢ç©ºé—´ï¼Œåœ¨åç»­æ­¥éª¤ä¸­èµ·åˆ°äº†è‡³å…³é‡è¦çš„ä½œç”¨ã€‚
- en: '**Cpts**: For a card to be considered a Cpts, it must be in a position where
    we have to make a choice on which meld (run or set) to append it to. If a card
    can naturally fit into multiple melds without forcing a choice (for example, a
    duplicate card with two options for melds each card will append to a meld), it
    wonâ€™t be considered a Cpts.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cpts**ï¼šä¸ºäº†å°†ä¸€å¼ ç‰Œè§†ä¸ºCptsï¼Œå®ƒå¿…é¡»å¤„äºä¸€ä¸ªéœ€è¦æˆ‘ä»¬åšå‡ºé€‰æ‹©çš„ä½å­ï¼Œå³å†³å®šå°†å®ƒæ·»åŠ åˆ°å“ªä¸ªç»„åˆï¼ˆé¡ºå­æˆ–ä¸‰å¼ ç›¸åŒï¼‰ã€‚å¦‚æœä¸€å¼ ç‰Œå¯ä»¥è‡ªç„¶åœ°é€‚åº”å¤šä¸ªç»„åˆè€Œä¸éœ€è¦åšå‡ºå¼ºåˆ¶é€‰æ‹©ï¼ˆä¾‹å¦‚ï¼Œä¸€å¼ é‡å¤çš„ç‰Œå¯ä»¥æœ‰ä¸¤ä¸ªé¡ºå­é€‰é¡¹ï¼Œæ¯å¼ ç‰Œéƒ½ä¼šæ·»åŠ åˆ°ä¸€ä¸ªé¡ºå­ï¼‰ï¼Œé‚£ä¹ˆå®ƒä¸ä¼šè¢«è§†ä¸ºCptsã€‚'
- en: In the case of our island example the 3 of heart is identified as a cpts. Below
    are all the melds that the 3 of Hearts could attach to, one at a time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„å²›å±¿ç¤ºä¾‹ä¸­ï¼Œçº¢å¿ƒ3è¢«æ ‡è¯†ä¸ºä¸€ä¸ªCptsã€‚ä¸‹é¢åˆ—å‡ºäº†çº¢å¿ƒ3å¯ä»¥é™„åŠ çš„æ‰€æœ‰ç»„åˆï¼Œæ¯æ¬¡ä¸€ä¸ªã€‚
- en: '![](../Images/990eb878a0ce456bec40091f08414ed7.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/990eb878a0ce456bec40091f08414ed7.png)'
- en: 'Our next step is to mark each card that qualifies as a Cpts. To do this, weâ€™ll
    create a 4x13 (in byte type) table lets call it _flagMap . Now for memory efficiency,
    you can make this a shared table each _cardGraph instance created from the hand
    can reference it and use it . In this table, each card in an island will be assigned
    a bitstream at the corresponding index in _flagMap, this byte will represents
    its potential placements in different runs or sets. If a card qualifies as a Cpts,
    it will be stored in a stack (we will need later), which weâ€™ll call _cptsStack.
    Hereâ€™s a breakdown of the byte structure: the first bit indicates whether the
    card belongs to a run, the second bit indicates its placement in an additional
    run, the third bit represents whether it belongs to a set, and the fourth bit
    specifies if it belongs to multiple sets.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬çš„ä¸‹ä¸€æ­¥æ˜¯æ ‡è®°æ¯å¼ ç¬¦åˆæ¡ä»¶çš„å¡ç‰‡ï¼Œç§°ä¹‹ä¸ºCptsã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ª4x13ï¼ˆå­—èŠ‚ç±»å‹ï¼‰çš„è¡¨æ ¼ï¼Œç§°ä¸º_flagMapã€‚ä¸ºäº†æé«˜å†…å­˜æ•ˆç‡ï¼Œå¯ä»¥å°†æ­¤è¡¨æ ¼è®¾ç½®ä¸ºå…±äº«è¡¨æ ¼ï¼Œæ¯ä¸ªç”±æ‰‹ç‰Œåˆ›å»ºçš„_cardGraphå®ä¾‹éƒ½å¯ä»¥å¼•ç”¨å¹¶ä½¿ç”¨å®ƒã€‚åœ¨æ­¤è¡¨æ ¼ä¸­ï¼Œæ¯å¼ å²›å±¿ä¸Šçš„å¡ç‰‡å°†è¢«åˆ†é…åˆ°_flagMapä¸­ç›¸åº”ç´¢å¼•çš„ä½ç½®ï¼Œè¿™ä¸ªå­—èŠ‚å°†è¡¨ç¤ºå…¶åœ¨ä¸åŒé¡ºå­æˆ–å¥—ç‰Œä¸­çš„æ½œåœ¨ä½ç½®ã€‚å¦‚æœä¸€å¼ å¡ç‰‡ç¬¦åˆCptsæ¡ä»¶ï¼Œå®ƒå°†è¢«å­˜å‚¨åœ¨ä¸€ä¸ªæ ˆä¸­ï¼ˆæˆ‘ä»¬ç¨åéœ€è¦ä½¿ç”¨ï¼‰ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸º_cptsStackã€‚ä»¥ä¸‹æ˜¯å­—èŠ‚ç»“æ„çš„ç»†èŠ‚ï¼šç¬¬ä¸€ä½è¡¨ç¤ºå¡ç‰‡æ˜¯å¦å±äºé¡ºå­ï¼Œç¬¬äºŒä½è¡¨ç¤ºå¡ç‰‡æ˜¯å¦å±äºå¦ä¸€ä¸ªé¡ºå­ï¼Œç¬¬ä¸‰ä½è¡¨ç¤ºå¡ç‰‡æ˜¯å¦å±äºå¥—ç‰Œï¼Œç¬¬å››ä½è¡¨ç¤ºå¡ç‰‡æ˜¯å¦å±äºå¤šä¸ªå¥—ç‰Œã€‚
- en: 'Hereâ€™s an example of a bitstream: 00000111 In here we have:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: è¿™æ˜¯ä¸€ä¸ªæ¯”ç‰¹æµçš„ç¤ºä¾‹ï¼š00000111 åœ¨è¿™é‡Œæˆ‘ä»¬æœ‰ï¼š
- en: '**â€¢** The first bit (1) means the card can belong to a run.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**â€¢** ç¬¬ä¸€ä½ï¼ˆ1ï¼‰è¡¨ç¤ºå¡ç‰‡å¯ä»¥å±äºä¸€ä¸ªé¡ºå­ã€‚'
- en: '**â€¢** The second bit (1) means the card can belong to a second run.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**â€¢** ç¬¬äºŒä¸ªä½ï¼ˆ1ï¼‰è¡¨ç¤ºè¯¥å¡ç‰‡å¯ä»¥å±äºç¬¬äºŒä¸ªé¡ºå­ã€‚'
- en: '**â€¢** The third bit (1) means the card belongs to a set.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**â€¢** ç¬¬ä¸‰ä½ï¼ˆ1ï¼‰è¡¨ç¤ºå¡ç‰‡å±äºä¸€ä¸ªå¥—ç‰Œã€‚'
- en: '**â€¢** The fourth bit (0) means the card doesnâ€™t belong to a second set.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**â€¢** ç¬¬å››ä½ï¼ˆ0ï¼‰è¡¨ç¤ºå¡ç‰‡ä¸å±äºç¬¬äºŒä¸ªå¥—ç‰Œã€‚'
- en: We might be in case where the configuration is 00000101 for one card (no copy),
    meaning the card belongs to a run or a set. Or another configuration could be
    00000011, meaning the card belongs to two different runs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å¯èƒ½ä¼šé‡åˆ°ä¸€ç§æƒ…å†µï¼Œå…¶ä¸­æŸå¼ å¡ç‰‡çš„é…ç½®ä¸º00000101ï¼ˆæ²¡æœ‰å‰¯æœ¬ï¼‰ï¼Œè¿™æ„å‘³ç€å¡ç‰‡å±äºä¸€ä¸ªé¡ºå­æˆ–ä¸€ä¸ªå¥—ç‰Œã€‚æˆ–è€…ï¼Œå¦ä¸€ç§é…ç½®å¯èƒ½æ˜¯00000011ï¼Œè¿™æ„å‘³ç€å¡ç‰‡å±äºä¸¤ä¸ªä¸åŒçš„é¡ºå­ã€‚
- en: To identify a cpts, simply count the â€˜1â€™s in its bit representation. If this
    count exceeds the total number of that card in the hand, itâ€™s considered a cpts.
    For instance, if a card appears twice (i.e., has two copies) and its bit representation
    is 00000101, itâ€™s not a cpts. However, if the bit representation is 00000111 like
    the example , then it qualifies as a cpts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: è¦è¯†åˆ«ä¸€ä¸ªCptsï¼Œåªéœ€è®¡ç®—å…¶ä½è¡¨ç¤ºä¸­çš„â€˜1â€™çš„æ•°é‡ã€‚å¦‚æœè¿™ä¸ªè®¡æ•°è¶…è¿‡äº†è¯¥å¡ç‰‡åœ¨æ‰‹ç‰Œä¸­çš„æ€»æ•°é‡ï¼Œåˆ™è®¤ä¸ºå®ƒæ˜¯ä¸€ä¸ªCptsã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€å¼ å¡ç‰‡å‡ºç°äº†ä¸¤æ¬¡ï¼ˆå³æœ‰ä¸¤ä¸ªå‰¯æœ¬ï¼‰ï¼Œå¹¶ä¸”å…¶ä½è¡¨ç¤ºä¸º00000101ï¼Œåˆ™å®ƒä¸æ˜¯Cptsã€‚ç„¶è€Œï¼Œå¦‚æœä½è¡¨ç¤ºä¸º00000111ï¼Œå¦‚ç¤ºä¾‹æ‰€ç¤ºï¼Œåˆ™å®ƒç¬¦åˆCptsçš„æ¡ä»¶ã€‚
- en: 'In our island example, hereâ€™s how the _flagMap table would look :'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬çš„å²›å±¿ç¤ºä¾‹ä¸­ï¼Œ_flagMapè¡¨æ ¼å°†å¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '![](../Images/42daff5e8143ad8ac312da7980769396.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/42daff5e8143ad8ac312da7980769396.png)'
- en: _FlagMap Representation of the â€˜hand Aâ€™ Example
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: _â€˜æ‰‹ç‰Œ Aâ€™ ç¤ºä¾‹çš„FlagMapè¡¨ç¤º_
- en: Once weâ€™ve populated the _flagMap and identified the cpts, the next task is
    to decompose the island into horizontal and vertical lines. **But why?** Breaking
    down the card graph into these lines simplifies the process of identifying runs
    and sets, as it allows us to focus on contiguous sequences of cards that can be
    processed more efficiently. As you might guess, the vertical lines will represent
    the sets, while the horizontal lines will represent the runs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ä¸€æ—¦æˆ‘ä»¬å¡«å……äº†_flagMapå¹¶è¯†åˆ«å‡ºCptsï¼Œæ¥ä¸‹æ¥çš„ä»»åŠ¡æ˜¯å°†å²›å±¿åˆ†è§£ä¸ºæ°´å¹³çº¿å’Œå‚ç›´çº¿ã€‚**ä½†ä¸ºä»€ä¹ˆï¼Ÿ** å°†å¡ç‰‡å›¾åˆ†è§£ä¸ºè¿™äº›çº¿æ¡å¯ä»¥ç®€åŒ–é¡ºå­å’Œå¥—ç‰Œçš„è¯†åˆ«è¿‡ç¨‹ï¼Œå› ä¸ºå®ƒè®©æˆ‘ä»¬èƒ½å¤Ÿä¸“æ³¨äºå¯ä»¥æ›´é«˜æ•ˆå¤„ç†çš„è¿ç»­å¡ç‰‡åºåˆ—ã€‚æ­£å¦‚ä½ å¯èƒ½çŒœåˆ°çš„ï¼Œå‚ç›´çº¿å°†ä»£è¡¨å¥—ç‰Œï¼Œè€Œæ°´å¹³çº¿å°†ä»£è¡¨é¡ºå­ã€‚
- en: '![](../Images/49485838531386555e5afa96ec5e4f1a.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/49485838531386555e5afa96ec5e4f1a.png)'
- en: Island decomposed into Horizontal and Vertical Lines
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: å²›å±¿åˆ†è§£ä¸ºæ°´å¹³çº¿å’Œå‚ç›´çº¿
- en: Weâ€™ll store each horizontal line in a list of a tuple type, where the first
    item represents the starting index of the line and the last item represents the
    end index (inclusive). For the vertical lines, itâ€™s sufficient to simply store
    the column index in a list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†æŠŠæ¯æ¡æ°´å¹³çº¿å­˜å‚¨åœ¨ä¸€ä¸ªå…ƒç»„ç±»å‹çš„åˆ—è¡¨ä¸­ï¼Œå…¶ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ è¡¨ç¤ºçº¿çš„èµ·å§‹ç´¢å¼•ï¼Œæœ€åä¸€ä¸ªå…ƒç´ è¡¨ç¤ºç»“æŸç´¢å¼•ï¼ˆåŒ…æ‹¬ï¼‰ã€‚å¯¹äºå‚ç›´çº¿ï¼Œç®€å•åœ°å°†åˆ—ç´¢å¼•å­˜å‚¨åœ¨ä¸€ä¸ªåˆ—è¡¨ä¸­å°±è¶³å¤Ÿäº†ã€‚
- en: '***Tip:*** We can accomplish this task along with the bit representation step
    in a single loop, achieving O(n) complexity.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '***æç¤º:*** æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨ä¸€ä¸ªå¾ªç¯ä¸­å®Œæˆæ­¤ä»»åŠ¡ï¼ŒåŒæ—¶è¿›è¡Œä½è¡¨ç¤ºæ­¥éª¤ï¼Œä»è€Œå®ç°O(n)çš„å¤æ‚åº¦ã€‚'
- en: '**Generate Combos**'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ç”Ÿæˆç»„åˆ**'
- en: 'Now, letâ€™s take a break and recap: we have identified the control points (CPTs)
    and stored them in the _cptsStack. We also decomposed the island into vertical
    and horizontal lines, and populated the _flagMap with card bit representation.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ç°åœ¨ï¼Œè®©æˆ‘ä»¬ä¼‘æ¯ä¸€ä¸‹å¹¶å›é¡¾ä¸€ä¸‹ï¼šæˆ‘ä»¬å·²ç»è¯†åˆ«äº†æ§åˆ¶ç‚¹ (CPTs)ï¼Œå¹¶å°†å®ƒä»¬å­˜å‚¨åœ¨ `_cptsStack` ä¸­ã€‚æˆ‘ä»¬è¿˜å°†å²›å±¿åˆ†è§£ä¸ºå‚ç›´å’Œæ°´å¹³çº¿ï¼Œå¹¶ç”¨å¡ç‰‡çš„ä½è¡¨ç¤ºå¡«å……äº†
    `_flagMap`ã€‚
- en: 'With our data in place, what remains is to use it to generate all possible
    valid combos of the island. But how do we do that? Hereâ€™s a simplified approach:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨æˆ‘ä»¬å‡†å¤‡å¥½æ•°æ®åï¼Œå‰©ä¸‹çš„å°±æ˜¯åˆ©ç”¨å®ƒç”Ÿæˆå²›å±¿çš„æ‰€æœ‰æœ‰æ•ˆç»„åˆã€‚ä½†æˆ‘ä»¬è¯¥æ€ä¹ˆåšå‘¢ï¼Ÿè¿™é‡Œæœ‰ä¸€ä¸ªç®€åŒ–çš„æ–¹æ³•ï¼š
- en: '**1\. Assign Valid Placements for the Control Points (Cpts):**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**1\. ä¸ºæ§åˆ¶ç‚¹ (Cpts) åˆ†é…æœ‰æ•ˆæ”¾ç½®ä½ç½®ï¼š**'
- en: We take the bit representation of a cpts from _flagMap, which indicates all
    possible placements for that cpts. Then, we look at the number of copies of the
    cpts in the _cardGraph and adjust its bit representation to a current valid configuration.
    For example, if the cpts has a bit representation of 00001111 and 2 copies, we
    can generate all valid placements for it, which is C(4,2)=6C(4,2) = 6C(4,2)=6\.
    Possible combinations would be 0011, 0101, 1100, 1010, 1001, and 0110.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬ä» `_flagMap` è·å–ä¸€ä¸ª cpts çš„ä½è¡¨ç¤ºï¼Œè¡¨ç¤ºè¯¥ cpts æ‰€æœ‰å¯èƒ½çš„æ”¾ç½®ä½ç½®ã€‚ç„¶åï¼Œæˆ‘ä»¬æŸ¥çœ‹è¯¥ cpts åœ¨ `_cardGraph`
    ä¸­çš„å‰¯æœ¬æ•°é‡ï¼Œå¹¶å°†å…¶ä½è¡¨ç¤ºè°ƒæ•´ä¸ºå½“å‰æœ‰æ•ˆçš„é…ç½®ã€‚ä¾‹å¦‚ï¼Œå¦‚æœè¯¥ cpts çš„ä½è¡¨ç¤ºä¸º 00001111ï¼Œå¹¶ä¸”æœ‰ 2 ä¸ªå‰¯æœ¬ï¼Œæˆ‘ä»¬å¯ä»¥ç”Ÿæˆè¯¥ cpts çš„æ‰€æœ‰æœ‰æ•ˆæ”¾ç½®ä½ç½®ï¼Œè®¡ç®—å…¬å¼ä¸º
    C(4,2)=6ã€‚å¯èƒ½çš„ç»„åˆåŒ…æ‹¬ 0011ã€0101ã€1100ã€1010ã€1001 å’Œ 0110ã€‚
- en: '**2\. Using DFS to Configure All Possible Combinations for Each Cpts:**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**2\. ä½¿ç”¨ DFS é…ç½®æ¯ä¸ª Cpts çš„æ‰€æœ‰å¯èƒ½ç»„åˆï¼š**'
- en: Weâ€™ll use a depth-first search (DFS) to iterate over the valid placements for
    each cpts as shown in step 1\. Each node in the DFS tree represents a possible
    placement for a given cpts, so each unique DFS path represents a valid combo configuration.
    For each â€œleafâ€ node (end of the DFS path), we proceed to the next step.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: æˆ‘ä»¬å°†ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ (DFS) æ¥éå†æ¯ä¸ª cpts çš„æœ‰æ•ˆæ”¾ç½®ä½ç½®ï¼Œå¦‚æ­¥éª¤ 1 æ‰€ç¤ºã€‚DFS æ ‘ä¸­çš„æ¯ä¸ªèŠ‚ç‚¹ä»£è¡¨ç»™å®š cpts çš„ä¸€ä¸ªå¯èƒ½æ”¾ç½®ä½ç½®ï¼Œå› æ­¤æ¯æ¡å”¯ä¸€çš„
    DFS è·¯å¾„ä»£è¡¨ä¸€ä¸ªæœ‰æ•ˆçš„ç»„åˆé…ç½®ã€‚å¯¹äºæ¯ä¸ªâ€œå¶å­â€èŠ‚ç‚¹ï¼ˆDFS è·¯å¾„çš„ç»“æŸï¼‰ï¼Œæˆ‘ä»¬è¿›å…¥ä¸‹ä¸€æ­¥éª¤ã€‚
- en: '**3\. Generating Combos:**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**3\. ç”Ÿæˆç»„åˆï¼š**'
- en: 'In this step, we iterate over the horizontal and vertical lines in the island
    to identify runs, sets, and a dump list. This is done in two passes for each line,
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨è¿™ä¸€æ­¥ä¸­ï¼Œæˆ‘ä»¬éå†å²›å±¿ä¸­çš„æ°´å¹³å’Œå‚ç›´çº¿ï¼Œä»¥è¯†åˆ«è¿ç»­æ®µã€é›†åˆå’Œä¸¢å¼ƒåˆ—è¡¨ã€‚å¯¹äºæ¯æ¡çº¿ï¼Œåˆ†ä¸¤æ¬¡éå†å®Œæˆï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
- en: '**Pass 1:** For a horizontal line, for example, we continuously append cards
    from [line start to line end] into a list to form a run. We stop adding if ( card_bit_representation
    | 00000001 == 0 ). If the length of the run is greater than or equal to 3, we
    add it to the run combo; otherwise, each card goes into the dump list, and we
    continue trying to form another run until we reach the line end.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ç¬¬ 1 è½®ï¼š** ä¾‹å¦‚ï¼Œå¯¹äºä¸€æ¡æ°´å¹³çº¿ï¼Œæˆ‘ä»¬ä¸æ–­åœ°å°†å¡ç‰‡ä» [çº¿å¼€å§‹åˆ°çº¿ç»“æŸ] æ·»åŠ åˆ°ä¸€ä¸ªåˆ—è¡¨ä¸­ä»¥å½¢æˆè¿ç»­æ®µã€‚å¦‚æœ ( card_bit_representation
    | 00000001 == 0 )ï¼Œåˆ™åœæ­¢æ·»åŠ ã€‚å¦‚æœè¿ç»­æ®µçš„é•¿åº¦å¤§äºæˆ–ç­‰äº 3ï¼Œæˆ‘ä»¬å°†å…¶æ·»åŠ åˆ°è¿ç»­æ®µç»„åˆä¸­ï¼›å¦åˆ™ï¼Œæ¯å¼ å¡ç‰‡å°†è¿›å…¥ä¸¢å¼ƒåˆ—è¡¨ï¼Œå¹¶ç»§ç»­å°è¯•å½¢æˆå¦ä¸€ä¸ªè¿ç»­æ®µï¼Œç›´åˆ°è¾¾åˆ°çº¿çš„æœ«ç«¯ã€‚'
- en: '**Pass 2:** Repeat the process, this time looking for cards that match a different
    bit pattern with or operation ( 00000010). This allows us to identify possible
    second runs.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ç¬¬ 2 è½®ï¼š** é‡å¤è¯¥è¿‡ç¨‹ï¼Œè¿™æ¬¡å¯»æ‰¾ä¸ä¸åŒä½æ¨¡å¼åŒ¹é…çš„å¡ç‰‡ï¼ˆæˆ–æ“ä½œ 00000010ï¼‰ã€‚è¿™ä½¿æˆ‘ä»¬èƒ½å¤Ÿè¯†åˆ«å¯èƒ½çš„ç¬¬äºŒä¸ªè¿ç»­æ®µã€‚'
- en: The same approach applies to extracting sets, but we use bit operations with
    00000100 and 00001000.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ç›¸åŒçš„æ–¹æ³•ä¹Ÿé€‚ç”¨äºæå–é›†åˆï¼Œä½†æˆ‘ä»¬ä½¿ç”¨ä½æ“ä½œ 00000100 å’Œ 00001000ã€‚
- en: '**4\. Register the Valid Combo and Move to the Next DFS Configuration:**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**4\. æ³¨å†Œæœ‰æ•ˆç»„åˆå¹¶ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ª DFS é…ç½®ï¼š**'
- en: After completing all runs, sets, and dumps for the current combo, we save the
    combo and then move on to the next DFS configuration to repeat the process. This
    way, we systematically explore all potential configurations for valid combos.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: å®Œæˆå½“å‰ç»„åˆçš„æ‰€æœ‰è¿ç»­æ®µã€é›†åˆå’Œä¸¢å¼ƒæ“ä½œåï¼Œæˆ‘ä»¬ä¿å­˜è¯¥ç»„åˆï¼Œç„¶åç»§ç»­ä¸‹ä¸€ä¸ª DFS é…ç½®ï¼Œé‡å¤è¯¥è¿‡ç¨‹ã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬ç³»ç»Ÿåœ°æ¢ç´¢æ‰€æœ‰æ½œåœ¨çš„æœ‰æ•ˆç»„åˆé…ç½®ã€‚
- en: Demo Output
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: æ¼”ç¤ºè¾“å‡º
- en: 'if you coded everything correctly and feed it our island example : â€2H3H4H5H4H5H6H3C3C3D3D4Dâ€,
    it should be decomposed as shown bellow. Notice that Iâ€™ve added some calculation
    to each generated combo so that we can get a sense of how the AI will act.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: å¦‚æœä½ æ­£ç¡®ç¼–å†™äº†ä»£ç ï¼Œå¹¶ä¸”å°†å²›å±¿ç¤ºä¾‹ â€œ2H3H4H5H4H5H6H3C3C3D3D4Dâ€ ä½œä¸ºè¾“å…¥ï¼Œå®ƒåº”è¯¥è¢«åˆ†è§£ä¸ºå¦‚ä¸‹æ‰€ç¤ºã€‚æ³¨æ„ï¼Œæˆ‘å·²ä¸ºæ¯ä¸ªç”Ÿæˆçš„ç»„åˆæ·»åŠ äº†ä¸€äº›è®¡ç®—ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥äº†è§£
    AI ä¼šå¦‚ä½•ååº”ã€‚
- en: '![](../Images/8c6c58c19398b8dc2b701a8d17d81fdd.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8c6c58c19398b8dc2b701a8d17d81fdd.png)'
- en: Console Output Showing the Generated Combo For the Island Example
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: æ§åˆ¶å°è¾“å‡ºæ˜¾ç¤ºç”Ÿæˆçš„å²›å±¿ç»„åˆç¤ºä¾‹
- en: Whatâ€™s Next?
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ä¸‹ä¸€æ­¥æ˜¯ä»€ä¹ˆï¼Ÿ
- en: In the next article, Iâ€™ll dive into the rest of the system, focusing on the
    dynamic modification of the hand and the AI strategy. If youâ€™ve followed along
    so far, it wonâ€™t be hard to see how we can optimize adding and removing cards,
    as well as incorporate the two rules we set aside at the beginning. Stay tuned,
    and see you next time! â€œhopefully ğŸ˜‰â€.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: åœ¨ä¸‹ä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘å°†æ·±å…¥æ¢è®¨ç³»ç»Ÿçš„å…¶ä½™éƒ¨åˆ†ï¼Œé‡ç‚¹è®¨è®ºæ‰‹ç‰Œçš„åŠ¨æ€ä¿®æ”¹å’ŒAIç­–ç•¥ã€‚å¦‚æœä½ å·²ç»è·Ÿéšåˆ°è¿™é‡Œï¼Œåº”è¯¥ä¸éš¾çœ‹å‡ºæˆ‘ä»¬å¦‚ä½•ä¼˜åŒ–æ·»åŠ å’Œç§»é™¤å¡ç‰Œï¼Œå¹¶å°†æˆ‘ä»¬ä¸€å¼€å§‹æ”¾ç½®ä¸€æ—çš„ä¸¤ä¸ªè§„åˆ™çº³å…¥å…¶ä¸­ã€‚æ•¬è¯·æœŸå¾…ï¼Œä¸‹æ¬¡è§ï¼â€œå¸Œæœ›å¦‚æ­¤ğŸ˜‰â€ã€‚
- en: Unless otherwise noted, all images are created by the author using Lucidchart
    ,Gimp and Python
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: é™¤éå¦æœ‰è¯´æ˜ï¼Œæ‰€æœ‰å›¾ç‰‡å‡ç”±ä½œè€…ä½¿ç”¨Lucidchartã€Gimpå’ŒPythonåˆ›å»ºã€‚

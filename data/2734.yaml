- en: Core AI For Any Rummy Variant
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任何 Rummy 变种的核心 AI
- en: 原文：[https://towardsdatascience.com/core-ai-for-any-rummy-variant-4ff414da1703?source=collection_archive---------2-----------------------#2024-11-09](https://towardsdatascience.com/core-ai-for-any-rummy-variant-4ff414da1703?source=collection_archive---------2-----------------------#2024-11-09)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/core-ai-for-any-rummy-variant-4ff414da1703?source=collection_archive---------2-----------------------#2024-11-09](https://towardsdatascience.com/core-ai-for-any-rummy-variant-4ff414da1703?source=collection_archive---------2-----------------------#2024-11-09)
- en: Step by Step guide to a Rummy AI
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rummy AI 的逐步指南
- en: '[](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)[![Iheb
    Rachdi](../Images/39cf41b34ea79226efa58484da1f90bb.png)](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)
    [Iheb Rachdi](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)[![Iheb
    Rachdi](../Images/39cf41b34ea79226efa58484da1f90bb.png)](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)
    [Iheb Rachdi](https://medium.com/@iheb.rachdi?source=post_page---byline--4ff414da1703--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)
    ·10 min read·Nov 9, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--4ff414da1703--------------------------------)
    ·阅读时间 10 分钟·2024年11月9日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/2122bd1ef90e34703cbb260791d126c8.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2122bd1ef90e34703cbb260791d126c8.png)'
- en: Image generated by the author using DALL-E
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 作者使用 DALL-E 生成的图像
- en: '**Motivation**'
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**动机**'
- en: As I was in the process of developing a reinforcement learning (RL) model for
    a Rummy game, I reached the stage where I needed an AI opponent to carry out the
    environment setup and contribute to the model training. However, after searching
    online, I found that resources for creating an AI for Rummy game were limited,
    and the few solutions available were too slow for my needs. Since the AI would
    be used in training, (training time was already high without it) therefore, the
    AI needed to operate quickly and efficiently in both processing speed and memory
    use. Needless to say Brute-force solution simply wouldn’t cut it, so I had to
    experiment with various algorithms and optimization techniques to achieve the
    complexity and speed appropriate for training.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我为 Rummy 游戏开发强化学习（RL）模型的过程中，我到了需要一个 AI 对手来执行环境设置并为模型训练提供支持的阶段。然而，在网上搜索后，我发现用于创建
    Rummy 游戏 AI 的资源非常有限，且现有的少数解决方案对我来说太慢了。由于 AI 将用于训练（而且没有它训练时间已经很长），因此，AI 需要在处理速度和内存使用上都能快速高效地运行。不用说，暴力破解法根本无法满足需求，所以我必须尝试各种算法和优化技术，以达到适合训练的复杂性和速度。
- en: '**So Why Read These Article ?**'
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**为什么要阅读这篇文章？**'
- en: What we’re going to build here is general, adaptable and suitable for almost
    any type of Rummy game you may be developing. You’ll only need to add your own
    strategy layer on top of it, then allow the AI to make decisions based on the
    output of this system. Additionally, you can directly integrate it into your Rummy
    game to be a tool to help players organize their cards by automatically Dividing
    them into possible meld combinations. Furthermore, the techniques we’ll implement
    here can be applied to other areas, so no matter what, I guarantee it will benefit
    you in one way or another.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里构建的是一个通用、可适应的系统，适用于几乎任何你可能开发的 Rummy 游戏类型。你只需要在其基础上添加自己的策略层，然后让 AI 根据该系统的输出做出决策。此外，你还可以将其直接集成到你的
    Rummy 游戏中，作为帮助玩家整理卡牌的工具，自动将卡牌分成可能的组合。此外，我们在这里实现的技术还可以应用到其他领域，所以无论如何，我保证它会在某种程度上对你有所帮助。
- en: '**Putting Things in Perspective,**'
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**从整体来看，**'
- en: This article won’t cover the complete AI; rather, it presents the essential
    building blocks and core component of the AI, which we’ll refer to as “hand evaluator”
    system. This hand evaluator analyzes a given Rummy hand and extracts all possible
    “Combos” that can be formed. It serves as the initial step and forms the groundwork
    for the AI’s decision-making process, that will be explored in a separate Medium
    article in the future.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本文不会涵盖完整的AI，而是介绍AI的基本构建块和核心组件，我们称之为“手牌评估器”系统。该手牌评估器分析给定的Rummy手牌，并提取所有可能形成的“组合”。它作为初步步骤，为AI决策过程打下基础，后续将在另一篇Medium文章中进一步探讨。
- en: '**Project Scope and Expectation**'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**项目范围与预期**'
- en: 'Before starting, it’s essential to define the scope of the hand evaluator system
    we aim to develop. In short, what we are gone build will take a set of *n* Rummy
    cards (15 in our case) and output a list of valid combinations, or “combo” that
    can be extracted from the hand. To keep the system widely adaptable for Rummy
    variants, we’ll exclude two specific options: first, the use of Joker cards, and
    second, the option to place the Ace card after the King in a run meld. By setting
    these rules, the system becomes easier to understand. However, these design choices
    don’t restrict the system’s adaptability, as it can easily be expanded to include
    those rules if needed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，定义我们目标系统的范围至关重要。简而言之，我们将构建一个可以处理一组*n*张Rummy牌（在我们的例子中为15张）的系统，并输出从这些牌中能提取出的有效组合或“组合（combo）”。为了使该系统能广泛适应不同的Rummy变种，我们将排除两个特定选项：首先是小丑牌的使用，其次是将A牌放在K牌后面组成顺子。通过设定这些规则，系统变得更加易于理解。然而，这些设计选择并不限制系统的适应性，因为如果需要，它可以很容易地扩展以包括这些规则。
- en: Since this hand evaluator will be called repeatedly throughout the gameplay,
    it must remain optimized and memory efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个手牌评估器将在整个游戏过程中反复调用，因此必须保持优化并高效使用内存。
- en: Moreover, given the nature of Rummy, for the AI to process all potential actions,
    it needs to evaluate different scenarios by adding or removing cards. To address
    this, the hand evaluator system must support dynamic hand modifications. Ideally,
    we want to avoid reprocessing the hand from scratch; instead, we need to use the
    already processed hand from previous runs of the system to minimize the work required
    to re-extract combos whenever the hand is modified.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，鉴于Rummy游戏的性质，为了让AI处理所有潜在的行动，它需要通过添加或移除牌来评估不同的场景。为了解决这个问题，手牌评估器系统必须支持动态修改手牌。理想情况下，我们希望避免从头开始重新处理手牌；而是希望利用之前系统运行中已经处理过的手牌，以最小化每次手牌修改后重新提取组合的工作量。
- en: '**Key Terminology and Setup**'
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**关键术语和设置**'
- en: '**Deck:** the deck will contain 104 card with 52 Unique card and each card
    is duplicated once with a total of 13 * 4 * 2 = 104.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**牌组：** 该牌组包含104张卡牌，其中有52张独特的卡牌，每张卡牌都重复一次，总共有13 * 4 * 2 = 104张卡牌。'
- en: '**Card Ranks:** from 1 to 13  with ranks 11, 12, and 13 representing the Jack,
    Queen, and King, respectively.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**牌面值（Card Ranks）：** 从1到13，其中11、12和13分别代表J（杰克）、Q（皇后）和K（国王）。'
- en: '**Card Suits:** The four suits are Hearts, Spades, Clubs, and Diamonds, which
    can also be indicated by **H**, **S**, **C**, and **D, or with icon** respectively.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**花色（Card Suits）：** 四种花色为红心、黑桃、梅花和方块，分别可以用**H**、**S**、**C**、**D**或相应的图标表示。'
- en: '**Run**: A sequence of three or more consecutive cards of the same suit.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺子（Run）：** 三张或更多连续点数的同花色牌。'
- en: '*Example*: 3H | 4H | 5H'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例*：3H | 4H | 5H'
- en: '**Set**: A group of three or four cards with the same rank but different suits.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**刻子（Set）：** 三张或四张同点数但花色不同的牌。'
- en: '*Example*: 6H | 6S | 6D'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例*：6H | 6S | 6D'
- en: '**Dump**: A group of cards that couldn’t be used to create or be added to valid
    melds.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**丢牌（Dump）：** 无法用来组成有效组合的牌。'
- en: '**Combo**: One possible division of a hand into runs, sets, and dump.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合（Combo）：** 一种可能的手牌划分方式，包括顺子、刻子和丢牌。'
- en: 'Example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '**Hand:**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**手牌：**'
- en: 3H | 4H | 5H | 6H | 7H | 7C | 7S | 6S | 10S | JD | 6D | KH | 2C | 3D | 4S
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 3H | 4H | 5H | 6H | 7H | 7C | 7S | 6S | 10S | JD | 6D | KH | 2C | 3D | 4S
- en: '**One Possible Combo:**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个可能的组合：**'
- en: · **Run:** 3H | 4H | 5H | 6H
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: · **顺子：** 3H | 4H | 5H | 6H
- en: · **Set:** 7H | 7C | 7S
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: · **刻子（Set）：** 7H | 7C | 7S
- en: · **Dump:** 6S | 10S | JD | 6D | KH | 2C | 3D | 4S
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: · **丢牌区：** 6S | 10S | JD | 6D | KH | 2C | 3D | 4S
- en: System Breakdown
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统分析
- en: '**Identifying and Collecting key Data**'
  id: totrans-36
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**识别与收集关键数据**'
- en: I explored several algorithms to optimize and reduce the search space for all
    possible combos. However, the fact that each card can appear twice increased the
    number of potential combos, making it challenging to track and validate each one.
    While competing on Codeforces, I encountered a problem that reminded me of the
    ‘[island problem](https://codeforces.com/problemset/problem/627/F),’ which gave
    me new insight into approaching the hand evaluator system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我探索了几种算法，以优化和减少所有可能组合的搜索空间。然而，每张牌可以出现两次的事实增加了潜在组合的数量，使得跟踪和验证每个组合变得具有挑战性。在参与Codeforces比赛时，我遇到一个问题，提醒我想到了‘[岛屿问题](https://codeforces.com/problemset/problem/627/F)’，它让我对手牌评估系统的处理方式有了新的洞察。
- en: 'We can represent the hand as a 2D grid of size 4x13, where each column represents
    ranks from 1 to 13 and each row corresponds to the 4 suits. Each cell in this
    grid contains the count of cards in the hand in our case either 1, 2, or 0 . This
    allows us to divide the hand into ‘islands,’ which are defined as groups of connected
    land cells with counts of 1 or 2 based on the following connectivity rules:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将手牌表示为一个4x13的二维网格，其中每一列代表从1到13的点数，每一行对应四种花色。网格中的每个单元格包含手牌中对应牌的数量，在我们的情况下可能是1、2或0。这允许我们将手牌划分为“岛屿”，岛屿定义为根据以下连接规则，计数为1或2的相邻格子的组：
- en: '**1.** Two cells are considered connected if they share a side (left, right,
    above, or below) in the grid.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**1.** 如果两个单元格在网格中有一边相接（左、右、上或下），则它们被认为是连接的。'
- en: '**2.** All cells within the same column are also connected if they both contain
    at least 1s, even if they are not adjacent (above or below).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.** 同一列中的所有单元格也被认为是连接的，如果它们都包含至少一个1，即使它们不相邻（上下）。'
- en: 'EXP of ‘ hand A’ : 11C 3H 4H 11D 3D 5H 9D 2H 6H 3C 4H 3D 4D 5H 12D 3C'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ‘手牌A’的EXP：11C 3H 4H 11D 3D 5H 9D 2H 6H 3C 4H 3D 4D 5H 12D 3C
- en: '![](../Images/9e30a157f6d14454f9560390869bf1dc.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/9e30a157f6d14454f9560390869bf1dc.png)'
- en: Table representation of ‘hand A’
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ‘手牌A’的表格表示
- en: Our first task is to identify and label all distinct islands. Since each island
    is independent of the others, we can make our life easier by mapping each island
    to a class type let’s name it _cardGraph. This class will be responsible for that
    island in terms of extracting, modifying, or deleting operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是识别并标记所有不同的岛屿。由于每个岛屿彼此独立，我们可以通过将每个岛屿映射到一个类类型来简化工作，称其为_cardGraph_。该类将负责该岛屿的提取、修改或删除操作。
- en: 'For clarity, let’s isolate one island and work on it in the upcoming sections,
    so it’s easier for you to follow. If it helps, you can think of each island as
    a connected graph, as Shown in the figure below:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明，接下来我们将孤立一个岛屿并在后续章节中进行处理，这样你可以更容易地跟随。如果有帮助，你可以将每个岛屿视为一个连接图，如下图所示：
- en: '![](../Images/c040a20f4eccfb4b632fb89cc55efcf6.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c040a20f4eccfb4b632fb89cc55efcf6.png)'
- en: 'in Left: Island Represented in the Table; in Right: Same Island in a Connected
    Graph Perspective'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧：表格中表示的岛屿；右侧：相同岛屿在连接图中的视角
- en: Now If you take multiple island examples and try to extract the possible combos,
    you’ll notice that some cards have unique roles in branching out to a potential
    combinations. We’ll call these type of cards a **control points** or **Cpts**
    for short, as they play an essential role by reducing the search space significantly
    as you will see in the following steps.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你考虑多个岛屿示例并尝试提取可能的组合，你会注意到有些牌在分支潜在组合时起着独特的作用。我们将这种牌称为**控制点**或简写为**Cpts**，因为它们通过显著减少搜索空间，在后续步骤中起到了至关重要的作用。
- en: '**Cpts**: For a card to be considered a Cpts, it must be in a position where
    we have to make a choice on which meld (run or set) to append it to. If a card
    can naturally fit into multiple melds without forcing a choice (for example, a
    duplicate card with two options for melds each card will append to a meld), it
    won’t be considered a Cpts.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cpts**：为了将一张牌视为Cpts，它必须处于一个需要我们做出选择的位子，即决定将它添加到哪个组合（顺子或三张相同）。如果一张牌可以自然地适应多个组合而不需要做出强制选择（例如，一张重复的牌可以有两个顺子选项，每张牌都会添加到一个顺子），那么它不会被视为Cpts。'
- en: In the case of our island example the 3 of heart is identified as a cpts. Below
    are all the melds that the 3 of Hearts could attach to, one at a time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的岛屿示例中，红心3被标识为一个Cpts。下面列出了红心3可以附加的所有组合，每次一个。
- en: '![](../Images/990eb878a0ce456bec40091f08414ed7.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/990eb878a0ce456bec40091f08414ed7.png)'
- en: 'Our next step is to mark each card that qualifies as a Cpts. To do this, we’ll
    create a 4x13 (in byte type) table lets call it _flagMap . Now for memory efficiency,
    you can make this a shared table each _cardGraph instance created from the hand
    can reference it and use it . In this table, each card in an island will be assigned
    a bitstream at the corresponding index in _flagMap, this byte will represents
    its potential placements in different runs or sets. If a card qualifies as a Cpts,
    it will be stored in a stack (we will need later), which we’ll call _cptsStack.
    Here’s a breakdown of the byte structure: the first bit indicates whether the
    card belongs to a run, the second bit indicates its placement in an additional
    run, the third bit represents whether it belongs to a set, and the fourth bit
    specifies if it belongs to multiple sets.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是标记每张符合条件的卡片，称之为Cpts。为此，我们将创建一个4x13（字节类型）的表格，称为_flagMap。为了提高内存效率，可以将此表格设置为共享表格，每个由手牌创建的_cardGraph实例都可以引用并使用它。在此表格中，每张岛屿上的卡片将被分配到_flagMap中相应索引的位置，这个字节将表示其在不同顺子或套牌中的潜在位置。如果一张卡片符合Cpts条件，它将被存储在一个栈中（我们稍后需要使用），我们称之为_cptsStack。以下是字节结构的细节：第一位表示卡片是否属于顺子，第二位表示卡片是否属于另一个顺子，第三位表示卡片是否属于套牌，第四位表示卡片是否属于多个套牌。
- en: 'Here’s an example of a bitstream: 00000111 In here we have:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个比特流的示例：00000111 在这里我们有：
- en: '**•** The first bit (1) means the card can belong to a run.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**•** 第一位（1）表示卡片可以属于一个顺子。'
- en: '**•** The second bit (1) means the card can belong to a second run.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**•** 第二个位（1）表示该卡片可以属于第二个顺子。'
- en: '**•** The third bit (1) means the card belongs to a set.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**•** 第三位（1）表示卡片属于一个套牌。'
- en: '**•** The fourth bit (0) means the card doesn’t belong to a second set.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**•** 第四位（0）表示卡片不属于第二个套牌。'
- en: We might be in case where the configuration is 00000101 for one card (no copy),
    meaning the card belongs to a run or a set. Or another configuration could be
    00000011, meaning the card belongs to two different runs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会遇到一种情况，其中某张卡片的配置为00000101（没有副本），这意味着卡片属于一个顺子或一个套牌。或者，另一种配置可能是00000011，这意味着卡片属于两个不同的顺子。
- en: To identify a cpts, simply count the ‘1’s in its bit representation. If this
    count exceeds the total number of that card in the hand, it’s considered a cpts.
    For instance, if a card appears twice (i.e., has two copies) and its bit representation
    is 00000101, it’s not a cpts. However, if the bit representation is 00000111 like
    the example , then it qualifies as a cpts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别一个Cpts，只需计算其位表示中的‘1’的数量。如果这个计数超过了该卡片在手牌中的总数量，则认为它是一个Cpts。例如，如果一张卡片出现了两次（即有两个副本），并且其位表示为00000101，则它不是Cpts。然而，如果位表示为00000111，如示例所示，则它符合Cpts的条件。
- en: 'In our island example, here’s how the _flagMap table would look :'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的岛屿示例中，_flagMap表格将如下所示：
- en: '![](../Images/42daff5e8143ad8ac312da7980769396.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/42daff5e8143ad8ac312da7980769396.png)'
- en: _FlagMap Representation of the ‘hand A’ Example
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: _‘手牌 A’ 示例的FlagMap表示_
- en: Once we’ve populated the _flagMap and identified the cpts, the next task is
    to decompose the island into horizontal and vertical lines. **But why?** Breaking
    down the card graph into these lines simplifies the process of identifying runs
    and sets, as it allows us to focus on contiguous sequences of cards that can be
    processed more efficiently. As you might guess, the vertical lines will represent
    the sets, while the horizontal lines will represent the runs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们填充了_flagMap并识别出Cpts，接下来的任务是将岛屿分解为水平线和垂直线。**但为什么？** 将卡片图分解为这些线条可以简化顺子和套牌的识别过程，因为它让我们能够专注于可以更高效处理的连续卡片序列。正如你可能猜到的，垂直线将代表套牌，而水平线将代表顺子。
- en: '![](../Images/49485838531386555e5afa96ec5e4f1a.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/49485838531386555e5afa96ec5e4f1a.png)'
- en: Island decomposed into Horizontal and Vertical Lines
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 岛屿分解为水平线和垂直线
- en: We’ll store each horizontal line in a list of a tuple type, where the first
    item represents the starting index of the line and the last item represents the
    end index (inclusive). For the vertical lines, it’s sufficient to simply store
    the column index in a list.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把每条水平线存储在一个元组类型的列表中，其中第一个元素表示线的起始索引，最后一个元素表示结束索引（包括）。对于垂直线，简单地将列索引存储在一个列表中就足够了。
- en: '***Tip:*** We can accomplish this task along with the bit representation step
    in a single loop, achieving O(n) complexity.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '***提示:*** 我们可以通过在一个循环中完成此任务，同时进行位表示步骤，从而实现O(n)的复杂度。'
- en: '**Generate Combos**'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**生成组合**'
- en: 'Now, let’s take a break and recap: we have identified the control points (CPTs)
    and stored them in the _cptsStack. We also decomposed the island into vertical
    and horizontal lines, and populated the _flagMap with card bit representation.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们休息一下并回顾一下：我们已经识别了控制点 (CPTs)，并将它们存储在 `_cptsStack` 中。我们还将岛屿分解为垂直和水平线，并用卡片的位表示填充了
    `_flagMap`。
- en: 'With our data in place, what remains is to use it to generate all possible
    valid combos of the island. But how do we do that? Here’s a simplified approach:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们准备好数据后，剩下的就是利用它生成岛屿的所有有效组合。但我们该怎么做呢？这里有一个简化的方法：
- en: '**1\. Assign Valid Placements for the Control Points (Cpts):**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**1\. 为控制点 (Cpts) 分配有效放置位置：**'
- en: We take the bit representation of a cpts from _flagMap, which indicates all
    possible placements for that cpts. Then, we look at the number of copies of the
    cpts in the _cardGraph and adjust its bit representation to a current valid configuration.
    For example, if the cpts has a bit representation of 00001111 and 2 copies, we
    can generate all valid placements for it, which is C(4,2)=6C(4,2) = 6C(4,2)=6\.
    Possible combinations would be 0011, 0101, 1100, 1010, 1001, and 0110.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `_flagMap` 获取一个 cpts 的位表示，表示该 cpts 所有可能的放置位置。然后，我们查看该 cpts 在 `_cardGraph`
    中的副本数量，并将其位表示调整为当前有效的配置。例如，如果该 cpts 的位表示为 00001111，并且有 2 个副本，我们可以生成该 cpts 的所有有效放置位置，计算公式为
    C(4,2)=6。可能的组合包括 0011、0101、1100、1010、1001 和 0110。
- en: '**2\. Using DFS to Configure All Possible Combinations for Each Cpts:**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**2\. 使用 DFS 配置每个 Cpts 的所有可能组合：**'
- en: We’ll use a depth-first search (DFS) to iterate over the valid placements for
    each cpts as shown in step 1\. Each node in the DFS tree represents a possible
    placement for a given cpts, so each unique DFS path represents a valid combo configuration.
    For each “leaf” node (end of the DFS path), we proceed to the next step.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用深度优先搜索 (DFS) 来遍历每个 cpts 的有效放置位置，如步骤 1 所示。DFS 树中的每个节点代表给定 cpts 的一个可能放置位置，因此每条唯一的
    DFS 路径代表一个有效的组合配置。对于每个“叶子”节点（DFS 路径的结束），我们进入下一步骤。
- en: '**3\. Generating Combos:**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**3\. 生成组合：**'
- en: 'In this step, we iterate over the horizontal and vertical lines in the island
    to identify runs, sets, and a dump list. This is done in two passes for each line,
    as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们遍历岛屿中的水平和垂直线，以识别连续段、集合和丢弃列表。对于每条线，分两次遍历完成，如下所示：
- en: '**Pass 1:** For a horizontal line, for example, we continuously append cards
    from [line start to line end] into a list to form a run. We stop adding if ( card_bit_representation
    | 00000001 == 0 ). If the length of the run is greater than or equal to 3, we
    add it to the run combo; otherwise, each card goes into the dump list, and we
    continue trying to form another run until we reach the line end.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 1 轮：** 例如，对于一条水平线，我们不断地将卡片从 [线开始到线结束] 添加到一个列表中以形成连续段。如果 ( card_bit_representation
    | 00000001 == 0 )，则停止添加。如果连续段的长度大于或等于 3，我们将其添加到连续段组合中；否则，每张卡片将进入丢弃列表，并继续尝试形成另一个连续段，直到达到线的末端。'
- en: '**Pass 2:** Repeat the process, this time looking for cards that match a different
    bit pattern with or operation ( 00000010). This allows us to identify possible
    second runs.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 2 轮：** 重复该过程，这次寻找与不同位模式匹配的卡片（或操作 00000010）。这使我们能够识别可能的第二个连续段。'
- en: The same approach applies to extracting sets, but we use bit operations with
    00000100 and 00001000.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的方法也适用于提取集合，但我们使用位操作 00000100 和 00001000。
- en: '**4\. Register the Valid Combo and Move to the Next DFS Configuration:**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**4\. 注册有效组合并移动到下一个 DFS 配置：**'
- en: After completing all runs, sets, and dumps for the current combo, we save the
    combo and then move on to the next DFS configuration to repeat the process. This
    way, we systematically explore all potential configurations for valid combos.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 完成当前组合的所有连续段、集合和丢弃操作后，我们保存该组合，然后继续下一个 DFS 配置，重复该过程。通过这种方式，我们系统地探索所有潜在的有效组合配置。
- en: Demo Output
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示输出
- en: 'if you coded everything correctly and feed it our island example : ”2H3H4H5H4H5H6H3C3C3D3D4D”,
    it should be decomposed as shown bellow. Notice that I’ve added some calculation
    to each generated combo so that we can get a sense of how the AI will act.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确编写了代码，并且将岛屿示例 “2H3H4H5H4H5H6H3C3C3D3D4D” 作为输入，它应该被分解为如下所示。注意，我已为每个生成的组合添加了一些计算，以便我们可以了解
    AI 会如何反应。
- en: '![](../Images/8c6c58c19398b8dc2b701a8d17d81fdd.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8c6c58c19398b8dc2b701a8d17d81fdd.png)'
- en: Console Output Showing the Generated Combo For the Island Example
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出显示生成的岛屿组合示例
- en: What’s Next?
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步是什么？
- en: In the next article, I’ll dive into the rest of the system, focusing on the
    dynamic modification of the hand and the AI strategy. If you’ve followed along
    so far, it won’t be hard to see how we can optimize adding and removing cards,
    as well as incorporate the two rules we set aside at the beginning. Stay tuned,
    and see you next time! “hopefully 😉”.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一篇文章中，我将深入探讨系统的其余部分，重点讨论手牌的动态修改和AI策略。如果你已经跟随到这里，应该不难看出我们如何优化添加和移除卡牌，并将我们一开始放置一旁的两个规则纳入其中。敬请期待，下次见！“希望如此😉”。
- en: Unless otherwise noted, all images are created by the author using Lucidchart
    ,Gimp and Python
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非另有说明，所有图片均由作者使用Lucidchart、Gimp和Python创建。

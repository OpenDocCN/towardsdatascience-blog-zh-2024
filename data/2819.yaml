- en: Building a Research Assistant That Can Write to Google Docs (Part 2)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个能够写入Google Docs的研究助手（第二部分）
- en: 原文：[https://towardsdatascience.com/building-a-research-assistant-that-can-write-to-google-docs-part-2-ac9dcacff4ff?source=collection_archive---------9-----------------------#2024-11-20](https://towardsdatascience.com/building-a-research-assistant-that-can-write-to-google-docs-part-2-ac9dcacff4ff?source=collection_archive---------9-----------------------#2024-11-20)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/building-a-research-assistant-that-can-write-to-google-docs-part-2-ac9dcacff4ff?source=collection_archive---------9-----------------------#2024-11-20](https://towardsdatascience.com/building-a-research-assistant-that-can-write-to-google-docs-part-2-ac9dcacff4ff?source=collection_archive---------9-----------------------#2024-11-20)
- en: '![](../Images/84311f1635442fb3094ebc3095549255.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/84311f1635442fb3094ebc3095549255.png)'
- en: Dalle-3’s interpretation of “An AI assistant throwing documents to the wind
    over a clear blue ocean”. Image generated by the author.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Dalle-3对“一个AI助手将文件随风抛向清澈蓝海”的解读。图像由作者生成。
- en: A tool that might help with your homework
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可能对你做作业有所帮助的工具
- en: '[](https://medium.com/@rmartinshort?source=post_page---byline--ac9dcacff4ff--------------------------------)[![Robert
    Martin-Short](../Images/e3910071b72a914255b185b850579a5a.png)](https://medium.com/@rmartinshort?source=post_page---byline--ac9dcacff4ff--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--ac9dcacff4ff--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--ac9dcacff4ff--------------------------------)
    [Robert Martin-Short](https://medium.com/@rmartinshort?source=post_page---byline--ac9dcacff4ff--------------------------------)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@rmartinshort?source=post_page---byline--ac9dcacff4ff--------------------------------)[![Robert
    Martin-Short](../Images/e3910071b72a914255b185b850579a5a.png)](https://medium.com/@rmartinshort?source=post_page---byline--ac9dcacff4ff--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--ac9dcacff4ff--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--ac9dcacff4ff--------------------------------)
    [Robert Martin-Short](https://medium.com/@rmartinshort?source=post_page---byline--ac9dcacff4ff--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--ac9dcacff4ff--------------------------------)
    ·12 min read·Nov 20, 2024
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于[Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--ac9dcacff4ff--------------------------------)
    ·12分钟阅读·2024年11月20日
- en: --
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '***This article is the second of a two part series where we use LangGraph and
    Tavily to build a simple research agent, which writes and refines short articles.
    To keep track of the plans, articles and comments it generates we add the ability
    to programmatically create and edit Google Docs. In the first article we built
    the agent. Now we will build the docs connection. You can find all the relevant
    code*** [***here***](https://github.com/rmartinshort/research_assist)***.***'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '***本文是两部分系列中的第二部分，我们使用LangGraph和Tavily构建了一个简单的研究助手，该助手能够撰写和修改短篇文章。为了跟踪它生成的计划、文章和评论，我们为其增加了编程创建和编辑Google
    Docs文档的功能。在第一篇文章中，我们构建了该助手。现在，我们将构建文档连接功能。你可以在[这里](https://github.com/rmartinshort/research_assist)找到所有相关代码。***'
- en: In [part 1 of this series](/building-a-research-agent-that-can-write-to-google-docs-part-1-4b49ea05a292)
    we discussed agents, and used tools from LangGraph and Tavily to build a minimal
    agent that can research, write, review and revise short articles. This is great
    for a demo, but what if we actually want to read those articles outside of a notebook?
    Or, more ambitiously, what if we can to make this agent into a tool that might
    actually be useful to someone learning about a new subject? This has the potential
    to become a full stack project, but here I will focus on just one interesting
    element — giving out system the ability to upload essays to Google Docs. Recall
    that we also save the intermediate steps that the agent takes in getting to the
    final answer too — probably its worth making a record of those as well.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[本系列的第一部分](/building-a-research-agent-that-can-write-to-google-docs-part-1-4b49ea05a292)中，我们讨论了代理，并使用LangGraph和Tavily的工具构建了一个最小化的代理，能够进行研究、写作、审阅和修订短篇文章。这对于展示很有用，但如果我们实际上希望在笔记本外阅读这些文章怎么办？或者，更雄心勃勃的目标是，如何将这个代理做成一个工具，可能对某个学习新主题的人有实际帮助？这有潜力成为一个完整的项目，但在这里，我将专注于其中一个有趣的元素——赋予我们的系统上传文章到Google
    Docs的能力。回想一下，我们还保存了代理在得出最终答案过程中所采取的中间步骤——或许也值得对这些步骤进行记录。
- en: '**1\. A minimal viable product**'
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**1. 最小可行产品**'
- en: In response to a question or topic prompt, our agent produces a long list of
    output. At a minimum, we’d like to dump this into a Google Doc with a title, and
    timestamp. We’d also like to control where in Google Drive this doc is to be written,
    and preferably have the option to create and name a folders so that our essays
    can be stored logically. We won’t focus too much on formatting here — although
    this is certainly possible using the Google Docs API — we are more interested
    in just getting the text into a place where someone would actually read it. Formatting
    could be a follow up, or simply left to the preference of the reader.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 针对一个问题或话题提示，我们的代理会生成一长串输出。至少，我们希望将其导入到一个 Google 文档中，并附上标题和时间戳。我们还希望能够控制该文档写入
    Google Drive 的位置，并最好能够创建和命名文件夹，以便将我们的文章进行有逻辑地存储。我们这里不会过多关注格式化——尽管使用 Google Docs
    API 完全可以实现——我们更关心的是将文本放入一个人们实际会阅读的地方。格式化可以稍后进行，或者直接留给读者的个人偏好。
- en: Once we have a docs connection set up, there’s a whole host of more advanced
    things we could do with our essay — what about using an LLM to reformat them for
    a presentation and uploading that into a Google Slides deck? Or scraping some
    referenced data source and uploading that to Google Sheets? We could add this
    functionality as tools inside the control flow of our agent and have it decide
    what to do. Clearly there’s a lot of options here but its good to start small.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了文档连接，接下来有很多更高级的操作可以做——比如使用 LLM 来重新格式化它们以用于演示，并将其上传到 Google Slides 演示文稿中？或者抓取某个参考数据源并将其上传到
    Google Sheets？我们可以将这些功能作为工具添加到代理的控制流程中，让它来决定执行什么。显然这里有很多选择，但最好还是从简单的开始。
- en: 2\. Connecting to Google Drive
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 连接到 Google Drive
- en: 'Let’s start by writing some code to interact with Google Docs in some basic
    ways. Some setup is required first: You will need a Google Cloud account and a
    new project. You will then need to enable the Google Drive and Google Docs APIs.
    To create some credentials for this project, we will be using a [service account](https://cloud.google.com/iam/docs/service-account-overview#:~:text=A%20service%20account%20is%20a,is%20unique%20to%20the%20account.),
    which can be set up using the instructions [here](https://developers.google.com/zero-touch/guides/customer/quickstart/python-service-account).
    This process will create a private key in a `.json` file, which you store on your
    local machine. Next, it’s a good idea to make a “master folder” for this project
    in your Google Drive. When that’s done, you can add your service account to this
    folder and give it write permissions. Now your service account has the authorization
    to programmatically interact with the contents of that folder.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先写一些代码，以基本方式与 Google Docs 进行交互。首先需要进行一些设置：您需要一个 Google Cloud 账户和一个新的项目。然后，您需要启用
    Google Drive 和 Google Docs API。为了为此项目创建一些凭证，我们将使用[服务账户](https://cloud.google.com/iam/docs/service-account-overview#:~:text=A%20service%20account%20is%20a,is%20unique%20to%20the%20account.)，可以按照[这里](https://developers.google.com/zero-touch/guides/customer/quickstart/python-service-account)的说明进行设置。此过程将生成一个
    `.json` 文件格式的私钥，您将其存储在本地计算机上。接下来，最好在您的 Google Drive 中为此项目创建一个“主文件夹”。完成后，您可以将您的服务账户添加到该文件夹并授予其写入权限。现在，您的服务账户就具备了以编程方式与该文件夹内容进行交互的权限。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code is set up like this because there are many GSuite APIs (drive, docs,
    sheets, slides etc) that we might want to use in future. They would all inherit
    from `GSuiteService` and have their `get_service` and `get_scopes` methods overwritten
    with the specific details of that API.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是这样设置的，因为未来我们可能需要使用许多 GSuite API（如 drive、docs、sheets、slides 等）。它们都会继承自 `GSuiteService`，并将它们的
    `get_service` 和 `get_scopes` 方法重写为该 API 的特定细节。
- en: Once this is all set up, you’re ready to interact with drive. This is a great
    [article](https://medium.com/@matheodaly.md/using-google-drive-api-with-python-and-a-service-account-d6ae1f6456c2)
    showing some of the main ways of doing so.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这一切设置完成，您就可以开始与 Google Drive 进行交互了。这是一篇很棒的[文章](https://medium.com/@matheodaly.md/using-google-drive-api-with-python-and-a-service-account-d6ae1f6456c2)，展示了几种主要的操作方法。
- en: In our implementation, the way we’ll interact with drive is via methods of `GoogleDriveHelper`
    , which creates an instance of `GoogleDriveService` on initialization. We start
    with giving it the name of our master folder
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现中，我们与 Google Drive 的交互方式是通过 `GoogleDriveHelper` 的方法，该方法在初始化时创建一个 `GoogleDriveService`
    实例。我们首先为它提供我们的主文件夹的名称。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let’s say we want to create a project about the Voyager series of space
    probes, for example. We can get organized by setting up a folder for that inside
    the master folder:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想创建一个关于“旅行者”系列太空探测器的项目。我们可以通过在主文件夹中设置一个文件夹来进行组织：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates the folder and returns its ID, which we can use to create a document
    there. There might be multiple versions of this project, so we can also make relevant
    subfolders
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个文件夹并返回其ID，我们可以利用这个ID在文件夹中创建文档。这个项目可能有多个版本，所以我们也可以创建相关的子文件夹。
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we’re ready to make a blank document, which we can also do with the drive
    service
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建一个空白文档，这也可以通过驱动服务来完成。
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Under the hood, the drive helper is running the following code, which passes
    some metadata indicating that we want to make a document to the create method
    of `googleapiclient.discovery.build` (i.e. what comes out of running `GoogleDriveService().build()`
    )
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，驱动助手运行以下代码，它传递了一些元数据，指示我们要通过`googleapiclient.discovery.build`的创建方法来创建文档（即运行`GoogleDriveService().build()`时返回的内容）。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you might imagine, the Google Drive API has a lot of different functionality
    and options that we’re not covering here. The most comprehensive python wrapper
    for it that I’ve found is [this one](https://github.com/iterative/PyDrive2), which
    would be a good starting point if you want to explore further.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能想象的那样，Google Drive API有很多不同的功能和选项，我们在这里并没有涉及。到目前为止，我找到的最全面的Python封装库是[这个](https://github.com/iterative/PyDrive2)，如果你想进一步探索，这是一个很好的起点。
- en: '**3\. Writing to Google Docs**'
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**3\. 写入Google Docs**'
- en: Now that we’ve made a blank document, let’s fill it with the final essay! This
    is where the `GoogleDocsService` and `GoogleDocsHelper` come in. `GoogleDocsService`
    is very similar to `GoogleDriveService` , and also inherits from `GSuiteService`
    as we discussed in section 2\. `GoogleDocsHelper` contains some tools to write
    text and images to Google Docs. They’re very basic right now, but thats all we
    need for this project.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个空白文档，接下来让我们用最终的文章填充它！这时`GoogleDocsService`和`GoogleDocsHelper`就派上用场了。`GoogleDocsService`与`GoogleDriveService`非常相似，也继承自我们在第二节中讨论过的`GSuiteService`。`GoogleDocsHelper`包含一些工具，可以将文本和图像写入Google
    Docs。它们现在非常基础，但对于这个项目来说已经足够了。
- en: We can first use the agent we built in part 1 to write an essay about Voyager
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以首先使用我们在第一部分中构建的代理来写一篇关于“旅行者”的文章。
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Recall that the various outputs of the agent are stored in its memory, which
    can be explored with the following. In the code, you can see that we’re using
    “user_id = 1” as a placeholder here, but in an application that has multiple users
    this id would allow the model to access the correct memory store.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，代理的各种输出会存储在它的内存中，可以通过以下方式进行探索。在代码中，你可以看到我们在这里使用“user_id = 1”作为占位符，但在有多个用户的应用程序中，这个ID将允许模型访问正确的内存存储。
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The final report text can be found here, with the key names corresponding to
    the AgentState that we discussed in part 1\. It’s at index -3 because it’s followed
    by a call to the editor node (which said yes) and the accept node, which right
    now just returns “True”. The accept node could be easily be extended to actually
    write this report to a doc automatically.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最终报告的文本可以在这里找到，关键名称与我们在第一部分中讨论过的AgentState相对应。它位于索引-3的位置，因为它后面跟着一个调用编辑器节点（它返回了“是”）和接受节点，当前接受节点只是返回“True”。接受节点可以很容易地扩展，实际上将这个报告自动写入文档。
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let’s see how we can put this text in a google doc. Recall that in section 2
    we made a blank document with `doc_id` . There are two basic methods of `GoogleDocsHelper`
    which can do this. The first is designed to provide a title and basic metadata,
    which is just the date and time at which the document was written. The second
    will paste some text into the document.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将这些文本放入Google文档中。回想一下，在第二节中我们用`doc_id`创建了一个空白文档。`GoogleDocsHelper`有两个基本方法可以做到这一点。第一个方法用于提供标题和基本元数据，基本上就是文档编写的日期和时间。第二个方法则是将文本粘贴到文档中。
- en: The code shows how to control aspects of the position and formatting of the
    text, which can be a bit confusing. We define a list of requests containing instructions
    like `insertText` . When we insert text, we need to provide the index at which
    to start the insertion, which corresponds to a position in the document.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码展示了如何控制文本的位置和格式，可能会有些混淆。我们定义了一个请求列表，包含像`insertText`这样的指令。当我们插入文本时，我们需要提供开始插入的索引，它对应于文档中的某个位置。
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can learn more about how indices are defined [here](https://developers.google.com/docs/api/concepts/structure#indexes).
    When multiple `insertText` calls, it appears to be easier to write the last piece
    of text first — for example in the code below `template` (which is the metadata
    that’s supposed to appear below the title) appears first in the list at index
    1\. Then we write `title` at index 1\. This results in `title` appearing first
    in the document and `template` appearing below. Note how we also need to specify
    the `startIndex` and `endIndex` of the `paragraphStyle` blocks in order to change
    the formatting of the text.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[这里](https://developers.google.com/docs/api/concepts/structure#indexes)了解有关索引如何定义的更多信息。当有多个
    `insertText` 调用时，似乎先写最后一段文本更容易——例如在下面的代码中，`template`（即应出现在标题下方的元数据）首先出现在索引 1 的列表中。然后我们在索引
    1 写入 `title`。这导致 `title` 在文档中首先出现，而 `template` 出现在其下方。注意，我们还需要指定 `paragraphStyle`
    块的 `startIndex` 和 `endIndex`，才能改变文本的格式。
- en: Both methods in the code above return the end index of the current block of
    text so that it can be used as the start index of subsequent blocks to be appended.
    If you intend to get more creative with the style and formatting of documents,
    this [guide](https://developers.google.com/docs/api/concepts/document) will likely
    help.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上面代码中的两种方法都会返回当前文本块的结束索引，以便它可以用作后续要附加文本块的起始索引。如果你打算在文档的样式和格式上更加富有创意，这份[指南](https://developers.google.com/docs/api/concepts/document)可能会有所帮助。
- en: Now that we’ve seen the underlying code, we can call it to write our final report
    to a document.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了底层代码，我们可以调用它来将最终报告写入文档。
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Great! Now we have all the tools of docs at our disposal to edit, format and
    share the report that our agent generated. Interestingly, the agent formatted
    the text as markdown which is supported by Google Docs, but I was unable to find
    a way to get the document to automatically recognize this and convert the markdown
    into nice headers and subheaders. No doubt there is a way to do that and it would
    make the reports look much nicer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有了所有文档工具，可以用来编辑、格式化并分享我们的代理生成的报告。有趣的是，代理将文本格式化为 markdown，而 Google Docs
    支持这种格式，但我没能找到一种方法来让文档自动识别并将 markdown 转换为漂亮的标题和副标题。毫无疑问，一定有办法做到这一点，这样报告看起来会更漂亮。
- en: After running the code above, the doc should look something like this.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上面的代码后，文档应该会呈现如下所示的内容。
- en: '![](../Images/dd497a4dcc365990a44e1855caaf2128.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dd497a4dcc365990a44e1855caaf2128.png)'
- en: Screenshot of the document containing the agent-generated final report. Image
    generated by the author
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 包含代理生成的最终报告的文档截图。图像由作者生成
- en: '**4\. What about the other agent outputs?**'
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**4. 那么其他代理输出呢？**'
- en: 'We should be able to write all the information thats stored in the agent memory
    to docs, which will allow us to easily browse through the results of each stage.
    A somewhat hacky way to do this is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够将代理内存中存储的所有信息写入文档，这样我们就可以轻松浏览每个阶段的结果。一种稍微黑客一点的方式如下：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is going to make 7 documents, and we’ll take a look at some example screenshots
    below
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成 7 个文档，下面我们将查看一些示例截图。
- en: '![](../Images/e354c6d90ddac665527ba3f8e7124e08.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e354c6d90ddac665527ba3f8e7124e08.png)'
- en: Outputs from the running the code above. Image generated by the author
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码的输出。图像由作者生成
- en: The initial plan outlines the structure of the report. It’s interesting that
    the model seems to favor lots of short sections, which I think is appropriate
    given the prompt request to make it concise and digestible to a general readership.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 初步计划概述了报告的结构。有趣的是，模型似乎更倾向于使用大量简短的章节，我认为这很合适，因为提示要求将报告做得简洁且易于普通读者消化。
- en: '![](../Images/3a7eb62fe4a38648c0866643ef27dede.png)![](../Images/9b48c7b1ec4952ca764da720e9929c35.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3a7eb62fe4a38648c0866643ef27dede.png)![](../Images/9b48c7b1ec4952ca764da720e9929c35.png)'
- en: Screenshots of part of the initial plan and research documents written by the
    code snippet above. Images generated by the author.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段编写的初步计划和研究文档的部分截图。图像由作者生成。
- en: At the research phase, Tavily search is called and returns small chunks of nicely
    formatted text relevant to the queries that were used. Some of these chunks are
    truncated and this document is not especially readable, but it gives a good sense
    of the type of information that is passing from the research node to the write
    node.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究阶段，调用了 Tavily 搜索，并返回了与使用的查询相关的格式良好的小块文本。其中一些小块被截断，这使得文档不太易读，但它很好地展示了从研究节点到写作节点传递的信息类型。
- en: At the review phase, we get an eloquent criticism of the first version of the
    essay. Typically these reviews are structured similarly to the initial plan and
    make a lot of very general recommendations such as “consider using more descriptive
    titles” or “this section could be expanded to include more examples”. If we compare
    the actual reports before and after the reviews, we typically see only minor changes
    to the stucture and some additional details in each of the sections. The extent
    to which this actually improves the quality of the text is debatable, but from
    trying it out on a few examples I am convinced that it does help.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在审阅阶段，我们得到了对文章第一版本的精彩批评。通常这些审阅的结构与初始计划类似，提出许多非常笼统的建议，如“考虑使用更具描述性的标题”或“这一部分可以扩展，增加更多例子”。如果我们比较审阅前后的实际报告，通常会看到结构上的微小变化以及每个部分中增加的一些细节。这是否真正提高了文本的质量值得商榷，但通过在几个例子中进行尝试，我相信它确实有所帮助。
- en: '![](../Images/a1dd4e1dc0e37f1c84a80d1535b14765.png)![](../Images/0184229a9da34e4de535a5b1c7c25d0b.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a1dd4e1dc0e37f1c84a80d1535b14765.png)![](../Images/0184229a9da34e4de535a5b1c7c25d0b.png)'
- en: Screenshots of part of the review and editor response documents written by the
    code snippet above. Images generated by the author.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过上述代码片段生成的部分审阅和编辑反馈文档的截图。图片由作者生成。
- en: Finally, we get the editor’s judgement on the post-review draft. The prompt
    I am currently using makes the editor rather lenient, so it usually says something
    to the effect of whats shown here. With some prompt tweaks we could encourage
    it to send more reports back to review if desirable.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到了编辑对审阅后草稿的判断。我目前使用的提示使得编辑相当宽容，因此它通常会说一些类似这里所示的内容。通过调整一些提示，我们可以鼓励它在需要时将更多的报告发送回审阅。
- en: That’s it for this article and this mini series. Thanks for reading and I hope
    you find some of this useful for your own projects. There are lots of potential
    extensions here in terms of making the research agent more robust, a proper evaluation
    of its outputs and better integrations with Docs (or other GSuite APIs). Please
    let me know if you have any other cool ideas!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本文及本小系列的全部内容。感谢阅读，希望你能从中找到一些对你自己项目有用的内容。在让研究代理更加健壮、对其输出进行适当评估以及更好地与Docs（或其他GSuite
    API）集成方面，这里有很多潜在的扩展。如果你有任何其他酷炫的想法，请告诉我！
- en: The author is unaffiliated with any of the tools discussed in this article.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作者与本文讨论的任何工具没有关联。

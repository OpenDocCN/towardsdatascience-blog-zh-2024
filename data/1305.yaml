- en: Practical Computer Simulations for Product Analysts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向产品分析师的实用计算机仿真
- en: 原文：[https://towardsdatascience.com/practical-computer-simulations-for-product-analysts-fe61e2b577f5?source=collection_archive---------8-----------------------#2024-05-24](https://towardsdatascience.com/practical-computer-simulations-for-product-analysts-fe61e2b577f5?source=collection_archive---------8-----------------------#2024-05-24)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/practical-computer-simulations-for-product-analysts-fe61e2b577f5?source=collection_archive---------8-----------------------#2024-05-24](https://towardsdatascience.com/practical-computer-simulations-for-product-analysts-fe61e2b577f5?source=collection_archive---------8-----------------------#2024-05-24)
- en: 'Part 3: Modelling Ops queues'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分：建模运营队列
- en: '[](https://miptgirl.medium.com/?source=post_page---byline--fe61e2b577f5--------------------------------)[![Mariya
    Mansurova](../Images/b1dd377b0a1887db900cc5108bca8ea8.png)](https://miptgirl.medium.com/?source=post_page---byline--fe61e2b577f5--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--fe61e2b577f5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--fe61e2b577f5--------------------------------)
    [Mariya Mansurova](https://miptgirl.medium.com/?source=post_page---byline--fe61e2b577f5--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://miptgirl.medium.com/?source=post_page---byline--fe61e2b577f5--------------------------------)[![Mariya
    Mansurova](../Images/b1dd377b0a1887db900cc5108bca8ea8.png)](https://miptgirl.medium.com/?source=post_page---byline--fe61e2b577f5--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--fe61e2b577f5--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--fe61e2b577f5--------------------------------)
    [Mariya Mansurova](https://miptgirl.medium.com/?source=post_page---byline--fe61e2b577f5--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--fe61e2b577f5--------------------------------)
    ·23 min read·May 24, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发布于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--fe61e2b577f5--------------------------------)
    ·阅读时长23分钟·2024年5月24日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/71a5c5982659d4e38fd756c9ae246157.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/71a5c5982659d4e38fd756c9ae246157.png)'
- en: Image by DALL-E 3
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图像由DALL-E 3生成
- en: Today, I would like to show you an example of the discrete-event simulation
    approach. We will model the Customer Support team and decide what strategy to
    use to improve its performance. But first, let me share a bit of my personal story.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我想给大家展示一个离散事件仿真方法的例子。我们将模拟客户支持团队，并决定采用何种策略来提高其绩效。但首先，请允许我分享一下我的个人经历。
- en: I first learned about discrete simulations at university. One of my subjects
    was [Queueing theory](https://en.wikipedia.org/wiki/Queueing_theory), and to get
    a final grade for it, I had to implement the airport simulation and calculate
    some KPIs. Unfortunately, I missed all the seminars because I was already working
    full-time, so I had no idea about the theory behind this topic and how to approach
    it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次在大学里学习离散仿真。我的一门课程是[排队论](https://en.wikipedia.org/wiki/Queueing_theory)，为了获得期末成绩，我需要实现一个机场仿真并计算一些关键绩效指标（KPI）。不幸的是，由于我已经全职工作，我错过了所有的研讨会，因此对这一主题背后的理论以及如何进行操作毫无头绪。
- en: I was determined to get an excellent mark, so I found a book, read it, understood
    the basics and spent a couple of evenings on implementation. It was pretty challenging
    since I hadn’t been coding for some time, but I figured it out and got my A grade.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我下定决心要获得一个优异的成绩，因此找了一本书，读懂了基础知识，并花了几个晚上进行实现。虽然这对我来说相当有挑战性，因为一段时间没写代码了，但我还是搞明白了，并且得到了A的成绩。
- en: At this point (as often happens with students), I had a feeling that this information
    wouldn't be helpful for my future work. However, later, I realised that many analytical
    tasks can be solved with this approach. So, I would like to share it with you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在那时（就像很多学生一样），我感觉这些信息对我未来的工作没有什么帮助。然而，后来我意识到，许多分析性任务都可以通过这种方法来解决。所以，我想和大家分享这个方法。
- en: 'One of the most apparent use cases for agent-based simulations is Operational
    analytics. Most products have customer support where clients can get help. A CS
    team often looks at such metrics as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代理基础仿真最明显的应用场景之一是运营分析。大多数产品都有客户支持，客户可以在此寻求帮助。客户支持团队通常会关注以下指标：
- en: '***average resolution time*** — how much time passed from the customer reaching
    out to CS and getting the first answer,'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***平均解决时间*** — 客户向客服提出问题到收到第一次回复所经历的时间，'
- en: '***size of the queue*** that shows how many tasks we have in a backlog right
    now.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***队列大小***，即目前我们积压了多少任务。'
- en: Without a proper model, it may be tricky to understand how our changes (i.e.
    introducing night shifts or just increasing the number of agents) will affect
    the KPIs. Simulations will help us do it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 没有适当的模型，理解我们的变化（例如，增加夜班或仅仅增加代理数量）如何影响 KPI 可能会比较困难。模拟将帮助我们做到这一点。
- en: So, let’s not waste our time and move on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们不要浪费时间，继续前进。
- en: Basics of simulations and modelling
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟和建模的基础
- en: Let’s start from the very beginning. We will be modelling***the system***. The
    system is a collection of entities (for example, people, servers or even mechanical
    tools) that interact with each other to achieve some logical goal (i.e. answering
    a customer question or passing border control in an airport).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从最开始开始。我们将建模***系统***。系统是一个由实体（例如人、服务器甚至机械工具）组成的集合，这些实体相互作用以实现某个逻辑目标（即回答客户问题或通过机场的边检）。
- en: You could define the system with the needed granularity level, depending on
    your research goal. For example, in our case, we would like to investigate how
    the changes to agents’ efficiency and schedules could affect average CS ticket
    resolution time. So, the system will be just a set of agents. However, if we would
    like to model the possibility of outsourcing some tickets to different outsourcing
    companies, we will need to include these partners in our model.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据研究目标定义系统所需的粒度级别。例如，在我们的案例中，我们希望研究代理的效率和时间表的变化如何影响平均的 CS 工单解决时间。因此，系统将仅是一个代理集合。然而，如果我们想要模拟将一些工单外包给不同的外包公司，我们就需要在模型中包含这些合作伙伴。
- en: The system is described by a set of variables — for example, the number of tickets
    in a queue or the number of agents working at the moment in time. These variables
    define ***the system state***.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 系统由一组变量描述——例如队列中的工单数量或当前在工作时刻的代理数量。这些变量定义了***系统状态***。
- en: 'There are two types of systems:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 系统有两种类型：
- en: '***discrete*** *—* when the system state changes instantaneously, for example,
    the new ticket has been added to a queue or an agent has finished their shift.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***离散*** *—* 当系统状态瞬间发生变化时，例如，新的工单被添加到队列中，或者代理完成了他们的班次。'
- en: '***continuous —*** when the system is constantly evolving*.* One such example
    is a flying plane, in which coordinates, velocity, height, and other parameters
    change all the time during flight.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***连续——***当系统不断演变时。例如，飞行中的飞机，坐标、速度、高度等参数在飞行过程中持续变化。'
- en: For our task, we can treat the system as discrete and use ***the******discrete-event
    simulation approach***. It's a case when the system can change at only a countable
    number of points in time. These time points are where events occur and instantly
    change the system state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的任务，我们可以将系统视为离散的，并使用***离散事件模拟方法***。这是指系统只能在有限的时间点发生变化。这些时间点是事件发生的时刻，并立即改变系统状态。
- en: So, the whole approach is based on events. We will generate and process events
    one by one to simulate how the system works. We can use the concept of a timeline
    to structure events.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整个方法基于事件。我们将逐一生成和处理事件，以模拟系统如何运作。我们可以使用时间线的概念来结构化事件。
- en: Since this process is dynamic, we need to keep track of the current value of
    simulated time and be able to advance it from one value to another. The variable
    in a simulation model that shows the current time is often called ***the simulation
    clock***.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个过程是动态的，我们需要跟踪模拟时间的当前值，并能够将其从一个值推进到另一个值。在模拟模型中，显示当前时间的变量通常称为***模拟时钟***。
- en: 'We also need a mechanism to advance simulated time. There are two approaches
    to advance time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个机制来推进模拟时间。推进时间有两种方法：
- en: '***next-event time advance*** — we are moving from one event timestamp to the
    next one,'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***下一事件时间推进*** — 我们从一个事件的时间戳移动到下一个事件的时间戳。'
- en: '***fixed-increment time advance*** — we select the period, for example, 1 minute,
    and shift clocks each time for this period.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***固定增量时间推进*** — 我们选择一个时间段，例如 1 分钟，每次按照这个时间段调整时钟。'
- en: I think the first approach is easier to understand, implement and debug. So,
    I will stick to it for this article.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为第一种方法更容易理解、实现和调试。因此，在本文中我将坚持使用这种方法。
- en: Let's review a simple example to understand how it works. We will discuss a
    simplified case of the CS tickets queue.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个简单的例子，理解它是如何运作的。我们将讨论一个简化的 CS 工单队列案例。
- en: We start the simulation, initialising the simulation clock. Sometimes, people
    use zero as the initial value. I prefer to use real-life data and the actual date
    times.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始模拟，初始化模拟时钟。有时候，人们会使用零作为初始值。我更喜欢使用真实的时间数据和实际的日期时间。
- en: Here's the initial state of our system. We have two events on our timeline related
    to two incoming customer requests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们系统的初始状态。我们的时间线上有两个与客户请求相关的事件。
- en: '![](../Images/dd95b05f1a22997ef9e856012f5d64c6.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/dd95b05f1a22997ef9e856012f5d64c6.png)'
- en: The next step is to advance the simulation clock to the first event on our timeline
    — the customer request at 9:15.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将模拟时钟推进到我们的时间线上的第一个事件——9:15的客户请求。
- en: '![](../Images/31f4bc945689d456b0ed1715677cc691.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/31f4bc945689d456b0ed1715677cc691.png)'
- en: It's time to process this event. We should find an agent to work on this request,
    assign the request to them, and generate an event to finish the task. Events are
    the main drivers of our simulation, so it's okay if one event creates another
    one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是处理这个事件的时候了。我们应该找到一个代理来处理这个请求，分配请求给他们，并生成一个完成任务的事件。事件是我们模拟的主要驱动力，所以如果一个事件创造了另一个事件是可以的。
- en: Looking at the updated timeline, we can see that the most imminent event is
    not the second customer request but the completion of the first task.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 查看更新后的时间线，我们可以看到，最紧迫的事件不是第二个客户请求，而是第一个任务的完成。
- en: '![](../Images/39e090293ad9228610e4c0829fc9c08c.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/39e090293ad9228610e4c0829fc9c08c.png)'
- en: So, we need to advance our clock to 9:30 and process the next event. The completion
    of the request won't create new events, so after that, we will move to the second
    customer request.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要将时钟推进到9:30，并处理下一个事件。请求的完成不会创造新的事件，因此在此之后，我们将转到第二个客户请求。
- en: '![](../Images/cef08b7308d87f030a8239ecdf7ccdd0.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/cef08b7308d87f030a8239ecdf7ccdd0.png)'
- en: We will repeat this process of moving from one event to another until the end
    of the simulation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重复这个从一个事件到另一个事件的过程，直到模拟结束。
- en: 'To avoid never-ending processes, we need to define the stopping criteria. In
    this case, we can use the following logic: if no more events are on the timeline,
    we should stop the simulation. In this simplified example, our simulation will
    stop after finishing the second task.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免无限循环的过程，我们需要定义停止标准。在这种情况下，我们可以使用以下逻辑：如果时间线上没有更多事件，我们应该停止模拟。在这个简化的例子中，我们的模拟将在完成第二个任务后停止。
- en: We've discussed the theory of discrete event simulations and understood how
    it works. Now, it's time to practice and implement this approach in code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了离散事件模拟的理论，并理解了它是如何工作的。现在，是时候实践并在代码中实现这种方法了。
- en: The program architecture
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序架构
- en: Objective-oriented programming
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: In my day-to-day job, I usually use a procedural programming paradigm. I create
    functions for some repetitive tasks, but rather than that, my code is quite linear.
    It's pretty standard approach for data-wrangling tasks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的日常工作中，我通常使用过程式编程范式。我为一些重复性的任务创建函数，但除此之外，我的代码是相当线性的。这是数据处理任务中的一种标准方法。
- en: In this example, we would use [Objective-Oriented Programming](https://en.wikipedia.org/wiki/Object-oriented_programming).
    So, let's spend some time revising this topic if you haven’t used classes in Python
    before or need a refresher.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用[面向对象编程](https://en.wikipedia.org/wiki/Object-oriented_programming)。所以，如果你之前没有使用过
    Python 类，或者需要复习一下这个主题，那就花点时间来复习它吧。
- en: 'OOP is based on the concept of objects. Objects consist of data (some features
    that are called attributes) and actions (functions or methods). The whole program
    describes the interactions between different objects. For example, if we have
    an object representing a CS agent, it can have the following properties:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）基于对象的概念。对象由数据（称为属性的某些特征）和行为（函数或方法）组成。整个程序描述了不同对象之间的交互。例如，如果我们有一个代表客户服务代理的对象，它可以具有以下属性：
- en: '***attributes***: name, date when an agent started working, average time they
    spend on tasks or current status (`"out of office"`, `"working on task"` or `"free"`).'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***属性***：名称、代理开始工作的日期、他们在任务上花费的平均时间或当前状态（`"out of office"`、`"working on task"`
    或 `"free"`）。'
- en: '***methods***: return the name, update the status or start processing a customer
    request.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***方法***：返回名称，更新状态或开始处理客户请求。'
- en: To represent such an object, we can use Python classes. Let's write a simple
    class for a CS agent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示这样的一个对象，我们可以使用 Python 类。让我们为客户服务代理编写一个简单的类。
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class defines each agent's name, average handling time, and role. I've
    also added a couple of functions that can return internal variables following
    the incapsulation pattern. Also, we have the `update_handling_time` function that
    allows us to update the agent’s performance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义了每个代理人的姓名、平均处理时间和角色。我还添加了一些可以返回内部变量的函数，遵循封装模式。另外，我们有一个`update_handling_time`函数，可以让我们更新代理人的表现。
- en: We've created a class (an object that explains any kind of CS agent). Let's
    make an instance of the object — the agent John Doe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类（一个解释任何类型CS代理的对象）。现在让我们创建该对象的实例——代理人John Doe。
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we created an instance of the class, the function `__init__` was executed.
    We can use `__dict__` property to present class fields as a dictionary. It often
    can be handy, for example, if you want to convert a list of objects into a data
    frame.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建类的实例时，`__init__`函数会被执行。我们可以使用`__dict__`属性将类字段以字典的形式展示出来。这在很多情况下都很有用，例如，如果你想把一系列对象转换为数据框架。
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can try to execute a method and update the agent’s performance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试执行一个方法并更新代理人的表现。
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: One of the fundamental concepts of OOP that we will use today is inheritance.
    Inheritance allows us to have a high-level ancestor class and use its features
    in the descendant classes. Imagine we want to have not only CS agents but also
    KYC agents. We can create a high-level `Agent` class with common functionality
    and define it only once for both KYC and CS agents.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们将使用的面向对象编程的基本概念之一是继承。继承允许我们有一个高层的祖先类，并在子类中使用其特性。想象一下，我们不仅想要CS代理人，还想要KYC代理人。我们可以创建一个高层的`Agent`类，包含共同功能，并仅为KYC和CS代理人定义一次。
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we can create separate classes for these agent types and define slightly
    different `__init__` and `get_job_description` functions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为这些代理类型创建独立的类，并定义稍微不同的`__init__`和`get_job_description`函数。
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To specify inheritance, we mentioned the base class in brackets after the current
    class name. With `super()` , we can call the base class methods, for example,
    `__init__` to create an object with a custom `role` value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定继承关系，我们在当前类名后面的括号中提到基类。使用`super()`，我们可以调用基类的方法，例如`__init__`，用自定义的`role`值创建对象。
- en: Let's create objects and check whether they work as expected.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建对象并检查它们是否按预期工作。
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's update Marie's handling time. Even though we haven’t implemented this
    function in the `KYCAgent` class, it uses the implementation from the base class
    and works quite well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新Marie的处理时间。尽管我们没有在`KYCAgent`类中实现这个函数，它使用的是基类中的实现，效果很好。
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can also call the methods we defined in the classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以调用我们在类中定义的方法。
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, we've covered the basics of the Objective-oriented paradigm and Python classes.
    I hope it was a helpful refresher.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经涵盖了面向对象编程范式和Python类的基础。我希望这对你有所帮助，起到了复习作用。
- en: Now, it’s time to return to our task and the model we need for our simulation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候回到我们的任务和我们需要的仿真模型了。
- en: 'Architecture: classes'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构：类
- en: If you haven’t used OOP a lot before, switching your mindset from procedures
    to objects might be challenging. It takes some time to make this mindset shift.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没怎么使用过面向对象编程，可能会觉得从过程式编程切换到面向对象编程有些困难。这需要一些时间来完成思维方式的转变。
- en: One of the life hacks is to use real-world analogies (i.e. it's pretty clear
    that an agent is an object with some features and actions).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个生活小窍门是使用现实世界的类比（例如，很明显代理人是一个具有一些特征和行为的对象）。
- en: 'Also, don''t be afraid to make a mistake. There are better or worse program
    architectures: some will be easier to read and support over time. However, there
    are a lot of debates about the best practices, even among mature software engineers,
    so I wouldn’t bother trying to make it perfect too much for analytical ad-hoc
    research.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，不要害怕犯错。程序架构有好有坏：有些架构随时间推移更容易阅读和维护。然而，即使在成熟的软件工程师之间，对于最佳实践也有很多争论，所以我建议不要过于纠结于让它在分析性临时研究中变得完美。
- en: 'Let''s think about what objects we need in our simulation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下在仿真中需要哪些对象：
- en: '`System` — the most high-level concept we have in our task. The system will
    represent the current state and execute the simulation.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System`——我们任务中最顶层的概念。系统将表示当前状态并执行仿真。'
- en: As we discussed before, the system is a collection of entities. So, the next
    object we need is `Agent` . This class will describe agents working on tasks.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，系统是一个实体的集合。因此，我们需要的下一个对象是`Agent`。这个类将描述在任务中工作的代理人。
- en: 'Each agent will have its schedule: hours when this agent is working, so I''ve
    isolated it into a separate class `Schedule`.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个代理人都有自己的时间表：代理人工作的小时数，所以我将其提取到一个单独的类`Schedule`中。
- en: Our agents will be working on customer requests. So, it's a no-brainer— we need
    to represent them in our system. Also, we will store a list of processed requests
    in the `System` object to get the final stats after the simulation.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代理人将处理客户请求。所以，这不言而喻——我们需要在系统中表示它们。此外，我们将在`System`对象中存储一个已处理请求的列表，以便在仿真结束后获取最终统计数据。
- en: If no free agent picks up a new customer request, it will be put into a queue.
    So, we will have a `RequestQueue` as an object to store all customer requests
    with the FIFO logic (First In, First Out).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有空闲的代理人接手新的客户请求，该请求将被放入队列中。因此，我们将拥有一个`RequestQueue`对象来存储所有客户请求，采用FIFO逻辑（先进先出）。
- en: The following important concept is `TimeLine` that represents the set of events
    we need to process ordered by time.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个重要的概念，即`TimeLine`，它代表了我们需要按时间顺序处理的事件集合。
- en: '`TimeLine` will include events, so we will also create a class `Event` for
    them. Since we will have a bunch of different event types that we need to process
    differently, we can leverage the OOP inheritance. We will discuss event types
    in more detail in the next section.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TimeLine`将包括事件，因此我们也将为它们创建一个`Event`类。由于我们将有许多不同类型的事件需要以不同方式处理，我们可以利用面向对象编程的继承机制。我们将在下一节中更详细地讨论事件类型。'
- en: That's it. I’ve put all the classes and links between them into a diagram to
    clarify it. I use such charts to have a high-level view of the system before starting
    the implementation — it helps to think about the architecture early on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我已经把所有的类和它们之间的关系放入了图表中，以便更清晰地表达它。在开始实现之前，我使用这样的图表来获得系统的高层次视图——它有助于提前考虑架构。
- en: '![](../Images/b29d63495089da7a70b25081a396022f.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b29d63495089da7a70b25081a396022f.png)'
- en: As you might have noticed, the diagram is not super detailed. For example, it
    doesn’t include all field names and methods. It's intentional. This schema will
    be used as a helicopter view to guide the development. So, I don't want to spend
    too much time writing down all the field and method names because these details
    might change during the implementation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，图表并不是特别详细。例如，它没有包含所有字段名称和方法。这是故意的。这个架构将作为一个宏观视图来指导开发。因此，我不想花太多时间列出所有字段和方法的名称，因为这些细节可能会在实现过程中发生变化。
- en: 'Architecture: event types'
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构：事件类型
- en: We've covered the program architecture, and now it's time to think about the
    main drivers of our simulation — events.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了程序架构，现在是时候思考我们仿真的主要驱动因素——事件。
- en: Let's discuss what events we need to generate to keep our system working.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们需要生成哪些事件来保持系统的运转。
- en: The event I will start with is the "*Agent Ready*" event. It shows that an agent
    starts their work and is ready to pick up a task (if we have any waiting in the
    queue).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将从"*Agent Ready*"事件开始。它表示代理人开始工作并准备接手任务（如果队列中有等待的任务）。
- en: We need to know when agents start working. These working hours can depend on
    an agent and the day of the week. Potentially, we might even want to change the
    schedules during the simulation. It's pretty challenging to create all "*Agent
    Ready*" events when we initialise the system (especially since we don't know how
    much time we need to finish the simulation). So, I propose a recurrent "*Plan
    Agents Schedule*" event to create ready-to-work events for the next day.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要知道代理人何时开始工作。这些工作时间可以依赖于代理人以及星期几。可能的话，我们甚至希望在仿真过程中更改这些时间表。由于在系统初始化时我们并不知道完成仿真需要多长时间，创建所有的"*Agent
    Ready*"事件是相当具有挑战性的。因此，我建议使用一个周期性的"*Plan Agents Schedule*"事件来为第二天创建准备工作的事件。
- en: The other essential event we need is a "*New Customer Request*" — an event that
    shows that we got a new CS contact, and we need to either start working on it
    or put it in a queue.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个必不可少的事件是"*New Customer Request*"——一个表示我们收到了新的客户服务请求，我们需要么开始处理它，么将其放入队列中的事件。
- en: The last event is "*Agent Finished Task*", which shows that the agent finished
    the task he was working on and is potentially ready to pick up a new task.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的事件是"*Agent Finished Task*"，它表示代理人完成了他正在处理的任务，并且可能准备好接手一个新的任务。
- en: That's it. These four events are enough to run the whole simulation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。这四个事件足以运行整个仿真。
- en: Similar to classes, there are no right or wrong answers for system modelling.
    You might use a slightly different set of events. For example, you can add a "*Start
    Task*" event to have it explicitly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于类的定义，对于系统建模没有对错之分。你可以使用略有不同的事件集。例如，你可以添加一个“*开始任务*”事件，以便明确表示。
- en: Implementation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: You can find the full implementation on [GitHub](https://github.com/miptgirl/miptgirl_medium/blob/main/simulations/queue_simulation.ipynb).
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在[GitHub](https://github.com/miptgirl/miptgirl_medium/blob/main/simulations/queue_simulation.ipynb)上找到完整的实现。
- en: We've defined the high-level structure of our solution, so we are ready to start
    implementing it. Let’s start with the heart of our simulation — the system class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们解决方案的高层结构，因此我们准备好开始实现它了。让我们从我们的仿真核心——系统类开始。
- en: Initialising the system
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化系统
- en: Let's start with the `__init__` method for the system class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从系统类的`__init__`方法开始。
- en: 'First, let''s think about the parameters we would like to specify for the simulation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下我们希望为仿真指定的参数：
- en: '`agents` — set of agents that will be working in the CS team,'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`agents` — 将在CS团队中工作的代理集，'
- en: '`queue` — the current queue of customer requests (if we have any),'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue` — 当前的客户请求队列（如果有的话），'
- en: '`initial_date` — since we agreed to use the actual timestamps instead of relative
    ones, I will specify the date when we start simulations,'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_date` — 由于我们同意使用实际时间戳而非相对时间戳，我将指定开始仿真的日期，'
- en: '`logging` — flag that defines whether we would like to print some info for
    debugging,'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logging` — 定义我们是否希望打印一些调试信息的标志，'
- en: '`customer_requests_df` — data frame with information about the set of customer
    requests we would like to process.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`customer_requests_df` — 包含我们希望处理的客户请求集的信息的数据框。'
- en: 'Besides input parameters, we will also create the following internal fields:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 除了输入参数，我们还将创建以下内部字段：
- en: '`current_time` — the simulation clock that we will initialise as 00:00:00 of
    the initial date specified,'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`current_time` — 我们将初始化为指定初始日期的00:00:00的仿真时钟，'
- en: '`timeline` object that we will use to define the order of events,'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeline`对象，我们将用它来定义事件的顺序，'
- en: '`processed_request` — an empty list where we will store the processed customer
    requests to get the data after simulation.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processed_request` — 一个空列表，我们将在其中存储处理过的客户请求，以便在仿真后获取数据。'
- en: 'It''s time to take the necessary actions to initialise a system. There are
    only two steps left:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候采取必要的行动来初始化系统了。只剩下两个步骤：
- en: Plan agents work for the first day. I’ll generate and process a corresponding
    event with an initial timestamp.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划代理在第一天工作。我将生成并处理一个带有初始时间戳的相应事件。
- en: Load customer requests by adding corresponding "*New Customer Request*" events
    to the timeline.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将相应的“*新客户请求*”事件添加到时间线上来加载客户请求。
- en: Here's the code that does all these actions to initialise the system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行所有这些初始化系统操作的代码。
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's not working yet since it has links to non-implemented classes and methods,
    but we will cover it all one by one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它还没有工作，因为它链接到一些未实现的类和方法，但我们会逐一解决这些问题。
- en: Timeline
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间线
- en: 'Let''s start with the classes we used in the system definition. The first one
    is `TimeLine` . The only field it has is the list of events. Also, it implements
    a bunch of methods:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从系统定义中使用的类开始。第一个是`TimeLine`。它唯一的字段是事件列表。此外，它实现了一些方法：
- en: adding events (and ensuring that they are ordered chronologically),
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加事件（并确保它们按时间顺序排列），
- en: returning the next event and deleting it from the list,
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回下一个事件并将其从列表中删除，
- en: telling how many events are left.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示剩余的事件数量。
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Customer requests queue
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户请求队列
- en: The other class we used in initialisation is `RequestQueue`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在初始化中使用的另一个类是`RequestQueue`。
- en: 'There are no surprises: the request queue consists of customer requests. Let''s
    start with this building block. We know each request''s creation time and how
    much time an agent will need to work on it.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么意外的情况：请求队列由客户请求组成。让我们从这个构建块开始。我们知道每个请求的创建时间以及处理该请求时，代理需要多少时间。
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's a simple data class that contains only parameters. The only new thing here
    is that I've overridden the `__str__` method to change the output of a print function.
    It's pretty handy for debugging. You can compare it yourself.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个简单的数据类，仅包含参数。这里唯一的新内容是我重写了`__str__`方法，以改变打印函数的输出。这对调试非常有用。你可以自己比较。
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we can move on to the requests queue. Similarly to the timeline, we've
    implemented methods to add new requests, calculate requests in the queue and get
    the subsequent request from the queue.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续处理请求队列。与时间轴类似，我们实现了方法来添加新请求、计算队列中的请求并获取队列中的下一个请求。
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Agents
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: The other thing we need to initialise the system is agents. First, each agent
    has a schedule — a period when they are working depending on a weekday.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要初始化系统的另一件事是代理。首先，每个代理都有一个时间表——根据工作日来决定他们的工作时间。
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The only method we have for a schedule is whether at the specified moment the
    agent is working or not.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一有的关于时间表的方法是检查在指定时刻代理是否在工作。
- en: 'Let''s define the agent class. Each agent will have the following attributes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义代理类。每个代理将具有以下属性：
- en: '`id` and `name` — primarily for logging and debugging purposes,'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`和`name` — 主要用于日志记录和调试目的，'
- en: '`schedule` — the agent’s schedule object we’ve just defined,'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedule` — 我们刚刚定义的代理时间表对象，'
- en: '`request_in_work` — link to customer request object that shows whether an agent
    is occupied right now or not.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request_in_work` — 连接到客户请求对象，显示代理当前是否忙碌。'
- en: '`effectiveness` — the coefficient that shows how efficient the agent is compared
    to the expected time to solve the particular task.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`effectiveness` — 显示代理与解决特定任务的预期时间相比效率的系数。'
- en: 'We have the following methods implemented for agents:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为代理实现了以下方法：
- en: understanding whether they can take on a new task (whether they are free and
    still working),
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解他们是否能接受新的任务（即他们是否空闲并仍在工作）。
- en: start and finish processing the customer request.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和结束处理客户请求。
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Loading initial customer requests to the timeline
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将初始客户请求加载到时间轴中
- en: The only thing we are missing from the system `__init__` function (besides the
    events processing that we will discuss in detail a bit later) is `load_customer_request_events`
    function implementation. It's pretty straightforward. We just need to add it to
    our `System` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在系统的`__init__`函数中唯一缺失的部分（除了稍后我们将详细讨论的事件处理）是`load_customer_request_events`函数的实现。这个相当直接。我们只需要将其添加到我们的`System`类中。
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Cool, we've figured out the primary classes. So, let's move on to the implementation
    of the events.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经弄清楚了主要类。那么，接下来我们就开始实现事件。
- en: Processing events
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件
- en: As discussed, I will use the inheritance approach and create an `Event` class.
    For now, it implements only `__init__` and `__str__` functions, but potentially,
    it can help us provide additional functionality for all events.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我将使用继承方法并创建一个`Event`类。目前，它只实现了`__init__`和`__str__`函数，但它可能帮助我们为所有事件提供额外的功能。
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Then, I implement a separate subclass for each event type that might have a
    bit different initialisation. For example, for the `AgentReady` event, we also
    have an `Agent` object. More than that, each Event class implements `process`
    method that takes `system` as an input.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我为每种可能具有略微不同初始化方式的事件类型实现了一个单独的子类。例如，对于`AgentReady`事件，我们还有一个`Agent`对象。更重要的是，每个事件类都实现了`process`方法，该方法以`system`作为输入。
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's actually it with the events processing business logic. The only bit we
    need to finish is to put everything together to run our simulation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，事件处理的业务逻辑就到此为止。我们需要完成的唯一部分就是将所有内容组合起来，运行我们的仿真。
- en: Putting all together in the system class
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在系统类中将所有内容整合在一起
- en: As we discussed, the `System` class will be in charge of running the simulations.
    So, we will put the remaining nuts and bolts there.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的那样，`System`类将负责运行仿真。因此，我们将在那里完成剩下的部分。
- en: 'Here''s the remaining code. Let me briefly walk you through the main points:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是剩余的代码。让我简要地向你介绍一下要点：
- en: '`is_simulation_finished` defines the stopping criteria for our simulation —
    no requests are in the queue, and no events are in the timeline.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_simulation_finished`定义了我们的仿真停止标准——队列中没有请求，且时间轴中没有事件。'
- en: '`process_next_event` gets the next event from the timeline and executes `process`
    for it. There''s a slight nuance here: we might end up in a situation where our
    simulation never ends because of recurring "*Plan Agents Schedule*" events. That''s
    why, in case of processing such an event type, I check whether there are any other
    events in the timeline and if not, I don''t process it since we don''t need to
    schedule agents anymore.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process_next_event`从时间线中获取下一个事件并对其执行`process`。这里有一个小细节：我们可能会遇到一种情况，模拟永远不会结束，因为"*Plan
    Agents Schedule*"事件不断发生。因此，在处理这种事件时，我会检查时间线中是否还有其他事件，如果没有，我就不再处理它，因为我们不再需要安排代理了。'
- en: '`run_simulation` is the function that rules our world, but since we have quite
    a decent architecture, it''s a couple of lines: we check whether we can finish
    the simulation, and if not, we process the next event.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run_simulation`是控制我们世界的函数，但由于我们的架构相当不错，它只有几行代码：我们检查是否能完成模拟，如果不能，我们就处理下一个事件。'
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It was a long journey, but we've done it. Amazing job! Now, we have all the
    logic we need. Let's move on to the funny part and use our model for analysis.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段漫长的旅程，但我们做到了。做得好！现在，我们拥有了所有需要的逻辑。让我们进入有趣的部分，使用我们的模型进行分析。
- en: You can find the full implementation on [GitHub](https://github.com/miptgirl/miptgirl_medium/blob/main/simulations/queue_simulation.ipynb).
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可以在[GitHub](https://github.com/miptgirl/miptgirl_medium/blob/main/simulations/queue_simulation.ipynb)上找到完整的实现。
- en: Analysis
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: I will use a synthetic Customer Requests dataset to simulate different Ops setups.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用一个合成的客户请求数据集来模拟不同的运营设置。
- en: '![](../Images/3766fb4263d15047736abfe15e6b3b64.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3766fb4263d15047736abfe15e6b3b64.png)'
- en: First of all, let's run our system and look at metrics. I will start with 15
    agents who are working regular hours.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们运行我们的系统并查看指标。我将从15个工作正常时间的代理开始。
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As a result of the execution, we got all the stats in `system.processed_requests`.
    Let's put together a couple of helper functions to analyse results easier.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 执行结果后，我们得到了`system.processed_requests`中的所有统计数据。让我们编写几个辅助函数，方便分析结果。
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Also, let's make a couple of charts and calculate weekly metrics.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们做几个图表并计算每周的指标。
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we can use this function to analyse the simulation results. Apparently,
    15 agents are not enough for our product since, after three weeks, we have 4K+
    requests in a queue and an average resolution time of around ten days. Customers
    would be very unhappy with our service if we had just 15 agents.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个函数来分析模拟结果。显然，15个代理对于我们的产品来说不够，因为经过三周后，我们队列中有超过4000个请求，平均解决时间大约是十天。如果我们只有15个代理，客户对我们的服务肯定会非常不满意。
- en: '![](../Images/f8de16ff06157ff13f33a00afa3c4fc4.png)![](../Images/febfa76237f01782abdc2d85c423424c.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f8de16ff06157ff13f33a00afa3c4fc4.png)![](../Images/febfa76237f01782abdc2d85c423424c.png)'
- en: Let's find out how many agents we need to be able to cope with the demand. We
    can run a bunch of simulations with the different number of agents and compare
    results.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出需要多少个代理才能应对需求。我们可以进行多个模拟，使用不同数量的代理并比较结果。
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see that from ~25–30 agents, metrics for different weeks are roughly
    the same, so there's enough capacity to handle incoming requests and queue is
    not growing week after week.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在大约25到30个代理的情况下，不同周的指标大致相同，因此有足够的容量来处理不断增加的请求，队列不会一周一周地增长。
- en: '![](../Images/e010166cb7d3325c2b92f2992fa55b4c.png)![](../Images/eefc26c7547bf7a3d19eda50a903becc.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e010166cb7d3325c2b92f2992fa55b4c.png)![](../Images/eefc26c7547bf7a3d19eda50a903becc.png)'
- en: If we model the situation when we have 30 agents, we can see that the queue
    is empty from 13:50 till the end of the working day from Tuesday to Friday. Agents
    spend Monday processing the huge queue we are gathering during weekends.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们模拟30个代理的情况，可以看到从星期二到星期五，队列从13:50开始一直到工作日结束都为空。代理们会在星期一处理我们在周末积累的大量队列。
- en: '![](../Images/28e8e206ea36958c081ae0b870719357.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/28e8e206ea36958c081ae0b870719357.png)'
- en: With such a setup, the average resolution time is 500.67 minutes, and the average
    queue length is 259.39.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置下，平均解决时间为500.67分钟，平均队列长度为259.39。
- en: 'Let''s try to think about the possible improvements for our Operations team:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试思考一些可能改善我们运营团队的方案：
- en: we can hire another five agents,
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以再雇佣五个代理，
- en: we can start leveraging LLMs and reduce handling time by 30%,
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以开始利用LLMs，减少30%的处理时间，
- en: we can shift agents' schedules to provide coverage during weekends and late
    hours.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以调整代理的工作时间表，以便在周末和晚间时段提供覆盖。
- en: Since we now have a model, we can easily estimate all the opportunities and
    pick the most feasible one.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们现在有了模型，我们可以轻松地估算所有机会并选择最可行的方案。
- en: The first two approaches are straightforward. Let's discuss how we can shift
    the agents' schedules. All our agents are working from Monday to Friday from 9
    to 18\. Let's try to make their coverage a little bit more equally distributed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法很简单。接下来我们讨论如何调整代理的工作时间安排。我们所有的代理都在周一至周五，从9点到18点工作。我们尝试让他们的覆盖时间分布更均匀一些。
- en: First, we can cover later and earlier hours, splitting agents into two groups.
    We will have agents working from 7 to 16 and from 11 to 20.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以覆盖更早和更晚的时间段，将代理分为两组。一组的工作时间是从7点到16点，另一组是从11点到20点。
- en: Second, we can split them across working days more evenly. I used quite a straightforward
    approach.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以更加均匀地分配他们的工作日。我使用了一种相当直接的方法。
- en: '![](../Images/58d97ada596f273dd5961143534c44e9.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/58d97ada596f273dd5961143534c44e9.png)'
- en: In reality, you can go even further and allocate fewer agents on weekends since
    we have way less demand. It can improve your metrics even further. However, the
    additional effect will be marginal.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以进一步减少周末的代理人数，因为我们在周末的需求要少得多。这可以进一步改善你的指标。然而，额外的效果会是边际性的。
- en: If we run simulations for all these scenarios, surprisingly, we will see that
    KPIs will be way better if we just change agents' schedules. If we hire five more
    people or improve agents' performance by 30%, we won't achieve such a significant
    improvement.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对所有这些情境进行仿真，令人惊讶的是，如果我们只是调整代理的工作时间，KPI会有显著的提升。如果我们再雇佣五个员工或提高代理的绩效30%，也无法取得如此显著的改善。
- en: '![](../Images/feab62766dc8914d050a73e643a049f1.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/feab62766dc8914d050a73e643a049f1.png)'
- en: Let's see how changes in agents' schedules affect our KPIs. Resolution time
    grows only for cases outside working hours (from 20 to 7), and queue size never
    reaches 200 cases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代理工作时间的变化如何影响我们的关键绩效指标（KPI）。分辨时间只会在非工作时间（从20点到7点）增长，队列大小也永远不会超过200个案件。
- en: '![](../Images/60dc8a0dd103e62122945661f028ea08.png)![](../Images/ec4402a2bc799068f60099f32244c5d2.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/60dc8a0dd103e62122945661f028ea08.png)![](../Images/ec4402a2bc799068f60099f32244c5d2.png)'
- en: That's an excellent result. Our simulation model has helped us prioritise operational
    changes instead of hiring more people or investing in LLM tool development.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的结果。我们的仿真模型帮助我们优先考虑运营变更，而不是雇佣更多员工或投资于大语言模型工具的开发。
- en: 'We''ve discussed the basics of this approach in this article. If you want to
    dig deeper and use it in practice, here are a couple more suggestions that might
    be useful:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本文中讨论了这种方法的基本原理。如果你想深入了解并将其应用于实践，这里有一些可能有用的建议：
- en: Before starting to use such models in production, it’s worth testing them. The
    most straightforward way is to model your current situation and compare the main
    KPIs. If they differ a lot, then your system doesn’t represent the real world
    well enough, and you need to make it more accurate before using it for decision-making.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开始将这些模型投入生产之前，值得先进行测试。最简单的方法是模拟你当前的状况，并比较主要KPI。如果它们相差很大，那么你的系统并没有很好地反映现实世界，你需要在决策前使其更加准确。
- en: The current metrics are customer-focused. I've used average resolution time
    as the primary KPI to make decisions. In business, we also care about costs. So,
    it's worth looking at this task from an operational perspective as well, i.e.
    measure the percentage of time when agents don't have tasks to work on (which
    means we are paying them for nothing).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的指标是以客户为中心的。我使用了平均解决时间作为主要KPI来做决策。在商业中，我们还关心成本。因此，从运营角度来看这个问题也是值得的，也就是说，衡量代理没有任务可做的时间百分比（这意味着我们在为他们支付薪水，但他们什么都不做）。
- en: In real life, there might be spikes (i.e. the number of customer requests has
    doubled because of a bug in your product), so I recommend you use such models
    to ensure that your CS team can handle such situations.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实生活中，可能会出现突发情况（例如，由于产品中的一个bug，客户请求数量翻倍），因此我建议你使用这些模型来确保你的客服团队能够应对这种情况。
- en: Last but not least, the model I've used was entirely deterministic (it returns
    the same result on every run), because handling time was defined for each customer
    request. To better understand metrics variability, you can specify the distribution
    of handling times (depending on the task type, day of the week, etc.) for each
    agent and get handling time from this distribution at each iteration. Then, you
    can run the simulation multiple times and calculate the confidence intervals of
    your metrics.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我使用的模型完全是确定性的（每次运行返回相同的结果），因为处理时间是为每个客户请求定义的。为了更好地理解指标的变动性，您可以为每个代理指定处理时间的分布（取决于任务类型、星期几等），并在每次迭代中从该分布中获取处理时间。然后，您可以多次运行仿真并计算您的指标的置信区间。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'So, let’s briefly summarise the main points we’ve discussed today:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们简要总结一下今天讨论的要点：
- en: We’ve learned the basics of the discrete-event simulation approach that helps
    to model discrete systems with a countable number of events.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学习了离散事件仿真方法的基础，这种方法有助于模拟具有可计数事件的离散系统。
- en: We’ve revised the object-oriented programming and classes in Python since this
    paradigm is more suitable for this task than the common procedural code data analysts
    usually use.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经复习了Python中的面向对象编程和类，因为这种范式比数据分析师通常使用的常规过程化代码更适合此任务。
- en: We’ve built the model of the CS team and were able to estimate the impact of
    different potential improvements on our KPIs (resolution time and queue size).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经构建了CS团队的模型，并能够估算不同潜在改进对我们的KPI（解决时间和队列大小）的影响。
- en: Thank you a lot for reading this article. If you have any follow-up questions
    or comments, please leave them in the comments section.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 非常感谢您阅读本文。如果您有任何后续问题或评论，请在评论区留言。
- en: Reference
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考
- en: '*All the images are produced by the author unless otherwise stated.*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非另有说明，否则所有图片均由作者制作。*'

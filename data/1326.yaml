- en: Algorithmic Thinking for Data Scientists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据科学家的算法思维
- en: 原文：[https://towardsdatascience.com/algorithmic-thinking-for-data-scientists-4601ac68496f?source=collection_archive---------1-----------------------#2024-05-28](https://towardsdatascience.com/algorithmic-thinking-for-data-scientists-4601ac68496f?source=collection_archive---------1-----------------------#2024-05-28)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/algorithmic-thinking-for-data-scientists-4601ac68496f?source=collection_archive---------1-----------------------#2024-05-28](https://towardsdatascience.com/algorithmic-thinking-for-data-scientists-4601ac68496f?source=collection_archive---------1-----------------------#2024-05-28)
- en: How to Write Code that Saves Time and Space
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何编写节省时间和空间的代码
- en: '[](https://kcpub21.medium.com/?source=post_page---byline--4601ac68496f--------------------------------)[![Chinmay
    Kakatkar](../Images/873531f24cd4ee8a927669a211d61ae8.png)](https://kcpub21.medium.com/?source=post_page---byline--4601ac68496f--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--4601ac68496f--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--4601ac68496f--------------------------------)
    [Chinmay Kakatkar](https://kcpub21.medium.com/?source=post_page---byline--4601ac68496f--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://kcpub21.medium.com/?source=post_page---byline--4601ac68496f--------------------------------)[![Chinmay
    Kakatkar](../Images/873531f24cd4ee8a927669a211d61ae8.png)](https://kcpub21.medium.com/?source=post_page---byline--4601ac68496f--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--4601ac68496f--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--4601ac68496f--------------------------------)
    [Chinmay Kakatkar](https://kcpub21.medium.com/?source=post_page---byline--4601ac68496f--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--4601ac68496f--------------------------------)
    ·20 min read·May 28, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--4601ac68496f--------------------------------)
    ·阅读时间：20分钟·2024年5月28日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/c33f1f9833993abe0aa49f4f5eb1554a.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c33f1f9833993abe0aa49f4f5eb1554a.png)'
- en: Photo by [Jose Castillo](https://unsplash.com/@curiousjorge?utm_source=medium&utm_medium=referral)
    on [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Jose Castillo](https://unsplash.com/@curiousjorge?utm_source=medium&utm_medium=referral)
    提供，来源于 [Unsplash](https://unsplash.com/?utm_source=medium&utm_medium=referral)
- en: '***Note:*** *All example code snippets in the following sections have been
    created by the author of this article.*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '***注意：*** *以下所有示例代码片段均由本文作者编写。*'
- en: A*lgorithmic thinking* is about combining rigorous logic and creativity to frame,
    solve, and analyze problems, usually with the help of a computer. Problems involving
    some form of sorting, searching, and optimization are closely associated with
    algorithmic thinking and often show up during data science projects. Algorithmic
    thinking helps us solve such problems in ways that make efficient use of time
    and space (as in the disk space or memory of a computer), leading to fast and
    frugal algorithms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*算法思维* 是将严谨的逻辑和创造力结合起来，用以框定、解决和分析问题，通常借助计算机的帮助。涉及某种排序、查找和优化形式的问题与算法思维密切相关，且常出现在数据科学项目中。算法思维帮助我们以高效利用时间和空间（例如计算机的磁盘空间或内存）的方式解决这些问题，从而得到快速且节省资源的算法。'
- en: Even if the costs of storage and computing continue to drop in the foreseeable
    future, algorithmic thinking is unlikely to become any less important for data
    science projects than it is today for at least a few key reasons. First, the requirements
    of customers tend to outpace the capabilities of available solutions in many commercial
    use cases, regardless of the underlying complexity of data science pipelines (from
    data sourcing and transformation to modeling and provisioning). Customers expect
    tasks that take days or hours to take minutes or seconds, and tasks that take
    minutes or seconds to happen in the blink of an eye. Second, a growing number
    of use cases involving on-device analytics (e.g., in the context of embedded systems,
    IoT and edge computing) require resource-efficient computation; space and memory
    are at a premium, and it may not be possible to offload computational tasks to
    a more powerful, centralized infrastructure on the cloud. And third, the operation
    of industrial data science pipelines can consume significant energy, which can
    worsen the ongoing climate crisis. A firm grasp of algorithmic thinking can help
    data scientists build efficient and sustainable solutions that address such challenges.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在可预见的未来，存储和计算的成本持续下降，算法思维在数据科学项目中的重要性仍然不会因为以下几个关键原因而减弱。首先，客户的需求往往超过了现有解决方案的能力，在许多商业应用场景中，无论数据科学管道的底层复杂性如何（从数据获取、转换到建模和供应），这一点都成立。客户期望那些需要数天或数小时才能完成的任务变得只需要几分钟或几秒钟，而那些需要几分钟或几秒钟的任务则希望能在眨眼间完成。第二，越来越多的应用场景涉及设备端分析（例如，在嵌入式系统、物联网和边缘计算的背景下），这要求计算资源更加高效；存储空间和内存非常紧张，可能无法将计算任务转移到云端更强大、更集中的基础设施上。第三，工业数据科学管道的运行可能会消耗大量能源，从而加剧持续的气候危机。深入理解算法思维可以帮助数据科学家构建高效且可持续的解决方案，以应对这些挑战。
- en: While data scientists with computer science degrees will be familiar with the
    core concepts of algorithmic thinking, many increasingly enter the field with
    other backgrounds, ranging from the natural and social sciences to the arts; this
    trend is likely to accelerate in the coming years as a result of advances in generative
    AI and the growing prevalence of data science in school and university curriculums.
    As such, the following sections of this article are aimed primarily at readers
    unfamiliar with algorithmic thinking. We will begin with a high-level overview
    of the algorithmic problem-solving process, and then start to build some intuition
    for algorithmic thinking in a hands-on way by looking at a selection of programming
    challenges posted on *HackerRank* (a popular platform used by companies for hiring
    data scientists). We will also go over some helpful resources for further reading.
    Finally, we will briefly talk about the relevance of algorithmic thinking in the
    context of AI-assisted software development (e.g., using GitHub Copilot), and
    conclude with a wrap up.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管拥有计算机科学学位的数据科学家会熟悉算法思维的核心概念，但越来越多的人以其他背景进入该领域，这些背景涵盖了自然科学、社会科学以及艺术等多个领域；随着生成性人工智能的进步和数据科学在学校及大学课程中日益普及，这一趋势在未来几年可能会加速。因此，本文接下来的章节主要面向那些不熟悉算法思维的读者。我们将从算法问题解决过程的高层次概述开始，然后通过研究一些发布在*HackerRank*上的编程挑战（一个广泛被公司用于招聘数据科学家的平台）以动手的方式帮助读者逐步建立算法思维的直觉。我们还将介绍一些有用的进一步阅读资源。最后，我们将简要讨论算法思维在AI辅助软件开发中的相关性（例如，使用GitHub
    Copilot），并作总结。
- en: How to Solve It
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何解决问题
- en: 'The title of this section is also the title of a famous book, first published
    in 1945, by Hungarian-American mathematician and Stanford professor George Pólya.
    In *How to Solve It* ([link](https://www.amazon.com/How-Solve-Mathematical-Penguin-Science/dp/0140124993)),
    Pólya lays out a deceptively simple, yet highly effective, four-step approach
    that can be applied to algorithmic problem solving:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的标题也是一本著名书籍的标题，该书最早由匈牙利裔美国数学家、斯坦福大学教授乔治·波利亚于1945年出版。在*《如何解题》*（[link](https://www.amazon.com/How-Solve-Mathematical-Penguin-Science/dp/0140124993)）中，波利亚提出了一个看似简单但极为有效的四步法，适用于算法问题解决：
- en: '**Understand the problem**: Frame the problem carefully, with due consideration
    to any constraints on the problem and solution space (e.g., permissible input
    data types and data ranges, output format, maximum execution time). Ask questions
    such as, “can I restate the problem in my own words?”, and “do I have enough data
    to implement a useful solution?”, to check your understanding. Use concrete examples
    (or datasets) to make the problem and its edge cases more tangible. Spending sufficient
    time on this step often makes the remaining steps easier to carry out.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**理解问题**：仔细框定问题，充分考虑问题和解决方案空间的任何限制（例如，允许的输入数据类型和数据范围、输出格式、最大执行时间）。提出类似“我能否用自己的话重新陈述问题？”和“我是否拥有足够的数据来实施一个有用的解决方案？”等问题，以检查自己的理解。使用具体的例子（或数据集）使问题及其边缘情况更加具体。花足够的时间在这一步通常能让后续步骤更容易执行。'
- en: '**Devise a plan**: This will often involve breaking down the problem into smaller
    sub-problems for which efficient solutions may already be known. The ability to
    identify and apply suitable existing solutions to different types of sub-problems
    (e.g., in searching, sorting, etc.) will come with practice and experience. But
    sometimes, additional creativity may be needed to combine multiple existing approaches,
    invent a new approach, or borrow an approach from another domain using analogies.
    Pólya gives several tips to aid the thinking process, such as drawing a diagram
    and working backwards from a desired goal. In general, it is useful at this stage
    to gauge, at least at a high-level, whether the devised plan is likely solve the
    specified problem.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**制定计划**：这通常涉及将问题分解为更小的子问题，对于这些子问题，可能已经有了有效的解决方案。识别和应用合适的现有解决方案来处理不同类型的子问题（例如，在搜索、排序等方面）是通过实践和经验获得的。但有时，可能需要额外的创造力，将多个现有方法结合，发明新的方法，或者借用其他领域的解决方案并通过类比加以应用。Pólya
    提出了几个帮助思考过程的建议，例如画图并从期望目标反向推理。通常，在这一阶段，至少从高层次判断所制定的计划是否能够解决指定问题是很有用的。'
- en: '**Carry out the plan**: Implement the solution using relevant tooling. In a
    data science project, this might involve libraries such as scikit-learn, PyTorch
    and TensorFlow for machine learning, and platforms such as AWS, GCP or Azure for
    hosting and running pipelines. Attention to detail is crucial at this stage, since
    even small bugs in the code can lead to implementations that do not accurately
    reflect the previously devised plan, and thus do not end up solving the stated
    problem. Add sufficient unit tests to check whether the different parts of the
    code work properly, even for edge cases.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**执行计划**：使用相关工具实施解决方案。在数据科学项目中，这可能涉及使用诸如 scikit-learn、PyTorch 和 TensorFlow
    等机器学习库，以及 AWS、GCP 或 Azure 等平台来托管和运行流水线。在这一阶段，注重细节至关重要，因为即使是代码中的小错误也可能导致实现结果无法准确反映之前制定的计划，从而无法解决所述问题。添加足够的单元测试，以检查代码的不同部分是否正常工作，即使是边缘情况也要考虑在内。'
- en: '**Look back**: The practice of “looking back” is an instinctive part of the
    validation phase of most data science projects; questions such as “did the new
    machine learning model perform better than the last?” can only be answered by
    collecting and reviewing relevant metrics for each experiment. But reviewing other
    aspects of the data science pipeline (e.g., the ETL code, test cases, productization
    scripts) and AI lifecycle management (e.g., level of automation, attention to
    data privacy and security, implementation of a feedback loop in production) is
    also vital for improving the current project and doing better on future projects,
    even if finding the time for such a holistic “look back” can be challenging in
    a fast-paced work environment.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**回顾**：“回顾”是大多数数据科学项目验证阶段的本能部分；例如，“新的机器学习模型是否比之前的更好？”这样的问题，只有通过收集和审查每个实验的相关指标才能回答。但是，回顾数据科学流水线的其他方面（例如，ETL
    代码、测试用例、产品化脚本）和人工智能生命周期管理（例如，自动化水平、数据隐私和安全性、生产中的反馈环实施）同样至关重要，这有助于改进当前项目并在未来的项目中做得更好，即使在快速节奏的工作环境中，找到时间进行这种全面的“回顾”可能会有挑战。'
- en: 'Steps 1 and 2 in Pólya’s problem-solving process can be particularly difficult
    to get right. Framing a problem or solution in a conceptually logical and systematic
    way is often a non-trivial task. However, gaining familiarity with *conceptual
    frameworks* (analytical structures for representing abstract concepts) can help
    significantly in this regard. Common examples of conceptual frameworks include
    tree diagrams, matrices, process diagrams, and relational diagrams. The book *Conceptual
    Frameworks: A Guide to Structuring Analyses, Decisions and Presentations* ([link](https://www.amazon.com/Conceptual-Frameworks-Structuring-Decisions-Presentations-ebook/dp/B07GC1JDV8)),
    written by the author of this article, teaches how to understand, create, apply
    and evaluate such conceptual frameworks in an easy-to-digest manner.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '在波利亚问题解决过程中，步骤1和步骤2特别难以正确完成。以概念上逻辑且系统的方式框定问题或解决方案通常是一项复杂的任务。然而，熟悉 *概念框架*（用于表示抽象概念的分析结构）可以大大帮助解决这个问题。常见的概念框架包括树形图、矩阵、流程图和关系图。由本文作者编写的书籍
    *Conceptual Frameworks: A Guide to Structuring Analyses, Decisions and Presentations*
    （[链接](https://www.amazon.com/Conceptual-Frameworks-Structuring-Decisions-Presentations-ebook/dp/B07GC1JDV8)）介绍了如何以易于理解的方式理解、创建、应用和评估这些概念框架。'
- en: Algorithmic Complexity
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法复杂度
- en: 'One topic that deserves special attention in the context of algorithmic problem
    solving is that of *complexity*. When comparing two different algorithms, it is
    useful to consider the time and space complexity of each algorithm, i.e., how
    the time and space taken by each algorithm scales relative to the problem size
    (or data size). There are five basic levels of complexity, from lowest (best)
    to highest (worst), that you should be aware of. We will only describe them below
    in terms of time complexity to simplify the discussion:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法问题求解的背景下，有一个值得特别注意的话题，那就是 *复杂度*。在比较两个不同的算法时，考虑每个算法的时间和空间复杂度是非常有用的，即每个算法在相对于问题规模（或数据规模）的时间和空间消耗如何变化。你应该了解五种基本的复杂度等级，从最低（最好）到最高（最差）。为了简化讨论，下面我们仅从时间复杂度的角度描述它们：
- en: '**Instantaneous**: regardless of the scale of the problem, the algorithm executes
    instantaneously. E.g., to determine whether an integer is even, we can simply
    check if dividing its rightmost digit by two leaves no remainder, regardless of
    the size of the integer. Accessing a list element by index can also typically
    be done instantaneously, no matter the length of the list.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**瞬时**：无论问题规模如何，算法都能瞬间执行。例如，要判断一个整数是否为偶数，我们可以简单地检查它的最右边的数字是否能被二整除，无论这个整数有多大。通过索引访问列表元素通常也可以瞬间完成，不管列表的长度如何。'
- en: '**Logarithmic**: For a dataset of size *n*, the algorithm executes in *log(n)*
    time steps. Note that logarithms may have different bases (e.g., *log2(n)* for
    binary search as the size of the problem is halved in each iteration). Like instantaneous
    algorithms, those with logarithmic complexity are attractive because they scale
    sub-linearly with respect to the size of the problem.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对数级**：对于大小为 *n* 的数据集，算法执行大约 *log(n)* 步骤。请注意，对数的底数可能不同（例如，*log2(n)* 用于二分查找，因为每次迭代都将问题的大小减半）。像瞬时算法一样，具有对数复杂度的算法也很有吸引力，因为它们相对于问题规模是次线性扩展的。'
- en: '**Linear**: As the name suggests, for a dataset of size *n*, an algorithm with
    linear complexity executes in roughly *n* time steps.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**线性**：顾名思义，对于大小为 *n* 的数据集，具有线性复杂度的算法大约执行 *n* 步。'
- en: '**Polynomial**: The algorithm executes in *x^2* (quadratic), *x^3* (cubic),
    or more generally, *x^m* time steps, for some positive integer *m*. A common trick
    to check for polynomial complexity in code is to count the number of nested loops;
    e.g., a function with 2 nested loops (a loop within a loop) has a complexity of
    x^2, a function with 3 nested loops has a complexity of x^3, and so on.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**多项式**：该算法的执行时间是 *x^2*（二次）、*x^3*（三次）或更一般的 *x^m* 步骤，其中 *m* 为某个正整数。检查代码中多项式复杂度的常见方法是计数嵌套循环的数量；例如，包含两个嵌套循环（循环内有循环）的函数，其复杂度为
    x^2，包含三个嵌套循环的函数复杂度为 x^3，依此类推。'
- en: '**Exponential**: The algorithm executes in *2^x*, *3^x*, or more generally,
    *m^x* time steps, for some positive integer *m*. See these posts on StackExchange
    ([link 1](https://math.stackexchange.com/questions/55468/how-to-prove-that-exponential-grows-faster-than-polynomial),
    [link 2](https://math.stackexchange.com/questions/4042364/why-does-an-exponential-function-eventually-get-bigger-than-a-quadratic))
    to see why exponential functions eventually get bigger than polynomial ones and
    are therefore worse in terms of algorithmic complexity for large problems.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指数级**：算法执行的时间步长为*2^x*，*3^x*，或者更一般地，*m^x*，其中*m*是某个正整数。请参考StackExchange上的这些帖子（[链接
    1](https://math.stackexchange.com/questions/55468/how-to-prove-that-exponential-grows-faster-than-polynomial)，[链接
    2](https://math.stackexchange.com/questions/4042364/why-does-an-exponential-function-eventually-get-bigger-than-a-quadratic)），了解为什么指数函数最终会比多项式函数增长更快，因此在处理大规模问题时，指数函数的算法复杂度会更差。'
- en: Some algorithms may manifest *additive* or *multiplicative* combinations of
    the above complexity levels. E.g., a for loop followed by a binary search entails
    an additive combination of linear and logarithmic complexities, attributable to
    sequential execution of the loop and the search routine, respectively. By contrast,
    a for loop that carries out a binary search in each iteration entails a multiplicative
    combination of linear and logarithmic complexities. While multiplicative combinations
    may generally be more expensive than additive ones, sometimes they are unavoidable
    and can still be optimized. E.g., a sorting algorithm such as merge sort, with
    a time complexity of *nlog(n)*, is less expensive than selection sort, which has
    a quadratic time complexity (see [this](https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/)
    article for a table comparing the complexities of different sorting algorithms).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法可能会表现出*加法*或*乘法*的组合复杂度。例如，一个for循环后接二分查找会导致线性和对数复杂度的加法组合，这是由于循环和查找过程分别是顺序执行的。相比之下，如果每次迭代中都进行二分查找，那么将会是线性和对数复杂度的乘法组合。虽然乘法组合通常比加法组合开销更大，但有时是不可避免的，且仍然可以进行优化。例如，像归并排序这样的排序算法，其时间复杂度为*nlog(n)*，比选择排序的二次时间复杂度要便宜（参见[这篇](https://www.geeksforgeeks.org/time-complexities-of-all-sorting-algorithms/)文章，里面有不同排序算法复杂度的对比表）。
- en: Building Intuition with Example Problems
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过示例问题建立直觉
- en: In the following, we will study a selection of problems posted on [*HackerRank*](https://www.hackerrank.com/).
    Similar problems can be found on platforms such as [*LeetCode*](https://leetcode.com/)
    and [*CodeWars*](https://www.codewars.com/). Studying problems posted on such
    platforms will help train your algorithmic thinking muscles, can help you more
    easily navigate technical interviews (hiring managers regularly pose algorithmic
    questions to candidates applying for data science roles), and may yield pieces
    of code that you can reuse on the job.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的内容中，我们将研究在[*HackerRank*](https://www.hackerrank.com/)上发布的一些问题。类似的问题也可以在[*LeetCode*](https://leetcode.com/)和[*CodeWars*](https://www.codewars.com/)等平台上找到。研究这些平台上发布的问题有助于训练你的算法思维能力，可以帮助你更轻松地应对技术面试（招聘经理通常会向申请数据科学岗位的候选人提出算法问题），并且可能会产出一些可以在工作中复用的代码。
- en: 'All example code snippets below have been written by the author of this article
    in C++, a popular choice among practitioners for building fast data pipelines.
    These snippets can be readily translated to other languages such as Python or
    R as needed. To simplify the code snippets, we will assume that the following
    lines are present at the top of the code file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有的示例代码片段均由本文作者编写，使用了C++，这是一种在构建快速数据管道时常被从业者选择的语言。根据需要，这些代码片段也可以很容易地转化为其他语言，如Python或R。为了简化代码片段，我们假设代码文件的顶部包含以下几行：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will allow us to omit “std::” everywhere in the code, letting readers focus
    on the algorithms themselves. Of course, in productive C++ code, only the relevant
    libraries would be included and “std::” written explicitly as per the coding guidelines.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够在代码中省略“std::”，从而让读者更专注于算法本身。当然，在实际的C++代码中，只有相关的库会被包含，且“std::”会按照编码规范显式写出。
- en: When a Formula Will Do
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当公式能派上用场时
- en: A problem that initially seems to call for an iterative solution with polynomial
    complexity (e.g., using for loops, while loops, or list comprehensions) can sometimes
    be solved algebraically using a formula that returns the desired answer instantaneously.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最初看起来需要通过多项式复杂度的迭代解法（例如，使用for循环、while循环或列表推导式）的问题，有时可以通过一个公式在瞬间得出所需的答案，从而避免复杂的迭代。
- en: Consider the *Number Line Jumps* problem ([link](https://www.hackerrank.com/challenges/kangaroo/problem)).
    There are two kangaroos placed somewhere on a number line (at positions *x1* and
    *x2*, respectively) and can move by jumping. The first kangaroo can move *v1*
    meters per jump, while the second can move *v2* meters per jump. Given input values
    for *x1*, *v1*, *x2*, and *v2*, the task is to determine whether it is possible
    for both kangaroos to end up at the same position on the number line at some future
    time step, assuming that each kangaroo can make only one jump per time step; the
    solution function should return “YES” or “NO” accordingly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑*数字线跳跃*问题（[链接](https://www.hackerrank.com/challenges/kangaroo/problem)）。有两只袋鼠被放置在数字线上某个位置（分别在位置*x1*和*x2*），并且可以通过跳跃移动。第一只袋鼠每次跳跃可以移动*v1*米，而第二只袋鼠每次跳跃可以移动*v2*米。给定*x1*、*v1*、*x2*和*v2*的输入值，任务是确定是否有可能在未来的某个时间步，两个袋鼠会出现在数字线上的相同位置，假设每只袋鼠每个时间步只能跳一次；解决函数应相应地返回“YES”或“NO”。
- en: Suppose *x1* is smaller than *x2*. Then one approach is to implement a loop
    that checks if the kangaroo starting at *x1* will ever catch up with the kangaroo
    starting at *x2*. In other words, we would check whether a positive (integer)
    time step exists where *x1 + v1*t = x2 + v2*t*. If *x1* is greater than *x2*,
    we could swap the values in the respective variables and follow the same approach
    described above. But such a solution could take a long time to execute if *t*
    is large and might even loop infinitely (causing a time-out or crash) if the kangaroos
    never end up meeting.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*x1*小于*x2*。一种方法是实现一个循环，检查从*x1*出发的袋鼠是否会追上从*x2*出发的袋鼠。换句话说，我们会检查是否存在一个正的（整数）时间步长，使得*x1
    + v1*t = x2 + v2*t*。如果*x1*大于*x2*，我们可以交换相应变量中的值，并遵循上述相同的方法。但是，如果*t*很大，这样的解决方案可能需要很长时间才能执行，甚至如果袋鼠永远不会相遇，它可能会导致无限循环（导致超时或崩溃）。
- en: We can do much better. Let us rearrange the above equation to solve for a positive
    integer *t*. We get *t = (x1 — x2)/(v2 — v1)*. This equation for *t* is undefined
    when *v2 = v1* (due to division by zero), but in such a case we could return “YES”
    if both kangaroos start at the same position, since both kangaroos will then obviously
    arrive at the same position on the number line at the very next time step. Moreover,
    if the jump distances of both kangaroos are the same but the starting positions
    are different, then we can directly return “NO”, since the kangaroo starting on
    the left will never catch up with the kangaroo on the right. Finally, if we find
    a positive solution to *t*, we should check that it is also an integer; this can
    be done by casting *t* to an integer data type and checking whether this is equivalent
    to the original value. The example code snippet below implements this solution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做得更好。让我们重新排列上面的方程，解出正整数*t*。我们得到*t = (x1 — x2)/(v2 — v1)*。当*v2 = v1*时，这个*t*方程是未定义的（由于除以零），但在这种情况下，如果两只袋鼠起始位置相同，我们可以返回“YES”，因为两只袋鼠显然会在下一个时间步到达数字线上的相同位置。此外，如果两只袋鼠的跳跃距离相同，但起始位置不同，那么我们可以直接返回“NO”，因为从左边出发的袋鼠永远追不上右边的袋鼠。最后，如果我们找到一个正的*t*解，我们应该检查它是否也是一个整数；这可以通过将*t*转换为整数数据类型并检查其是否等于原始值来实现。下面的示例代码片段实现了这个解决方案。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Picking from Multiple Options
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从多个选项中选择
- en: There may be several valid ways of solving the same problem. Having found one
    solution approach, trying to find others can still be illuminating and worthwhile;
    each approach will have its pros and cons, making it more or less suitable to
    the problem context. To illustrate this, we will look at three problems below
    in varying degrees of detail.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 解决同一问题可能有多种有效的方法。在找到一种解决方案后，尝试寻找其他解决方案仍然是有意义且值得的；每种方法都有其优缺点，使得它更适合或不适合特定的问题上下文。为了说明这一点，我们将在下面以不同程度的细节看三个问题。
- en: First, consider the *Beautiful Days at the Movies* problem ([link](https://www.hackerrank.com/challenges/beautiful-days-at-the-movies/problem)).
    Upon reading the description, it will become apparent that a key part of solving
    the problem is coming up with a function to reverse a positive integer. E.g.,
    the reverse of 123 is 321 and the reverse of 12000 is 21 (note the omission of
    leading zeros in the reversed number).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑*电影中的美丽日子*问题（[链接](https://www.hackerrank.com/challenges/beautiful-days-at-the-movies/problem)）。阅读问题描述后，可以明显看出，解决问题的关键部分是编写一个函数来反转一个正整数。例如，123的反转是321，12000的反转是21（注意反转后的数字没有前导零）。
- en: One solution approach (call it *reverse_num_v1*) uses a combination of division
    and modulo operations to bring the rightmost digit to the leftmost position in
    a way that naturally takes care of leading zeros; see an example implementation
    below. What makes this approach attractive is that, since the number of digits
    grows logarithmically relative to the size of the number, the time complexity
    of *reverse_num_v1* is sub-linear; the space complexity is also negligible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方法（称为*reverse_num_v1*）使用除法和取余操作的组合，将最右边的数字移动到最左边的位置，从而自然处理前导零问题；请参见下面的示例实现。这个方法的吸引力在于，由于数字的位数是相对于数字大小对数增长的，*reverse_num_v1*的时间复杂度是子线性的；空间复杂度也可以忽略不计。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another approach (call it *reverse_num_v2*) uses the idea of converting the
    integer to a string data type, reversing it, trimming any leading zeros, converting
    the string back to an integer, and returning the result; see an example implementation
    below.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法（称为*reverse_num_v2*）使用将整数转换为字符串数据类型、反转字符串、去掉前导零、将字符串重新转换为整数并返回结果的思路；请参见下面的示例实现。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Such *type casting* is a common practice in many languages (C++, Python, etc.),
    library functions for string reversion and trimming leading zeros may also be
    readily available, and chaining functions to form a pipeline of data transformation
    operations is a typical pattern seen in data science projects; *reverse_num_v2*
    might thus be the first approach that occurs to many data scientists. If memory
    space is scarce, however, *reverse_num_v1* might be the better option, since the
    string representation of an integer will take up more space than the integer itself
    (see [this](https://www.codecademy.com/resources/docs/cpp/data-types) documentation
    of memory requirements for different data types in C++).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*类型转换*在许多编程语言中都是常见做法（如C++、Python等），字符串反转和去掉前导零的库函数也可能随时可用，而将多个函数链式调用以形成数据转换操作流水线，是数据科学项目中的典型模式；因此，*reverse_num_v2*可能是许多数据科学家首先想到的方法。然而，如果内存空间紧张，*reverse_num_v1*可能是更好的选择，因为整数的字符串表示形式会占用比整数本身更多的空间（请参阅[C++中不同数据类型的内存要求](https://www.codecademy.com/resources/docs/cpp/data-types)文档）。
- en: Next, let us briefly consider two further problems, *Time Conversion* ([link](https://www.hackerrank.com/challenges/time-conversion/problem))
    and *Forming a Magic Square* ([link](https://www.hackerrank.com/challenges/magic-square-forming/problem)).
    While these problems might appear to be quite different on the surface, the same
    technique — namely, the use of lookup tables (or maps) — can be used to solve
    both problems. In the case of *Time Conversion*, a lookup table can be used to
    provide an instantaneous mapping between 12-hour and 24-hour formats for afternoon
    times (e.g., 8 pm is mapped to 20, 9 pm is mapped to 21, and so on). In *Forming
    a Magic Square*, the problem is restricted to magic squares consisting of 3 rows
    and 3 columns, and as it happens, there are only 8 such squares. By storing the
    configurations of these 8 magic squares in a lookup table, we can implement a
    fairly simple solution to the problem despite its “medium” difficulty rating on
    *HackerRank*. It is left to the reader to go through these problems in more detail
    via the links provided above, but the relevant example code snippets of each solution
    are shown below for comparison.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们简要考虑两个问题，*时间转换*（[link](https://www.hackerrank.com/challenges/time-conversion/problem)）和*魔方阵的构造*（[link](https://www.hackerrank.com/challenges/magic-square-forming/problem)）。虽然这些问题在表面上看起来非常不同，但相同的技术——即使用查找表（或映射表）——可以用来解决这两个问题。在*时间转换*的情况下，可以使用查找表在12小时制和24小时制之间为下午时间（例如，下午8点映射到20点，下午9点映射到21点，以此类推）提供即时映射。在*魔方阵的构造*问题中，问题被限制为由3行3列组成的魔方阵，而恰好有8个这样的魔方阵。通过将这8个魔方阵的配置存储在查找表中，我们可以实现一个相对简单的解决方案，尽管在*HackerRank*上它的“中等”难度评级。读者可以通过上面提供的链接更详细地阅读这些问题，但每个解决方案的相关示例代码片段已在下方显示，供比较使用。
- en: '*Time Conversion*:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间转换*：'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Forming a Magic Square*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*魔方阵的构造*：'
- en: Notice that, although part of the code below uses 3 nested for loops, only 8*3*3
    = 72 loops involving simple operations are ever needed to solve the problem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管下面的部分代码使用了3个嵌套的for循环，但实际上只需要72次简单操作的循环（8*3*3=72）来解决这个问题。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Divide and Conquer
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分治法
- en: When a problem seems too big or too complicated to solve in one go, it can often
    be a good idea to divide the original problem into smaller sub-problems that can
    each be conquered more easily. The exact nature of these sub-problems (e.g., sorting,
    searching, transforming), and their “part-to-whole” relationship with the original
    problem may vary. For instance, in the case of data cleaning, a common type of
    problem in data science, each sub-problem may represent a specific, sequential
    step in the data cleaning process (e.g., removing stop-words, lemmatization).
    In a “go/no-go” decision-making problem, each sub-problem might reflect smaller
    decisions that must all result in a “go” decision for the original problem to
    resolve to “go”; in logical terms, one can think of this as a complex Boolean
    statement of the form *A AND B*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个问题看起来太大或太复杂，无法一次性解决时，将原问题分解成更小的子问题通常是个好主意，这些子问题可以更容易地被解决。这些子问题的具体性质（例如，排序、搜索、转换），以及它们与原问题之间的“部分与整体”关系可能会有所不同。例如，在数据清理的情况下，这是数据科学中的常见问题，每个子问题可能代表数据清理过程中的一个特定的、顺序的步骤（例如，去除停用词、词形还原）。在一个“继续/停止”决策问题中，每个子问题可能反映了必须满足的更小的决策，只有当所有这些决策都为“继续”时，原问题才能解决为“继续”；用逻辑术语来说，可以将其看作是一个复杂的布尔语句，如*A
    AND B*。
- en: To see how divide-and-conquer works in practice, we will look at two problems
    that appear to be very different on the surface. First, let us consider the *Electronics
    Shop* problem ([link](https://www.hackerrank.com/challenges/electronics-shop/problem)),
    which is fundamentally about constrained optimization. Given a total spending
    budget *b* and unsorted price lists for computer keyboards and USB drives (call
    these *K* and *D*, respectively), the goal is to buy the most expensive keyboard
    and drive without exceeding the budget. The price lists can have up to 1000 items
    in the problem posted on *HackerRank*, but we can imagine much longer lists in
    practice.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看分治法如何在实践中运作，我们将考察两个表面上看似非常不同的问题。首先，让我们考虑*电子商店*问题([link](https://www.hackerrank.com/challenges/electronics-shop/problem))，它本质上是关于约束优化的问题。给定一个总支出预算*b*和未排序的电脑键盘和USB驱动器价格列表（分别称为*K*和*D*），目标是购买最昂贵的键盘和驱动器，而不超过预算。在*HackerRank*上发布的问题中，价格列表最多可以有1000个项目，但我们可以想象在实际中这些列表会更长。
- en: A naïve approach might be to iterate through the price lists *K* and *D* with
    two nested loops to find the *i*-th keyboard and the *j*-th drive that make maximal
    use of the budget. This would be easy to implement, but very slow if *K* and *D*
    are long, especially since the price lists are unsorted. In fact, the time complexity
    of the naïve approach is quadratic, which does not bode well for scaling to large
    datasets. A more efficient approach would work as follows. First, sort both price
    lists. Second, pick the shorter of the two price lists for looping. Third, for
    each item *x* in the looped list, do a binary search on the other list to find
    an item *y* (if any), such that *x + y* does not exceed the given budget *b*,
    and maintain this result in a variable called *max_spent* outside the loop. In
    each successive iteration of the loop, *max_spent* is only updated if the total
    cost of the latest keyboard-drive pair is within budget and exceeds the current
    value of *max_spent*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法可能是用两个嵌套循环遍历价格列表*K*和*D*，找出第*i*个键盘和第*j*个硬盘，使预算得到最大化利用。这种方法实现起来很简单，但如果*K*和*D*很长，尤其是因为价格列表是未排序的，它会变得非常慢。事实上，简单方法的时间复杂度是二次方的，这对于大数据集的扩展并不乐观。一种更高效的方法是按如下方式进行。首先，排序两个价格列表。其次，选择较短的价格列表进行循环。第三，对于循环列表中的每个项目*x*，在另一个列表上进行二分查找，找到一个项目*y*（如果有的话），使得*x
    + y*不超过给定的预算*b*，并将这个结果保存在一个名为*max_spent*的变量中，变量在循环外部维护。在每次循环迭代中，只有当最新的键盘-硬盘组合的总成本在预算内且超过当前的*max_spent*值时，*max_spent*才会更新。
- en: 'Although there is no way around searching both price lists in this problem,
    the efficient approach reduces the overall search time significantly by picking
    the smaller price list for looping, and crucially, doing a binary search of the
    longer price list (which takes logarithmic/sub-linear time to execute). Moreover,
    while it might initially seem that pre-sorting the two price lists adds to the
    solution complexity, the sorting can actually be done quite efficiently (e.g.,
    using merge sort), and crucially, this enables the binary search of the longer
    price list. The net result is a much faster algorithm compared to the naïve approach.
    See an example implementation of the efficient approach below:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个问题中无法避免同时搜索两个价格列表，但高效的方法通过选择较小的价格列表进行循环，并且关键的是，对较长的价格列表进行二分查找（执行时需要对数时间/子线性时间），大大减少了整体搜索时间。此外，虽然最初看起来预先排序两个价格列表会增加解决方案的复杂度，但排序实际上可以非常高效地完成（例如，使用归并排序），并且关键是，这使得可以对较长的价格列表进行二分查找。最终结果是，相比于朴素的方法，这种算法要快得多。下面是高效方法的示例实现：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, let us consider the *Climbing the Leaderboard* problem ([link](https://www.hackerrank.com/challenges/climbing-the-leaderboard/problem)).
    Imagine you are playing an arcade game and wish to track your rank on the leaderboard
    after each attempt. The leaderboard uses *dense ranking*, so players with the
    same scores will get the same rank. E.g., if the scores are 100, 90, 90, and 80,
    then the player scoring 100 has rank 1, the two players scoring 90 both have rank
    2, and the player scoring 80 has rank 3\. The leaderboard is represented as an
    array or list of integers (each player’s high score) in descending order. What
    makes the problem tricky is that, whenever a new score is added to the leaderboard,
    determining the resulting rank is non-trivial since this rank might be shared
    between multiple players. See the problem description page at the above link on
    *HackerRank* for an illustrated example.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来考虑*攀登排行榜*问题（[链接](https://www.hackerrank.com/challenges/climbing-the-leaderboard/problem)）。假设你正在玩一款街机游戏，并希望在每次尝试后跟踪你在排行榜上的排名。排行榜使用*密集排名*，所以得分相同的玩家会获得相同的排名。例如，如果得分为100、90、90和80，那么得分100的玩家排名第1，得分90的两个玩家排名第2，得分80的玩家排名第3。排行榜以一个整数数组或列表表示（每个玩家的最高得分），按降序排列。问题的难点在于，每当有新得分加入排行榜时，确定最终的排名并非易事，因为该排名可能会被多个玩家共享。有关详细示例，请参见上述链接中的*HackerRank*问题描述页面。
- en: 'Although the *Electronics Shop* and *Climbing the Leaderboard* problems have
    difficulty ratings of “easy” and “medium” on *HackerRank*, respectively, the latter
    problem is simpler in a way, since the leaderboard is already sorted. The example
    implementation below exploits this fact by running a binary search on the sorted
    leaderboard to get the rank after each new score:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*电子商店*和*攀登排行榜*问题在*HackerRank*上的难度评级分别为“简单”和“中等”，但后者从某种程度上更简单，因为排行榜已经是排序好的。下面的示例实现通过在已排序的排行榜上进行二分查找来获取每个新得分后的排名，利用了这一事实：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Resources for Further Reading
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读的资源
- en: 'The problems discussed above give an initial taste of algorithmic thinking,
    but there are many other related topics worth studying in more depth. The aptly
    titled book *Algorithmic Thinking: A Problem-Based Introduction* by Daniel Zingaro,
    is an excellent place to continue to your journey ([link](https://www.amazon.com/Algorithmic-Thinking-Problem-Based-Daniel-Zingaro/dp/1718500807)).
    Zingaro has an engaging writing style and walks the reader through basic concepts
    like *hash tables*, *recursion*, *dynamic programming*, *graph search*, and more.
    The book also contains an appendix section on *Big O notation*, which is a handy
    way of expressing and reasoning about the complexity of algorithms. Another book
    that covers several essential algorithms in a digestible manner is *Grokking Algorithms*
    by Aditya Bhargava ([link](https://www.amazon.com/Grokking-Algorithms-Second-Aditya-Bhargava/dp/1633438538)).
    The book contains several useful illustrations and code snippets in Python, and
    is a great resource for brushing up on the basics of algorithmic thinking before
    technical interviews.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述讨论的问题提供了算法思维的初步体验，但还有许多其他相关主题值得更深入研究。丹尼尔·津加罗（Daniel Zingaro）所著的书籍《*算法思维：基于问题的入门*》是继续你学习之旅的绝佳选择
    ([link](https://www.amazon.com/Algorithmic-Thinking-Problem-Based-Daniel-Zingaro/dp/1718500807))。津加罗具有引人入胜的写作风格，带领读者了解诸如*哈希表*、*递归*、*动态规划*、*图搜索*等基本概念。书中还包含了关于*大O符号*的附录部分，它是一种表达和推理算法复杂度的便捷方法。另一本以易于理解的方式讲解几种基本算法的书是阿迪提亚·巴尔伽瓦（Aditya
    Bhargava）所著的《*Grokking Algorithms*》 ([link](https://www.amazon.com/Grokking-Algorithms-Second-Aditya-Bhargava/dp/1633438538))。这本书包含了若干有用的插图和Python代码片段，是在技术面试之前复习算法思维基础的好资源。
- en: 'When it comes to dynamic programming, the series of YouTube videos ([link to
    playlist](https://www.youtube.com/playlist?list=PLVrpF4r7WIhTT1hJqZmjP10nxsmrbRvlf))
    created by Andrey Grehov provides a great introduction. Dynamic programming is
    a powerful tool to have in your arsenal, and once you learn it, you will start
    seeing several opportunities to apply it in data science projects, e.g., to solve
    optimization problems (where some quantity like cost or revenue must be minimized
    or maximized, respectively) or combinatorics problems (where the focus is on counting
    something, essentially answering the question, “how many ways are there to do
    XYZ?”). Dynamic programming can be usefully applied to problems that exhibit the
    following two properties: (1) An *optimal substructure*, i.e., optimally solving
    a smaller piece of the problem helps solve the larger problem, and (2) *overlapping
    sub-problems*, i.e., a result calculated as part of a solution to one sub-problem
    can be used without need for recalculation (e.g., using *memoization* or *caching*)
    during the process of solving another sub-problem.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态规划方面，由安德烈·格列霍夫（Andrey Grehov）创作的一系列YouTube视频 ([link to playlist](https://www.youtube.com/playlist?list=PLVrpF4r7WIhTT1hJqZmjP10nxsmrbRvlf))
    提供了一个很好的入门介绍。动态规划是一个非常强大的工具，一旦学会，你会发现有很多机会将其应用于数据科学项目中，例如解决优化问题（其中某些数量如成本或收入必须分别最小化或最大化）或组合问题（其焦点是计数某些事物，实质上是在回答“有多少种方法可以做XYZ？”）。动态规划可以有效应用于具备以下两个特性的题目：（1）*最优子结构*，即优化地解决问题的较小部分有助于解决更大的问题；（2）*重叠子问题*，即在解决一个子问题的过程中，已经计算出的结果可以在不重新计算的情况下用于解决另一个子问题（例如，使用*记忆化*或*缓存*）。
- en: Finally, the doctoral dissertation *Advanced Applications of Network Analysis
    in Marketing Science* ([link](https://www.amazon.com/Advanced-Applications-Network-Analysis-Marketing/dp/3746068118/)),
    published by the author of this article, discusses a range of practical data science
    use cases for applying graph theory concepts to fundamental problems in marketing
    and innovation management, such as identifying promising crowdsourced ideas for
    new product development, dynamic pricing, and predicting customer behavior with
    anonymized tracking data. The dissertation demonstrates how transforming tabular
    or unstructured data into a graph/network representation consisting of nodes (entities)
    and edges (relationships between entities) can unlock valuable insights and lead
    to the development of powerful predictive models across a wide range of data science
    problems.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本文作者出版的博士论文《*网络分析在营销科学中的高级应用*》([链接](https://www.amazon.com/Advanced-Applications-Network-Analysis-Marketing/dp/3746068118/))讨论了应用图论概念解决营销和创新管理中的一系列实际数据科学用例，诸如识别用于新产品开发的有前景的众包创意、动态定价、以及通过匿名化跟踪数据预测客户行为等。该论文展示了如何将表格数据或非结构化数据转化为由节点（实体）和边（实体间关系）组成的图/网络表示，这一过程可以揭示有价值的见解，并推动在广泛的数据科学问题中开发强大的预测模型。
- en: Algorithmic Thinking in the Age of AI-Assisted Software Development
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 《AI辅助软件开发时代的算法思维》
- en: In October 2023, Matt Walsh, an erstwhile computer science professor and engineering
    director at Google, gave an intriguing guest lecture at Harvard ([YouTube link](https://www.youtube.com/watch?v=JhCl-GeT4jw)).
    His talk had a provocative title (*Large Language Models and The End of Programming*)
    and suggested that advances in generative AI — and large language models, in particular
    — could dramatically change the way we develop software. While he noted that humans
    would likely still be needed in roles such as product management (to define *what*
    the software should do, and *why*), and software testing/QA (to ensure that the
    software works as intended), he argued that the act of translating a problem specification
    to production-ready code could largely be automated using AI in the not-too-distant
    future. By late 2023, AI-powered tools like GitHub Copilot were already showing
    the ability to auto-complete various basic types of code (e.g., test cases, simple
    loops and conditionals), and suggested the potential to improve the productivity
    of developers — if not remove the need for developers entirely. And since then,
    AI has continued to make impressive advances in delivering increasingly accurate,
    multimodal predictions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 2023年10月，前谷歌计算机科学教授兼工程总监马特·沃尔什在哈佛大学进行了一场引人入胜的讲座（[YouTube 链接](https://www.youtube.com/watch?v=JhCl-GeT4jw)）。他的演讲标题颇具挑衅性（*大语言模型与编程的终结*），并提出生成式人工智能——尤其是大语言模型的进展——可能会极大地改变我们开发软件的方式。他指出，人类可能仍然需要在一些角色中发挥作用，比如产品管理（定义软件应该做什么，*以及*为什么这么做）和软件测试/质量保证（确保软件按预期运行），但他认为，将问题规格转化为生产就绪的代码这一过程，可能在不久的将来通过人工智能实现大规模自动化。到2023年底，像GitHub
    Copilot这样的AI驱动工具已经显示出自动完成各种基本代码类型（例如，测试用例、简单的循环和条件语句）的能力，并表明它们有潜力提高开发人员的生产力——甚至有可能完全取代开发人员的需求。自那时以来，AI在提供越来越精确的多模态预测方面取得了令人印象深刻的进展。
- en: In this context, given the subject of this article, it is worth considering
    to what extent algorithmic thinking will remain a relevant skill for data scientists
    in the age of AI-assisted software development. The short answer is that algorithmic
    thinking will likely be more important than ever before. The longer answer would
    first start by acknowledging that, even today, it is possible in many cases to
    generate a draft version of an algorithm (such as the code snippets shown in the
    sections above) using generative AI tools like ChatGPT or GitHub Copilot. After
    all, such AI tools are trained by scraping the internet, and there is plenty of
    code on the internet — but this code may not necessarily be high-quality code,
    potentially leading to “garbage in, garbage out”. AI-generated code should therefore
    arguably always be thoroughly reviewed before using it in any data science project,
    which implies the continued need for human reviewers with relevant technical skills.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种背景下，考虑到本文的主题，值得思考的是，在AI辅助软件开发的时代，算法思维对数据科学家来说将保持多大程度的相关性。简短的答案是，算法思维可能比以往任何时候都更为重要。更长的答案首先需要承认，即使在今天，许多情况下也可以使用像ChatGPT或GitHub
    Copilot这样的生成性AI工具生成一个算法草稿版本（如上文所示的代码片段）。毕竟，这些AI工具是通过抓取互联网内容进行训练的，互联网上有大量的代码——但这些代码不一定是高质量的，可能会导致“垃圾进，垃圾出”的情况。因此，AI生成的代码应该始终在用于任何数据科学项目之前进行彻底审查，这意味着仍然需要具备相关技术技能的人类审查员。
- en: Furthermore, AI-generated code may need to be customized and/or optimized to
    fit a particular use case, and prompt engineering alone will likely not be enough.
    In fact, crafting a prompt that can reliably generate the required code (capturing
    the prompt engineer’s tacit know-how and motivation) often seems to be more verbose
    and time-consuming than writing the code directly in the target language, and
    neither approach obviates the need to properly frame the problem and devise a
    sensible plan for implementing the solution. Tasks such as framing, planning,
    customizing, optimizing and reviewing AI-generated code for individual use cases
    will arguably continue to require a decent level of algorithmic thinking, coupled
    with a deep understanding of the *intent* behind the code (i.e., the “why”). It
    seems unlikely in practice that such work will be substantially delegated to an
    AI “copilot” any time soon — not least due to the ethical and legal concerns involved;
    e.g., imagine letting the object avoidance software of a self-driving car system
    be generated by AI without sufficient human oversight.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AI生成的代码可能需要定制和/或优化以适应特定的用例，单靠提示工程可能不足够。事实上，设计一个能够可靠生成所需代码的提示（捕捉提示工程师的隐性知识和动机）通常比直接用目标语言编写代码更冗长且耗时，而且无论哪种方法，都不能避免需要正确框定问题并制定合理的实施计划。像框定问题、规划、定制、优化和审查AI生成代码以适应特定用例等任务，可能仍然需要一定程度的算法思维，并且需要对代码背后的*意图*（即“为什么”）有深入的理解。在实践中，似乎不太可能很快将这类工作完全委托给AI“副驾驶”——这不仅仅是因为涉及到伦理和法律问题；例如，想象一下，如果没有足够的人工监督，让自动驾驶汽车系统的物体避让软件由AI生成会是什么样的情形。
- en: The Wrap
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Algorithmic thinking can help data scientists write code that is fast and makes
    sparing use of computational resources such as memory and storage. As more and
    more data scientists enter the field with diverse backgrounds and lacking sufficient
    exposure to algorithmic thinking, this article takes a step towards filling the
    knowledge gap. By providing a high-level introduction and hands-on examples of
    the kind that often appear in technical interviews, this article invites readers
    to take the next step and extend their study of algorithmic thinking with various
    resources for further education. Ultimately, algorithmic thinking is a vital skill
    for data scientists to have today, and will continue to be a skill worth having
    in our AI-assisted future.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 算法思维可以帮助数据科学家编写快速且高效利用计算资源（如内存和存储）的代码。随着越来越多背景多样且缺乏足够算法思维训练的数据科学家进入这一领域，本文旨在填补这一知识空白。通过提供高层次的介绍和一些在技术面试中常见的实际示例，本文邀请读者迈出下一步，借助各种教育资源进一步学习算法思维。最终，算法思维是当今数据科学家必备的重要技能，未来在AI辅助的时代中依然将是一个值得掌握的技能。

- en: A Sharp and Solid Outline of 3D Grid Neighborhoods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D网格邻域的清晰和扎实的轮廓
- en: 原文：[https://towardsdatascience.com/a-sharp-and-solid-outline-of-3d-grid-neighborhoods-1b0f264e7c11?source=collection_archive---------3-----------------------#2024-03-08](https://towardsdatascience.com/a-sharp-and-solid-outline-of-3d-grid-neighborhoods-1b0f264e7c11?source=collection_archive---------3-----------------------#2024-03-08)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://towardsdatascience.com/a-sharp-and-solid-outline-of-3d-grid-neighborhoods-1b0f264e7c11?source=collection_archive---------3-----------------------#2024-03-08](https://towardsdatascience.com/a-sharp-and-solid-outline-of-3d-grid-neighborhoods-1b0f264e7c11?source=collection_archive---------3-----------------------#2024-03-08)
- en: How 2D grid-based algorithms can be brought into the 3D world
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何将2D网格算法引入3D世界
- en: '[](https://medium.com/@rhys.goldstein?source=post_page---byline--1b0f264e7c11--------------------------------)[![Rhys
    Goldstein](../Images/75dafe578e93f357d5cfd6822b274373.png)](https://medium.com/@rhys.goldstein?source=post_page---byline--1b0f264e7c11--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--1b0f264e7c11--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--1b0f264e7c11--------------------------------)
    [Rhys Goldstein](https://medium.com/@rhys.goldstein?source=post_page---byline--1b0f264e7c11--------------------------------)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[](https://medium.com/@rhys.goldstein?source=post_page---byline--1b0f264e7c11--------------------------------)[![Rhys
    Goldstein](../Images/75dafe578e93f357d5cfd6822b274373.png)](https://medium.com/@rhys.goldstein?source=post_page---byline--1b0f264e7c11--------------------------------)[](https://towardsdatascience.com/?source=post_page---byline--1b0f264e7c11--------------------------------)[![Towards
    Data Science](../Images/a6ff2676ffcc0c7aad8aaf1d79379785.png)](https://towardsdatascience.com/?source=post_page---byline--1b0f264e7c11--------------------------------)
    [Rhys Goldstein](https://medium.com/@rhys.goldstein?source=post_page---byline--1b0f264e7c11--------------------------------)'
- en: ·Published in [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--1b0f264e7c11--------------------------------)
    ·20 min read·Mar 8, 2024
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·发表于 [Towards Data Science](https://towardsdatascience.com/?source=post_page---byline--1b0f264e7c11--------------------------------)
    ·阅读时间：20分钟·2024年3月8日
- en: --
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: --
- en: '![](../Images/f060f791dcb2e8c13912b577f52a19e2.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f060f791dcb2e8c13912b577f52a19e2.png)'
- en: Closeup of the triangular 50-neighborhood. (Image by author)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形50邻域的特写。（图片来源：作者）
- en: In my previous two articles, [A Short and Direct Walk with Pascal’s Triangle](/a-short-and-direct-walk-with-pascals-triangle-26a86d76f75f)
    and [A Quick and Clear Look at Grid-Based Visibility](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78),
    we saw how easy it is to generate decent-looking travel paths and compute visible
    regions using grid-based algorithms. The techniques I shared in those posts can
    be used for video games, mobile robotics, and architectural design, though our
    examples were limited to two dimensions. In this third and final installment of
    the series, we take what we know about 2D grid-based algorithms and add the third
    dimension. Read on to discover five 3D grid neighborhoods you can use to solve
    AI problems like navigation and visibility in 3D.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我之前的两篇文章中，[《与帕斯卡三角形的简短直接漫步》](/a-short-and-direct-walk-with-pascals-triangle-26a86d76f75f)
    和 [《基于网格的可视性的快速清晰分析》](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78)，我们看到使用基于网格的算法生成看起来不错的旅行路径并计算可视区域是多么容易。我在这些文章中分享的技巧可以应用于视频游戏、移动机器人和建筑设计，尽管我们的例子仅限于二维。在本系列的第三篇也是最后一篇中，我们将把我们对2D网格算法的理解扩展到第三维度。继续阅读，了解五种可以用于解决3D导航和可视性等AI问题的3D网格邻域。
- en: 3D Navigation and Visibility Problems
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D导航和可视性问题
- en: Since the world is 3D, it’s no surprise that video games, mobile robotics challenges,
    and architectural design tools often require 3D variants of pathfinding and visibility
    algorithms. For example, the image below shows what a person can see from a certain
    point in a 3D model of a city. An architect might use this kind of 3D visibility
    analysis to design a large building while allowing nearby pedestrians to see as
    much of the sky as possible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于世界是三维的，视频游戏、移动机器人挑战和建筑设计工具通常需要路径寻找和可视性算法的3D变种也就不足为奇了。例如，下面的图片展示了一个人在城市的3D模型中从某个点看到的景象。建筑师可能会使用这种3D可视性分析来设计一座大型建筑，同时让附近的行人尽可能多地看到天空。
- en: '![](../Images/132e399cb44f2355ad549d7592144194.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/132e399cb44f2355ad549d7592144194.png)'
- en: Example of 3D visibility by [Kean Walmsley](https://through-the-interface.typepad.com/through_the_interface/about-the-author.html)
    on [Through the Interface](https://www.keanw.com/2023/10/using-vasa-with-forma-part-2.html).
    (Used with permission)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kean Walmsley](https://through-the-interface.typepad.com/through_the_interface/about-the-author.html)在[《Through
    the Interface》](https://www.keanw.com/2023/10/using-vasa-with-forma-part-2.html)上的3D可视性示例。（经许可使用）'
- en: This next image gives us an X-ray view of the route a person might walk between
    two points on different floors of a building.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张图片为我们展示了一个人可能在大楼不同楼层之间走动的路线的X光视图。
- en: '![](../Images/a5c80ec26afd238023088d63ee30b0b7.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a5c80ec26afd238023088d63ee30b0b7.png)'
- en: Example of 3D pathfinding by [Kean Walmsley](https://through-the-interface.typepad.com/through_the_interface/about-the-author.html)
    on [Through the Interface](https://www.keanw.com/2021/10/streamlines-in-the-forge-viewer.html).
    (Used with permission)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kean Walmsley](https://through-the-interface.typepad.com/through_the_interface/about-the-author.html)在[Through
    the Interface](https://www.keanw.com/2021/10/streamlines-in-the-forge-viewer.html)上的3D路径寻找示例。（已获许可使用）'
- en: The above example is typical of 3D pathfinding in that the path is constrained
    to walkable surfaces such as staircases and floors. Another type of 3D navigation
    problem arises when generating a flight path for an aerial robot such as a quadcopter
    drone. In that case, the path may go straight through the air instead of adhering
    to surfaces.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子是典型的3D路径寻找，路径被限制在可行走的表面上，例如楼梯和地板。另一种类型的3D导航问题出现在为空中机器人（如四旋翼无人机）生成飞行路径时。在这种情况下，路径可能会直接穿越空中，而不是依附于表面。
- en: As in the previous articles, we are interested in solving navigation and visibility
    problems using grid-based algorithms**.** This means that every time a grid point
    is visited, information may flow only to neighboring grid points. The set of grid
    points considered to be “neighbors” is given by the **grid neighborhood**. There
    are many possible grid neighborhoods, but the ones depicted in the image below
    are the five smallest **standard 2D grid neighborhoods** [1]. Notice that as the
    neighborhoods increase in size from 4 to 16 neighbors, they alternate between
    rectangular and triangular grids. Generally speaking, algorithms that use larger
    neighborhoods take longer to run but produce more accurate results.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的文章一样，我们的目的是使用基于网格的算法来解决导航和可视性问题**。**这意味着每次访问一个网格点时，信息只能流向相邻的网格点。被认为是“邻居”的网格点集合由**网格邻域**决定。网格邻域有很多种可能性，但下图所示的是五种最小的**标准二维网格邻域**[1]。请注意，随着邻域从4个到16个邻居的增加，它们在矩形网格和三角形网格之间交替。一般来说，使用更大邻域的算法运行时间较长，但结果更为精确。
- en: '![](../Images/2eb92480d8f720af9a57326b84011511.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2eb92480d8f720af9a57326b84011511.png)'
- en: Rectangular and triangular 2D grid neighborhoods. (Image by [Autodesk Research](https://www.research.autodesk.com/)
    [1], used with permission)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形和三角形二维网格邻域。（图片由[Autodesk Research](https://www.research.autodesk.com/) [1]提供，已获许可使用）
- en: 'What interests us now is the following question:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们关心的问题是：
- en: What do these 2D neighborhoods look like in 3D?
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这些二维邻域在3D中是什么样的？
- en: The 3D equivalent of the 4-neighborhood and the 8-neighborhood are described
    in the journal paper “[Path Counting for Grid-Based Navigation](https://www.jair.org/index.php/jair/article/view/13544)”
    and elsewhere in the literature, but I had difficulty finding the 3D versions
    of the other three neighborhoods. I eventually decided to work them out myself
    so that I could present the complete set. Before we go through them one by one,
    here’s a sneak peek at the five smallest **standard 3D grid neighborhoods**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 4邻域和8邻域的3D等效形式在期刊论文《[基于网格的导航路径计数](https://www.jair.org/index.php/jair/article/view/13544)》以及文献中的其他地方有描述，但我在查找其他三种邻域的3D版本时遇到了困难。最后我决定自己推导出来，这样就可以呈现完整的集合。在逐一讲解之前，这里先给大家看一下五种最小的**标准3D网格邻域**。
- en: '![](../Images/ecab56499e51e27b28777ecb25c11b1e.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ecab56499e51e27b28777ecb25c11b1e.png)'
- en: The five smallest standard grid neighborhoods in 3D. (Image by author)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 3D中五种最小的标准网格邻域。（图片由作者提供）
- en: To demonstrate these five neighborhoods, we’ll solve the 3D visibility problem
    with each of them and compare the five solutions for accuracy. The reason we’re
    focusing on grid-based visibility is because it’s one of the simplest grid-based
    algorithms — simple enough for us to take a good look at the code. Once you’ve
    seen how grid-based visibility can be implemented in 3D, you can use your choice
    of 3D grid neighborhood to solve 3D pathfinding problems and other AI challenges
    that arise in the 3D world.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这五种邻域，我们将使用它们来解决3D可视性问题，并比较五种解法的准确性。我们之所以专注于基于网格的可视性，是因为它是最简单的基于网格的算法之一——足够简单，我们可以仔细查看代码。一旦你了解了如何在3D中实现基于网格的可视性，你可以使用自己选择的3D网格邻域来解决3D路径寻找问题以及其他在3D世界中出现的AI挑战。
- en: Rectangular 6-Neighborhood
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形6邻域
- en: We’ll start with the neighborhoods defined on a **3D rectangular grid**, which
    is simply the set of points [x, y, z] where x, y, and z are integers. These grids
    are widely used. They can be represented on a computer using a standard 3D array.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义在**3D矩形网格**上的邻域开始，简单来说，3D矩形网格是由一组点[x, y, z]组成，其中x、y和z是整数。这些网格被广泛使用，可以使用标准的3D数组在计算机上表示。
- en: '![](../Images/eb84b12179c6d509b0b5d7c69c77f66e.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/eb84b12179c6d509b0b5d7c69c77f66e.png)'
- en: A 3x3x3 slice of a 3D rectangular grid. (Image by author)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 3D矩形网格的3x3x3切片。（图片由作者制作）
- en: The first 3D grid neighborhood is nearly ubiquitous, but we’ll present it anyway
    for the sake of completeness. When the rectangular 4-neighborhood in 2D is extended
    to 3D, we end up with the **rectangular 6-neighborhood** illustrated below. To
    interpret the image, imagine that the two vertical arrows point up and down while
    the remaining arrows point north, east, south, and west.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个3D网格邻域几乎是无处不在的，但我们还是将其展示出来以完整性考虑。当二维的矩形4邻域扩展到3D时，我们得到下图所示的**矩形6邻域**。要解读这张图，请想象两个垂直箭头分别指向上和下，其余箭头分别指向北、东、南和西。
- en: '![](../Images/805464f757c3dc9ce175d72d25dc45e4.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/805464f757c3dc9ce175d72d25dc45e4.png)'
- en: The rectangular 6-neighborhood represented with vectors. (Image by author)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用向量表示的矩形6邻域。（图片由作者制作）
- en: Now we’ll apply the rectangular 6-neighborhood to solve the 3D visibility problem
    using Python. In the code below, the function `grid_visibility` inputs a 3D array
    named `grid0` representing the environment. Cells in this initial grid with a
    value of 1 represent empty space, and cells with a value of 0 represent an obstacle.
    The function computes the visibility results in a separate 3D array named `grid`.
    Cells in this output grid with a value of 1 are considered visible from a viewpoint
    at [0, 0, 0], and cells with a value of 0 are considered blocked.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将应用矩形6邻域来使用Python解决3D可视化问题。在下面的代码中，`grid_visibility`函数输入一个名为`grid0`的3D数组，表示环境。初始网格中值为1的单元表示空旷区域，值为0的单元表示障碍物。该函数将在另一个3D数组`grid`中计算可视化结果。输出网格中值为1的单元被认为从视点[0,
    0, 0]处可见，值为0的单元则被认为是被遮挡的。
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The reason the viewpoint is fixed at [0, 0, 0] is just to simplify the code.
    If you want the viewpoint to be located somewhere else, such as the center of
    the grid, the [previous article](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78)
    solves that problem in 2D with an array indexing trick that will also work in
    3D.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 视点固定在[0, 0, 0]的原因只是为了简化代码。如果你希望视点位于其他地方，比如网格的中心，[上一篇文章](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78)通过数组索引技巧解决了这个问题，并且该技巧也适用于3D情况。
- en: To test our 3D grid-based visibility solver, we’ll use the scenario shown below.
    The input grid is 40x40x40 and features a spherical obstacle with center at [10,
    20, 16] and radius 8.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的3D网格可视化解算器，我们将使用下面显示的场景。输入网格为40x40x40，具有一个球形障碍物，中心位于[10, 20, 16]，半径为8。
- en: '![](../Images/e0a0030f8b428dfb572f4ddc0f583f9b.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e0a0030f8b428dfb572f4ddc0f583f9b.png)'
- en: The test scenario. (Image by author)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试场景。（图片由作者制作）
- en: This problem is simple enough to solve analytically, allowing us to test the
    accuracy of the grid-based solution. The red dots in the animation below indicate
    the grid points that have been misclassified using our 6-neighbor grid-based approach.
    Notice that the vast majority of the 40x40x40 grid points have no red dot, meaning
    that they are correctly classified. The errors occur near the boundary of the
    obstacle’s “shadow”, where grid points are either barely visible or barely obstructed.
    I find that errors such as these are usually tolerable, though it depends on the
    application. I’ll provide the testing and visualization code near the end of the
    article.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题足够简单，可以通过解析的方法解决，从而让我们测试基于网格的解决方案的准确性。下面动画中的红点表示我们使用6邻域网格方法错误分类的网格点。请注意，40x40x40网格中的绝大多数点没有红点，这意味着它们被正确分类。错误发生在障碍物“阴影”的边界附近，那里网格点要么几乎不可见，要么几乎被遮挡。我发现此类错误通常是可以容忍的，尽管这取决于具体应用。我将在文章的最后提供测试和可视化代码。
- en: '![](../Images/d3a755e13c69176dedca4e79efdd4efc.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d3a755e13c69176dedca4e79efdd4efc.png)'
- en: Grid-based visibility classification errors using the 6-neighborhood. (Animation
    by author)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用6邻域的网格可视化分类错误。（动画由作者制作）
- en: Now we are going to rewrite our grid-based visibility algorithm in a way that
    accommodates the larger 3D grid neighborhoods. The key is to solve the visibility
    problem within a cone bracketed by a set of vectors. In the [previous article](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78),
    we defined a 2D `visibility_within_cone` function that required two vectors to
    specify a triangular cone. In 3D, the function requires three vectors to define
    a tetrahedral cone.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重新编写基于网格的可见性算法，以适应更大的 3D 网格邻域。关键是解决在由一组向量界定的圆锥内的可见性问题。在[上一篇文章](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78)中，我们定义了一个
    2D 的 `visibility_within_cone` 函数，该函数需要两个向量来指定一个三角形圆锥。在 3D 中，该函数需要三个向量来定义一个四面体圆锥。
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Below is an alternative illustration of the 6-neighborhood showing the triangular
    faces associated with each cone. Represented in this fashion, the 6-neighborhood
    appears as an octahedron.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 6-邻域的另一种表示方式，展示了与每个圆锥相关的三角面。以这种方式表示，6-邻域看起来像一个八面体。
- en: '![](../Images/4601851dfbbb5639aa34b1241e03d191.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/4601851dfbbb5639aa34b1241e03d191.png)'
- en: The rectangular 6-neighborhood represented with triangular faces. (Image by
    author)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形 6-邻域，表示为三角面。（图片由作者提供）
- en: 'If we slice the octahedron in half, we can see the rectangular 6-neighborhood’s
    2D counterpart: the 4-neighborhood.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将八面体切成两半，就可以看到矩形 6-邻域的 2D 对应物：4-邻域。
- en: '![](../Images/92ac9ce07cb930dd4dca23aaa6e3d1dd.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/92ac9ce07cb930dd4dca23aaa6e3d1dd.png)'
- en: The 3D 6-neighborhood cut in half to reveal the 2D 4-neighborhood. (Image by
    author)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将 3D 6-邻域切成两半，揭示出 2D 4-邻域。（图片由作者提供）
- en: Let’s look at the full octahedron again, and project one of the triangles away
    from the origin to help us visualize a tetrahedral cone. The 6-neighborhood has
    8 such cones in total, one for each 3D octant of the domain. Note that each cone
    extends to infinity, taking up its entire octant.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看完整的八面体，并将其中一个三角形从原点投影出去，以帮助我们可视化一个四面体圆锥。6-邻域总共有 8 个这样的圆锥，每个圆锥对应于该区域的一个三维八分之一。请注意，每个圆锥延伸到无穷远，覆盖其整个八分之一。
- en: '![](../Images/8d576426c956f300bf649e37f1253cec.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/8d576426c956f300bf649e37f1253cec.png)'
- en: Visualization of a cone in the rectangular 6-neighborhood. (Image by author)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 6-邻域中圆锥的可视化。（图片由作者提供）
- en: Here is a plot of just one octant of the 6-neighborhood, with its single cone.
    The plot makes it easy to read off the coordinates of the bracketing vectors,
    which we’ll need in order to reimplement the grid-based algorithm. In this case
    the bracketing vectors are `[1,0,0]`, `[0,1,0]`, `[0,0,1]`, the corners of the
    triangle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是仅包含 6-邻域一个八分之一及其单个圆锥的图。该图使我们可以轻松读取界定向量的坐标，后续我们将需要这些坐标来重新实现基于网格的算法。在这种情况下，界定向量是
    `[1,0,0]`、`[0,1,0]`、`[0,0,1]`，即三角形的三个角。
- en: '![](../Images/865ba5e86babf689fae45bcdb7a3925e.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/865ba5e86babf689fae45bcdb7a3925e.png)'
- en: Plot of a cone in one octant of the rectangular 6-neighborhood. (Image by author)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在矩形 6-邻域的一个八分之一中绘制了一个圆锥图形。（图片由作者提供）
- en: Below is our new implementation of 6-neighbor 3D grid-based visibility.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们新的 6-邻域 3D 基于网格的可见性实现。
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The new `grid6-visibility` function produces exactly the same results as the
    `grid-visibility` function we saw earlier, but our refactoring efforts will help
    us tackle the larger 3D neighborhoods which have many more cones.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `grid6-visibility` 函数产生的结果与我们之前看到的 `grid-visibility` 函数完全相同，但我们的重构工作将帮助我们处理更大的三维邻域，这些邻域包含更多的圆锥。
- en: Rectangular 26-Neighborhood
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形 26-邻域
- en: When the rectangular 8-neighborhood in 2D is extended to 3D, we get the **rectangular
    26-neighborhood** shown below. The neighborhood appears as a 2x2x2 cube with each
    side tessellated into triangles representing cones.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当矩形 8-邻域在 2D 中被扩展到 3D 时，我们得到下图所示的**矩形 26-邻域**。该邻域呈现为一个 2x2x2 的立方体，每一面都被三角形镶嵌，代表圆锥。
- en: '![](../Images/d23900bcdc3fca8be0bf65a743a8771b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/d23900bcdc3fca8be0bf65a743a8771b.png)'
- en: The rectangular 26-neighborhood. (Image by author)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形 26-邻域。（图片由作者提供）
- en: 'As before, we can cut the neighborhood in half to see its 2D counterpart: the
    8-neighborhood.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们可以将邻域切成两半，以查看其 2D 对应物：8-邻域。
- en: '![](../Images/a8d17575956761aebe87c798ee9503c2.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/a8d17575956761aebe87c798ee9503c2.png)'
- en: The 3D 26-neighborhood cut in half to reveal the 2D 8-neighborhood. (Image by
    author)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将 3D 26-邻域切成两半，揭示出 2D 8-邻域。（图片由作者提供）
- en: The rectangular 26-neighborhood is well known, though it is rarely shown in
    a way that identifies its 48 tetrahedral cones. The illustration below highlights
    one of these cones.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形 26-邻域是众所周知的，尽管它很少以能识别其 48 个四面体圆锥的方式展示。下面的插图突出了其中一个圆锥。
- en: '![](../Images/415826e69252c7b41127b750dc1bfc6a.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/415826e69252c7b41127b750dc1bfc6a.png)'
- en: Visualization of a cone in the rectangular 26-neighborhood. (Image by author)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形26邻域中一个锥体的可视化。（图片来源：作者）
- en: The following plot helps us to read off the coordinates of the 6 cones within
    one octant.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下图帮助我们读取一个八分体内6个锥体的坐标。
- en: '![](../Images/e9b8272550bfd7a08d7b9c87baa67539.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e9b8272550bfd7a08d7b9c87baa67539.png)'
- en: Plot of the 6 cones in one octant of the rectangular 26-neighborhood. (Image
    by author)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形26邻域中一个八分体内6个锥体的图。（图片来源：作者）
- en: Here’s our implementation of 26-neighbor 3D grid-based visibility. Notice that
    we call `visibility_within_cone` once for each triangle in the plot above.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们基于26邻域的3D网格可视性实现。请注意，我们对上图中的每个三角形调用了一次`visibility_within_cone`。
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The visibility results we obtain with the 26-neighborhood contain fewer errors
    than with the 6-neighborhood. You can see below that the red dots are sparser.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用26邻域得到的可视性结果比使用6邻域的错误更少。你可以看到，下面红点的分布更加稀疏。
- en: '![](../Images/c98d5a0f0de79e315d2f44e3fd9cebc2.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/c98d5a0f0de79e315d2f44e3fd9cebc2.png)'
- en: Classification errors using the 6-neighborhood (left) and 26-neighborhood (right).
    (Image by author)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用6邻域（左）和26邻域（右）的分类错误。（图片来源：作者）
- en: The 26-neighborhood is common, though it is usually presented without identifying
    the 48 tetrahedral cones. In theory these cones aren’t needed for pathfinding
    or visibility, but they allow us to adopt faster algorithms. For example, it is
    widely understood among computer scientists that one can find shortest grid paths
    in 3D by applying Dijkstra’s algorithm using 26 neighbors on a rectangular grid.
    Dijkstra’s algorithm does not require us to know how those neighbors are grouped
    into cones. However, if we have identified the cones, we can adopt a faster pathfinding
    method called [3D Jump Point Search](https://ojs.aaai.org/index.php/SOCS/article/view/21762)
    [2]. If you’re looking for a challenge, try implementing Jump Point Search with
    your choice of 3D grid neighborhood.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 26邻域是常见的，尽管通常未标明48个四面体锥体。理论上，这些锥体对于路径寻找或可视性并非必需，但它们使得我们能够采用更快的算法。例如，计算机科学家普遍认为，可以通过在矩形网格上应用26个邻域的Dijkstra算法来找到3D中的最短网格路径。Dijkstra算法不要求我们知道这些邻域如何组合成锥体。然而，如果我们已经标识出锥体，就可以采用一种更快速的路径寻找方法，称为[3D跳点搜索](https://ojs.aaai.org/index.php/SOCS/article/view/21762)
    [2]。如果你正在寻找挑战，不妨尝试使用你选择的3D网格邻域实现跳点搜索。
- en: Rectangular 74-Neighborhood
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形74邻域
- en: The previous two 3D grid neighborhoods are reasonably well established, but
    now we must venture into unknown territory. When the rectangular 16-neighborhood
    in 2D is extended to 3D, we get the **rectangular 74-neighborhood**. I’m not sure
    how to describe the shape of the 74-neighborhood, but this is what it looks like.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个3D网格邻域已经相对成熟，但现在我们必须进入未知领域。当二维的矩形16邻域扩展到三维时，我们得到了**矩形74邻域**。我不确定该如何描述74邻域的形状，但它大致长这个样子。
- en: '![](../Images/45691df1c6421f1a8af489a7989592e8.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/45691df1c6421f1a8af489a7989592e8.png)'
- en: The rectangular 74-neighborhood. (Image by author)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形74邻域。（图片来源：作者）
- en: And here it is again, this time sliced in half to reveal the 16-neighborhood.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的再次展示，这次被切成两半以展示16邻域。
- en: '![](../Images/2341320c37a99e203d94a1be913b7f4b.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2341320c37a99e203d94a1be913b7f4b.png)'
- en: The 3D 74-neighborhood cut in half to reveal the 2D 16-neighborhood. (Image
    by author)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 3D的74邻域被切成两半，展示了2D的16邻域。（图片来源：作者）
- en: The rectangular 74-neighborhood has 144 cones in total. Below is a plot representing
    the 18 cones in one octant.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形74邻域共有144个锥体。以下是表示一个八分体内18个锥体的图。
- en: '![](../Images/b25a575a10d1756dd0883cafb5828091.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/b25a575a10d1756dd0883cafb5828091.png)'
- en: Plot of the 18 cones in one octant of the rectangular 74-neighborhood. (Image
    by author)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形74邻域中一个八分体内18个锥体的图。（图片来源：作者）
- en: Reading off the coordinates of each triangle in the plot, we can now implement
    74-neighbor 3D grid-based visibility.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读图中每个三角形的坐标后，我们现在可以实现74邻域的3D网格可视性。
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Below are the errors for all three of our 3D rectangular grid neighborhoods
    applied to the test scenario. The 74-neighbor solution contains the fewest misclassified
    points.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在测试场景中应用的三种3D矩形网格邻域的错误。74邻域解决方案包含最少的分类错误点。
- en: '![](../Images/2cdc619389de8f9fe56d6011a46490ee.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2cdc619389de8f9fe56d6011a46490ee.png)'
- en: Classification errors using the 6-neighborhood (left), 26-neighborhood (center),
    and 74-neighborhood (right). (Image by author)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用6邻域（左）、26邻域（中）、和74邻域（右）的分类错误。（图片来源：作者）
- en: Triangular 18-Neighborhood
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角形 18 邻域
- en: 'With the 3D rectangular neighborhoods taken care of, it’s time to see what
    the triangular neighborhoods look like in 3D. They’re surprisingly hard to visualize!
    A good way to start is by asking the following question:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完 3D 矩形邻域后，接下来就该看看 3D 中的三角形邻域是什么样的了。它们出奇地难以可视化！一个好的开始方法是提出以下问题：
- en: What solid objects have faces that are equilateral triangles, and can be used
    to fill 3D space?
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哪些固体物体的面是等边三角形，并且可以用于填充 3D 空间？
- en: 'Aristotle took a stab at answering that question over 2000 years ago. He famously
    taught that regular tetrahedra fill space [3]. He was wrong. If you have a whole
    bunch of regular tetrahedra and try putting them together, you will necessarily
    end up with gaps. The same can be said for regular octahedra: they also do not
    fill space. But as shown below, you ***can*** fill space using ***both*** tetrahedra
    and octahedra.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 亚里士多德在 2000 多年前试图回答这个问题。他著名地提出，规则的四面体可以填充空间[3]。但他错了。如果你有一大堆规则四面体并尝试将它们组合起来，你必然会遇到空隙。规则八面体也是如此：它们也无法填充空间。但如下所示，你***可以***使用***四面体和八面体***填充空间。
- en: '![](../Images/f9f13e329e4c69b00575c0456a102498.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f9f13e329e4c69b00575c0456a102498.png)'
- en: '[Octahedrons (blue) and tetrahedrons (red) filling space](https://commons.wikimedia.org/wiki/File:HC_P1-P3.png),
    by [TED-43](https://commons.wikimedia.org/wiki/User:TED-43) on [Wikipedia](https://en.wikipedia.org/wiki/Tetrahedral-octahedral_honeycomb)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[八面体（蓝色）和四面体（红色）填充空间](https://commons.wikimedia.org/wiki/File:HC_P1-P3.png)，由
    [TED-43](https://commons.wikimedia.org/wiki/User:TED-43) 在 [维基百科](https://en.wikipedia.org/wiki/Tetrahedral-octahedral_honeycomb)
    上提供'
- en: In the space-filling arrangement above, notice that the vertices of the tetrahedra
    and octahedra occur at regularly spaced points. These are the points of a **face-centered
    cubic lattice**, which we’ll refer to as a **3D triangular grid**. If one of these
    points is located at [0, 0, 0], we can scale and orient the 3D triangular grid
    so that its points coincide with every ***alternate*** point on a 3D rectangular
    grid. The plot below shows a 3D triangular grid with this configuration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的空间填充排列中，请注意四面体和八面体的顶点位于规则间隔的点上。这些点构成了一个**面心立方晶格**，我们将其称为**3D 三角网格**。如果其中一个点位于
    [0, 0, 0]，我们可以缩放并定向 3D 三角网格，使得其点与 3D 矩形网格上的每个***交替***点重合。下图显示了具有此配置的 3D 三角网格。
- en: '![](../Images/3ff387818d893a0e70a19e3c14ccb3ff.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3ff387818d893a0e70a19e3c14ccb3ff.png)'
- en: A 3x3x3 slice of a 3D triangular grid. (Image by author)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 3x3x3 的 3D 三角网格切片。（图片由作者提供）
- en: To represent these grids on a computer, we’ll adopt the same kind of arrays
    that we employed for 3D rectangular grids. However, in the case of a 3D triangular
    grid, only half of the array elements will ever get used. An array element at
    [x, y, z] will be used only if (x + y + z) is an even number. If (x + y + z) is
    odd, the element will be initialized to 0 and will always remain 0.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在计算机上表示这些网格，我们将采用与 3D 矩形网格相同的数组类型。然而，在 3D 三角网格的情况下，只有一半的数组元素会被使用。只有当 (x +
    y + z) 为偶数时，数组元素 [x, y, z] 才会被使用。如果 (x + y + z) 是奇数，则该元素将初始化为 0，并始终保持为 0。
- en: We now know how points in a 3D triangular grid can be arranged, but what does
    a **triangular grid cell** look like in 3D? When I use the term “grid cell”, I’m
    referring to a space filling shape that is centered on a grid point. In 2D, a
    triangular grid cell is not a triangle, but rather a hexagon. The [Red Blog Games](https://www.redblobgames.com/)
    tutorial on [Hexagonal Grids](https://www.redblobgames.com/grids/hexagons/) makes
    this easy to see. It turns out that in 3D, a triangular grid cell is called a
    **rhombic dodecahedron**. Rhombic dodecahedra fill 3D space.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何排列 3D 三角网格中的点，但在 3D 中，**三角网格单元**长什么样呢？当我使用“网格单元”这个术语时，我指的是一个以网格点为中心的填充空间的形状。在
    2D 中，三角网格单元不是三角形，而是六边形。[红博客游戏](https://www.redblobgames.com/)上关于[六边形网格](https://www.redblobgames.com/grids/hexagons/)的教程使这一点变得容易理解。结果证明，在
    3D 中，三角网格单元被称为**菱形十二面体**。菱形十二面体填充 3D 空间。
- en: '![](../Images/f8336f6f13341ff3cb42b31ca9eb4c2f.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/f8336f6f13341ff3cb42b31ca9eb4c2f.png)'
- en: '[Rhombic dodecahedron](https://commons.wikimedia.org/wiki/File:Rhombicdodecahedron.jpg)
    by [Cyp](https://en.wikipedia.org/wiki/User:Cyp) on [Wikipedia](https://en.wikipedia.org/wiki/Rhombic_dodecahedron)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[菱形十二面体](https://commons.wikimedia.org/wiki/File:Rhombicdodecahedron.jpg) 由
    [Cyp](https://en.wikipedia.org/wiki/User:Cyp) 在 [维基百科](https://en.wikipedia.org/wiki/Rhombic_dodecahedron)
    上提供'
- en: The dual of a polyhedron is the shape you get when you replace each face with
    a vertex and each vertex with a face. The dual of a **rhombic dodecahedron** is
    called a **cuboctahedron**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 多面体的对偶是你将每个面替换为一个顶点，每个顶点替换为一个面的形状。**菱形十二面体**的对偶被称为**立方八面体**。
- en: '![](../Images/90a249fbea0e531c2486bcbc414bf176.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/90a249fbea0e531c2486bcbc414bf176.png)'
- en: '[Cuboctahedron](https://commons.wikimedia.org/wiki/File:Cuboctahedron.jpg)
    by [Cyp](https://en.wikipedia.org/wiki/User:Cyp) on [Wikipedia](https://en.wikipedia.org/wiki/Cuboctahedron)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[立方八面体](https://commons.wikimedia.org/wiki/File:Cuboctahedron.jpg) 由 [Cyp](https://en.wikipedia.org/wiki/User:Cyp)
    上传至 [维基百科](https://en.wikipedia.org/wiki/Cuboctahedron)'
- en: If we center a cuboctahedron on a 3D triangular grid point, we can scale and
    orient it so that its 12 vertices coincide with the nearest neighboring grid points.
    In other words, the cuboctahedron is a viable 3D grid neighborhood. I would not
    consider this 12-neighborhood to be a ***standard*** 3D grid neighborhood, however,
    for the simple reason that some its faces are squares rather than triangles. There
    is a grid-based visibility algorithm from the urban design community that could
    be adapted to work with the square faces of the 12-neighborhood [4], but we will
    stick with our current algorithm requiring triangular faces.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个立方八面体置于3D三角网格点的中心，可以对其进行缩放和定向，使其12个顶点与最近的邻网格点重合。换句话说，立方八面体是一个可行的3D网格邻域。然而，我不会认为这个12-邻域是一个***标准的***
    3D网格邻域，原因很简单：它的一些面是正方形而非三角形。城市设计领域有一个基于网格的可视性算法，可以调整以适应12-邻域的正方形面[4]，但我们将坚持使用当前需要三角形面的算法。
- en: The smallest 3D triangular neighborhood that meets our criteria is the **triangular
    18-neighborhood**. It appears as an octahedron with each side tessellated into
    triangles.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 满足我们标准的最小3D三角形邻域是**三角形18-邻域**。它呈现为一个八面体，每一面都被镶嵌成三角形。
- en: '![](../Images/94986125756c1fc93f346a866d21f56a.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/94986125756c1fc93f346a866d21f56a.png)'
- en: The triangular 18-neighborhood. (Image by author)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形18-邻域。（图像来源：作者）
- en: If we slice the 18-neighborhood at an angle, we can see that it extends the
    2D triangular 6-neighborhood.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们斜切18-邻域，可以看到它扩展了2D三角形6-邻域。
- en: '![](../Images/780f03018e6ec7d9e521833c47129193.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/780f03018e6ec7d9e521833c47129193.png)'
- en: The 3D 18-neighborhood cut in half to reveal the 2D 6-neighborhood. (Image by
    author)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 18-邻域被切成两半，揭示出2D 6-邻域。（图像来源：作者）
- en: The triangular 18-neighborhood has 32 cones, 4 cones per octant.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形18-邻域有32个锥体，每个八分之一有4个锥体。
- en: '![](../Images/0148e8b82a3b960add5cca3f0ec545be.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0148e8b82a3b960add5cca3f0ec545be.png)'
- en: Plot of the 4 cones in one octant of the triangular 18-neighborhood. (Image
    by author)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 4个锥体在三角形18-邻域的一个八分之一中的图示。（图像来源：作者）
- en: Here’s our 18-neighbor implementation of grid-based visibility.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们基于网格的18-邻域可视性实现。
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And here are the results.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果。
- en: '![](../Images/0d3a398590890cf6e6fd53b29a404dd9.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/0d3a398590890cf6e6fd53b29a404dd9.png)'
- en: Classification errors using the 18-neighborhood. (Image by author)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用18-邻域的分类错误。（图像来源：作者）
- en: At first glance it may seem that the 18-neighborhood has yielded greater accuracy
    than the three rectangular neighborhoods, even the ones with more neighbors and
    cones. However, the main reason the red dots are sparser here than in previous
    plots is because, for 3D triangular grids, we only evaluate every alternate point
    [x, y, z].
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，18-邻域似乎比三个矩形邻域（即使它们的邻居和锥体更多）更精确。然而，红点比之前的图中更稀疏的主要原因是，对于3D三角网格，我们只评估每隔一个点的[x,
    y, z]。
- en: Triangular 50-Neighborhood
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角形50-邻域
- en: The fifth and final neighborhood in our collection is the **triangular 50-neighborhood**.
    Its overall shape is known as a stellated octahedron, which is basically an octahedron
    with a tetrahedron glued onto each face. In the case of the 50-neighborhood, each
    face of the stellated octahedron is tessellated into 4 triangles, as shown below.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们集合中的第五个也是最后一个邻域是**三角形50-邻域**。它的整体形状被称为星形八面体，基本上是一个在每个面上粘贴一个四面体的八面体。在50-邻域的情况下，星形八面体的每个面都被镶嵌成4个三角形，如下所示。
- en: '![](../Images/ac92c81dc500e7b563c6b875a2d2e215.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/ac92c81dc500e7b563c6b875a2d2e215.png)'
- en: The triangular 50-neighborhood. (Image by author)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形50-邻域。（图像来源：作者）
- en: The 50-neighborhood extends the 2D triangular 12-neighborhood.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 50-邻域扩展了2D三角形12-邻域。
- en: '![](../Images/e609b885e180fa601046e14f97af99fd.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e609b885e180fa601046e14f97af99fd.png)'
- en: The 3D 50-neighborhood cut in half to reveal the 2D 12-neighborhood. (Image
    by author)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 3D 50-邻域被切成两半，揭示出2D 12-邻域。（图像来源：作者）
- en: It has 96 cones, 12 per octant.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它有96个锥体，每个八分之一区域12个。
- en: '![](../Images/086820635761d7c5fc6a2eb62ef60e7b.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/086820635761d7c5fc6a2eb62ef60e7b.png)'
- en: Plot of the 12 cones in one octant of the triangular 50-neighborhood. (Image
    by author)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个三角形50邻域的八分之一区域中绘制的12个锥体。（图片来源：作者）
- en: Below is 50-neighbor grid-based visibility.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是50邻域网格基础的可见性。
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And finally, here are the results for both of our 3D triangular grid neighborhoods.
    It may be hard to tell at a glance, but the 50-neighbor results contain fewer
    errors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是我们两个3D三角网格邻域的结果。可能一眼看不出区别，但50邻域的结果错误较少。
- en: '![](../Images/5b298d1761c7f05c869e290ce8e75c1c.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5b298d1761c7f05c869e290ce8e75c1c.png)'
- en: Classification errors using the 18-neighborhood (left) and 50-neighborhood (right).
    (Image by author)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用18邻域（左）和50邻域（右）的分类错误。（图片来源：作者）
- en: Comparison of Neighborhoods
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻域比较
- en: The table below lists the five presented 3D grid neighborhoods, their properties,
    and the accuracy obtained when applying each neighborhood to our test problem.
    The accuracy values are calculated by taking the number of grid points correctly
    classified as visible or not visible, and dividing by the total number of evaluated
    grid points. As we’d expect, the accuracy scores increase with the number of neighbors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了五种展示的3D网格邻域、它们的属性，以及将每个邻域应用于我们的测试问题时获得的准确性。准确性值是通过计算正确分类为可见或不可见的网格点数量，并除以评估的网格点总数来得出的。正如我们所预期的，准确性分数随着邻居数量的增加而提高。
- en: '![](../Images/1362e61553064817460ee59bef9139cb.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1362e61553064817460ee59bef9139cb.png)'
- en: List of 3D grid neighborhoods, their properties, and accuracy results. (Image
    by author)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 3D网格邻域、其属性和准确性结果的列表。（图片来源：作者）
- en: This analysis is mostly for illustrative purposes. If our goal were to perform
    a rigorous comparison of these five 3D grid neighborhoods, we would not be satisfied
    with our single test scenario. Instead we would want to apply each neighborhood
    to a large set of test scenarios, and average the results.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该分析主要用于说明性目的。如果我们的目标是对这五种3D网格邻域进行严格比较，我们不会满足于单一的测试场景。相反，我们会希望将每个邻域应用于大量的测试场景，并对结果进行平均。
- en: I should also point out that in this article and the [previous one](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78),
    I have taken a shortcut both literally and figuratively when implementing grid-based
    visibility for large neighborhoods. The proper formula, which you can find in
    the journal paper “[Path Counting for Grid-Based Navigation](https://www.jair.org/index.php/jair/article/view/13544)”
    [1], requires a line-of-sight test between every pair of neighboring grid points.
    To illustrate, consider the following 2D scenario.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该指出，在本文和[上一篇文章](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78)中，我在实现大邻域的网格基础可见性时，字面和比喻上都采取了捷径。正确的公式，你可以在期刊论文“[基于网格的路径计数](https://www.jair.org/index.php/jair/article/view/13544)”[1]中找到，要求对每一对相邻网格点进行视距测试。为了说明这一点，请考虑以下2D场景。
- en: '![](../Images/1a5e7e7569249bf6ed02e5e3faf23acd.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1a5e7e7569249bf6ed02e5e3faf23acd.png)'
- en: Two labelled cells on a 2D rectangular grid. (Image by author)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D矩形网格上的两个标记单元格。（图片来源：作者）
- en: If we’re using the 4-neighborhood or the 8-neighborhood, then cells **A** and
    **B** in the above example are not neighbors. But if we’re using the 16-neighborhood,
    then these two points ***are*** neighbors and so we should technically perform
    a line-of-sight test between them. The algorithms in this article series alleviate
    the need for line-of-sight checks between distant grid points, though it is still
    best to precompute these checks over the short distances between neighbors. If
    we draw a line between the centers of cells **A** and **B**, the line will pass
    through a blocked cell. This suggests that the visibility algorithm should probably
    ***not*** propagate information directly from **A** to **B**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用4邻域或8邻域，那么上面示例中的单元格**A**和**B**不是邻居。但是，如果我们使用16邻域，那么这两个点***是***邻居，因此我们应该在它们之间执行视距测试。本文系列中的算法减轻了对远距离网格点之间视距检查的需求，尽管在邻居之间的短距离上最好预先计算这些检查。如果我们在单元格**A**和**B**的中心之间画一条线，这条线将穿过一个被阻塞的单元格。这表明，视距算法可能***不应该***直接从**A**传播信息到**B**。
- en: The literal and figurative shortcut I’ve been taking is to assume two neighboring
    cells are mutually visible as long as they’re both empty. This works perfectly
    well for the 4-neighborhood in 2D and the 6-neighborhood in 3D, but it isn’t quite
    right for the larger neighborhoods. In the example above, a 16-neighbor version
    of my Python code would treat cells **A** and **B** as mutually visible. It would
    happily propagate information from one to the other, essentially taking a “shortcut”
    through the obstacle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我采取的字面和比喻上的快捷方式是，假设两个相邻的单元格只要它们都是空的，就可以互相可见。这个方法在二维的4邻域和三维的6邻域中效果很好，但对于更大的邻域来说并不完全正确。在上面的示例中，我的Python代码的16邻域版本会将单元格**A**和**B**视为互相可见。它会愉快地将信息从一个单元格传播到另一个单元格，实际上是通过障碍物“走捷径”。
- en: This shortcut I’m describing isn’t such a big deal if our obstacles are sufficiently
    wide compared with the grid spacing. In our test results, the larger 3D neighborhoods
    achieved greater accuracy than the smaller ones despite this flaw. But if you
    plan to use large 2D or 3D grid neighborhoods in your own work, I encourage you
    to carefully consider which neighboring grid points should and should not be treated
    as direct pathways for information.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的障碍物与网格间距相比足够宽，这种我描述的“捷径”并不那么重要。在我们的测试结果中，尽管存在这个缺陷，但较大的3D邻域比较小的邻域取得了更高的准确度。但如果你计划在自己的工作中使用大型的二维或三维网格邻域，我建议你仔细考虑哪些相邻的网格点应该被视为直接的信息通道，哪些不应该。
- en: Testing and Visualization Code
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和可视化代码
- en: Please skip this section and [proceed to the conclusion](#6036) if you are ***not***
    interested in running the Python code presented in this article.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你***不感兴趣***运行本文中展示的Python代码，请跳过此部分并[继续阅读结论](#6036)。
- en: 'If you ***are*** interested in running the code, follow these steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你***有兴趣***运行代码，请按照以下步骤操作：
- en: Make sure you have Python installed along with the NumPy and Matplotlib libraries.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已安装Python，并且安装了NumPy和Matplotlib库。
- en: Create an empty text file named `grid_visibility_3D.py`. Starting from the top,
    copy into this text file all of the code blocks that have appeared in this article
    until this point.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空文本文件，命名为`grid_visibility_3D.py`。从顶部开始，将本文到目前为止出现的所有代码块复制到这个文本文件中。
- en: Create another text file named `test_grid_visibility_3D.py` and copy in the
    long code block that appears below these instructions.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个文本文件，命名为`test_grid_visibility_3D.py`，并将下面这些指令后的长代码块复制进去。
- en: On the command prompt, run `python test_grid_visibility_3D.py`. You should see
    the same accuracy scores that were reported in the [Comparison of Neighborhoods](#2d42)
    table. You should also see a 3D visualization of the test scenario.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符下，运行`python test_grid_visibility_3D.py`。你应该看到与[邻域比较](#2d42)表中报告的相同准确性分数。你还应该看到测试场景的3D可视化。
- en: Close the visualization window and run the command `python test_grid_visibility_3D.py
    6`. You should see the same output except with red dots appearing in the 3D visualization.
    You can drag the cursor on the plot to rotate it and get a better view. These
    dots are the errors associated with the 6-neighbor visibility algorithm. Run the
    code again with the command line argument `6` changed to `18`, `26`, `50`, or
    `74` to see the errors associated with the other 3D grid neighborhoods.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭可视化窗口并运行命令`python test_grid_visibility_3D.py 6`。你应该看到相同的输出，但在3D可视化中会出现红点。你可以拖动光标旋转图形以获得更好的视角。这些红点是与6邻域可见性算法相关的错误。再次运行代码，将命令行参数`6`更改为`18`、`26`、`50`或`74`，查看与其他3D网格邻域相关的错误。
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Conclusion
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Thank you for reading my articles on pathfinding and visibility in both 2D and
    3D. I hope this series has expanded your view of what can be done using simple
    grid-based algorithms. By counting paths (see [part 1](/a-short-and-direct-walk-with-pascals-triangle-26a86d76f75f)),
    employing linear interpolation (see [part 2](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78)),
    selecting a larger grid neighborhood (as in this article — part 3), or simply
    choosing a finer grid resolution, we can overcome the perceived limitations of
    grids and achieve highly satisfactory results. The next time you encounter an
    AI problem that is usually tackled with brute force ray casting or cumbersome
    analytic calculations, remember what you can accomplish with a grid-based method
    and your neighborhood of choice.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '感谢您阅读我关于二维和三维路径寻找与可视性的文章。我希望这系列文章扩展了您对于使用简单网格算法能够实现的功能的视野。通过路径计数（参见[第1部分](/a-short-and-direct-walk-with-pascals-triangle-26a86d76f75f)）、线性插值（参见[第2部分](/a-quick-and-clear-look-at-grid-based-visibility-bf63769fbc78)）、选择更大的网格邻域（如本文所述——第3部分）或仅仅选择更精细的网格分辨率，我们可以克服网格的感知局限，取得非常满意的结果。下次当您遇到通常通过暴力射线投射或繁琐的解析计算解决的AI问题时，请记住您可以通过基于网格的方法和您选择的邻域完成的工作。  '
- en: References
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '参考文献  '
- en: '[1] R. Goldstein, K. Walmsley, J. Bibliowicz, A. Tessier, S. Breslav, A. Khan,
    [Path Counting for Grid-Based Navigation](https://www.jair.org/index.php/jair/article/view/13544)
    (2022), Journal of Artificial Intelligence Research, vol. 74, pp. 917–955'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] R. Goldstein, K. Walmsley, J. Bibliowicz, A. Tessier, S. Breslav, A. Khan,
    [基于网格的导航路径计数](https://www.jair.org/index.php/jair/article/view/13544)（2022），《人工智能研究杂志》，第74卷，917–955页  '
- en: '[2] T. K. Nobes, D. D. Harabor, M. Wybrow, S. D. C. Walsh, [The Jump Point
    Search Pathfinding System in 3D](https://ojs.aaai.org/index.php/SOCS/article/view/21762)
    (2022), Proceedings of the International Symposium on Combinatorial Search (SoCS)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[2] T. K. Nobes, D. D. Harabor, M. Wybrow, S. D. C. Walsh, [3D中的跳跃点搜索路径寻找系统](https://ojs.aaai.org/index.php/SOCS/article/view/21762)（2022），《组合搜索国际研讨会论文集》（SoCS）  '
- en: '[3] C. L. Jeffrey, C. Zong, [Mysteries in Packing Regular Tetrahedra](https://www.ams.org/journals/notices/201211/rtx121101540p.pdf)
    (2012), Notices of the American Mathematical Society, vol. 59, no. 11, pp. 1540–1549'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[3] C. L. Jeffrey, C. Zong, [规律四面体堆积的奥秘](https://www.ams.org/journals/notices/201211/rtx121101540p.pdf)（2012），《美国数学学会通知》，第59卷，第11期，1540–1549页  '
- en: '[4] D. Fisher-Gewirtzman, A. Shashkov, Y. Doytsher, [Voxel Based Volumetric
    Visibility Analysis of Urban Environments](https://www.tandfonline.com/doi/abs/10.1179/1752270613Y.0000000059)
    (2013), Survey Review, vol. 45, no. 333, pp. 451–461'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[4] D. Fisher-Gewirtzman, A. Shashkov, Y. Doytsher, [基于体素的城市环境可视性分析](https://www.tandfonline.com/doi/abs/10.1179/1752270613Y.0000000059)（2013），《测量回顾》，第45卷，第333期，451–461页'
